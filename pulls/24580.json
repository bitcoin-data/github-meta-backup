{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580",
    "id": 881079029,
    "node_id": "PR_kwDOABII5840hDL1",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/24580",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/24580.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/24580.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24580",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24580/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/e378883892b104b2f2441540550c39c6a5dd71d0",
    "number": 24580,
    "state": "closed",
    "locked": true,
    "maintainer_can_modify": false,
    "title": "test: coinselection edge cases",
    "user": {
      "login": "S3RK",
      "id": 1466284,
      "node_id": "MDQ6VXNlcjE0NjYyODQ=",
      "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/S3RK",
      "html_url": "https://github.com/S3RK",
      "followers_url": "https://api.github.com/users/S3RK/followers",
      "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
      "organizations_url": "https://api.github.com/users/S3RK/orgs",
      "repos_url": "https://api.github.com/users/S3RK/repos",
      "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/S3RK/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This PR adds tests for some edge cases in coin selection.\r\n\r\nThere are 4 sections by the type of utxo pool:\r\n1) a few small inputs of equal value\r\n2) one big input and many small inputs\r\n3) just one input\r\n4) one big and one small input",
    "labels": [
      {
        "id": 62963516,
        "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
        "name": "Tests",
        "color": "d4c5f9",
        "default": false
      }
    ],
    "created_at": "2022-03-16T08:39:03Z",
    "updated_at": "2023-05-23T10:02:59Z",
    "closed_at": "2022-05-23T06:06:01Z",
    "mergeable_state": "unknown",
    "merge_commit_sha": "85f0a1f3fbee3ecf70be99e39207244c95cad587",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "S3RK:coinselection_tests",
      "ref": "coinselection_tests",
      "sha": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "user": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 268426115,
        "node_id": "MDEwOlJlcG9zaXRvcnkyNjg0MjYxMTU=",
        "name": "bitcoin",
        "full_name": "S3RK/bitcoin",
        "owner": {
          "login": "S3RK",
          "id": 1466284,
          "node_id": "MDQ6VXNlcjE0NjYyODQ=",
          "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/S3RK",
          "html_url": "https://github.com/S3RK",
          "followers_url": "https://api.github.com/users/S3RK/followers",
          "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
          "organizations_url": "https://api.github.com/users/S3RK/orgs",
          "repos_url": "https://api.github.com/users/S3RK/repos",
          "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/S3RK/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/S3RK/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/S3RK/bitcoin",
        "archive_url": "https://api.github.com/repos/S3RK/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/S3RK/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/S3RK/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/S3RK/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/S3RK/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/S3RK/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/S3RK/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/S3RK/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/S3RK/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/S3RK/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/S3RK/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/S3RK/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/S3RK/bitcoin/events",
        "forks_url": "https://api.github.com/repos/S3RK/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/S3RK/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/S3RK/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/S3RK/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/S3RK/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/S3RK/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/S3RK/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/S3RK/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/S3RK/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/S3RK/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/S3RK/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/S3RK/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/S3RK/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/S3RK/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/S3RK/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/S3RK/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:S3RK/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/S3RK/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/S3RK/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/S3RK/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/S3RK/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/S3RK/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/S3RK/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/S3RK/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/S3RK/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/S3RK/bitcoin/hooks",
        "svn_url": "https://github.com/S3RK/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 0,
        "stargazers_count": 1,
        "watchers_count": 1,
        "size": 213012,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-02-15T08:37:12Z",
        "created_at": "2020-06-01T04:37:33Z",
        "updated_at": "2022-11-28T07:47:20Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "138d55e6a0241f126916fde6ac9177c7e2a119c4",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 34324,
        "stargazers_count": 69819,
        "watchers_count": 69819,
        "size": 233879,
        "default_branch": "master",
        "open_issues_count": 627,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-06-07T05:35:10Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2023-06-07T04:47:18Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 269,
    "deletions": 0,
    "changed_files": 2,
    "commits": 1,
    "review_comments": 37,
    "comments": 8
  },
  "events": [
    {
      "event": "head_ref_force_pushed",
      "id": 6249028929,
      "node_id": "HRFPE_lADOABII585Fx4nIzwAAAAF0eJ1B",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6249028929",
      "actor": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-03-16T08:47:48Z"
    },
    {
      "event": "labeled",
      "id": 6249047951,
      "node_id": "LE_lADOABII585Fx4nIzwAAAAF0eOeP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6249047951",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-03-16T08:51:02Z",
      "label": {
        "name": "Tests",
        "color": "d4c5f9"
      }
    },
    {
      "event": "review_requested",
      "id": 6253991285,
      "node_id": "RRE_lADOABII585Fx4nIzwAAAAF0xFV1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6253991285",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-03-16T21:05:15Z",
      "requested_reviewer": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "reviewed",
      "id": 912326810,
      "node_id": "PRR_kwDOABII5842YQCa",
      "url": null,
      "actor": null,
      "commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Cool! Concept ACK. Did a light review, haven't reproduced all the numbers.",
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#pullrequestreview-912326810",
      "submitted_at": "2022-03-17T22:24:50Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGUzNzg4ODM4OTJiMTA0YjJmMjQ0MTU0MDU1MGMzOWM2YTVkZDcxZDA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e378883892b104b2f2441540550c39c6a5dd71d0",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/e378883892b104b2f2441540550c39c6a5dd71d0",
      "tree": {
        "sha": "c2c9efcdf70200906e7fb10a53d14446c9b2401e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c2c9efcdf70200906e7fb10a53d14446c9b2401e"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/310ba924949b0052105a7937ac69d65a3864692b",
          "sha": "310ba924949b0052105a7937ac69d65a3864692b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/310ba924949b0052105a7937ac69d65a3864692b"
        }
      ],
      "message": "test: coinselection edge cases",
      "committer": {
        "name": "S3RK",
        "email": "1466284+S3RK@users.noreply.github.com",
        "date": "2022-03-22T08:49:42Z"
      },
      "author": {
        "name": "S3RK",
        "email": "1466284+S3RK@users.noreply.github.com",
        "date": "2022-03-16T08:35:18Z"
      },
      "sha": "e378883892b104b2f2441540550c39c6a5dd71d0"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6281714224,
      "node_id": "HRFPE_lADOABII585Fx4nIzwAAAAF2a1ow",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6281714224",
      "actor": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-03-22T08:49:54Z"
    },
    {
      "event": "commented",
      "id": 1074893626,
      "node_id": "IC_kwDOABII585AEZM6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1074893626",
      "actor": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-03-22T08:51:03Z",
      "updated_at": "2022-03-22T08:51:03Z",
      "author_association": "MEMBER",
      "body": "Retouched comments to address Xekyo's feedback.",
      "user": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#issuecomment-1074893626",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24580"
    },
    {
      "event": "commented",
      "id": 1076797170,
      "node_id": "IC_kwDOABII585ALp7y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1076797170",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-03-23T20:38:55Z",
      "updated_at": "2022-03-23T20:38:55Z",
      "author_association": "MEMBER",
      "body": "Looks good. What is the next step you plan for this PR? How can one help?",
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#issuecomment-1076797170",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24580"
    },
    {
      "event": "commented",
      "id": 1077381807,
      "node_id": "IC_kwDOABII585AN4qv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1077381807",
      "actor": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-03-24T08:50:46Z",
      "updated_at": "2022-03-24T08:50:46Z",
      "author_association": "MEMBER",
      "body": "I thought this PR can be merged roughly as it is (addressing all the concerns of course), as I believe the test is valuable in itself.\r\n\r\nAs a follow up I'd like to fix some of the inefficiencies of coin selection by increasing BnB upper limit. But for that we need to improve how we drop change for fees.  I tried one approach in #23367 but it doesn't work that well. So I'm going splitting #23367 into parts that could be merged independently (the first one -> #24649).\r\n\r\nLet's talk on the next wallet meeting.",
      "user": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#issuecomment-1077381807",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24580"
    },
    {
      "event": "commented",
      "id": 1081453982,
      "node_id": "IC_kwDOABII585Ada2e",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1081453982",
      "actor": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-03-29T06:27:49Z",
      "updated_at": "2022-03-29T06:27:49Z",
      "author_association": "MEMBER",
      "body": "There is probably a conflict with #24494. ",
      "user": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#issuecomment-1081453982",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24580"
    },
    {
      "event": "commented",
      "id": 1099386858,
      "node_id": "IC_kwDOABII585Bh0_q",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1099386858",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-04-14T16:38:54Z",
      "updated_at": "2022-04-14T16:38:54Z",
      "author_association": "MEMBER",
      "body": "While I appreciate more tests, these tests seem to be extremely specific to the way that coin selection currently works and look like they would start failing as soon as we change something, such as removing knapsack. So I'm not sure if we actually want to have these tests if they are going to be removed and/or require a ton of recalculation for future coin selection changes.\r\n\r\nIf we do want these tests, then I don't think it should use legacy addresses so much as hopefully we won't make those by default soon.",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#issuecomment-1099386858",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24580"
    },
    {
      "event": "commented",
      "id": 1102164420,
      "node_id": "IC_kwDOABII585BsbHE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1102164420",
      "actor": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-04-19T06:59:39Z",
      "updated_at": "2022-04-19T06:59:39Z",
      "author_association": "MEMBER",
      "body": "> While I appreciate more tests, these tests seem to be extremely specific to the way that coin selection currently works and look like they would start failing as soon as we change something, such as removing knapsack. So I'm not sure if we actually want to have these tests if they are going to be removed and/or require a ton of recalculation for future coin selection changes. \r\n\r\nAgree, these are not your normal tests, primarily because it's hard to define the \"right\" or \"expected\" outcome. I created these tests to expose some shortcomings of current coin selection and justify increasing BnB limit (#24752). It'd be nice to have them around in some form to avoid regressions, maybe we can incorporate them somehow into simulations. wdyt?\r\n\r\n> If we do want these tests, then I don't think it should use legacy addresses so much as hopefully we won't make those by default soon.\r\n",
      "user": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#issuecomment-1102164420",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24580"
    },
    {
      "event": "commented",
      "id": 1133247916,
      "node_id": "IC_kwDOABII585Di_2s",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1133247916",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-20T19:27:40Z",
      "updated_at": "2022-05-20T19:27:40Z",
      "author_association": "MEMBER",
      "body": "To throw my relatively unproductive opinion into the mix, this is a staggeringly large number of magic numbers. Ideally all numbers in tests are \"obvious\" or programmatic. It's a nightmare to maintain otherwise.\r\n\r\nDidn't read or think enough about overall thrust of the tests.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#issuecomment-1133247916",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24580"
    },
    {
      "event": "commented",
      "id": 1134219091,
      "node_id": "IC_kwDOABII585Dms9T",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1134219091",
      "actor": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-23T06:06:01Z",
      "updated_at": "2022-05-23T06:06:01Z",
      "author_association": "MEMBER",
      "body": "Thanks for the feedback. Maybe a better way to verify coin selection would to integrate some simulation/benchmark into this repo.",
      "user": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#issuecomment-1134219091",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24580"
    },
    {
      "event": "closed",
      "id": 6657991794,
      "node_id": "CE_lADOABII585Fx4nIzwAAAAGM2ORy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6657991794",
      "actor": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-23T06:06:01Z"
    },
    {
      "event": "locked",
      "id": 9313991747,
      "node_id": "LOE_lADOABII585Fx4nIzwAAAAIrKDxD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9313991747",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-23T10:02:59Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/828485890",
      "pull_request_review_id": 912326810,
      "id": 828485890,
      "node_id": "PRRC_kwDOABII584xYbEC",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly",
      "path": "test/functional/wallet_coinselection.py",
      "position": 44,
      "original_position": 41,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": null,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I noticed there is a todo left here. Is that an open question?",
      "created_at": "2022-03-16T21:58:36Z",
      "updated_at": "2022-03-17T22:24:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r828485890",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/828485890"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 44,
      "original_line": 44,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829496634",
      "pull_request_review_id": 912326810,
      "id": 829496634,
      "node_id": "PRRC_kwDOABII584xcR06",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):\n+            w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.05)\n+\n+        # We will target a solution with 20 coins that will add up exactly to 1btc.\n+        # Add a coin that will cover all the fees and exactly match the target.\n+        # TODO: fix that knapsack targets change even if there is no change needed\n+        # (148*20+42+31)*350+5000000 = 6061550",
      "path": "test/functional/wallet_coinselection.py",
      "position": null,
      "original_position": 146,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": null,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What's the 42 here? Is that the header plus a P2SH output?",
      "created_at": "2022-03-17T20:51:11Z",
      "updated_at": "2022-03-17T22:24:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r829496634",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829496634"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 146,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829510715",
      "pull_request_review_id": 912326810,
      "id": 829510715,
      "node_id": "PRRC_kwDOABII584xcVQ7",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat",
      "path": "test/functional/wallet_coinselection.py",
      "position": null,
      "original_position": 88,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": null,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm wondering what the 42 is here. Is that the output plus header? My first intuition was that it was just the output, but then I realized that it probably is the whole transaction weight that's being calculated. Does that mean that we're expecting a wrapped segwit output here? Perhaps you could split up the calculation a bit more for clarity, e.g. (10+148+32), if I interpret that correctly.",
      "created_at": "2022-03-17T21:03:41Z",
      "updated_at": "2022-03-17T22:24:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r829510715",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829510715"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829514531",
      "pull_request_review_id": 912326810,
      "id": 829514531,
      "node_id": "PRRC_kwDOABII584xcWMj",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte",
      "path": "test/functional/wallet_coinselection.py",
      "position": null,
      "original_position": 61,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": null,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        # 1-input-1-output tx is 110vbytes (42/4+68+31) which results in 2200sat fee at 20sat/vbyte\r\n```",
      "created_at": "2022-03-17T21:09:29Z",
      "updated_at": "2022-03-17T22:24:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r829514531",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829514531"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829527051",
      "pull_request_review_id": 912326810,
      "id": 829527051,
      "node_id": "PRRC_kwDOABII584xcZQL",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD",
      "path": "test/functional/wallet_coinselection.py",
      "position": null,
      "original_position": 111,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": null,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I was wondering for a bit why the solution could not be found by Knapsack, but then I realized that it probably would, but then a solution with one bech32 input and one legacy input would be preferred because it overshoots the target less by spending more in fees. Given the 1000 iterations, Knapsack would definitely find that solution.\r\n\r\nHowever, then if SRD also found the solution with two bech32 inputs, it would get preferred per the waste metric.\r\nWas that your reasoning as well?",
      "created_at": "2022-03-17T21:27:48Z",
      "updated_at": "2022-03-17T22:24:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r829527051",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829527051"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829530854",
      "pull_request_review_id": 912326810,
      "id": 829530854,
      "node_id": "PRRC_kwDOABII584xcaLm",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32",
      "path": "test/functional/wallet_coinselection.py",
      "position": 127,
      "original_position": 123,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": null,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What do you think would be the outcome if we changed knapsack to keep the solution with the best waste instead of the solution with the smallest change?",
      "created_at": "2022-03-17T21:34:10Z",
      "updated_at": "2022-03-17T22:24:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r829530854",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829530854"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 127,
      "original_line": 127,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829532736",
      "pull_request_review_id": 912326810,
      "id": 829532736,
      "node_id": "PRRC_kwDOABII584xcapA",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):",
      "path": "test/functional/wallet_coinselection.py",
      "position": 144,
      "original_position": 140,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": null,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I was just looking into this user asking about a [transaction with 856 inputs](https://bitcoin.stackexchange.com/q/100437/5406) a few days ago. I'd be curious to see if we could still reproduce behavior like that on a wallet with a UTXO pool of only about 1,000. I think SRD would hopefully make that better, but I would say we could even go higher than 100 here. :)",
      "created_at": "2022-03-17T21:37:26Z",
      "updated_at": "2022-03-17T22:24:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r829532736",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829532736"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 144,
      "original_line": 144,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829534866",
      "pull_request_review_id": 912326810,
      "id": 829534866,
      "node_id": "PRRC_kwDOABII584xcbKS",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):\n+            w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.05)\n+\n+        # We will target a solution with 20 coins that will add up exactly to 1btc.\n+        # Add a coin that will cover all the fees and exactly match the target.\n+        # TODO: fix that knapsack targets change even if there is no change needed",
      "path": "test/functional/wallet_coinselection.py",
      "position": 149,
      "original_position": 145,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": null,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm not sure we should be improving Knapsack. I'd rather get rid of it, but only after we have better coin selection than Knapsack. @achow101 and I were looking into why Knapsack still produces such a high percentage of the selection results in simulations and realized that after all those 1000 random walks, it'll still prefer `lowest_larger` if the latter produces a smaller change (that's still bigger than `min_change`).",
      "created_at": "2022-03-17T21:40:46Z",
      "updated_at": "2022-03-17T22:24:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r829534866",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829534866"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 149,
      "original_line": 149,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829536365",
      "pull_request_review_id": 912326810,
      "id": 829536365,
      "node_id": "PRRC_kwDOABII584xcbht",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):\n+            w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.05)\n+\n+        # We will target a solution with 20 coins that will add up exactly to 1btc.\n+        # Add a coin that will cover all the fees and exactly match the target.\n+        # TODO: fix that knapsack targets change even if there is no change needed",
      "path": "test/functional/wallet_coinselection.py",
      "position": 149,
      "original_position": 145,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": 829534866,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Also, even when Knapsack can't find changeless transactions, wouldn't the expectation be that BnB finds it?",
      "created_at": "2022-03-17T21:43:16Z",
      "updated_at": "2022-03-17T22:24:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r829536365",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829536365"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 149,
      "original_line": 149,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829541057",
      "pull_request_review_id": 912326810,
      "id": 829541057,
      "node_id": "PRRC_kwDOABII584xccrB",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):\n+            w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.05)\n+\n+        # We will target a solution with 20 coins that will add up exactly to 1btc.\n+        # Add a coin that will cover all the fees and exactly match the target.\n+        # TODO: fix that knapsack targets change even if there is no change needed\n+        # (148*20+42+31)*350+5000000 = 6061550\n+        w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.0606155)\n+        self.generate(self.nodes[0], 6)\n+\n+        fee_rate = 350\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins(big_coin, target, iterations=100):\n+            txid = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), big_coin)\n+            self.generate(self.nodes[0], 6)\n+\n+            fee_total = 0\n+            max_fee = 0\n+            for _ in range(iterations):\n+                result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+                fee_total += result['fee']\n+                max_fee = max(max_fee, result['fee'])\n+\n+            # lock big coin\n+            w1.lockunspent(False, [tx for tx in w1.listunspent() if tx['txid'] == txid])\n+            return fee_total, max_fee\n+\n+        # in all the scenarios below the best solution would be to take one big coin and create a change output\n+        best_fee = (42 + 68 + 31) * fee_rate / COIN",
      "path": "test/functional/wallet_coinselection.py",
      "position": null,
      "original_position": 169,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": null,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "42 kinda throws me off a bit as before, but still assuming it's header + output",
      "created_at": "2022-03-17T21:51:54Z",
      "updated_at": "2022-03-17T22:24:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r829541057",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829541057"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829548137",
      "pull_request_review_id": 912326810,
      "id": 829548137,
      "node_id": "PRRC_kwDOABII584xceZp",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):\n+            w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.05)\n+\n+        # We will target a solution with 20 coins that will add up exactly to 1btc.\n+        # Add a coin that will cover all the fees and exactly match the target.\n+        # TODO: fix that knapsack targets change even if there is no change needed\n+        # (148*20+42+31)*350+5000000 = 6061550\n+        w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.0606155)\n+        self.generate(self.nodes[0], 6)\n+\n+        fee_rate = 350\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins(big_coin, target, iterations=100):\n+            txid = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), big_coin)\n+            self.generate(self.nodes[0], 6)\n+\n+            fee_total = 0\n+            max_fee = 0\n+            for _ in range(iterations):\n+                result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+                fee_total += result['fee']\n+                max_fee = max(max_fee, result['fee'])\n+\n+            # lock big coin\n+            w1.lockunspent(False, [tx for tx in w1.listunspent() if tx['txid'] == txid])\n+            return fee_total, max_fee\n+\n+        # in all the scenarios below the best solution would be to take one big coin and create a change output\n+        best_fee = (42 + 68 + 31) * fee_rate / COIN\n+\n+        # 0) no exact match is possible, the big coin is closest to target + MIN_CHANGE,\n+        # knapsack always finds the best solution\n+        fee_total, max_fee = select_coins(big_coin=1.01051, target=1.00000001, iterations=100)\n+        assert_approx(max_fee, best_fee)\n+        assert_approx(fee_total, best_fee * 100)\n+\n+        # 1) knapsack latches to the exact match solution and can't find the best solution\n+        # SRD can find a solution better than knapsack if draws the big coin in the first 21 tries\n+        # chances for SRD to find it are roughly 2*(21/102) = ±40%.\n+        # Chances are doubled due to coinselection run twice with and without APS enabled",
      "path": "test/functional/wallet_coinselection.py",
      "position": 184,
      "original_position": 180,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": null,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What's \"APS\"?",
      "created_at": "2022-03-17T22:05:11Z",
      "updated_at": "2022-03-17T22:24:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r829548137",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829548137"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 184,
      "original_line": 184,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829550908",
      "pull_request_review_id": 912326810,
      "id": 829550908,
      "node_id": "PRRC_kwDOABII584xcfE8",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):\n+            w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.05)\n+\n+        # We will target a solution with 20 coins that will add up exactly to 1btc.\n+        # Add a coin that will cover all the fees and exactly match the target.\n+        # TODO: fix that knapsack targets change even if there is no change needed\n+        # (148*20+42+31)*350+5000000 = 6061550\n+        w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.0606155)\n+        self.generate(self.nodes[0], 6)\n+\n+        fee_rate = 350\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins(big_coin, target, iterations=100):\n+            txid = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), big_coin)\n+            self.generate(self.nodes[0], 6)\n+\n+            fee_total = 0\n+            max_fee = 0\n+            for _ in range(iterations):\n+                result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+                fee_total += result['fee']\n+                max_fee = max(max_fee, result['fee'])\n+\n+            # lock big coin\n+            w1.lockunspent(False, [tx for tx in w1.listunspent() if tx['txid'] == txid])\n+            return fee_total, max_fee\n+\n+        # in all the scenarios below the best solution would be to take one big coin and create a change output\n+        best_fee = (42 + 68 + 31) * fee_rate / COIN\n+\n+        # 0) no exact match is possible, the big coin is closest to target + MIN_CHANGE,\n+        # knapsack always finds the best solution\n+        fee_total, max_fee = select_coins(big_coin=1.01051, target=1.00000001, iterations=100)\n+        assert_approx(max_fee, best_fee)\n+        assert_approx(fee_total, best_fee * 100)\n+\n+        # 1) knapsack latches to the exact match solution and can't find the best solution\n+        # SRD can find a solution better than knapsack if draws the big coin in the first 21 tries\n+        # chances for SRD to find it are roughly 2*(21/102) = ±40%.",
      "path": "test/functional/wallet_coinselection.py",
      "position": 183,
      "original_position": 179,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": null,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think the chance is (1-(101/102)×(100/101)×…×(81/82))=(1-81/102)… oh, I see, that's (21/102). So, to get a better SRD solution that would need to occur at least once, which is 1-(81/102)² = 36.93%… okay, I gotcha.",
      "created_at": "2022-03-17T22:08:57Z",
      "updated_at": "2022-03-17T22:24:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r829550908",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829550908"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 183,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829553702",
      "pull_request_review_id": 912326810,
      "id": 829553702,
      "node_id": "PRRC_kwDOABII584xcfwm",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):\n+            w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.05)\n+\n+        # We will target a solution with 20 coins that will add up exactly to 1btc.\n+        # Add a coin that will cover all the fees and exactly match the target.\n+        # TODO: fix that knapsack targets change even if there is no change needed\n+        # (148*20+42+31)*350+5000000 = 6061550\n+        w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.0606155)\n+        self.generate(self.nodes[0], 6)\n+\n+        fee_rate = 350\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins(big_coin, target, iterations=100):\n+            txid = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), big_coin)\n+            self.generate(self.nodes[0], 6)\n+\n+            fee_total = 0\n+            max_fee = 0\n+            for _ in range(iterations):\n+                result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+                fee_total += result['fee']\n+                max_fee = max(max_fee, result['fee'])\n+\n+            # lock big coin\n+            w1.lockunspent(False, [tx for tx in w1.listunspent() if tx['txid'] == txid])\n+            return fee_total, max_fee\n+\n+        # in all the scenarios below the best solution would be to take one big coin and create a change output\n+        best_fee = (42 + 68 + 31) * fee_rate / COIN\n+\n+        # 0) no exact match is possible, the big coin is closest to target + MIN_CHANGE,\n+        # knapsack always finds the best solution\n+        fee_total, max_fee = select_coins(big_coin=1.01051, target=1.00000001, iterations=100)\n+        assert_approx(max_fee, best_fee)\n+        assert_approx(fee_total, best_fee * 100)\n+\n+        # 1) knapsack latches to the exact match solution and can't find the best solution",
      "path": "test/functional/wallet_coinselection.py",
      "position": null,
      "original_position": 177,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": null,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We've previously used \"exact match\" for any changeless solution, so it wasn't immediately obvious to me that it was used in the literal sense here. Perhaps you should clarify that you mean that it's literally the same to the sat.",
      "created_at": "2022-03-17T22:12:04Z",
      "updated_at": "2022-03-17T22:24:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r829553702",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829553702"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 177,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829553922",
      "pull_request_review_id": 912326810,
      "id": 829553922,
      "node_id": "PRRC_kwDOABII584xcf0C",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):\n+            w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.05)\n+\n+        # We will target a solution with 20 coins that will add up exactly to 1btc.\n+        # Add a coin that will cover all the fees and exactly match the target.\n+        # TODO: fix that knapsack targets change even if there is no change needed\n+        # (148*20+42+31)*350+5000000 = 6061550\n+        w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.0606155)\n+        self.generate(self.nodes[0], 6)\n+\n+        fee_rate = 350\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins(big_coin, target, iterations=100):\n+            txid = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), big_coin)\n+            self.generate(self.nodes[0], 6)\n+\n+            fee_total = 0\n+            max_fee = 0\n+            for _ in range(iterations):\n+                result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+                fee_total += result['fee']\n+                max_fee = max(max_fee, result['fee'])\n+\n+            # lock big coin\n+            w1.lockunspent(False, [tx for tx in w1.listunspent() if tx['txid'] == txid])\n+            return fee_total, max_fee\n+\n+        # in all the scenarios below the best solution would be to take one big coin and create a change output\n+        best_fee = (42 + 68 + 31) * fee_rate / COIN\n+\n+        # 0) no exact match is possible, the big coin is closest to target + MIN_CHANGE,\n+        # knapsack always finds the best solution\n+        fee_total, max_fee = select_coins(big_coin=1.01051, target=1.00000001, iterations=100)\n+        assert_approx(max_fee, best_fee)\n+        assert_approx(fee_total, best_fee * 100)\n+\n+        # 1) knapsack latches to the exact match solution and can't find the best solution\n+        # SRD can find a solution better than knapsack if draws the big coin in the first 21 tries\n+        # chances for SRD to find it are roughly 2*(21/102) = ±40%.\n+        # Chances are doubled due to coinselection run twice with and without APS enabled\n+        fee_total, max_fee = select_coins(big_coin=1.01051, target=1.0, iterations=100)\n+        knapsack_fee = (42 + 31 + 148*20) * fee_rate / COIN\n+        assert_approx(max_fee, knapsack_fee)\n+        # total fee is lower due to lucky SRD solutions\n+        assert_greater_than(knapsack_fee * 100, fee_total)\n+        assert_greater_than(fee_total, best_fee * 100)\n+\n+        # 2) no exact match, effective value of the big coin is smaller than target + MIN_CHANGE",
      "path": "test/functional/wallet_coinselection.py",
      "position": null,
      "original_position": 188,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": null,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I realized above use of \"exact match\" here. :)",
      "created_at": "2022-03-17T22:12:30Z",
      "updated_at": "2022-03-17T22:24:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r829553922",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829553922"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 188,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829554970",
      "pull_request_review_id": 912326810,
      "id": 829554970,
      "node_id": "PRRC_kwDOABII584xcgEa",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):\n+            w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.05)\n+\n+        # We will target a solution with 20 coins that will add up exactly to 1btc.\n+        # Add a coin that will cover all the fees and exactly match the target.\n+        # TODO: fix that knapsack targets change even if there is no change needed\n+        # (148*20+42+31)*350+5000000 = 6061550\n+        w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.0606155)\n+        self.generate(self.nodes[0], 6)\n+\n+        fee_rate = 350\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins(big_coin, target, iterations=100):\n+            txid = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), big_coin)\n+            self.generate(self.nodes[0], 6)\n+\n+            fee_total = 0\n+            max_fee = 0\n+            for _ in range(iterations):\n+                result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+                fee_total += result['fee']\n+                max_fee = max(max_fee, result['fee'])\n+\n+            # lock big coin\n+            w1.lockunspent(False, [tx for tx in w1.listunspent() if tx['txid'] == txid])\n+            return fee_total, max_fee\n+\n+        # in all the scenarios below the best solution would be to take one big coin and create a change output\n+        best_fee = (42 + 68 + 31) * fee_rate / COIN\n+\n+        # 0) no exact match is possible, the big coin is closest to target + MIN_CHANGE,\n+        # knapsack always finds the best solution\n+        fee_total, max_fee = select_coins(big_coin=1.01051, target=1.00000001, iterations=100)\n+        assert_approx(max_fee, best_fee)\n+        assert_approx(fee_total, best_fee * 100)\n+\n+        # 1) knapsack latches to the exact match solution and can't find the best solution\n+        # SRD can find a solution better than knapsack if draws the big coin in the first 21 tries\n+        # chances for SRD to find it are roughly 2*(21/102) = ±40%.\n+        # Chances are doubled due to coinselection run twice with and without APS enabled\n+        fee_total, max_fee = select_coins(big_coin=1.01051, target=1.0, iterations=100)\n+        knapsack_fee = (42 + 31 + 148*20) * fee_rate / COIN\n+        assert_approx(max_fee, knapsack_fee)\n+        # total fee is lower due to lucky SRD solutions\n+        assert_greater_than(knapsack_fee * 100, fee_total)\n+        assert_greater_than(fee_total, best_fee * 100)\n+\n+        # 2) no exact match, effective value of the big coin is smaller than target + MIN_CHANGE\n+        # BnB can find the same solution from previous test but dropping the change output to fees",
      "path": "test/functional/wallet_coinselection.py",
      "position": null,
      "original_position": 189,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": null,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        # BnB will find the same solution from previous test but dropping the change output to fees\r\n```\r\nBnB is deterministic, so if it \"can\" I would expect that it does? Does \"change output\" mean \"remainder\" here?—Is this the BnB without an upper bound or the variant we currently use?",
      "created_at": "2022-03-17T22:14:36Z",
      "updated_at": "2022-03-17T22:24:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r829554970",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829554970"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829556908",
      "pull_request_review_id": 912326810,
      "id": 829556908,
      "node_id": "PRRC_kwDOABII584xcgis",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):\n+            w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.05)\n+\n+        # We will target a solution with 20 coins that will add up exactly to 1btc.\n+        # Add a coin that will cover all the fees and exactly match the target.\n+        # TODO: fix that knapsack targets change even if there is no change needed\n+        # (148*20+42+31)*350+5000000 = 6061550\n+        w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.0606155)\n+        self.generate(self.nodes[0], 6)\n+\n+        fee_rate = 350\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins(big_coin, target, iterations=100):\n+            txid = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), big_coin)\n+            self.generate(self.nodes[0], 6)\n+\n+            fee_total = 0\n+            max_fee = 0\n+            for _ in range(iterations):\n+                result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+                fee_total += result['fee']\n+                max_fee = max(max_fee, result['fee'])\n+\n+            # lock big coin\n+            w1.lockunspent(False, [tx for tx in w1.listunspent() if tx['txid'] == txid])\n+            return fee_total, max_fee\n+\n+        # in all the scenarios below the best solution would be to take one big coin and create a change output\n+        best_fee = (42 + 68 + 31) * fee_rate / COIN\n+\n+        # 0) no exact match is possible, the big coin is closest to target + MIN_CHANGE,\n+        # knapsack always finds the best solution\n+        fee_total, max_fee = select_coins(big_coin=1.01051, target=1.00000001, iterations=100)\n+        assert_approx(max_fee, best_fee)\n+        assert_approx(fee_total, best_fee * 100)\n+\n+        # 1) knapsack latches to the exact match solution and can't find the best solution\n+        # SRD can find a solution better than knapsack if draws the big coin in the first 21 tries\n+        # chances for SRD to find it are roughly 2*(21/102) = ±40%.\n+        # Chances are doubled due to coinselection run twice with and without APS enabled\n+        fee_total, max_fee = select_coins(big_coin=1.01051, target=1.0, iterations=100)\n+        knapsack_fee = (42 + 31 + 148*20) * fee_rate / COIN\n+        assert_approx(max_fee, knapsack_fee)\n+        # total fee is lower due to lucky SRD solutions\n+        assert_greater_than(knapsack_fee * 100, fee_total)\n+        assert_greater_than(fee_total, best_fee * 100)\n+\n+        # 2) no exact match, effective value of the big coin is smaller than target + MIN_CHANGE\n+        # BnB can find the same solution from previous test but dropping the change output to fees\n+        # SRD still occasionally find better solution\n+        fee_total, max_fee = select_coins(big_coin=1.01031, target=1.00000001, iterations=100)\n+        dropped_to_fees = 31 * fee_rate\n+        bnb_fee = ((42 + 148*20) * fee_rate + dropped_to_fees) / COIN\n+        assert_approx(max_fee, bnb_fee)\n+        assert_greater_than(bnb_fee * 100, fee_total)\n+        assert_greater_than(fee_total, best_fee * 100)\n+\n+        # 3) target is too far away for BnB to find a solution\n+        # effective value of the big coin is smaller than target + MIN_CHANGE\n+        #  * BnB can't find a solution as the distance from target is farther than cost of change\n+        #    6061550 + 5000000*19-(42+148*20)*350-99999319 = 11531\n+        #    cost_of_change = 11530 = 31*350 + 68*10\n+        #  * knapsack finds closest solution to target + MIN_CHANGE with 21 small coins\n+        #  * SRD still occasionally find better solution\n+        fee_total, max_fee = select_coins(big_coin=1.01031, target=0.99999319, iterations=100)\n+        srd_fee = (41 + 147*21 + 31) * fee_rate / COIN\n+        assert_approx(max_fee, srd_fee)\n+        assert_greater_than(srd_fee * 100, fee_total)\n+        assert_greater_than(fee_total, best_fee * 100)\n+\n+        # 4) knapsack latches to exact match + MIN_CHANGE\n+        # SRD still occasionally find better solution\n+        fee_total, max_fee = select_coins(big_coin=1.00051, target=0.99, iterations=100)",
      "path": "test/functional/wallet_coinselection.py",
      "position": 218,
      "original_position": 213,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": null,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It's a bit hard for me to follow how the exact values were picked, since both the `big_coin` and `target` are changing. I haven't tried to step by step reproduce each calculation in this first review, and I do see that many of your test cases do explain some of the calculation, but I just noticed that this one for example does not.\r\n\r\nSince it's not trivial for me to follow, I kinda expect that other reviewers might also need a bit help. :grin: ",
      "created_at": "2022-03-17T22:18:37Z",
      "updated_at": "2022-03-17T22:24:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r829556908",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829556908"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 218,
      "original_line": 218,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829559587",
      "pull_request_review_id": 912326810,
      "id": 829559587,
      "node_id": "PRRC_kwDOABII584xchMj",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):\n+            w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.05)\n+\n+        # We will target a solution with 20 coins that will add up exactly to 1btc.\n+        # Add a coin that will cover all the fees and exactly match the target.\n+        # TODO: fix that knapsack targets change even if there is no change needed\n+        # (148*20+42+31)*350+5000000 = 6061550\n+        w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.0606155)\n+        self.generate(self.nodes[0], 6)\n+\n+        fee_rate = 350\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins(big_coin, target, iterations=100):\n+            txid = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), big_coin)\n+            self.generate(self.nodes[0], 6)\n+\n+            fee_total = 0\n+            max_fee = 0\n+            for _ in range(iterations):\n+                result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+                fee_total += result['fee']\n+                max_fee = max(max_fee, result['fee'])\n+\n+            # lock big coin\n+            w1.lockunspent(False, [tx for tx in w1.listunspent() if tx['txid'] == txid])\n+            return fee_total, max_fee\n+\n+        # in all the scenarios below the best solution would be to take one big coin and create a change output\n+        best_fee = (42 + 68 + 31) * fee_rate / COIN\n+\n+        # 0) no exact match is possible, the big coin is closest to target + MIN_CHANGE,\n+        # knapsack always finds the best solution\n+        fee_total, max_fee = select_coins(big_coin=1.01051, target=1.00000001, iterations=100)\n+        assert_approx(max_fee, best_fee)\n+        assert_approx(fee_total, best_fee * 100)\n+\n+        # 1) knapsack latches to the exact match solution and can't find the best solution\n+        # SRD can find a solution better than knapsack if draws the big coin in the first 21 tries\n+        # chances for SRD to find it are roughly 2*(21/102) = ±40%.\n+        # Chances are doubled due to coinselection run twice with and without APS enabled\n+        fee_total, max_fee = select_coins(big_coin=1.01051, target=1.0, iterations=100)\n+        knapsack_fee = (42 + 31 + 148*20) * fee_rate / COIN\n+        assert_approx(max_fee, knapsack_fee)\n+        # total fee is lower due to lucky SRD solutions\n+        assert_greater_than(knapsack_fee * 100, fee_total)\n+        assert_greater_than(fee_total, best_fee * 100)\n+\n+        # 2) no exact match, effective value of the big coin is smaller than target + MIN_CHANGE\n+        # BnB can find the same solution from previous test but dropping the change output to fees\n+        # SRD still occasionally find better solution\n+        fee_total, max_fee = select_coins(big_coin=1.01031, target=1.00000001, iterations=100)\n+        dropped_to_fees = 31 * fee_rate\n+        bnb_fee = ((42 + 148*20) * fee_rate + dropped_to_fees) / COIN\n+        assert_approx(max_fee, bnb_fee)\n+        assert_greater_than(bnb_fee * 100, fee_total)\n+        assert_greater_than(fee_total, best_fee * 100)\n+\n+        # 3) target is too far away for BnB to find a solution\n+        # effective value of the big coin is smaller than target + MIN_CHANGE\n+        #  * BnB can't find a solution as the distance from target is farther than cost of change\n+        #    6061550 + 5000000*19-(42+148*20)*350-99999319 = 11531\n+        #    cost_of_change = 11530 = 31*350 + 68*10\n+        #  * knapsack finds closest solution to target + MIN_CHANGE with 21 small coins\n+        #  * SRD still occasionally find better solution\n+        fee_total, max_fee = select_coins(big_coin=1.01031, target=0.99999319, iterations=100)\n+        srd_fee = (41 + 147*21 + 31) * fee_rate / COIN\n+        assert_approx(max_fee, srd_fee)\n+        assert_greater_than(srd_fee * 100, fee_total)\n+        assert_greater_than(fee_total, best_fee * 100)\n+\n+        # 4) knapsack latches to exact match + MIN_CHANGE\n+        # SRD still occasionally find better solution\n+        fee_total, max_fee = select_coins(big_coin=1.00051, target=0.99, iterations=100)\n+        knapsack_fee = (41 + 31 + 147*20) * fee_rate / COIN\n+        assert_approx(max_fee, knapsack_fee)\n+        assert_greater_than(knapsack_fee * 100, fee_total)\n+        assert_greater_than(fee_total, best_fee * 100)\n+\n+    def test_one_big_coin(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_coin\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_coin\")\n+\n+        w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 50)\n+        self.generate(self.nodes[0], 1)\n+\n+        # change is less than MIN_CHANGE but we still create it as we don't have other options\n+        result = w1.fundrawtransaction(w1.createrawtransaction([], {w0.getnewaddress(): 49.9999}), {\"fee_rate\": 10})\n+        tx = w1.decoderawtransaction(result['hex'])\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_small_coin(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_small_coin\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_small_coin\")\n+\n+        w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.011)\n+        w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 50)\n+        self.generate(self.nodes[0], 1)\n+\n+        dummyaddress = w0.getnewaddress()\n+        fee_rate = 20\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # if change is > MIN_CHANGE than we just spend big coin and create a change\n+        tx = select_coins_for(49.9)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # if small coins > MIN_CHANGE than we just add one small coin to the big one and create change",
      "path": "test/functional/wallet_coinselection.py",
      "position": 261,
      "original_position": 254,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": null,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This comment confuses me. After paying the fees, the big coin doesn't have enough funds to pay fees and create the output here, so we would always need both coins.",
      "created_at": "2022-03-17T22:24:07Z",
      "updated_at": "2022-03-17T22:24:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r829559587",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/829559587"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 261,
      "original_line": 261,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/830870365",
      "pull_request_review_id": 915407965,
      "id": 830870365,
      "node_id": "PRRC_kwDOABII584xhhNd",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):\n+            w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.05)\n+\n+        # We will target a solution with 20 coins that will add up exactly to 1btc.\n+        # Add a coin that will cover all the fees and exactly match the target.\n+        # TODO: fix that knapsack targets change even if there is no change needed\n+        # (148*20+42+31)*350+5000000 = 6061550",
      "path": "test/functional/wallet_coinselection.py",
      "position": null,
      "original_position": 146,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": 829496634,
      "user": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "42 is header (11) + p2pwkh (31). I'll updated the comment",
      "created_at": "2022-03-21T08:52:27Z",
      "updated_at": "2022-03-21T08:52:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r830870365",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/830870365"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 146,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/830871189",
      "pull_request_review_id": 915409092,
      "id": 830871189,
      "node_id": "PRRC_kwDOABII584xhhaV",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat",
      "path": "test/functional/wallet_coinselection.py",
      "position": null,
      "original_position": 88,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": 829510715,
      "user": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, 42 is output + header. I'll update the comment",
      "created_at": "2022-03-21T08:53:32Z",
      "updated_at": "2022-03-21T08:53:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r830871189",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/830871189"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/830871748",
      "pull_request_review_id": 915409883,
      "id": 830871748,
      "node_id": "PRRC_kwDOABII584xhhjE",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte",
      "path": "test/functional/wallet_coinselection.py",
      "position": null,
      "original_position": 61,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": 829514531,
      "user": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'll update the comment",
      "created_at": "2022-03-21T08:54:19Z",
      "updated_at": "2022-03-21T08:54:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r830871748",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/830871748"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/830876140",
      "pull_request_review_id": 915416006,
      "id": 830876140,
      "node_id": "PRRC_kwDOABII584xhins",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD",
      "path": "test/functional/wallet_coinselection.py",
      "position": null,
      "original_position": 111,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": 829527051,
      "user": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Exactly. Knapsack prefers a solution with legacy+bech32 as it's closer to the target + MIN_CHANGE due to higher fees.\r\nI'll update the comment",
      "created_at": "2022-03-21T08:59:57Z",
      "updated_at": "2022-03-21T08:59:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r830876140",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/830876140"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/830879280",
      "pull_request_review_id": 915420468,
      "id": 830879280,
      "node_id": "PRRC_kwDOABII584xhjYw",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):\n+            w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.05)\n+\n+        # We will target a solution with 20 coins that will add up exactly to 1btc.\n+        # Add a coin that will cover all the fees and exactly match the target.\n+        # TODO: fix that knapsack targets change even if there is no change needed\n+        # (148*20+42+31)*350+5000000 = 6061550\n+        w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.0606155)\n+        self.generate(self.nodes[0], 6)\n+\n+        fee_rate = 350\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins(big_coin, target, iterations=100):\n+            txid = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), big_coin)\n+            self.generate(self.nodes[0], 6)\n+\n+            fee_total = 0\n+            max_fee = 0\n+            for _ in range(iterations):\n+                result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+                fee_total += result['fee']\n+                max_fee = max(max_fee, result['fee'])\n+\n+            # lock big coin\n+            w1.lockunspent(False, [tx for tx in w1.listunspent() if tx['txid'] == txid])\n+            return fee_total, max_fee\n+\n+        # in all the scenarios below the best solution would be to take one big coin and create a change output\n+        best_fee = (42 + 68 + 31) * fee_rate / COIN",
      "path": "test/functional/wallet_coinselection.py",
      "position": null,
      "original_position": 169,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": 829541057,
      "user": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "yes, it's. I'll split off the calculation",
      "created_at": "2022-03-21T09:04:03Z",
      "updated_at": "2022-03-21T09:04:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r830879280",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/830879280"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 169,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/830879786",
      "pull_request_review_id": 915421247,
      "id": 830879786,
      "node_id": "PRRC_kwDOABII584xhjgq",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):\n+            w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.05)\n+\n+        # We will target a solution with 20 coins that will add up exactly to 1btc.\n+        # Add a coin that will cover all the fees and exactly match the target.\n+        # TODO: fix that knapsack targets change even if there is no change needed\n+        # (148*20+42+31)*350+5000000 = 6061550\n+        w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.0606155)\n+        self.generate(self.nodes[0], 6)\n+\n+        fee_rate = 350\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins(big_coin, target, iterations=100):\n+            txid = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), big_coin)\n+            self.generate(self.nodes[0], 6)\n+\n+            fee_total = 0\n+            max_fee = 0\n+            for _ in range(iterations):\n+                result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+                fee_total += result['fee']\n+                max_fee = max(max_fee, result['fee'])\n+\n+            # lock big coin\n+            w1.lockunspent(False, [tx for tx in w1.listunspent() if tx['txid'] == txid])\n+            return fee_total, max_fee\n+\n+        # in all the scenarios below the best solution would be to take one big coin and create a change output\n+        best_fee = (42 + 68 + 31) * fee_rate / COIN\n+\n+        # 0) no exact match is possible, the big coin is closest to target + MIN_CHANGE,\n+        # knapsack always finds the best solution\n+        fee_total, max_fee = select_coins(big_coin=1.01051, target=1.00000001, iterations=100)\n+        assert_approx(max_fee, best_fee)\n+        assert_approx(fee_total, best_fee * 100)\n+\n+        # 1) knapsack latches to the exact match solution and can't find the best solution\n+        # SRD can find a solution better than knapsack if draws the big coin in the first 21 tries\n+        # chances for SRD to find it are roughly 2*(21/102) = ±40%.\n+        # Chances are doubled due to coinselection run twice with and without APS enabled",
      "path": "test/functional/wallet_coinselection.py",
      "position": 184,
      "original_position": 180,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": 829548137,
      "user": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "avoid partial spends. We run transaction building two times (with and without aps)",
      "created_at": "2022-03-21T09:04:49Z",
      "updated_at": "2022-03-21T09:04:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r830879786",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/830879786"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 184,
      "original_line": 184,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/830881731",
      "pull_request_review_id": 915424185,
      "id": 830881731,
      "node_id": "PRRC_kwDOABII584xhj_D",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):\n+            w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.05)\n+\n+        # We will target a solution with 20 coins that will add up exactly to 1btc.\n+        # Add a coin that will cover all the fees and exactly match the target.\n+        # TODO: fix that knapsack targets change even if there is no change needed\n+        # (148*20+42+31)*350+5000000 = 6061550\n+        w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.0606155)\n+        self.generate(self.nodes[0], 6)\n+\n+        fee_rate = 350\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins(big_coin, target, iterations=100):\n+            txid = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), big_coin)\n+            self.generate(self.nodes[0], 6)\n+\n+            fee_total = 0\n+            max_fee = 0\n+            for _ in range(iterations):\n+                result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+                fee_total += result['fee']\n+                max_fee = max(max_fee, result['fee'])\n+\n+            # lock big coin\n+            w1.lockunspent(False, [tx for tx in w1.listunspent() if tx['txid'] == txid])\n+            return fee_total, max_fee\n+\n+        # in all the scenarios below the best solution would be to take one big coin and create a change output\n+        best_fee = (42 + 68 + 31) * fee_rate / COIN\n+\n+        # 0) no exact match is possible, the big coin is closest to target + MIN_CHANGE,\n+        # knapsack always finds the best solution\n+        fee_total, max_fee = select_coins(big_coin=1.01051, target=1.00000001, iterations=100)\n+        assert_approx(max_fee, best_fee)\n+        assert_approx(fee_total, best_fee * 100)\n+\n+        # 1) knapsack latches to the exact match solution and can't find the best solution\n+        # SRD can find a solution better than knapsack if draws the big coin in the first 21 tries\n+        # chances for SRD to find it are roughly 2*(21/102) = ±40%.",
      "path": "test/functional/wallet_coinselection.py",
      "position": 183,
      "original_position": 179,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": 829550908,
      "user": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes. that is correct. Not sure if I can improve the comment here somehow",
      "created_at": "2022-03-21T09:07:36Z",
      "updated_at": "2022-03-21T09:07:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r830881731",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/830881731"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 183,
      "original_line": 183,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/830881982",
      "pull_request_review_id": 915424564,
      "id": 830881982,
      "node_id": "PRRC_kwDOABII584xhkC-",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):\n+            w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.05)\n+\n+        # We will target a solution with 20 coins that will add up exactly to 1btc.\n+        # Add a coin that will cover all the fees and exactly match the target.\n+        # TODO: fix that knapsack targets change even if there is no change needed\n+        # (148*20+42+31)*350+5000000 = 6061550\n+        w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.0606155)\n+        self.generate(self.nodes[0], 6)\n+\n+        fee_rate = 350\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins(big_coin, target, iterations=100):\n+            txid = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), big_coin)\n+            self.generate(self.nodes[0], 6)\n+\n+            fee_total = 0\n+            max_fee = 0\n+            for _ in range(iterations):\n+                result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+                fee_total += result['fee']\n+                max_fee = max(max_fee, result['fee'])\n+\n+            # lock big coin\n+            w1.lockunspent(False, [tx for tx in w1.listunspent() if tx['txid'] == txid])\n+            return fee_total, max_fee\n+\n+        # in all the scenarios below the best solution would be to take one big coin and create a change output\n+        best_fee = (42 + 68 + 31) * fee_rate / COIN\n+\n+        # 0) no exact match is possible, the big coin is closest to target + MIN_CHANGE,\n+        # knapsack always finds the best solution\n+        fee_total, max_fee = select_coins(big_coin=1.01051, target=1.00000001, iterations=100)\n+        assert_approx(max_fee, best_fee)\n+        assert_approx(fee_total, best_fee * 100)\n+\n+        # 1) knapsack latches to the exact match solution and can't find the best solution",
      "path": "test/functional/wallet_coinselection.py",
      "position": null,
      "original_position": 177,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": 829553702,
      "user": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Will update the comment",
      "created_at": "2022-03-21T09:07:56Z",
      "updated_at": "2022-03-21T09:07:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r830881982",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/830881982"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 177,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/830882145",
      "pull_request_review_id": 915424796,
      "id": 830882145,
      "node_id": "PRRC_kwDOABII584xhkFh",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):\n+            w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.05)\n+\n+        # We will target a solution with 20 coins that will add up exactly to 1btc.\n+        # Add a coin that will cover all the fees and exactly match the target.\n+        # TODO: fix that knapsack targets change even if there is no change needed\n+        # (148*20+42+31)*350+5000000 = 6061550\n+        w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.0606155)\n+        self.generate(self.nodes[0], 6)\n+\n+        fee_rate = 350\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins(big_coin, target, iterations=100):\n+            txid = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), big_coin)\n+            self.generate(self.nodes[0], 6)\n+\n+            fee_total = 0\n+            max_fee = 0\n+            for _ in range(iterations):\n+                result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+                fee_total += result['fee']\n+                max_fee = max(max_fee, result['fee'])\n+\n+            # lock big coin\n+            w1.lockunspent(False, [tx for tx in w1.listunspent() if tx['txid'] == txid])\n+            return fee_total, max_fee\n+\n+        # in all the scenarios below the best solution would be to take one big coin and create a change output\n+        best_fee = (42 + 68 + 31) * fee_rate / COIN\n+\n+        # 0) no exact match is possible, the big coin is closest to target + MIN_CHANGE,\n+        # knapsack always finds the best solution\n+        fee_total, max_fee = select_coins(big_coin=1.01051, target=1.00000001, iterations=100)\n+        assert_approx(max_fee, best_fee)\n+        assert_approx(fee_total, best_fee * 100)\n+\n+        # 1) knapsack latches to the exact match solution and can't find the best solution\n+        # SRD can find a solution better than knapsack if draws the big coin in the first 21 tries\n+        # chances for SRD to find it are roughly 2*(21/102) = ±40%.\n+        # Chances are doubled due to coinselection run twice with and without APS enabled\n+        fee_total, max_fee = select_coins(big_coin=1.01051, target=1.0, iterations=100)\n+        knapsack_fee = (42 + 31 + 148*20) * fee_rate / COIN\n+        assert_approx(max_fee, knapsack_fee)\n+        # total fee is lower due to lucky SRD solutions\n+        assert_greater_than(knapsack_fee * 100, fee_total)\n+        assert_greater_than(fee_total, best_fee * 100)\n+\n+        # 2) no exact match, effective value of the big coin is smaller than target + MIN_CHANGE",
      "path": "test/functional/wallet_coinselection.py",
      "position": null,
      "original_position": 188,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": 829553922,
      "user": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks. Will retouch the comment",
      "created_at": "2022-03-21T09:08:10Z",
      "updated_at": "2022-03-21T09:08:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r830882145",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/830882145"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 188,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/830882765",
      "pull_request_review_id": 915425574,
      "id": 830882765,
      "node_id": "PRRC_kwDOABII584xhkPN",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):\n+            w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.05)\n+\n+        # We will target a solution with 20 coins that will add up exactly to 1btc.\n+        # Add a coin that will cover all the fees and exactly match the target.\n+        # TODO: fix that knapsack targets change even if there is no change needed\n+        # (148*20+42+31)*350+5000000 = 6061550\n+        w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.0606155)\n+        self.generate(self.nodes[0], 6)\n+\n+        fee_rate = 350\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins(big_coin, target, iterations=100):\n+            txid = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), big_coin)\n+            self.generate(self.nodes[0], 6)\n+\n+            fee_total = 0\n+            max_fee = 0\n+            for _ in range(iterations):\n+                result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+                fee_total += result['fee']\n+                max_fee = max(max_fee, result['fee'])\n+\n+            # lock big coin\n+            w1.lockunspent(False, [tx for tx in w1.listunspent() if tx['txid'] == txid])\n+            return fee_total, max_fee\n+\n+        # in all the scenarios below the best solution would be to take one big coin and create a change output\n+        best_fee = (42 + 68 + 31) * fee_rate / COIN\n+\n+        # 0) no exact match is possible, the big coin is closest to target + MIN_CHANGE,\n+        # knapsack always finds the best solution\n+        fee_total, max_fee = select_coins(big_coin=1.01051, target=1.00000001, iterations=100)\n+        assert_approx(max_fee, best_fee)\n+        assert_approx(fee_total, best_fee * 100)\n+\n+        # 1) knapsack latches to the exact match solution and can't find the best solution\n+        # SRD can find a solution better than knapsack if draws the big coin in the first 21 tries\n+        # chances for SRD to find it are roughly 2*(21/102) = ±40%.\n+        # Chances are doubled due to coinselection run twice with and without APS enabled\n+        fee_total, max_fee = select_coins(big_coin=1.01051, target=1.0, iterations=100)\n+        knapsack_fee = (42 + 31 + 148*20) * fee_rate / COIN\n+        assert_approx(max_fee, knapsack_fee)\n+        # total fee is lower due to lucky SRD solutions\n+        assert_greater_than(knapsack_fee * 100, fee_total)\n+        assert_greater_than(fee_total, best_fee * 100)\n+\n+        # 2) no exact match, effective value of the big coin is smaller than target + MIN_CHANGE\n+        # BnB can find the same solution from previous test but dropping the change output to fees",
      "path": "test/functional/wallet_coinselection.py",
      "position": null,
      "original_position": 189,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": 829554970,
      "user": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Any BnB, since we're within the cost of change bound. I'll retouch the comment",
      "created_at": "2022-03-21T09:08:53Z",
      "updated_at": "2022-03-21T09:08:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r830882765",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/830882765"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 189,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/831839767",
      "pull_request_review_id": 916759715,
      "id": 831839767,
      "node_id": "PRRC_kwDOABII584xlN4X",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):\n+            w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.05)\n+\n+        # We will target a solution with 20 coins that will add up exactly to 1btc.\n+        # Add a coin that will cover all the fees and exactly match the target.\n+        # TODO: fix that knapsack targets change even if there is no change needed\n+        # (148*20+42+31)*350+5000000 = 6061550\n+        w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.0606155)\n+        self.generate(self.nodes[0], 6)\n+\n+        fee_rate = 350\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins(big_coin, target, iterations=100):\n+            txid = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), big_coin)\n+            self.generate(self.nodes[0], 6)\n+\n+            fee_total = 0\n+            max_fee = 0\n+            for _ in range(iterations):\n+                result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+                fee_total += result['fee']\n+                max_fee = max(max_fee, result['fee'])\n+\n+            # lock big coin\n+            w1.lockunspent(False, [tx for tx in w1.listunspent() if tx['txid'] == txid])\n+            return fee_total, max_fee\n+\n+        # in all the scenarios below the best solution would be to take one big coin and create a change output\n+        best_fee = (42 + 68 + 31) * fee_rate / COIN\n+\n+        # 0) no exact match is possible, the big coin is closest to target + MIN_CHANGE,\n+        # knapsack always finds the best solution\n+        fee_total, max_fee = select_coins(big_coin=1.01051, target=1.00000001, iterations=100)\n+        assert_approx(max_fee, best_fee)\n+        assert_approx(fee_total, best_fee * 100)\n+\n+        # 1) knapsack latches to the exact match solution and can't find the best solution\n+        # SRD can find a solution better than knapsack if draws the big coin in the first 21 tries\n+        # chances for SRD to find it are roughly 2*(21/102) = ±40%.\n+        # Chances are doubled due to coinselection run twice with and without APS enabled\n+        fee_total, max_fee = select_coins(big_coin=1.01051, target=1.0, iterations=100)\n+        knapsack_fee = (42 + 31 + 148*20) * fee_rate / COIN\n+        assert_approx(max_fee, knapsack_fee)\n+        # total fee is lower due to lucky SRD solutions\n+        assert_greater_than(knapsack_fee * 100, fee_total)\n+        assert_greater_than(fee_total, best_fee * 100)\n+\n+        # 2) no exact match, effective value of the big coin is smaller than target + MIN_CHANGE\n+        # BnB can find the same solution from previous test but dropping the change output to fees\n+        # SRD still occasionally find better solution\n+        fee_total, max_fee = select_coins(big_coin=1.01031, target=1.00000001, iterations=100)\n+        dropped_to_fees = 31 * fee_rate\n+        bnb_fee = ((42 + 148*20) * fee_rate + dropped_to_fees) / COIN\n+        assert_approx(max_fee, bnb_fee)\n+        assert_greater_than(bnb_fee * 100, fee_total)\n+        assert_greater_than(fee_total, best_fee * 100)\n+\n+        # 3) target is too far away for BnB to find a solution\n+        # effective value of the big coin is smaller than target + MIN_CHANGE\n+        #  * BnB can't find a solution as the distance from target is farther than cost of change\n+        #    6061550 + 5000000*19-(42+148*20)*350-99999319 = 11531\n+        #    cost_of_change = 11530 = 31*350 + 68*10\n+        #  * knapsack finds closest solution to target + MIN_CHANGE with 21 small coins\n+        #  * SRD still occasionally find better solution\n+        fee_total, max_fee = select_coins(big_coin=1.01031, target=0.99999319, iterations=100)\n+        srd_fee = (41 + 147*21 + 31) * fee_rate / COIN\n+        assert_approx(max_fee, srd_fee)\n+        assert_greater_than(srd_fee * 100, fee_total)\n+        assert_greater_than(fee_total, best_fee * 100)\n+\n+        # 4) knapsack latches to exact match + MIN_CHANGE\n+        # SRD still occasionally find better solution\n+        fee_total, max_fee = select_coins(big_coin=1.00051, target=0.99, iterations=100)",
      "path": "test/functional/wallet_coinselection.py",
      "position": 218,
      "original_position": 213,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": 829556908,
      "user": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is basically the same as test case \"1)\" in this section, but all the values decreased by MIN_CHANGE. The idea is to  demonstrate that Knapsack latches not only to down-to-satoshi matches. I'll improve the comment",
      "created_at": "2022-03-22T07:23:21Z",
      "updated_at": "2022-03-22T07:23:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r831839767",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/831839767"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 218,
      "original_line": 218,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/831843902",
      "pull_request_review_id": 916764756,
      "id": 831843902,
      "node_id": "PRRC_kwDOABII584xlO4-",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):\n+            w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.05)\n+\n+        # We will target a solution with 20 coins that will add up exactly to 1btc.\n+        # Add a coin that will cover all the fees and exactly match the target.\n+        # TODO: fix that knapsack targets change even if there is no change needed",
      "path": "test/functional/wallet_coinselection.py",
      "position": 149,
      "original_position": 145,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": 829534866,
      "user": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm not really arguing for improving it. I guess maybe one way that fix that would be to just remove Knapsack that targets no change and leave only knapsack that targets a MIN_CHANGE.\r\n\r\nP.S. BnB won't produce same solutions even in the situations when a changeless solution is possible, because BnB optimizes for waste. But I think this is okay.",
      "created_at": "2022-03-22T07:28:49Z",
      "updated_at": "2022-03-22T07:28:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r831843902",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/831843902"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 149,
      "original_line": 149,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/831845896",
      "pull_request_review_id": 916767399,
      "id": 831845896,
      "node_id": "PRRC_kwDOABII584xlPYI",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32",
      "path": "test/functional/wallet_coinselection.py",
      "position": 127,
      "original_position": 123,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": 829530854,
      "user": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "To keep the solution with best waste out of a 1000 trials? Hm.. that would fix this test case, but it'd make Knapsack behave exactly like running SRD in a loop. I guess we can then just drop knapsack altogether.",
      "created_at": "2022-03-22T07:31:56Z",
      "updated_at": "2022-03-22T07:31:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r831845896",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/831845896"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 127,
      "original_line": 127,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/831856217",
      "pull_request_review_id": 916781401,
      "id": 831856217,
      "node_id": "PRRC_kwDOABII584xlR5Z",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):",
      "path": "test/functional/wallet_coinselection.py",
      "position": 144,
      "original_position": 140,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": 829532736,
      "user": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Actually I was trying to keep the number of small coins as a low as possible while still demonstrating some inefficiencies of coin selection.\r\n1) The more coins we have -> the more time the test takes.\r\n2) The more coins we have -> the harder it's to debug and to reason about.\r\n\r\nWhat is the test scenario that would be possible with 1000 coins, but not possible with 100 coins?\r\n\r\nP.S. I think we can definitely reproduce this scenario, I see no reasons why not? If utxo pool is equivalent to this test cases then even with SRD it will find better solution in ~856/1000 = 85%, which leaves 15% to a really bad knapsack alternative.",
      "created_at": "2022-03-22T07:46:31Z",
      "updated_at": "2022-03-22T07:46:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r831856217",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/831856217"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 144,
      "original_line": 144,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/831871813",
      "pull_request_review_id": 916802710,
      "id": 831871813,
      "node_id": "PRRC_kwDOABII584xlVtF",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly",
      "path": "test/functional/wallet_coinselection.py",
      "position": 44,
      "original_position": 41,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": 828485890,
      "user": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed that",
      "created_at": "2022-03-22T08:07:20Z",
      "updated_at": "2022-03-22T08:07:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r831871813",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/831871813"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 44,
      "original_line": 44,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/831895646",
      "pull_request_review_id": 916835286,
      "id": 831895646,
      "node_id": "PRRC_kwDOABII584xlbhe",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):\n+            w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.05)\n+\n+        # We will target a solution with 20 coins that will add up exactly to 1btc.\n+        # Add a coin that will cover all the fees and exactly match the target.\n+        # TODO: fix that knapsack targets change even if there is no change needed\n+        # (148*20+42+31)*350+5000000 = 6061550\n+        w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.0606155)\n+        self.generate(self.nodes[0], 6)\n+\n+        fee_rate = 350\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins(big_coin, target, iterations=100):\n+            txid = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), big_coin)\n+            self.generate(self.nodes[0], 6)\n+\n+            fee_total = 0\n+            max_fee = 0\n+            for _ in range(iterations):\n+                result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+                fee_total += result['fee']\n+                max_fee = max(max_fee, result['fee'])\n+\n+            # lock big coin\n+            w1.lockunspent(False, [tx for tx in w1.listunspent() if tx['txid'] == txid])\n+            return fee_total, max_fee\n+\n+        # in all the scenarios below the best solution would be to take one big coin and create a change output\n+        best_fee = (42 + 68 + 31) * fee_rate / COIN\n+\n+        # 0) no exact match is possible, the big coin is closest to target + MIN_CHANGE,\n+        # knapsack always finds the best solution\n+        fee_total, max_fee = select_coins(big_coin=1.01051, target=1.00000001, iterations=100)\n+        assert_approx(max_fee, best_fee)\n+        assert_approx(fee_total, best_fee * 100)\n+\n+        # 1) knapsack latches to the exact match solution and can't find the best solution",
      "path": "test/functional/wallet_coinselection.py",
      "position": null,
      "original_position": 177,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": 829553702,
      "user": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Updated, but I think we should stop using \"exact match\" in place of changeless solution. Changeless solution is a solution in the range around exact match constrained by the cost of change/discard fee rate.",
      "created_at": "2022-03-22T08:35:03Z",
      "updated_at": "2022-03-22T08:35:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r831895646",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/831895646"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 177,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/831904469",
      "pull_request_review_id": 916847159,
      "id": 831904469,
      "node_id": "PRRC_kwDOABII584xldrV",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):\n+            w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.05)\n+\n+        # We will target a solution with 20 coins that will add up exactly to 1btc.\n+        # Add a coin that will cover all the fees and exactly match the target.\n+        # TODO: fix that knapsack targets change even if there is no change needed\n+        # (148*20+42+31)*350+5000000 = 6061550\n+        w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.0606155)\n+        self.generate(self.nodes[0], 6)\n+\n+        fee_rate = 350\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins(big_coin, target, iterations=100):\n+            txid = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), big_coin)\n+            self.generate(self.nodes[0], 6)\n+\n+            fee_total = 0\n+            max_fee = 0\n+            for _ in range(iterations):\n+                result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+                fee_total += result['fee']\n+                max_fee = max(max_fee, result['fee'])\n+\n+            # lock big coin\n+            w1.lockunspent(False, [tx for tx in w1.listunspent() if tx['txid'] == txid])\n+            return fee_total, max_fee\n+\n+        # in all the scenarios below the best solution would be to take one big coin and create a change output\n+        best_fee = (42 + 68 + 31) * fee_rate / COIN\n+\n+        # 0) no exact match is possible, the big coin is closest to target + MIN_CHANGE,\n+        # knapsack always finds the best solution\n+        fee_total, max_fee = select_coins(big_coin=1.01051, target=1.00000001, iterations=100)\n+        assert_approx(max_fee, best_fee)\n+        assert_approx(fee_total, best_fee * 100)\n+\n+        # 1) knapsack latches to the exact match solution and can't find the best solution\n+        # SRD can find a solution better than knapsack if draws the big coin in the first 21 tries\n+        # chances for SRD to find it are roughly 2*(21/102) = ±40%.\n+        # Chances are doubled due to coinselection run twice with and without APS enabled\n+        fee_total, max_fee = select_coins(big_coin=1.01051, target=1.0, iterations=100)\n+        knapsack_fee = (42 + 31 + 148*20) * fee_rate / COIN\n+        assert_approx(max_fee, knapsack_fee)\n+        # total fee is lower due to lucky SRD solutions\n+        assert_greater_than(knapsack_fee * 100, fee_total)\n+        assert_greater_than(fee_total, best_fee * 100)\n+\n+        # 2) no exact match, effective value of the big coin is smaller than target + MIN_CHANGE\n+        # BnB can find the same solution from previous test but dropping the change output to fees\n+        # SRD still occasionally find better solution\n+        fee_total, max_fee = select_coins(big_coin=1.01031, target=1.00000001, iterations=100)\n+        dropped_to_fees = 31 * fee_rate\n+        bnb_fee = ((42 + 148*20) * fee_rate + dropped_to_fees) / COIN\n+        assert_approx(max_fee, bnb_fee)\n+        assert_greater_than(bnb_fee * 100, fee_total)\n+        assert_greater_than(fee_total, best_fee * 100)\n+\n+        # 3) target is too far away for BnB to find a solution\n+        # effective value of the big coin is smaller than target + MIN_CHANGE\n+        #  * BnB can't find a solution as the distance from target is farther than cost of change\n+        #    6061550 + 5000000*19-(42+148*20)*350-99999319 = 11531\n+        #    cost_of_change = 11530 = 31*350 + 68*10\n+        #  * knapsack finds closest solution to target + MIN_CHANGE with 21 small coins\n+        #  * SRD still occasionally find better solution\n+        fee_total, max_fee = select_coins(big_coin=1.01031, target=0.99999319, iterations=100)\n+        srd_fee = (41 + 147*21 + 31) * fee_rate / COIN\n+        assert_approx(max_fee, srd_fee)\n+        assert_greater_than(srd_fee * 100, fee_total)\n+        assert_greater_than(fee_total, best_fee * 100)\n+\n+        # 4) knapsack latches to exact match + MIN_CHANGE\n+        # SRD still occasionally find better solution\n+        fee_total, max_fee = select_coins(big_coin=1.00051, target=0.99, iterations=100)\n+        knapsack_fee = (41 + 31 + 147*20) * fee_rate / COIN\n+        assert_approx(max_fee, knapsack_fee)\n+        assert_greater_than(knapsack_fee * 100, fee_total)\n+        assert_greater_than(fee_total, best_fee * 100)\n+\n+    def test_one_big_coin(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_coin\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_coin\")\n+\n+        w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 50)\n+        self.generate(self.nodes[0], 1)\n+\n+        # change is less than MIN_CHANGE but we still create it as we don't have other options\n+        result = w1.fundrawtransaction(w1.createrawtransaction([], {w0.getnewaddress(): 49.9999}), {\"fee_rate\": 10})\n+        tx = w1.decoderawtransaction(result['hex'])\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_small_coin(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_small_coin\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_small_coin\")\n+\n+        w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.011)\n+        w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 50)\n+        self.generate(self.nodes[0], 1)\n+\n+        dummyaddress = w0.getnewaddress()\n+        fee_rate = 20\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # if change is > MIN_CHANGE than we just spend big coin and create a change\n+        tx = select_coins_for(49.9)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # if small coins > MIN_CHANGE than we just add one small coin to the big one and create change",
      "path": "test/functional/wallet_coinselection.py",
      "position": 261,
      "original_position": 254,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": 829559587,
      "user": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Oops. The idea was that you have more than 1 small coin. If small coins > MIN_CHANGE that the tests in `test_one_big_and_many_small_coins` doesn't work. Any idea how to improve that? For now, added more than one small coin in this test case",
      "created_at": "2022-03-22T08:44:32Z",
      "updated_at": "2022-03-22T08:44:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r831904469",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/831904469"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 261,
      "original_line": 261,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/831914707",
      "pull_request_review_id": 916860904,
      "id": 831914707,
      "node_id": "PRRC_kwDOABII584xlgLT",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):\n+            w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.05)\n+\n+        # We will target a solution with 20 coins that will add up exactly to 1btc.\n+        # Add a coin that will cover all the fees and exactly match the target.\n+        # TODO: fix that knapsack targets change even if there is no change needed\n+        # (148*20+42+31)*350+5000000 = 6061550\n+        w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 0.0606155)\n+        self.generate(self.nodes[0], 6)\n+\n+        fee_rate = 350\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins(big_coin, target, iterations=100):\n+            txid = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), big_coin)\n+            self.generate(self.nodes[0], 6)\n+\n+            fee_total = 0\n+            max_fee = 0\n+            for _ in range(iterations):\n+                result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+                fee_total += result['fee']\n+                max_fee = max(max_fee, result['fee'])\n+\n+            # lock big coin\n+            w1.lockunspent(False, [tx for tx in w1.listunspent() if tx['txid'] == txid])\n+            return fee_total, max_fee\n+\n+        # in all the scenarios below the best solution would be to take one big coin and create a change output\n+        best_fee = (42 + 68 + 31) * fee_rate / COIN\n+\n+        # 0) no exact match is possible, the big coin is closest to target + MIN_CHANGE,\n+        # knapsack always finds the best solution\n+        fee_total, max_fee = select_coins(big_coin=1.01051, target=1.00000001, iterations=100)\n+        assert_approx(max_fee, best_fee)\n+        assert_approx(fee_total, best_fee * 100)\n+\n+        # 1) knapsack latches to the exact match solution and can't find the best solution\n+        # SRD can find a solution better than knapsack if draws the big coin in the first 21 tries\n+        # chances for SRD to find it are roughly 2*(21/102) = ±40%.\n+        # Chances are doubled due to coinselection run twice with and without APS enabled",
      "path": "test/functional/wallet_coinselection.py",
      "position": 184,
      "original_position": 180,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": 829548137,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> What's \"APS\"?\r\n\r\nIn more detail, see the configuration flag `-maxapsfee` added by #14582 in 0.21, which sets the max allowed avoid partial spends (APS) fee. It defaults to 0 (fee is the same with and without APS), and setting it to -1 will disable APS, unless `-avoidpartialspends` is set.",
      "created_at": "2022-03-22T08:55:20Z",
      "updated_at": "2022-03-22T08:55:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r831914707",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/831914707"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 184,
      "original_line": 184,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/832422676",
      "pull_request_review_id": 917587829,
      "id": 832422676,
      "node_id": "PRRC_kwDOABII584xncMU",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):",
      "path": "test/functional/wallet_coinselection.py",
      "position": 144,
      "original_position": 140,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": 829532736,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, I think it would be easy to produce the scenario: \r\n\r\n• 100 small coins, 1 big coin\r\n• no BnB solution\r\n• a large set of the small coins produces a smaller change output than the 1 big coin, so knapsack prefers the former\r\n• SRD only finds the 1 big coin by itself as a solution in ~1/101 cases\r\n\r\n⇒ usually SRD finds the best, but it's a worse waste than best solution, but better than knapsack\r\n\r\nOne could probably make it even less likely that the best solution is found by SRD by having two big ones that are both necessary",
      "created_at": "2022-03-22T17:08:06Z",
      "updated_at": "2022-03-22T17:09:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r832422676",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/832422676"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 144,
      "original_line": 144,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/832975365",
      "pull_request_review_id": 918362374,
      "id": 832975365,
      "node_id": "PRRC_kwDOABII584xpjIF",
      "diff_hunk": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2020-2022 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.messages import (\n+    COIN\n+)\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal,\n+    assert_approx,\n+    assert_greater_than,\n+)\n+\n+\n+class CoinselectionTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def run_test(self):\n+        self.test_few_small_coins()\n+        self.test_one_big_and_many_small_coins()\n+        self.test_one_big_coin()\n+        self.test_one_big_and_small_coin()\n+\n+    def test_few_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_few_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_few_small_coins\")\n+\n+        # seed the wallet with three coins\n+        tx1 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx2 = w0.sendtoaddress(w1.getnewaddress(\"\", \"bech32\"), 1)\n+        tx3 = w0.sendtoaddress(w1.getnewaddress(\"\", \"legacy\"), 1)\n+        self.generate(self.nodes[0], 1)\n+\n+        # TODO: set long_term_fee_rate explicitly\n+        # fee rate is set above long_term_fee_rate (10 sat/vbyte)\n+        fee_rate = 20\n+\n+        # There are four possible transactions with 2 or less inputs:\n+        # 1x bech32      waste = 680  = 68*20 - 68*10\n+        #                fee = 2200\n+        # 1x legacy      waste = 1480 = 148*20 - 148*10\n+        #                fee = 3800\n+        # 2x bech32      waste = 2660 = (68*20 - 68*10)*2 + 68*10 + 31*20\n+        #                fee = 4180\n+        # legacy+bech32  waste = 3460 = (68*20 - 68*10) + (148*20 - 148*10) + 68*10 + 31*20\n+        #                fee = 5780\n+\n+        dummyaddress = w0.getnewaddress()\n+\n+        def select_coins_for(target):\n+            result = w1.fundrawtransaction(w1.createrawtransaction([], {dummyaddress: target}), {\"fee_rate\": fee_rate})\n+            return w1.decoderawtransaction(result['hex'])\n+\n+        # 1-input-1-output tx is 110vbytes which results in 2200sat fee at 20sat/vbyte\n+        # so we have to use 2 inputs and create a change\n+        tx = select_coins_for(0.99997801)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # max amount we can send with one coin\n+        tx = select_coins_for(0.99997800)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # cost of change is 31*20 + 68*10 = 1300sat\n+        # so it's economically efficient to drop anything below that amount to fees\n+        tx = select_coins_for(0.99996500)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # adding one more input to create a change increases waste by (68*20 - 68*10) = 680sat\n+        # so it's still efficient to drop that much more to fees\n+        tx = select_coins_for(0.99996201)\n+        # TODO: implement optimization and uncomment the assertions\n+        # assert_equal(len(tx['vin']), 1)\n+        # assert_equal(len(tx['vout']), 1)\n+        # assert(tx['vin'][0]['txid'] in [tx1, tx2])\n+\n+        # fees for 1 legacy input tx = (148+42)*20 = 3800sat\n+        # at this point we're dropping to fees enough so we can spend heavier input with less waste\n+        tx = select_coins_for(0.99996200)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # paying enough fees for 2x bech32 input tx\n+        # but using one legacy and dropping for fees is still more efficient in terms of waste\n+        tx = select_coins_for(0.99995820)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # max amount when dropping for fees is still more efficient than creating a change\n+        # With fee = 4980, we'd be dropping 1180sat excess which brings waste to 2660\n+        # which is equal to the waste of 2x bech32 solution\n+        tx = select_coins_for(0.99995021)\n+        assert_equal(len(tx['vin']), 1)\n+        assert_equal(len(tx['vout']), 1)\n+        assert_equal(tx['vin'][0]['txid'], tx3)\n+\n+        # a solution with two bech32 inputs and a change is the most efficient\n+        # but it could only be found by SRD\n+        tx = select_coins_for(0.99995020)\n+        # TODO: randomness here, could be one or two inputs\n+        # print(tx['vin'])\n+        # print(\"{} / {}\".format(len(tx['vin']), len(tx['vout'])))\n+\n+        # With fee at 5101sat we would be dropping 1301sat for fess\n+        # This is more than cost of change and BnB won't find a solution with single input\n+        # We either get\n+        # 1) 2x bech32 solution (SRD only)\n+        # 2) legacy + bech32 solution\n+        tx = select_coins_for(0.99994899)\n+        # legacy + dropping more for fees is still better in terms of waste than legacy + bech32\n+        # TODO: implement optimization and update asserts\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+        # a solution with change is the best solution\n+        # 2x bech32 is still more efficient than bech32-and-legacy, but only could be found with SRD\n+        tx = select_coins_for(0.99994220)\n+        assert_equal(len(tx['vin']), 2)\n+        assert_equal(len(tx['vout']), 2)\n+\n+    def test_one_big_and_many_small_coins(self):\n+        w0 = self.nodes[0].get_wallet_rpc(self.default_wallet_name)\n+        self.nodes[0].createwallet(wallet_name=\"test_one_big_and_many_small_coins\")\n+        w1 = self.nodes[0].get_wallet_rpc(\"test_one_big_and_many_small_coins\")\n+\n+        # Create a bunch of small coins\n+        for i in range(100):",
      "path": "test/functional/wallet_coinselection.py",
      "position": 144,
      "original_position": 140,
      "commit_id": "e378883892b104b2f2441540550c39c6a5dd71d0",
      "original_commit_id": "1607529ea5cba3c598084bc3614c8b33fbcb3456",
      "in_reply_to_id": 829532736,
      "user": {
        "login": "S3RK",
        "id": 1466284,
        "node_id": "MDQ6VXNlcjE0NjYyODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1466284?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/S3RK",
        "html_url": "https://github.com/S3RK",
        "followers_url": "https://api.github.com/users/S3RK/followers",
        "following_url": "https://api.github.com/users/S3RK/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/S3RK/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/S3RK/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/S3RK/subscriptions",
        "organizations_url": "https://api.github.com/users/S3RK/orgs",
        "repos_url": "https://api.github.com/users/S3RK/repos",
        "events_url": "https://api.github.com/users/S3RK/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/S3RK/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Isn't this exactly test case 3) in `test_one_big_and_many_small_coins`?",
      "created_at": "2022-03-23T08:18:52Z",
      "updated_at": "2022-03-23T08:19:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24580#discussion_r832975365",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/832975365"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24580"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 144,
      "original_line": 144,
      "side": "RIGHT"
    }
  ]
}