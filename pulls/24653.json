{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653",
    "id": 887399438,
    "node_id": "PR_kwDOABII58405KQO",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/24653",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/24653.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/24653.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24653",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24653/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/bc90b8d86916d43867762a391633664676550bd8",
    "number": 24653,
    "state": "closed",
    "locked": true,
    "maintainer_can_modify": false,
    "title": "test: use `MiniWallet` in `test/functional/interface_zmq`",
    "user": {
      "login": "josibake",
      "id": 7444140,
      "node_id": "MDQ6VXNlcjc0NDQxNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/josibake",
      "html_url": "https://github.com/josibake",
      "followers_url": "https://api.github.com/users/josibake/followers",
      "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
      "organizations_url": "https://api.github.com/users/josibake/orgs",
      "repos_url": "https://api.github.com/users/josibake/repos",
      "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/josibake/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "While working on #24584 , `interface_zmq` started failing due to coin selection not running deterministically. The test doesn't actually need the wallet, so this PR migrates it to use MiniWallet\r\n\r\n_Note for reviewers:_ the second commit moves large chunks of code out of an if block, so it may be helpful to review with something that ignores whitespace, e.g `git diff -w master`",
    "labels": [
      {
        "id": 62963516,
        "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
        "name": "Tests",
        "color": "d4c5f9",
        "default": false
      }
    ],
    "created_at": "2022-03-23T16:02:37Z",
    "updated_at": "2023-03-25T10:20:58Z",
    "closed_at": "2022-03-24T18:59:25Z",
    "mergeable_state": "unknown",
    "merged_at": "2022-03-24T18:59:25Z",
    "merge_commit_sha": "a697a3fc91561a509cbee571e3254a0e137d32d9",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "josibake:josibake-make-interfaces-zmq-test-use-miniwallet",
      "ref": "josibake-make-interfaces-zmq-test-use-miniwallet",
      "sha": "bc90b8d86916d43867762a391633664676550bd8",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 344501009,
        "node_id": "MDEwOlJlcG9zaXRvcnkzNDQ1MDEwMDk=",
        "name": "bitcoin",
        "full_name": "josibake/bitcoin",
        "owner": {
          "login": "josibake",
          "id": 7444140,
          "node_id": "MDQ6VXNlcjc0NDQxNDA=",
          "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/josibake",
          "html_url": "https://github.com/josibake",
          "followers_url": "https://api.github.com/users/josibake/followers",
          "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
          "organizations_url": "https://api.github.com/users/josibake/orgs",
          "repos_url": "https://api.github.com/users/josibake/repos",
          "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/josibake/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/josibake/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/josibake/bitcoin",
        "archive_url": "https://api.github.com/repos/josibake/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/josibake/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/josibake/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/josibake/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/josibake/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/josibake/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/josibake/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/josibake/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/josibake/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/josibake/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/josibake/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/josibake/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/josibake/bitcoin/events",
        "forks_url": "https://api.github.com/repos/josibake/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/josibake/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/josibake/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/josibake/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/josibake/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/josibake/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/josibake/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/josibake/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/josibake/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/josibake/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/josibake/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/josibake/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/josibake/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/josibake/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/josibake/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/josibake/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:josibake/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/josibake/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/josibake/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/josibake/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/josibake/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/josibake/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/josibake/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/josibake/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/josibake/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/josibake/bitcoin/hooks",
        "svn_url": "https://github.com/josibake/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 0,
        "stargazers_count": 0,
        "watchers_count": 0,
        "size": 223450,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-06-06T14:47:26Z",
        "created_at": "2021-03-04T14:24:20Z",
        "updated_at": "2022-01-04T15:38:49Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "98e9d8e8e2e3e65e6f1e14be26457a9f9090c092",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 34324,
        "stargazers_count": 69819,
        "watchers_count": 69819,
        "size": 233879,
        "default_branch": "master",
        "open_issues_count": 627,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-06-07T05:35:10Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2023-06-07T04:47:18Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 138,
    "deletions": 140,
    "changed_files": 1,
    "commits": 2,
    "review_comments": 14,
    "comments": 2
  },
  "events": [
    {
      "event": "labeled",
      "id": 6292921227,
      "node_id": "LE_lADOABII585GO-qDzwAAAAF3FluL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6292921227",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-03-23T16:03:59Z",
      "label": {
        "name": "Tests",
        "color": "d4c5f9"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6292976914,
      "node_id": "HRFPE_lADOABII585GO-qDzwAAAAF3FzUS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6292976914",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-03-23T16:11:03Z"
    },
    {
      "event": "reviewed",
      "id": 919057464,
      "node_id": "PRR_kwDOABII5842x7Q4",
      "url": null,
      "actor": null,
      "commit_id": "a15663362368b8452bdb035815bb36f09fbd7689",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24653#pullrequestreview-919057464",
      "submitted_at": "2022-03-23T16:15:43Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6293161528,
      "node_id": "HRFPE_lADOABII585GO-qDzwAAAAF3GgY4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6293161528",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-03-23T16:36:06Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6293518661,
      "node_id": "HRFPE_lADOABII585GO-qDzwAAAAF3H3lF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6293518661",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-03-23T17:26:03Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6293648756,
      "node_id": "HRFPE_lADOABII585GO-qDzwAAAAF3IXV0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6293648756",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-03-23T17:45:19Z"
    },
    {
      "event": "reviewed",
      "id": 919551356,
      "node_id": "PRR_kwDOABII5842zz18",
      "url": null,
      "actor": null,
      "commit_id": "44481fb3fd609ff520bc8d2736e0e57c55541924",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Nice, Concept ACK, will review this one soon!\r\n\r\nSome quick findings:\r\nNote that there's a typo in the PR title (s/zmg/zmq/), also I'm not sure if \"refactor\" is really applying here. For the second commit, adding a review suggestion for ignoring whitespace (not tested, but the very popular `--color-moved=dimmed-zebra` should work) would be probably very helpful for reviewers.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24653#pullrequestreview-919551356",
      "submitted_at": "2022-03-23T23:10:23Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
    },
    {
      "event": "renamed",
      "id": 6297895777,
      "node_id": "RTE_lADOABII585GO-qDzwAAAAF3YkNh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6297895777",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-03-24T09:40:21Z",
      "rename": {
        "from": "test, refactor: use `MiniWallet` in `test/functional/interface_zmg`",
        "to": "test: use `MiniWallet` in `test/functional/interface_zmq`"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6297954055,
      "node_id": "HRFPE_lADOABII585GO-qDzwAAAAF3YycH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6297954055",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-03-24T09:48:43Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDBiZmJmN2ZiMjQ4ODc1M2Q3OTVmZmMxYzYzYTg5NzdlNGZlNGEzYmM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0bfbf7fb2488753d795ffc1c63a8977e4fe4a3bc",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/0bfbf7fb2488753d795ffc1c63a8977e4fe4a3bc",
      "tree": {
        "sha": "4a2c8ac1180e72bf9f5468cd5f75d52dca505afe",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4a2c8ac1180e72bf9f5468cd5f75d52dca505afe"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 4a2c8ac1180e72bf9f5468cd5f75d52dca505afe\nparent bc562b9ef81d4e37c20c4fdbd73be44d6f12efa0\nauthor josibake <josibake@protonmail.com> 1648050005 +0100\ncommitter josibake <josibake@protonmail.com> 1648115858 +0100\n\ntest: use MiniWallet in `interfaces_zmq`\n\nmake interfaces_zmg run deterministically.\nthis test is for the zmg notifications,\nso it doesn't need the wallet compiled to run\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmI8QJoACgkQity1WMTz\nPWUixg/+NQL7oxi+e4tEvlY3w+5ElebgpwSyqBkstcgrBB+TfOSFINfplSq7I3NK\nYmUhuHaFzwi3lL9S1sEc6clmkXfTDltz/hEnca5aBhu7B/tZ4SCqzK29fmQcXu7/\ny5sWcVd+NwtXotJ39jnkTh670cl7wFE/l4h2RVTbqw48ollJMeJhYgdiGC6N8bHq\nzMpVVHNAxIDchoHPFaxtS2sciL2NAPZMj2kQM39H0jYj2pLdDjLjAAVN0/QiIylV\nkkgXMicd8AH9fHUD+Ka3jG5kLtMn56VOBda17PVQXV2p9xaqvRz7d2lTn8EhZ0sl\nGQL4ha0NSA2TK6PayPjA/jC+UJLkoY5Jvxp4P2HmpTiqP3sLro0oE+tm9Olgasjr\n7eRephVxAULczf2bN0bCLi5ZQQSWHJhngdii/YZCI1Gtc5/xIFXU34dsXRvqtXR9\nOlY+9gXKmJHegktcQFAceUHiXZY3RRORQ7cYLe1AeQvYrz1X4zOCxkO4rEbw7nqz\nCPiLgiW7IZrXa6ZGNFqKuyhVJeMtik0DF52WxUKldt9icoGrt9mOmYHZh8chm8AV\nZ7/16yKxojJLa+mrSPJjV62nynYnz1ifs9dDDc9iCJCVHbN07hX+wn5iYNWEgHay\ngrywiuMuLjtwkJF8ogF1SH/j0lsIyWMYiAaSVCfO27s5ikMhsJU=\n=M3jW\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bc562b9ef81d4e37c20c4fdbd73be44d6f12efa0",
          "sha": "bc562b9ef81d4e37c20c4fdbd73be44d6f12efa0",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/bc562b9ef81d4e37c20c4fdbd73be44d6f12efa0"
        }
      ],
      "message": "test: use MiniWallet in `interfaces_zmq`\n\nmake interfaces_zmg run deterministically.\nthis test is for the zmg notifications,\nso it doesn't need the wallet compiled to run",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2022-03-24T09:57:38Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2022-03-23T15:40:05Z"
      },
      "sha": "0bfbf7fb2488753d795ffc1c63a8977e4fe4a3bc"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGJjOTBiOGQ4NjkxNmQ0Mzg2Nzc2MmEzOTE2MzM2NjQ2NzY1NTBiZDg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bc90b8d86916d43867762a391633664676550bd8",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/bc90b8d86916d43867762a391633664676550bd8",
      "tree": {
        "sha": "48c33edc765874988a1ae53497dbebe0e704ab31",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/48c33edc765874988a1ae53497dbebe0e704ab31"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 48c33edc765874988a1ae53497dbebe0e704ab31\nparent 0bfbf7fb2488753d795ffc1c63a8977e4fe4a3bc\nauthor josibake <josibake@protonmail.com> 1648115245 +0100\ncommitter josibake <josibake@protonmail.com> 1648116022 +0100\n\n[move only] remove `is_wallet_compiled` checks\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYWUWuOtu0CiC/Ep6ity1WMTzPWUFAmI8QTkACgkQity1WMTz\nPWU9HhAAg1LS+Eztw44GHC5o0aNIteMYBNkwAG8jMkqOQ6v5HZnR4zS4Nm0ksqNP\n782Qp5M4GnlFzuxvCH2khLJOeX0y/U278rYr5l4/ZwgCp1eao2kvW5HrX4GxqOeA\nL8tHCYlmPj3LasEi9M8uyFlOCVH79vRk1bWpSvusT9Plj39+Kal1aPpUAlKoSu9E\naD3mtNM+ta5DyzKeKS4QW0u7CBydQyAQPTmZjN1t9T7TZG+FTQL6r0NkwG2nk5Lh\nHINT9E1DgHKuChLTCdZURc+Ov8YfryzhBl2CD9yGxYwRWVbvf+zVQ6iGMAZJVzBA\nsWNwC6x+JmbtBXxVACSZ8I1wERC1vNCob5OD236N8yQdQ1ob9KP+EJqPaxnyrR03\nBETz8iRcz1P2kEqHxqL52axKnup1pSWOt63QvWhwst7QSUvdjog+wkGCczHlB8Qj\npBSd35eI9uNaA8ThjXRiD0dPjpXvssrzwQoSST6aH2yKqDIGkv6ao1iWb62wOH/h\nu74op9Gejw/pTB/foZAjuU3DHjuPlwGrDdUXJ9989TBeajFY3AGwfNGIz89e6fsj\neDI3D+sfxFQxf6pGoubIpAizHQNtRHrjHP/z3mYV61QLno1XWQLZvUI6gPdIU2r1\nCUlQExzPdmHWzu/2ubUdHwC8MrIy69IArxIMdWY8OFnPAZpkrog=\n=wfeK\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0bfbf7fb2488753d795ffc1c63a8977e4fe4a3bc",
          "sha": "0bfbf7fb2488753d795ffc1c63a8977e4fe4a3bc",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/0bfbf7fb2488753d795ffc1c63a8977e4fe4a3bc"
        }
      ],
      "message": "[move only] remove `is_wallet_compiled` checks",
      "committer": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2022-03-24T10:00:22Z"
      },
      "author": {
        "name": "josibake",
        "email": "josibake@protonmail.com",
        "date": "2022-03-24T09:47:25Z"
      },
      "sha": "bc90b8d86916d43867762a391633664676550bd8"
    },
    {
      "event": "reviewed",
      "id": 920004303,
      "node_id": "PRR_kwDOABII58421ibP",
      "url": null,
      "actor": null,
      "commit_id": "ae409316c858c65b76c13aeac8dd55e97ab22108",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24653#pullrequestreview-920004303",
      "submitted_at": "2022-03-24T10:01:07Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6298077828,
      "node_id": "HRFPE_lADOABII585GO-qDzwAAAAF3ZQqE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6298077828",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-03-24T10:05:40Z"
    },
    {
      "event": "commented",
      "id": 1077460242,
      "node_id": "IC_kwDOABII585AOL0S",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1077460242",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-03-24T10:14:15Z",
      "updated_at": "2022-03-24T10:14:15Z",
      "author_association": "MEMBER",
      "body": "> Nice, Concept ACK, will review this one soon!\r\n> \r\n> Some quick findings: Note that there's a typo in the PR title (s/zmg/zmq/), also I'm not sure if \"refactor\" is really applying here. For the second commit, adding a review suggestion for ignoring whitespace (not tested, but the very popular `--color-moved=dimmed-zebra` should work) would be probably very helpful for reviewers.\r\n\r\nthanks for the suggestions, @theStack ! I updated the title and also added a note for reviewers. I found that `git diff -w master` worked best for me",
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24653#issuecomment-1077460242",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24653"
    },
    {
      "event": "mentioned",
      "id": 6298141220,
      "node_id": "MEE_lADOABII585GO-qDzwAAAAF3ZgIk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6298141220",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-03-24T10:14:15Z"
    },
    {
      "event": "subscribed",
      "id": 6298141227,
      "node_id": "SE_lADOABII585GO-qDzwAAAAF3ZgIr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6298141227",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-03-24T10:14:15Z"
    },
    {
      "event": "commented",
      "id": 1077775787,
      "node_id": "IC_kwDOABII585APY2r",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1077775787",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-03-24T15:48:52Z",
      "updated_at": "2022-03-24T15:48:52Z",
      "author_association": "MEMBER",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#23127](https://github.com/bitcoin/bitcoin/pull/23127) (tests: Use test framework utils where possible by vincenzopalazzo)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24653#issuecomment-1077775787",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/24653"
    },
    {
      "event": "reviewed",
      "id": 920706913,
      "node_id": "PRR_kwDOABII58424N9h",
      "url": null,
      "actor": null,
      "commit_id": "bc90b8d86916d43867762a391633664676550bd8",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "ACK https://github.com/bitcoin/bitcoin/pull/24653/commits/bc90b8d86916d43867762a391633664676550bd8",
      "user": {
        "login": "vincenzopalazzo",
        "id": 17150045,
        "node_id": "MDQ6VXNlcjE3MTUwMDQ1",
        "avatar_url": "https://avatars.githubusercontent.com/u/17150045?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/vincenzopalazzo",
        "html_url": "https://github.com/vincenzopalazzo",
        "followers_url": "https://api.github.com/users/vincenzopalazzo/followers",
        "following_url": "https://api.github.com/users/vincenzopalazzo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/vincenzopalazzo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/vincenzopalazzo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/vincenzopalazzo/subscriptions",
        "organizations_url": "https://api.github.com/users/vincenzopalazzo/orgs",
        "repos_url": "https://api.github.com/users/vincenzopalazzo/repos",
        "events_url": "https://api.github.com/users/vincenzopalazzo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/vincenzopalazzo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24653#pullrequestreview-920706913",
      "submitted_at": "2022-03-24T18:32:49Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
    },
    {
      "event": "merged",
      "id": 6301887611,
      "node_id": "ME_lADOABII585GO-qDzwAAAAF3nyx7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6301887611",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "a697a3fc91561a509cbee571e3254a0e137d32d9",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a697a3fc91561a509cbee571e3254a0e137d32d9",
      "created_at": "2022-03-24T18:59:25Z"
    },
    {
      "event": "closed",
      "id": 6301887653,
      "node_id": "CE_lADOABII585GO-qDzwAAAAF3nyyl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6301887653",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-03-24T18:59:26Z"
    },
    {
      "event": "reviewed",
      "id": 920783427,
      "node_id": "PRR_kwDOABII58424gpD",
      "url": null,
      "actor": null,
      "commit_id": "bc90b8d86916d43867762a391633664676550bd8",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Left some thoughts",
      "user": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24653#pullrequestreview-920783427",
      "submitted_at": "2022-03-24T19:37:08Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
    },
    {
      "event": "referenced",
      "id": 6357121988,
      "node_id": "REFE_lADOABII585GO-qDzwAAAAF66fvE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6357121988",
      "actor": {
        "login": "sidhujag",
        "id": 6238042,
        "node_id": "MDQ6VXNlcjYyMzgwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6238042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sidhujag",
        "html_url": "https://github.com/sidhujag",
        "followers_url": "https://api.github.com/users/sidhujag/followers",
        "following_url": "https://api.github.com/users/sidhujag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sidhujag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sidhujag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sidhujag/subscriptions",
        "organizations_url": "https://api.github.com/users/sidhujag/orgs",
        "repos_url": "https://api.github.com/users/sidhujag/repos",
        "events_url": "https://api.github.com/users/sidhujag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sidhujag/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "fad0b373172b2172e27d0fcbbd1ff11a8f029a43",
      "commit_url": "https://api.github.com/repos/syscoin/syscoin/commits/fad0b373172b2172e27d0fcbbd1ff11a8f029a43",
      "created_at": "2022-04-02T16:12:41Z"
    },
    {
      "event": "locked",
      "id": 8845108268,
      "node_id": "LOE_lADOABII585GO-qDzwAAAAIPNaQs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8845108268",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-25T10:20:58Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833461415",
      "pull_request_review_id": 919057464,
      "id": 833461415,
      "node_id": "PRRC_kwDOABII584xrZyn",
      "diff_hunk": "@@ -326,126 +324,126 @@ def test_sequence(self):\n         assert_equal((self.nodes[1].getblockhash(block_count), \"C\", None), seq.receive_sequence())\n \n         # Rest of test requires wallet functionality\n-        if self.is_wallet_compiled():\n-            self.log.info(\"Wait for tx from second node\")\n-            payment_txid = self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=5.0, replaceable=True)\n-            self.sync_all()\n-            self.log.info(\"Testing sequence notifications with mempool sequence values\")\n-\n-            # Should receive the broadcasted txid.\n-            assert_equal((payment_txid, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            self.log.info(\"Testing RBF notification\")\n-            # Replace it to test eviction/addition notification\n-            rbf_info = self.nodes[1].bumpfee(payment_txid)\n-            self.sync_all()\n-            assert_equal((payment_txid, \"R\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n-            # though the mempool sequence number does go up by the number of transactions\n-            # removed from the mempool by the block mining it.\n-            mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n-            # Make sure the number of mined transactions matches the number of txs out of mempool\n-            mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n-            assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n-            seq_num += mempool_size_delta\n-            payment_txid_2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-            self.sync_all()\n-            assert_equal((c_block, \"C\", None), seq.receive_sequence())\n-            assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Spot check getrawmempool results that they only show up when asked for\n-            assert type(self.nodes[0].getrawmempool()) is list\n-            assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n-            assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n-            assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n-            assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n-\n-            self.log.info(\"Testing reorg notifications\")\n-            # Manually invalidate the last block to test mempool re-entry\n-            # N.B. This part could be made more lenient in exact ordering\n-            # since it greatly depends on inner-workings of blocks/mempool\n-            # during \"deep\" re-orgs. Probably should \"re-construct\"\n-            # blockchain/mempool state from notifications instead.\n-            block_count = self.nodes[0].getblockcount()\n-            best_hash = self.nodes[0].getbestblockhash()\n-            self.nodes[0].invalidateblock(best_hash)\n-            sleep(2)  # Bit of room to make sure transaction things happened\n-\n-            # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n-            # of the time they were gathered.\n-            assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n-\n-            assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n-            self.nodes[0].reconsiderblock(best_hash)\n-            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n-\n-            self.log.info(\"Evict mempool transaction by block conflict\")\n-            orig_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # More to be simply mined\n-            more_tx = []\n-            for _ in range(5):\n-                more_tx.append(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.1))\n-\n-            raw_tx = self.nodes[0].getrawtransaction(orig_txid)\n-            bump_info = self.nodes[0].bumpfee(orig_txid)\n-            # Mine the pre-bump tx\n-            txs_to_add = [raw_tx] + [self.nodes[0].getrawtransaction(txid) for txid in more_tx]\n-            block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n-            add_witness_commitment(block)\n-            block.solve()\n-            assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n-            tip = self.nodes[0].getbestblockhash()\n-            assert_equal(int(tip, 16), block.sha256)\n-            orig_txid_2 = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # Flush old notifications until evicted tx original entry\n+        self.log.info(\"Wait for tx from second node\")\n+        payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])\n+        self.sync_all()\n+        self.log.info(\"Testing sequence notifications with mempool sequence values\")\n+\n+        # Should receive the broadcasted txid.\n+        assert_equal((payment_tx['txid'], \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        self.log.info(\"Testing RBF notification\")\n+        # Replace it to test eviction/addition notification\n+        payment_tx['tx'].vout[0].nValue -= 1000\n+        rbf_txid = self.nodes[1].sendrawtransaction(payment_tx['tx'].serialize().hex())\n+        self.sync_all()\n+        assert_equal((payment_tx['txid'], \"R\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n+        # though the mempool sequence number does go up by the number of transactions\n+        # removed from the mempool by the block mining it.\n+        mempool_size = len(self.nodes[0].getrawmempool())\n+        c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        # Make sure the number of mined transactions matches the number of txs out of mempool\n+        mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n+        assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n+        seq_num += mempool_size_delta\n+        payment_txid_2 = self.wallet.send_self_transfer(from_node=self.nodes[1])['txid']\n+        self.sync_all()\n+        assert_equal((c_block, \"C\", None), seq.receive_sequence())\n+        assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Spot check getrawmempool results that they only show up when asked for\n+        assert type(self.nodes[0].getrawmempool()) is list\n+        assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n+        assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n+        assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n+        assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n+\n+        self.log.info(\"Testing reorg notifications\")\n+        # Manually invalidate the last block to test mempool re-entry\n+        # N.B. This part could be made more lenient in exact ordering\n+        # since it greatly depends on inner-workings of blocks/mempool\n+        # during \"deep\" re-orgs. Probably should \"re-construct\"\n+        # blockchain/mempool state from notifications instead.\n+        block_count = self.nodes[0].getblockcount()\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        sleep(2)  # Bit of room to make sure transaction things happened\n+\n+        # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n+        # of the time they were gathered.\n+        assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n+\n+        assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n+        self.nodes[0].reconsiderblock(best_hash)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n+        self.log.info(\"Evict mempool transaction by block conflict\")\n+        orig_tx = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # More to be simply mined\n+        more_tx = []\n+        for _ in range(5):\n+            more_tx.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+\n+        orig_tx['tx'].vout[0].nValue -= 1000\n+        bump_txid = self.nodes[0].sendrawtransaction(orig_tx['tx'].serialize().hex())\n+        # Mine the pre-bump tx\n+        txs_to_add = [orig_tx['hex']] + [tx['hex'] for tx in more_tx]\n+        block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n+        tip = self.nodes[0].getbestblockhash()\n+        assert_equal(int(tip, 16), block.sha256)\n+        orig_tx_2 = self.wallet.send_self_transfer(from_node=self.nodes[0])",
      "path": "test/functional/interface_zmq.py",
      "position": null,
      "original_position": 268,
      "commit_id": "bc90b8d86916d43867762a391633664676550bd8",
      "original_commit_id": "a15663362368b8452bdb035815bb36f09fbd7689",
      "in_reply_to_id": null,
      "user": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think you can just assign to `orig_txid_2` to minimize the diff (also elsewhere)",
      "created_at": "2022-03-23T16:15:23Z",
      "updated_at": "2022-03-23T16:15:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833461415",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833461415"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 407,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833461590",
      "pull_request_review_id": 919057464,
      "id": 833461590,
      "node_id": "PRRC_kwDOABII584xrZ1W",
      "diff_hunk": "@@ -326,126 +324,126 @@ def test_sequence(self):\n         assert_equal((self.nodes[1].getblockhash(block_count), \"C\", None), seq.receive_sequence())\n \n         # Rest of test requires wallet functionality\n-        if self.is_wallet_compiled():\n-            self.log.info(\"Wait for tx from second node\")\n-            payment_txid = self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=5.0, replaceable=True)\n-            self.sync_all()\n-            self.log.info(\"Testing sequence notifications with mempool sequence values\")\n-\n-            # Should receive the broadcasted txid.\n-            assert_equal((payment_txid, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            self.log.info(\"Testing RBF notification\")\n-            # Replace it to test eviction/addition notification\n-            rbf_info = self.nodes[1].bumpfee(payment_txid)\n-            self.sync_all()\n-            assert_equal((payment_txid, \"R\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n-            # though the mempool sequence number does go up by the number of transactions\n-            # removed from the mempool by the block mining it.\n-            mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n-            # Make sure the number of mined transactions matches the number of txs out of mempool\n-            mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n-            assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n-            seq_num += mempool_size_delta\n-            payment_txid_2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-            self.sync_all()\n-            assert_equal((c_block, \"C\", None), seq.receive_sequence())\n-            assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Spot check getrawmempool results that they only show up when asked for\n-            assert type(self.nodes[0].getrawmempool()) is list\n-            assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n-            assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n-            assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n-            assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n-\n-            self.log.info(\"Testing reorg notifications\")\n-            # Manually invalidate the last block to test mempool re-entry\n-            # N.B. This part could be made more lenient in exact ordering\n-            # since it greatly depends on inner-workings of blocks/mempool\n-            # during \"deep\" re-orgs. Probably should \"re-construct\"\n-            # blockchain/mempool state from notifications instead.\n-            block_count = self.nodes[0].getblockcount()\n-            best_hash = self.nodes[0].getbestblockhash()\n-            self.nodes[0].invalidateblock(best_hash)\n-            sleep(2)  # Bit of room to make sure transaction things happened\n-\n-            # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n-            # of the time they were gathered.\n-            assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n-\n-            assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n-            self.nodes[0].reconsiderblock(best_hash)\n-            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n-\n-            self.log.info(\"Evict mempool transaction by block conflict\")\n-            orig_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # More to be simply mined\n-            more_tx = []\n-            for _ in range(5):\n-                more_tx.append(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.1))\n-\n-            raw_tx = self.nodes[0].getrawtransaction(orig_txid)\n-            bump_info = self.nodes[0].bumpfee(orig_txid)\n-            # Mine the pre-bump tx\n-            txs_to_add = [raw_tx] + [self.nodes[0].getrawtransaction(txid) for txid in more_tx]\n-            block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n-            add_witness_commitment(block)\n-            block.solve()\n-            assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n-            tip = self.nodes[0].getbestblockhash()\n-            assert_equal(int(tip, 16), block.sha256)\n-            orig_txid_2 = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # Flush old notifications until evicted tx original entry\n+        self.log.info(\"Wait for tx from second node\")\n+        payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])\n+        self.sync_all()\n+        self.log.info(\"Testing sequence notifications with mempool sequence values\")\n+\n+        # Should receive the broadcasted txid.\n+        assert_equal((payment_tx['txid'], \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        self.log.info(\"Testing RBF notification\")\n+        # Replace it to test eviction/addition notification\n+        payment_tx['tx'].vout[0].nValue -= 1000\n+        rbf_txid = self.nodes[1].sendrawtransaction(payment_tx['tx'].serialize().hex())\n+        self.sync_all()\n+        assert_equal((payment_tx['txid'], \"R\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n+        # though the mempool sequence number does go up by the number of transactions\n+        # removed from the mempool by the block mining it.\n+        mempool_size = len(self.nodes[0].getrawmempool())\n+        c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        # Make sure the number of mined transactions matches the number of txs out of mempool\n+        mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n+        assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n+        seq_num += mempool_size_delta\n+        payment_txid_2 = self.wallet.send_self_transfer(from_node=self.nodes[1])['txid']\n+        self.sync_all()\n+        assert_equal((c_block, \"C\", None), seq.receive_sequence())\n+        assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Spot check getrawmempool results that they only show up when asked for\n+        assert type(self.nodes[0].getrawmempool()) is list\n+        assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n+        assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n+        assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n+        assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n+\n+        self.log.info(\"Testing reorg notifications\")\n+        # Manually invalidate the last block to test mempool re-entry\n+        # N.B. This part could be made more lenient in exact ordering\n+        # since it greatly depends on inner-workings of blocks/mempool\n+        # during \"deep\" re-orgs. Probably should \"re-construct\"\n+        # blockchain/mempool state from notifications instead.\n+        block_count = self.nodes[0].getblockcount()\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        sleep(2)  # Bit of room to make sure transaction things happened\n+\n+        # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n+        # of the time they were gathered.\n+        assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n+\n+        assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n+        self.nodes[0].reconsiderblock(best_hash)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n+        self.log.info(\"Evict mempool transaction by block conflict\")\n+        orig_tx = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # More to be simply mined\n+        more_tx = []\n+        for _ in range(5):\n+            more_tx.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+\n+        orig_tx['tx'].vout[0].nValue -= 1000\n+        bump_txid = self.nodes[0].sendrawtransaction(orig_tx['tx'].serialize().hex())\n+        # Mine the pre-bump tx\n+        txs_to_add = [orig_tx['hex']] + [tx['hex'] for tx in more_tx]\n+        block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n+        tip = self.nodes[0].getbestblockhash()\n+        assert_equal(int(tip, 16), block.sha256)\n+        orig_tx_2 = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # Flush old notifications until evicted tx original entry\n+        (hash_str, label, mempool_seq) = seq.receive_sequence()\n+        while hash_str != orig_tx['txid']:\n+<<<<<<< HEAD\n+>>>>>>> ec13426c0d (self_transfer)\n+=======\n+>>>>>>> ead059e477 ([move only] remove `is_wallet_compiled` checks)",
      "path": "test/functional/interface_zmq.py",
      "position": null,
      "original_position": 276,
      "commit_id": "bc90b8d86916d43867762a391633664676550bd8",
      "original_commit_id": "a15663362368b8452bdb035815bb36f09fbd7689",
      "in_reply_to_id": null,
      "user": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "?",
      "created_at": "2022-03-23T16:15:33Z",
      "updated_at": "2022-03-23T16:15:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833461590",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833461590"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 417,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833462771",
      "pull_request_review_id": 919059221,
      "id": 833462771,
      "node_id": "PRRC_kwDOABII584xraHz",
      "diff_hunk": "@@ -326,126 +324,126 @@ def test_sequence(self):\n         assert_equal((self.nodes[1].getblockhash(block_count), \"C\", None), seq.receive_sequence())\n \n         # Rest of test requires wallet functionality\n-        if self.is_wallet_compiled():\n-            self.log.info(\"Wait for tx from second node\")\n-            payment_txid = self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=5.0, replaceable=True)\n-            self.sync_all()\n-            self.log.info(\"Testing sequence notifications with mempool sequence values\")\n-\n-            # Should receive the broadcasted txid.\n-            assert_equal((payment_txid, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            self.log.info(\"Testing RBF notification\")\n-            # Replace it to test eviction/addition notification\n-            rbf_info = self.nodes[1].bumpfee(payment_txid)\n-            self.sync_all()\n-            assert_equal((payment_txid, \"R\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n-            # though the mempool sequence number does go up by the number of transactions\n-            # removed from the mempool by the block mining it.\n-            mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n-            # Make sure the number of mined transactions matches the number of txs out of mempool\n-            mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n-            assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n-            seq_num += mempool_size_delta\n-            payment_txid_2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-            self.sync_all()\n-            assert_equal((c_block, \"C\", None), seq.receive_sequence())\n-            assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Spot check getrawmempool results that they only show up when asked for\n-            assert type(self.nodes[0].getrawmempool()) is list\n-            assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n-            assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n-            assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n-            assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n-\n-            self.log.info(\"Testing reorg notifications\")\n-            # Manually invalidate the last block to test mempool re-entry\n-            # N.B. This part could be made more lenient in exact ordering\n-            # since it greatly depends on inner-workings of blocks/mempool\n-            # during \"deep\" re-orgs. Probably should \"re-construct\"\n-            # blockchain/mempool state from notifications instead.\n-            block_count = self.nodes[0].getblockcount()\n-            best_hash = self.nodes[0].getbestblockhash()\n-            self.nodes[0].invalidateblock(best_hash)\n-            sleep(2)  # Bit of room to make sure transaction things happened\n-\n-            # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n-            # of the time they were gathered.\n-            assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n-\n-            assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n-            self.nodes[0].reconsiderblock(best_hash)\n-            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n-\n-            self.log.info(\"Evict mempool transaction by block conflict\")\n-            orig_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # More to be simply mined\n-            more_tx = []\n-            for _ in range(5):\n-                more_tx.append(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.1))\n-\n-            raw_tx = self.nodes[0].getrawtransaction(orig_txid)\n-            bump_info = self.nodes[0].bumpfee(orig_txid)\n-            # Mine the pre-bump tx\n-            txs_to_add = [raw_tx] + [self.nodes[0].getrawtransaction(txid) for txid in more_tx]\n-            block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n-            add_witness_commitment(block)\n-            block.solve()\n-            assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n-            tip = self.nodes[0].getbestblockhash()\n-            assert_equal(int(tip, 16), block.sha256)\n-            orig_txid_2 = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # Flush old notifications until evicted tx original entry\n+        self.log.info(\"Wait for tx from second node\")\n+        payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])\n+        self.sync_all()\n+        self.log.info(\"Testing sequence notifications with mempool sequence values\")\n+\n+        # Should receive the broadcasted txid.\n+        assert_equal((payment_tx['txid'], \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        self.log.info(\"Testing RBF notification\")\n+        # Replace it to test eviction/addition notification\n+        payment_tx['tx'].vout[0].nValue -= 1000\n+        rbf_txid = self.nodes[1].sendrawtransaction(payment_tx['tx'].serialize().hex())\n+        self.sync_all()\n+        assert_equal((payment_tx['txid'], \"R\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n+        # though the mempool sequence number does go up by the number of transactions\n+        # removed from the mempool by the block mining it.\n+        mempool_size = len(self.nodes[0].getrawmempool())\n+        c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        # Make sure the number of mined transactions matches the number of txs out of mempool\n+        mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n+        assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n+        seq_num += mempool_size_delta\n+        payment_txid_2 = self.wallet.send_self_transfer(from_node=self.nodes[1])['txid']\n+        self.sync_all()\n+        assert_equal((c_block, \"C\", None), seq.receive_sequence())\n+        assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Spot check getrawmempool results that they only show up when asked for\n+        assert type(self.nodes[0].getrawmempool()) is list\n+        assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n+        assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n+        assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n+        assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n+\n+        self.log.info(\"Testing reorg notifications\")\n+        # Manually invalidate the last block to test mempool re-entry\n+        # N.B. This part could be made more lenient in exact ordering\n+        # since it greatly depends on inner-workings of blocks/mempool\n+        # during \"deep\" re-orgs. Probably should \"re-construct\"\n+        # blockchain/mempool state from notifications instead.\n+        block_count = self.nodes[0].getblockcount()\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        sleep(2)  # Bit of room to make sure transaction things happened\n+\n+        # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n+        # of the time they were gathered.\n+        assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n+\n+        assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n+        self.nodes[0].reconsiderblock(best_hash)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n+        self.log.info(\"Evict mempool transaction by block conflict\")\n+        orig_tx = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # More to be simply mined\n+        more_tx = []\n+        for _ in range(5):\n+            more_tx.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+\n+        orig_tx['tx'].vout[0].nValue -= 1000\n+        bump_txid = self.nodes[0].sendrawtransaction(orig_tx['tx'].serialize().hex())\n+        # Mine the pre-bump tx\n+        txs_to_add = [orig_tx['hex']] + [tx['hex'] for tx in more_tx]\n+        block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n+        tip = self.nodes[0].getbestblockhash()\n+        assert_equal(int(tip, 16), block.sha256)\n+        orig_tx_2 = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # Flush old notifications until evicted tx original entry\n+        (hash_str, label, mempool_seq) = seq.receive_sequence()\n+        while hash_str != orig_tx['txid']:\n+<<<<<<< HEAD\n+>>>>>>> ec13426c0d (self_transfer)\n+=======\n+>>>>>>> ead059e477 ([move only] remove `is_wallet_compiled` checks)",
      "path": "test/functional/interface_zmq.py",
      "position": null,
      "original_position": 276,
      "commit_id": "bc90b8d86916d43867762a391633664676550bd8",
      "original_commit_id": "a15663362368b8452bdb035815bb36f09fbd7689",
      "in_reply_to_id": 833461590,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "whoops! fixing",
      "created_at": "2022-03-23T16:16:27Z",
      "updated_at": "2022-03-23T16:16:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833462771",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833462771"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 417,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833492049",
      "pull_request_review_id": 919100082,
      "id": 833492049,
      "node_id": "PRRC_kwDOABII584xrhRR",
      "diff_hunk": "@@ -326,126 +324,126 @@ def test_sequence(self):\n         assert_equal((self.nodes[1].getblockhash(block_count), \"C\", None), seq.receive_sequence())\n \n         # Rest of test requires wallet functionality\n-        if self.is_wallet_compiled():\n-            self.log.info(\"Wait for tx from second node\")\n-            payment_txid = self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=5.0, replaceable=True)\n-            self.sync_all()\n-            self.log.info(\"Testing sequence notifications with mempool sequence values\")\n-\n-            # Should receive the broadcasted txid.\n-            assert_equal((payment_txid, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            self.log.info(\"Testing RBF notification\")\n-            # Replace it to test eviction/addition notification\n-            rbf_info = self.nodes[1].bumpfee(payment_txid)\n-            self.sync_all()\n-            assert_equal((payment_txid, \"R\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n-            # though the mempool sequence number does go up by the number of transactions\n-            # removed from the mempool by the block mining it.\n-            mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n-            # Make sure the number of mined transactions matches the number of txs out of mempool\n-            mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n-            assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n-            seq_num += mempool_size_delta\n-            payment_txid_2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-            self.sync_all()\n-            assert_equal((c_block, \"C\", None), seq.receive_sequence())\n-            assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Spot check getrawmempool results that they only show up when asked for\n-            assert type(self.nodes[0].getrawmempool()) is list\n-            assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n-            assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n-            assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n-            assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n-\n-            self.log.info(\"Testing reorg notifications\")\n-            # Manually invalidate the last block to test mempool re-entry\n-            # N.B. This part could be made more lenient in exact ordering\n-            # since it greatly depends on inner-workings of blocks/mempool\n-            # during \"deep\" re-orgs. Probably should \"re-construct\"\n-            # blockchain/mempool state from notifications instead.\n-            block_count = self.nodes[0].getblockcount()\n-            best_hash = self.nodes[0].getbestblockhash()\n-            self.nodes[0].invalidateblock(best_hash)\n-            sleep(2)  # Bit of room to make sure transaction things happened\n-\n-            # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n-            # of the time they were gathered.\n-            assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n-\n-            assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n-            self.nodes[0].reconsiderblock(best_hash)\n-            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n-\n-            self.log.info(\"Evict mempool transaction by block conflict\")\n-            orig_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # More to be simply mined\n-            more_tx = []\n-            for _ in range(5):\n-                more_tx.append(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.1))\n-\n-            raw_tx = self.nodes[0].getrawtransaction(orig_txid)\n-            bump_info = self.nodes[0].bumpfee(orig_txid)\n-            # Mine the pre-bump tx\n-            txs_to_add = [raw_tx] + [self.nodes[0].getrawtransaction(txid) for txid in more_tx]\n-            block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n-            add_witness_commitment(block)\n-            block.solve()\n-            assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n-            tip = self.nodes[0].getbestblockhash()\n-            assert_equal(int(tip, 16), block.sha256)\n-            orig_txid_2 = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # Flush old notifications until evicted tx original entry\n+        self.log.info(\"Wait for tx from second node\")\n+        payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])\n+        self.sync_all()\n+        self.log.info(\"Testing sequence notifications with mempool sequence values\")\n+\n+        # Should receive the broadcasted txid.\n+        assert_equal((payment_tx['txid'], \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        self.log.info(\"Testing RBF notification\")\n+        # Replace it to test eviction/addition notification\n+        payment_tx['tx'].vout[0].nValue -= 1000\n+        rbf_txid = self.nodes[1].sendrawtransaction(payment_tx['tx'].serialize().hex())\n+        self.sync_all()\n+        assert_equal((payment_tx['txid'], \"R\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n+        # though the mempool sequence number does go up by the number of transactions\n+        # removed from the mempool by the block mining it.\n+        mempool_size = len(self.nodes[0].getrawmempool())\n+        c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        # Make sure the number of mined transactions matches the number of txs out of mempool\n+        mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n+        assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n+        seq_num += mempool_size_delta\n+        payment_txid_2 = self.wallet.send_self_transfer(from_node=self.nodes[1])['txid']\n+        self.sync_all()\n+        assert_equal((c_block, \"C\", None), seq.receive_sequence())\n+        assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Spot check getrawmempool results that they only show up when asked for\n+        assert type(self.nodes[0].getrawmempool()) is list\n+        assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n+        assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n+        assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n+        assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n+\n+        self.log.info(\"Testing reorg notifications\")\n+        # Manually invalidate the last block to test mempool re-entry\n+        # N.B. This part could be made more lenient in exact ordering\n+        # since it greatly depends on inner-workings of blocks/mempool\n+        # during \"deep\" re-orgs. Probably should \"re-construct\"\n+        # blockchain/mempool state from notifications instead.\n+        block_count = self.nodes[0].getblockcount()\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        sleep(2)  # Bit of room to make sure transaction things happened\n+\n+        # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n+        # of the time they were gathered.\n+        assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n+\n+        assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n+        self.nodes[0].reconsiderblock(best_hash)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n+        self.log.info(\"Evict mempool transaction by block conflict\")\n+        orig_tx = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # More to be simply mined\n+        more_tx = []\n+        for _ in range(5):\n+            more_tx.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+\n+        orig_tx['tx'].vout[0].nValue -= 1000\n+        bump_txid = self.nodes[0].sendrawtransaction(orig_tx['tx'].serialize().hex())\n+        # Mine the pre-bump tx\n+        txs_to_add = [orig_tx['hex']] + [tx['hex'] for tx in more_tx]\n+        block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n+        tip = self.nodes[0].getbestblockhash()\n+        assert_equal(int(tip, 16), block.sha256)\n+        orig_tx_2 = self.wallet.send_self_transfer(from_node=self.nodes[0])",
      "path": "test/functional/interface_zmq.py",
      "position": null,
      "original_position": 268,
      "commit_id": "bc90b8d86916d43867762a391633664676550bd8",
      "original_commit_id": "a15663362368b8452bdb035815bb36f09fbd7689",
      "in_reply_to_id": 833461415,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "fixed! in the other cases where i reassign, i belive its because i need both the txid, wtxid, and tx body. but ill double check",
      "created_at": "2022-03-23T16:44:01Z",
      "updated_at": "2022-03-23T16:44:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833492049",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833492049"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 407,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833559426",
      "pull_request_review_id": 919196158,
      "id": 833559426,
      "node_id": "PRRC_kwDOABII584xrxuC",
      "diff_hunk": "@@ -326,126 +324,126 @@ def test_sequence(self):\n         assert_equal((self.nodes[1].getblockhash(block_count), \"C\", None), seq.receive_sequence())\n \n         # Rest of test requires wallet functionality\n-        if self.is_wallet_compiled():\n-            self.log.info(\"Wait for tx from second node\")\n-            payment_txid = self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=5.0, replaceable=True)\n-            self.sync_all()\n-            self.log.info(\"Testing sequence notifications with mempool sequence values\")\n-\n-            # Should receive the broadcasted txid.\n-            assert_equal((payment_txid, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            self.log.info(\"Testing RBF notification\")\n-            # Replace it to test eviction/addition notification\n-            rbf_info = self.nodes[1].bumpfee(payment_txid)\n-            self.sync_all()\n-            assert_equal((payment_txid, \"R\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n-            # though the mempool sequence number does go up by the number of transactions\n-            # removed from the mempool by the block mining it.\n-            mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n-            # Make sure the number of mined transactions matches the number of txs out of mempool\n-            mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n-            assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n-            seq_num += mempool_size_delta\n-            payment_txid_2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-            self.sync_all()\n-            assert_equal((c_block, \"C\", None), seq.receive_sequence())\n-            assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Spot check getrawmempool results that they only show up when asked for\n-            assert type(self.nodes[0].getrawmempool()) is list\n-            assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n-            assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n-            assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n-            assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n-\n-            self.log.info(\"Testing reorg notifications\")\n-            # Manually invalidate the last block to test mempool re-entry\n-            # N.B. This part could be made more lenient in exact ordering\n-            # since it greatly depends on inner-workings of blocks/mempool\n-            # during \"deep\" re-orgs. Probably should \"re-construct\"\n-            # blockchain/mempool state from notifications instead.\n-            block_count = self.nodes[0].getblockcount()\n-            best_hash = self.nodes[0].getbestblockhash()\n-            self.nodes[0].invalidateblock(best_hash)\n-            sleep(2)  # Bit of room to make sure transaction things happened\n-\n-            # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n-            # of the time they were gathered.\n-            assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n-\n-            assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n-            self.nodes[0].reconsiderblock(best_hash)\n-            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n-\n-            self.log.info(\"Evict mempool transaction by block conflict\")\n-            orig_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # More to be simply mined\n-            more_tx = []\n-            for _ in range(5):\n-                more_tx.append(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.1))\n-\n-            raw_tx = self.nodes[0].getrawtransaction(orig_txid)\n-            bump_info = self.nodes[0].bumpfee(orig_txid)\n-            # Mine the pre-bump tx\n-            txs_to_add = [raw_tx] + [self.nodes[0].getrawtransaction(txid) for txid in more_tx]\n-            block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n-            add_witness_commitment(block)\n-            block.solve()\n-            assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n-            tip = self.nodes[0].getbestblockhash()\n-            assert_equal(int(tip, 16), block.sha256)\n-            orig_txid_2 = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # Flush old notifications until evicted tx original entry\n+        self.log.info(\"Wait for tx from second node\")\n+        payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])\n+        self.sync_all()\n+        self.log.info(\"Testing sequence notifications with mempool sequence values\")\n+\n+        # Should receive the broadcasted txid.\n+        assert_equal((payment_tx['txid'], \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        self.log.info(\"Testing RBF notification\")\n+        # Replace it to test eviction/addition notification\n+        payment_tx['tx'].vout[0].nValue -= 1000\n+        rbf_txid = self.nodes[1].sendrawtransaction(payment_tx['tx'].serialize().hex())\n+        self.sync_all()\n+        assert_equal((payment_tx['txid'], \"R\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n+        # though the mempool sequence number does go up by the number of transactions\n+        # removed from the mempool by the block mining it.\n+        mempool_size = len(self.nodes[0].getrawmempool())\n+        c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        # Make sure the number of mined transactions matches the number of txs out of mempool\n+        mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n+        assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n+        seq_num += mempool_size_delta\n+        payment_txid_2 = self.wallet.send_self_transfer(from_node=self.nodes[1])['txid']\n+        self.sync_all()\n+        assert_equal((c_block, \"C\", None), seq.receive_sequence())\n+        assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Spot check getrawmempool results that they only show up when asked for\n+        assert type(self.nodes[0].getrawmempool()) is list\n+        assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n+        assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n+        assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n+        assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n+\n+        self.log.info(\"Testing reorg notifications\")\n+        # Manually invalidate the last block to test mempool re-entry\n+        # N.B. This part could be made more lenient in exact ordering\n+        # since it greatly depends on inner-workings of blocks/mempool\n+        # during \"deep\" re-orgs. Probably should \"re-construct\"\n+        # blockchain/mempool state from notifications instead.\n+        block_count = self.nodes[0].getblockcount()\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        sleep(2)  # Bit of room to make sure transaction things happened\n+\n+        # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n+        # of the time they were gathered.\n+        assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n+\n+        assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n+        self.nodes[0].reconsiderblock(best_hash)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n+        self.log.info(\"Evict mempool transaction by block conflict\")\n+        orig_tx = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # More to be simply mined\n+        more_tx = []\n+        for _ in range(5):\n+            more_tx.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+\n+        orig_tx['tx'].vout[0].nValue -= 1000\n+        bump_txid = self.nodes[0].sendrawtransaction(orig_tx['tx'].serialize().hex())\n+        # Mine the pre-bump tx\n+        txs_to_add = [orig_tx['hex']] + [tx['hex'] for tx in more_tx]\n+        block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n+        tip = self.nodes[0].getbestblockhash()\n+        assert_equal(int(tip, 16), block.sha256)\n+        orig_tx_2 = self.wallet.send_self_transfer(from_node=self.nodes[0])",
      "path": "test/functional/interface_zmq.py",
      "position": null,
      "original_position": 268,
      "commit_id": "bc90b8d86916d43867762a391633664676550bd8",
      "original_commit_id": "a15663362368b8452bdb035815bb36f09fbd7689",
      "in_reply_to_id": 833461415,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "okay, in https://github.com/bitcoin/bitcoin/pull/24653/commits/7f943aa1e0543765f499b2f50697281d5fe22adf ive got the diff down",
      "created_at": "2022-03-23T17:47:44Z",
      "updated_at": "2022-03-23T17:47:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833559426",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833559426"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 407,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833947744",
      "pull_request_review_id": 919754477,
      "id": 833947744,
      "node_id": "PRRC_kwDOABII584xtQhg",
      "diff_hunk": "@@ -326,126 +324,126 @@ def test_sequence(self):\n         assert_equal((self.nodes[1].getblockhash(block_count), \"C\", None), seq.receive_sequence())\n \n         # Rest of test requires wallet functionality\n-        if self.is_wallet_compiled():\n-            self.log.info(\"Wait for tx from second node\")\n-            payment_txid = self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=5.0, replaceable=True)\n-            self.sync_all()\n-            self.log.info(\"Testing sequence notifications with mempool sequence values\")\n-\n-            # Should receive the broadcasted txid.\n-            assert_equal((payment_txid, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            self.log.info(\"Testing RBF notification\")\n-            # Replace it to test eviction/addition notification\n-            rbf_info = self.nodes[1].bumpfee(payment_txid)\n-            self.sync_all()\n-            assert_equal((payment_txid, \"R\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n-            # though the mempool sequence number does go up by the number of transactions\n-            # removed from the mempool by the block mining it.\n-            mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n-            # Make sure the number of mined transactions matches the number of txs out of mempool\n-            mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n-            assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n-            seq_num += mempool_size_delta\n-            payment_txid_2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-            self.sync_all()\n-            assert_equal((c_block, \"C\", None), seq.receive_sequence())\n-            assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Spot check getrawmempool results that they only show up when asked for\n-            assert type(self.nodes[0].getrawmempool()) is list\n-            assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n-            assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n-            assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n-            assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n-\n-            self.log.info(\"Testing reorg notifications\")\n-            # Manually invalidate the last block to test mempool re-entry\n-            # N.B. This part could be made more lenient in exact ordering\n-            # since it greatly depends on inner-workings of blocks/mempool\n-            # during \"deep\" re-orgs. Probably should \"re-construct\"\n-            # blockchain/mempool state from notifications instead.\n-            block_count = self.nodes[0].getblockcount()\n-            best_hash = self.nodes[0].getbestblockhash()\n-            self.nodes[0].invalidateblock(best_hash)\n-            sleep(2)  # Bit of room to make sure transaction things happened\n-\n-            # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n-            # of the time they were gathered.\n-            assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n-\n-            assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n-            self.nodes[0].reconsiderblock(best_hash)\n-            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n-\n-            self.log.info(\"Evict mempool transaction by block conflict\")\n-            orig_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # More to be simply mined\n-            more_tx = []\n-            for _ in range(5):\n-                more_tx.append(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.1))\n-\n-            raw_tx = self.nodes[0].getrawtransaction(orig_txid)\n-            bump_info = self.nodes[0].bumpfee(orig_txid)\n-            # Mine the pre-bump tx\n-            txs_to_add = [raw_tx] + [self.nodes[0].getrawtransaction(txid) for txid in more_tx]\n-            block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n-            add_witness_commitment(block)\n-            block.solve()\n-            assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n-            tip = self.nodes[0].getbestblockhash()\n-            assert_equal(int(tip, 16), block.sha256)\n-            orig_txid_2 = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # Flush old notifications until evicted tx original entry\n+        self.log.info(\"Wait for tx from second node\")\n+        payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])\n+        self.sync_all()\n+        self.log.info(\"Testing sequence notifications with mempool sequence values\")\n+\n+        # Should receive the broadcasted txid.\n+        assert_equal((payment_tx['txid'], \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        self.log.info(\"Testing RBF notification\")\n+        # Replace it to test eviction/addition notification\n+        payment_tx['tx'].vout[0].nValue -= 1000\n+        rbf_txid = self.nodes[1].sendrawtransaction(payment_tx['tx'].serialize().hex())\n+        self.sync_all()\n+        assert_equal((payment_tx['txid'], \"R\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n+        # though the mempool sequence number does go up by the number of transactions\n+        # removed from the mempool by the block mining it.\n+        mempool_size = len(self.nodes[0].getrawmempool())\n+        c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        # Make sure the number of mined transactions matches the number of txs out of mempool\n+        mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n+        assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n+        seq_num += mempool_size_delta\n+        payment_txid_2 = self.wallet.send_self_transfer(from_node=self.nodes[1])['txid']\n+        self.sync_all()\n+        assert_equal((c_block, \"C\", None), seq.receive_sequence())\n+        assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Spot check getrawmempool results that they only show up when asked for\n+        assert type(self.nodes[0].getrawmempool()) is list\n+        assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n+        assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n+        assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n+        assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n+\n+        self.log.info(\"Testing reorg notifications\")\n+        # Manually invalidate the last block to test mempool re-entry\n+        # N.B. This part could be made more lenient in exact ordering\n+        # since it greatly depends on inner-workings of blocks/mempool\n+        # during \"deep\" re-orgs. Probably should \"re-construct\"\n+        # blockchain/mempool state from notifications instead.\n+        block_count = self.nodes[0].getblockcount()\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        sleep(2)  # Bit of room to make sure transaction things happened\n+\n+        # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n+        # of the time they were gathered.\n+        assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n+\n+        assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n+        self.nodes[0].reconsiderblock(best_hash)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n+        self.log.info(\"Evict mempool transaction by block conflict\")\n+        orig_tx = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # More to be simply mined\n+        more_tx = []\n+        for _ in range(5):\n+            more_tx.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+\n+        orig_tx['tx'].vout[0].nValue -= 1000\n+        bump_txid = self.nodes[0].sendrawtransaction(orig_tx['tx'].serialize().hex())\n+        # Mine the pre-bump tx\n+        txs_to_add = [orig_tx['hex']] + [tx['hex'] for tx in more_tx]\n+        block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n+        tip = self.nodes[0].getbestblockhash()\n+        assert_equal(int(tip, 16), block.sha256)\n+        orig_tx_2 = self.wallet.send_self_transfer(from_node=self.nodes[0])",
      "path": "test/functional/interface_zmq.py",
      "position": null,
      "original_position": 268,
      "commit_id": "bc90b8d86916d43867762a391633664676550bd8",
      "original_commit_id": "a15663362368b8452bdb035815bb36f09fbd7689",
      "in_reply_to_id": 833461415,
      "user": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think this is fixed?",
      "created_at": "2022-03-24T06:10:44Z",
      "updated_at": "2022-03-24T06:10:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833947744",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833947744"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 407,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/834105068",
      "pull_request_review_id": 919974957,
      "id": 834105068,
      "node_id": "PRRC_kwDOABII584xt27s",
      "diff_hunk": "@@ -326,126 +324,126 @@ def test_sequence(self):\n         assert_equal((self.nodes[1].getblockhash(block_count), \"C\", None), seq.receive_sequence())\n \n         # Rest of test requires wallet functionality\n-        if self.is_wallet_compiled():\n-            self.log.info(\"Wait for tx from second node\")\n-            payment_txid = self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=5.0, replaceable=True)\n-            self.sync_all()\n-            self.log.info(\"Testing sequence notifications with mempool sequence values\")\n-\n-            # Should receive the broadcasted txid.\n-            assert_equal((payment_txid, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            self.log.info(\"Testing RBF notification\")\n-            # Replace it to test eviction/addition notification\n-            rbf_info = self.nodes[1].bumpfee(payment_txid)\n-            self.sync_all()\n-            assert_equal((payment_txid, \"R\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n-            # though the mempool sequence number does go up by the number of transactions\n-            # removed from the mempool by the block mining it.\n-            mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n-            # Make sure the number of mined transactions matches the number of txs out of mempool\n-            mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n-            assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n-            seq_num += mempool_size_delta\n-            payment_txid_2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-            self.sync_all()\n-            assert_equal((c_block, \"C\", None), seq.receive_sequence())\n-            assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Spot check getrawmempool results that they only show up when asked for\n-            assert type(self.nodes[0].getrawmempool()) is list\n-            assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n-            assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n-            assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n-            assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n-\n-            self.log.info(\"Testing reorg notifications\")\n-            # Manually invalidate the last block to test mempool re-entry\n-            # N.B. This part could be made more lenient in exact ordering\n-            # since it greatly depends on inner-workings of blocks/mempool\n-            # during \"deep\" re-orgs. Probably should \"re-construct\"\n-            # blockchain/mempool state from notifications instead.\n-            block_count = self.nodes[0].getblockcount()\n-            best_hash = self.nodes[0].getbestblockhash()\n-            self.nodes[0].invalidateblock(best_hash)\n-            sleep(2)  # Bit of room to make sure transaction things happened\n-\n-            # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n-            # of the time they were gathered.\n-            assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n-\n-            assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n-            self.nodes[0].reconsiderblock(best_hash)\n-            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n-\n-            self.log.info(\"Evict mempool transaction by block conflict\")\n-            orig_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # More to be simply mined\n-            more_tx = []\n-            for _ in range(5):\n-                more_tx.append(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.1))\n-\n-            raw_tx = self.nodes[0].getrawtransaction(orig_txid)\n-            bump_info = self.nodes[0].bumpfee(orig_txid)\n-            # Mine the pre-bump tx\n-            txs_to_add = [raw_tx] + [self.nodes[0].getrawtransaction(txid) for txid in more_tx]\n-            block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n-            add_witness_commitment(block)\n-            block.solve()\n-            assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n-            tip = self.nodes[0].getbestblockhash()\n-            assert_equal(int(tip, 16), block.sha256)\n-            orig_txid_2 = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # Flush old notifications until evicted tx original entry\n+        self.log.info(\"Wait for tx from second node\")\n+        payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])\n+        self.sync_all()\n+        self.log.info(\"Testing sequence notifications with mempool sequence values\")\n+\n+        # Should receive the broadcasted txid.\n+        assert_equal((payment_tx['txid'], \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        self.log.info(\"Testing RBF notification\")\n+        # Replace it to test eviction/addition notification\n+        payment_tx['tx'].vout[0].nValue -= 1000\n+        rbf_txid = self.nodes[1].sendrawtransaction(payment_tx['tx'].serialize().hex())\n+        self.sync_all()\n+        assert_equal((payment_tx['txid'], \"R\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n+        # though the mempool sequence number does go up by the number of transactions\n+        # removed from the mempool by the block mining it.\n+        mempool_size = len(self.nodes[0].getrawmempool())\n+        c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        # Make sure the number of mined transactions matches the number of txs out of mempool\n+        mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n+        assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n+        seq_num += mempool_size_delta\n+        payment_txid_2 = self.wallet.send_self_transfer(from_node=self.nodes[1])['txid']\n+        self.sync_all()\n+        assert_equal((c_block, \"C\", None), seq.receive_sequence())\n+        assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Spot check getrawmempool results that they only show up when asked for\n+        assert type(self.nodes[0].getrawmempool()) is list\n+        assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n+        assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n+        assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n+        assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n+\n+        self.log.info(\"Testing reorg notifications\")\n+        # Manually invalidate the last block to test mempool re-entry\n+        # N.B. This part could be made more lenient in exact ordering\n+        # since it greatly depends on inner-workings of blocks/mempool\n+        # during \"deep\" re-orgs. Probably should \"re-construct\"\n+        # blockchain/mempool state from notifications instead.\n+        block_count = self.nodes[0].getblockcount()\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        sleep(2)  # Bit of room to make sure transaction things happened\n+\n+        # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n+        # of the time they were gathered.\n+        assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n+\n+        assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n+        self.nodes[0].reconsiderblock(best_hash)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n+        self.log.info(\"Evict mempool transaction by block conflict\")\n+        orig_tx = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # More to be simply mined\n+        more_tx = []\n+        for _ in range(5):\n+            more_tx.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+\n+        orig_tx['tx'].vout[0].nValue -= 1000\n+        bump_txid = self.nodes[0].sendrawtransaction(orig_tx['tx'].serialize().hex())\n+        # Mine the pre-bump tx\n+        txs_to_add = [orig_tx['hex']] + [tx['hex'] for tx in more_tx]\n+        block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n+        tip = self.nodes[0].getbestblockhash()\n+        assert_equal(int(tip, 16), block.sha256)\n+        orig_tx_2 = self.wallet.send_self_transfer(from_node=self.nodes[0])",
      "path": "test/functional/interface_zmq.py",
      "position": null,
      "original_position": 268,
      "commit_id": "bc90b8d86916d43867762a391633664676550bd8",
      "original_commit_id": "a15663362368b8452bdb035815bb36f09fbd7689",
      "in_reply_to_id": 833461415,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "where are you still seeing an issue? I renamed `orig_tx_2` -> `orig_txid_2` and also added `payment_txid` as a variable to avoid touching lines just to rename `payment_txid` -> `payment_tx['txid']`",
      "created_at": "2022-03-24T09:39:10Z",
      "updated_at": "2022-03-24T09:39:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r834105068",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/834105068"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 407,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/834108910",
      "pull_request_review_id": 919980271,
      "id": 834108910,
      "node_id": "PRRC_kwDOABII584xt33u",
      "diff_hunk": "@@ -326,126 +324,126 @@ def test_sequence(self):\n         assert_equal((self.nodes[1].getblockhash(block_count), \"C\", None), seq.receive_sequence())\n \n         # Rest of test requires wallet functionality\n-        if self.is_wallet_compiled():\n-            self.log.info(\"Wait for tx from second node\")\n-            payment_txid = self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=5.0, replaceable=True)\n-            self.sync_all()\n-            self.log.info(\"Testing sequence notifications with mempool sequence values\")\n-\n-            # Should receive the broadcasted txid.\n-            assert_equal((payment_txid, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            self.log.info(\"Testing RBF notification\")\n-            # Replace it to test eviction/addition notification\n-            rbf_info = self.nodes[1].bumpfee(payment_txid)\n-            self.sync_all()\n-            assert_equal((payment_txid, \"R\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n-            # though the mempool sequence number does go up by the number of transactions\n-            # removed from the mempool by the block mining it.\n-            mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n-            # Make sure the number of mined transactions matches the number of txs out of mempool\n-            mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n-            assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n-            seq_num += mempool_size_delta\n-            payment_txid_2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-            self.sync_all()\n-            assert_equal((c_block, \"C\", None), seq.receive_sequence())\n-            assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Spot check getrawmempool results that they only show up when asked for\n-            assert type(self.nodes[0].getrawmempool()) is list\n-            assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n-            assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n-            assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n-            assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n-\n-            self.log.info(\"Testing reorg notifications\")\n-            # Manually invalidate the last block to test mempool re-entry\n-            # N.B. This part could be made more lenient in exact ordering\n-            # since it greatly depends on inner-workings of blocks/mempool\n-            # during \"deep\" re-orgs. Probably should \"re-construct\"\n-            # blockchain/mempool state from notifications instead.\n-            block_count = self.nodes[0].getblockcount()\n-            best_hash = self.nodes[0].getbestblockhash()\n-            self.nodes[0].invalidateblock(best_hash)\n-            sleep(2)  # Bit of room to make sure transaction things happened\n-\n-            # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n-            # of the time they were gathered.\n-            assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n-\n-            assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n-            self.nodes[0].reconsiderblock(best_hash)\n-            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n-\n-            self.log.info(\"Evict mempool transaction by block conflict\")\n-            orig_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # More to be simply mined\n-            more_tx = []\n-            for _ in range(5):\n-                more_tx.append(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.1))\n-\n-            raw_tx = self.nodes[0].getrawtransaction(orig_txid)\n-            bump_info = self.nodes[0].bumpfee(orig_txid)\n-            # Mine the pre-bump tx\n-            txs_to_add = [raw_tx] + [self.nodes[0].getrawtransaction(txid) for txid in more_tx]\n-            block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n-            add_witness_commitment(block)\n-            block.solve()\n-            assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n-            tip = self.nodes[0].getbestblockhash()\n-            assert_equal(int(tip, 16), block.sha256)\n-            orig_txid_2 = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # Flush old notifications until evicted tx original entry\n+        self.log.info(\"Wait for tx from second node\")\n+        payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])\n+        self.sync_all()\n+        self.log.info(\"Testing sequence notifications with mempool sequence values\")\n+\n+        # Should receive the broadcasted txid.\n+        assert_equal((payment_tx['txid'], \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        self.log.info(\"Testing RBF notification\")\n+        # Replace it to test eviction/addition notification\n+        payment_tx['tx'].vout[0].nValue -= 1000\n+        rbf_txid = self.nodes[1].sendrawtransaction(payment_tx['tx'].serialize().hex())\n+        self.sync_all()\n+        assert_equal((payment_tx['txid'], \"R\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n+        # though the mempool sequence number does go up by the number of transactions\n+        # removed from the mempool by the block mining it.\n+        mempool_size = len(self.nodes[0].getrawmempool())\n+        c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        # Make sure the number of mined transactions matches the number of txs out of mempool\n+        mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n+        assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n+        seq_num += mempool_size_delta\n+        payment_txid_2 = self.wallet.send_self_transfer(from_node=self.nodes[1])['txid']\n+        self.sync_all()\n+        assert_equal((c_block, \"C\", None), seq.receive_sequence())\n+        assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Spot check getrawmempool results that they only show up when asked for\n+        assert type(self.nodes[0].getrawmempool()) is list\n+        assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n+        assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n+        assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n+        assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n+\n+        self.log.info(\"Testing reorg notifications\")\n+        # Manually invalidate the last block to test mempool re-entry\n+        # N.B. This part could be made more lenient in exact ordering\n+        # since it greatly depends on inner-workings of blocks/mempool\n+        # during \"deep\" re-orgs. Probably should \"re-construct\"\n+        # blockchain/mempool state from notifications instead.\n+        block_count = self.nodes[0].getblockcount()\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        sleep(2)  # Bit of room to make sure transaction things happened\n+\n+        # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n+        # of the time they were gathered.\n+        assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n+\n+        assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n+        self.nodes[0].reconsiderblock(best_hash)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n+        self.log.info(\"Evict mempool transaction by block conflict\")\n+        orig_tx = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # More to be simply mined\n+        more_tx = []\n+        for _ in range(5):\n+            more_tx.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+\n+        orig_tx['tx'].vout[0].nValue -= 1000\n+        bump_txid = self.nodes[0].sendrawtransaction(orig_tx['tx'].serialize().hex())\n+        # Mine the pre-bump tx\n+        txs_to_add = [orig_tx['hex']] + [tx['hex'] for tx in more_tx]\n+        block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n+        tip = self.nodes[0].getbestblockhash()\n+        assert_equal(int(tip, 16), block.sha256)\n+        orig_tx_2 = self.wallet.send_self_transfer(from_node=self.nodes[0])",
      "path": "test/functional/interface_zmq.py",
      "position": null,
      "original_position": 268,
      "commit_id": "bc90b8d86916d43867762a391633664676550bd8",
      "original_commit_id": "a15663362368b8452bdb035815bb36f09fbd7689",
      "in_reply_to_id": 833461415,
      "user": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> where are you still seeing an issue?\r\n\r\nIn GitHub.\r\n\r\nUsually GitHub will display \"outdated\" if a review comment was addressed.\r\n\r\nYou can also check the files tab and use your browsers search feature to see that the `orig_tx_2` still exists.",
      "created_at": "2022-03-24T09:43:12Z",
      "updated_at": "2022-03-24T09:43:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r834108910",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/834108910"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 407,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/834115287",
      "pull_request_review_id": 919989498,
      "id": 834115287,
      "node_id": "PRRC_kwDOABII584xt5bX",
      "diff_hunk": "@@ -326,126 +324,126 @@ def test_sequence(self):\n         assert_equal((self.nodes[1].getblockhash(block_count), \"C\", None), seq.receive_sequence())\n \n         # Rest of test requires wallet functionality\n-        if self.is_wallet_compiled():\n-            self.log.info(\"Wait for tx from second node\")\n-            payment_txid = self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=5.0, replaceable=True)\n-            self.sync_all()\n-            self.log.info(\"Testing sequence notifications with mempool sequence values\")\n-\n-            # Should receive the broadcasted txid.\n-            assert_equal((payment_txid, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            self.log.info(\"Testing RBF notification\")\n-            # Replace it to test eviction/addition notification\n-            rbf_info = self.nodes[1].bumpfee(payment_txid)\n-            self.sync_all()\n-            assert_equal((payment_txid, \"R\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n-            # though the mempool sequence number does go up by the number of transactions\n-            # removed from the mempool by the block mining it.\n-            mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n-            # Make sure the number of mined transactions matches the number of txs out of mempool\n-            mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n-            assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n-            seq_num += mempool_size_delta\n-            payment_txid_2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-            self.sync_all()\n-            assert_equal((c_block, \"C\", None), seq.receive_sequence())\n-            assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Spot check getrawmempool results that they only show up when asked for\n-            assert type(self.nodes[0].getrawmempool()) is list\n-            assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n-            assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n-            assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n-            assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n-\n-            self.log.info(\"Testing reorg notifications\")\n-            # Manually invalidate the last block to test mempool re-entry\n-            # N.B. This part could be made more lenient in exact ordering\n-            # since it greatly depends on inner-workings of blocks/mempool\n-            # during \"deep\" re-orgs. Probably should \"re-construct\"\n-            # blockchain/mempool state from notifications instead.\n-            block_count = self.nodes[0].getblockcount()\n-            best_hash = self.nodes[0].getbestblockhash()\n-            self.nodes[0].invalidateblock(best_hash)\n-            sleep(2)  # Bit of room to make sure transaction things happened\n-\n-            # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n-            # of the time they were gathered.\n-            assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n-\n-            assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n-            self.nodes[0].reconsiderblock(best_hash)\n-            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n-\n-            self.log.info(\"Evict mempool transaction by block conflict\")\n-            orig_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # More to be simply mined\n-            more_tx = []\n-            for _ in range(5):\n-                more_tx.append(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.1))\n-\n-            raw_tx = self.nodes[0].getrawtransaction(orig_txid)\n-            bump_info = self.nodes[0].bumpfee(orig_txid)\n-            # Mine the pre-bump tx\n-            txs_to_add = [raw_tx] + [self.nodes[0].getrawtransaction(txid) for txid in more_tx]\n-            block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n-            add_witness_commitment(block)\n-            block.solve()\n-            assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n-            tip = self.nodes[0].getbestblockhash()\n-            assert_equal(int(tip, 16), block.sha256)\n-            orig_txid_2 = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # Flush old notifications until evicted tx original entry\n+        self.log.info(\"Wait for tx from second node\")\n+        payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])\n+        self.sync_all()\n+        self.log.info(\"Testing sequence notifications with mempool sequence values\")\n+\n+        # Should receive the broadcasted txid.\n+        assert_equal((payment_tx['txid'], \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        self.log.info(\"Testing RBF notification\")\n+        # Replace it to test eviction/addition notification\n+        payment_tx['tx'].vout[0].nValue -= 1000\n+        rbf_txid = self.nodes[1].sendrawtransaction(payment_tx['tx'].serialize().hex())\n+        self.sync_all()\n+        assert_equal((payment_tx['txid'], \"R\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n+        # though the mempool sequence number does go up by the number of transactions\n+        # removed from the mempool by the block mining it.\n+        mempool_size = len(self.nodes[0].getrawmempool())\n+        c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        # Make sure the number of mined transactions matches the number of txs out of mempool\n+        mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n+        assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n+        seq_num += mempool_size_delta\n+        payment_txid_2 = self.wallet.send_self_transfer(from_node=self.nodes[1])['txid']\n+        self.sync_all()\n+        assert_equal((c_block, \"C\", None), seq.receive_sequence())\n+        assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Spot check getrawmempool results that they only show up when asked for\n+        assert type(self.nodes[0].getrawmempool()) is list\n+        assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n+        assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n+        assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n+        assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n+\n+        self.log.info(\"Testing reorg notifications\")\n+        # Manually invalidate the last block to test mempool re-entry\n+        # N.B. This part could be made more lenient in exact ordering\n+        # since it greatly depends on inner-workings of blocks/mempool\n+        # during \"deep\" re-orgs. Probably should \"re-construct\"\n+        # blockchain/mempool state from notifications instead.\n+        block_count = self.nodes[0].getblockcount()\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        sleep(2)  # Bit of room to make sure transaction things happened\n+\n+        # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n+        # of the time they were gathered.\n+        assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n+\n+        assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n+        self.nodes[0].reconsiderblock(best_hash)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n+        self.log.info(\"Evict mempool transaction by block conflict\")\n+        orig_tx = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # More to be simply mined\n+        more_tx = []\n+        for _ in range(5):\n+            more_tx.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+\n+        orig_tx['tx'].vout[0].nValue -= 1000\n+        bump_txid = self.nodes[0].sendrawtransaction(orig_tx['tx'].serialize().hex())\n+        # Mine the pre-bump tx\n+        txs_to_add = [orig_tx['hex']] + [tx['hex'] for tx in more_tx]\n+        block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n+        tip = self.nodes[0].getbestblockhash()\n+        assert_equal(int(tip, 16), block.sha256)\n+        orig_tx_2 = self.wallet.send_self_transfer(from_node=self.nodes[0])",
      "path": "test/functional/interface_zmq.py",
      "position": null,
      "original_position": 268,
      "commit_id": "bc90b8d86916d43867762a391633664676550bd8",
      "original_commit_id": "a15663362368b8452bdb035815bb36f09fbd7689",
      "in_reply_to_id": 833461415,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "sorry, you're right! it was fixed in the first commit, but not in the second commit. it's fixed now.",
      "created_at": "2022-03-24T09:50:12Z",
      "updated_at": "2022-03-24T09:50:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r834115287",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/834115287"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 407,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/834660130",
      "pull_request_review_id": 920783427,
      "id": 834660130,
      "node_id": "PRRC_kwDOABII584xv-ci",
      "diff_hunk": "@@ -455,10 +452,10 @@ def test_mempool_sync(self):\n \n         # Some transactions have been happening but we aren't consuming zmq notifications yet\n         # or we lost a ZMQ message somehow and want to start over\n-        txids = []\n+        txs = []",
      "path": "test/functional/interface_zmq.py",
      "position": 331,
      "original_position": 331,
      "commit_id": "bc90b8d86916d43867762a391633664676550bd8",
      "original_commit_id": "bc90b8d86916d43867762a391633664676550bd8",
      "in_reply_to_id": null,
      "user": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Unrelated: It looks like this array is unused beside the last value? Could remove it and just assign the last value to a non-array name?",
      "created_at": "2022-03-24T19:35:28Z",
      "updated_at": "2022-03-24T19:37:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r834660130",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/834660130"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 455,
      "original_line": 455,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/834661173",
      "pull_request_review_id": 920783427,
      "id": 834661173,
      "node_id": "PRRC_kwDOABII584xv-s1",
      "diff_hunk": "@@ -484,11 +481,12 @@ def test_mempool_sync(self):\n         # Things continue to happen in the \"interim\" while waiting for snapshot results\n         # We have node 0 do all these to avoid p2p races with RBF announcements\n         for _ in range(num_txs):\n-            txids.append(self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=0.1, replaceable=True))\n-        self.nodes[0].bumpfee(txids[-1])\n+            txs.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+        txs[-1]['tx'].vout[0].nValue -= 1000\n+        self.nodes[0].sendrawtransaction(txs[-1]['tx'].serialize().hex())",
      "path": "test/functional/interface_zmq.py",
      "position": 347,
      "original_position": 347,
      "commit_id": "bc90b8d86916d43867762a391633664676550bd8",
      "original_commit_id": "bc90b8d86916d43867762a391633664676550bd8",
      "in_reply_to_id": null,
      "user": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I recall that you asked on IRC whether it makes sense to introduce a bumpfee method for the wallet. On a second thought, I think it could make sense.\r\n\r\nCurrently it looks like `send_self_transfer` will put an utxo in the wallet which will never exist if the tx is bumped?\r\n\r\nSo a helper could drop the utxo(s?) and even add the new ones?",
      "created_at": "2022-03-24T19:36:56Z",
      "updated_at": "2022-03-24T19:37:08Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r834661173",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/834661173"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 486,
      "original_line": 486,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/835182795",
      "pull_request_review_id": 921515194,
      "id": 835182795,
      "node_id": "PRRC_kwDOABII584xx-DL",
      "diff_hunk": "@@ -455,10 +452,10 @@ def test_mempool_sync(self):\n \n         # Some transactions have been happening but we aren't consuming zmq notifications yet\n         # or we lost a ZMQ message somehow and want to start over\n-        txids = []\n+        txs = []",
      "path": "test/functional/interface_zmq.py",
      "position": 331,
      "original_position": 331,
      "commit_id": "bc90b8d86916d43867762a391633664676550bd8",
      "original_commit_id": "bc90b8d86916d43867762a391633664676550bd8",
      "in_reply_to_id": 834660130,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "agreed, was very confused by this array. ended up leaving it alone just to minimize my changes to just `MiniWallet`",
      "created_at": "2022-03-25T11:24:46Z",
      "updated_at": "2022-03-25T11:24:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r835182795",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/835182795"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 455,
      "original_line": 455,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/835202270",
      "pull_request_review_id": 921543206,
      "id": 835202270,
      "node_id": "PRRC_kwDOABII584xyCze",
      "diff_hunk": "@@ -455,10 +452,10 @@ def test_mempool_sync(self):\n \n         # Some transactions have been happening but we aren't consuming zmq notifications yet\n         # or we lost a ZMQ message somehow and want to start over\n-        txids = []\n+        txs = []",
      "path": "test/functional/interface_zmq.py",
      "position": 331,
      "original_position": 331,
      "commit_id": "bc90b8d86916d43867762a391633664676550bd8",
      "original_commit_id": "bc90b8d86916d43867762a391633664676550bd8",
      "in_reply_to_id": 834660130,
      "user": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, it is good to keep unrelated changes for separate commits and/or follow-ups.",
      "created_at": "2022-03-25T11:54:39Z",
      "updated_at": "2022-03-25T11:54:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r835202270",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/835202270"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 455,
      "original_line": 455,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/835210505",
      "pull_request_review_id": 921555336,
      "id": 835210505,
      "node_id": "PRRC_kwDOABII584xyE0J",
      "diff_hunk": "@@ -484,11 +481,12 @@ def test_mempool_sync(self):\n         # Things continue to happen in the \"interim\" while waiting for snapshot results\n         # We have node 0 do all these to avoid p2p races with RBF announcements\n         for _ in range(num_txs):\n-            txids.append(self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=0.1, replaceable=True))\n-        self.nodes[0].bumpfee(txids[-1])\n+            txs.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+        txs[-1]['tx'].vout[0].nValue -= 1000\n+        self.nodes[0].sendrawtransaction(txs[-1]['tx'].serialize().hex())",
      "path": "test/functional/interface_zmq.py",
      "position": 347,
      "original_position": 347,
      "commit_id": "bc90b8d86916d43867762a391633664676550bd8",
      "original_commit_id": "bc90b8d86916d43867762a391633664676550bd8",
      "in_reply_to_id": 834661173,
      "user": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "yep, I think it would be a useful method to have. I'll open a follow-up PR for adding it as a method to `MiniWallet`",
      "created_at": "2022-03-25T12:07:17Z",
      "updated_at": "2022-03-25T12:07:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r835210505",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/835210505"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 486,
      "original_line": 486,
      "side": "RIGHT"
    }
  ]
}