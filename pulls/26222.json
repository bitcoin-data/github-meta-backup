{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222",
    "id": 1073616802,
    "node_id": "PR_kwDOABII584__hei",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/26222",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/26222.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/26222.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26222",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26222/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/2745abf17a86baa319c55ad96c7fef8eea145c6f",
    "number": 26222,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "Introduce secp256k1 module with field and group classes to test framework",
    "user": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This PR rewrites a portion of `test_framework/key.py`, in a compatible way, by introducing classes that encapsulate field element and group element logic, in an attempt to be more readable and reusable.\r\n\r\nTo maximize readability, the group element logic does not use Jacobian coordinates. Instead, group elements just store (affine) X and Y coordinates directly. To compensate for the performance loss this causes, field elements are represented as fractions. This undoes most, but not all, of the performance loss, and there is a few % slowdown (as measured in `feature_taproot.py`, which heavily uses this).\r\n\r\nThe upside is that the implementation for group laws (point doubling, addition, subtraction, ...) is very close to the mathematical description of elliptic curves, and this extends to potential future extensions (e.g. ElligatorSwift as needed by #27479).",
    "labels": [
      {
        "id": 62963516,
        "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
        "name": "Tests",
        "color": "d4c5f9",
        "default": false
      }
    ],
    "created_at": "2022-10-01T17:12:10Z",
    "updated_at": "2023-06-02T05:16:09Z",
    "mergeable": true,
    "mergeable_state": "blocked",
    "merge_commit_sha": "2d09243f91daedf1294fbf8989dd730d4a3274df",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": true,
    "head": {
      "label": "sipa:202209_fe_ge_classes",
      "ref": "202209_fe_ge_classes",
      "sha": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 1458655,
        "node_id": "MDEwOlJlcG9zaXRvcnkxNDU4NjU1",
        "name": "bitcoin",
        "full_name": "sipa/bitcoin",
        "owner": {
          "login": "sipa",
          "id": 548488,
          "node_id": "MDQ6VXNlcjU0ODQ4OA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/sipa",
          "html_url": "https://github.com/sipa",
          "followers_url": "https://api.github.com/users/sipa/followers",
          "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
          "organizations_url": "https://api.github.com/users/sipa/orgs",
          "repos_url": "https://api.github.com/users/sipa/repos",
          "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/sipa/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/sipa/bitcoin",
        "description": "Bitcoin integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/sipa/bitcoin",
        "archive_url": "https://api.github.com/repos/sipa/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/sipa/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/sipa/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/sipa/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/sipa/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/sipa/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/sipa/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/sipa/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/sipa/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/sipa/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/sipa/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/sipa/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/sipa/bitcoin/events",
        "forks_url": "https://api.github.com/repos/sipa/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/sipa/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/sipa/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/sipa/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/sipa/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/sipa/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/sipa/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/sipa/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/sipa/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/sipa/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/sipa/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/sipa/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/sipa/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/sipa/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/sipa/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/sipa/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:sipa/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/sipa/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/sipa/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/sipa/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/sipa/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/sipa/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/sipa/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/sipa/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/sipa/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/sipa/bitcoin/hooks",
        "svn_url": "https://github.com/sipa/bitcoin",
        "homepage": "http://www.bitcoin.org",
        "language": "TypeScript",
        "forks_count": 20,
        "stargazers_count": 81,
        "watchers_count": 81,
        "size": 215860,
        "default_branch": "lows",
        "open_issues_count": 16,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": true,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-06-06T11:52:48Z",
        "created_at": "2011-03-09T10:46:59Z",
        "updated_at": "2023-04-30T00:52:17Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "3a83d4417b35cb0173286b6da97315be861901bc",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 34324,
        "stargazers_count": 69818,
        "watchers_count": 69818,
        "size": 233879,
        "default_branch": "master",
        "open_issues_count": 627,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-06-07T07:15:46Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2023-06-07T06:49:43Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 408,
    "deletions": 286,
    "changed_files": 3,
    "commits": 2,
    "review_comments": 34,
    "comments": 8
  },
  "events": [
    {
      "event": "labeled",
      "id": 7500763266,
      "node_id": "LE_lADOABII585TDtOFzwAAAAG_FJCC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7500763266",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-01T17:13:09Z",
      "label": {
        "name": "Tests",
        "color": "d4c5f9"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7500789847,
      "node_id": "HRFPE_lADOABII585TDtOFzwAAAAG_FPhX",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7500789847",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-01T17:34:33Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7500827656,
      "node_id": "HRFPE_lADOABII585TDtOFzwAAAAG_FYwI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7500827656",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-01T18:02:48Z"
    },
    {
      "event": "commented",
      "id": 1264453668,
      "node_id": "IC_kwDOABII585LXggk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1264453668",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-01T19:02:57Z",
      "updated_at": "2023-06-02T05:16:09Z",
      "author_association": "MEMBER",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [theStack](https://github.com/bitcoin/bitcoin/pull/26222#pullrequestreview-1368140182), [hebasto](https://github.com/bitcoin/bitcoin/pull/26222#pullrequestreview-1424459844), [pinheadmz](https://github.com/bitcoin/bitcoin/pull/26222#pullrequestreview-1424673767), [real-or-random](https://github.com/bitcoin/bitcoin/pull/26222#pullrequestreview-1425172202) |\n\nIf your review is incorrectly listed, please react with 👎 to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#27653](https://github.com/bitcoin/bitcoin/pull/27653) (test: add unit test coverage for Python ECDSA implementation by theStack)\n* [#24005](https://github.com/bitcoin/bitcoin/pull/24005) (test: add python implementation of Elligator swift by stratospher)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1264453668",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26222"
    },
    {
      "event": "reviewed",
      "id": 1127567653,
      "node_id": "PRR_kwDOABII585DNVEl",
      "url": null,
      "actor": null,
      "commit_id": "4d6be313362cd648db6b8d5a76ded771d61fdd33",
      "commit_url": null,
      "created_at": null,
      "author_association": "NONE",
      "body": "Reviewed to learn.",
      "user": {
        "login": "amovfx",
        "id": 45839100,
        "node_id": "MDQ6VXNlcjQ1ODM5MTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/45839100?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amovfx",
        "html_url": "https://github.com/amovfx",
        "followers_url": "https://api.github.com/users/amovfx/followers",
        "following_url": "https://api.github.com/users/amovfx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amovfx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amovfx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amovfx/subscriptions",
        "organizations_url": "https://api.github.com/users/amovfx/orgs",
        "repos_url": "https://api.github.com/users/amovfx/repos",
        "events_url": "https://api.github.com/users/amovfx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amovfx/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#pullrequestreview-1127567653",
      "submitted_at": "2022-10-01T21:15:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7530079988,
      "node_id": "HRFPE_lADOABII585TDtOFzwAAAAHA0-b0",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7530079988",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-06T03:32:17Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8027618282,
      "node_id": "HRFPE_lADOABII585TDtOFzwAAAAHee7vq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8027618282",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-13T16:22:12Z"
    },
    {
      "event": "commented",
      "id": 1348977342,
      "node_id": "IC_kwDOABII585QZ8K-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1348977342",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-13T16:22:27Z",
      "updated_at": "2022-12-13T16:22:27Z",
      "author_association": "MEMBER",
      "body": "Rebased.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1348977342",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26222"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8027662399,
      "node_id": "HRFPE_lADOABII585TDtOFzwAAAAHefGg_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8027662399",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-13T16:25:57Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8027771436,
      "node_id": "HRFPE_lADOABII585TDtOFzwAAAAHefhIs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8027771436",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-13T16:35:54Z"
    },
    {
      "event": "labeled",
      "id": 8146472100,
      "node_id": "LE_lADOABII585TDtOFzwAAAAHlkUyk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8146472100",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-03T22:20:23Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 1227403349,
      "node_id": "PRR_kwDOABII585JKLBV",
      "url": null,
      "actor": null,
      "commit_id": "8851fea72aebedb53eb87e4eb07cc55a639c0432",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#pullrequestreview-1227403349",
      "submitted_at": "2023-01-04T19:57:19Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8154295132,
      "node_id": "HRFPE_lADOABII585TDtOFzwAAAAHmCKtc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8154295132",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-04T20:20:27Z"
    },
    {
      "event": "unlabeled",
      "id": 8154948014,
      "node_id": "UNLE_lADOABII585TDtOFzwAAAAHmEqGu",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8154948014",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-01-04T22:10:02Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 1366903430,
      "node_id": "PRR_kwDOABII585ReUqG",
      "url": null,
      "actor": null,
      "commit_id": "5b4477d6296b4aa56f652077c7ae2ab5cc79f369",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#pullrequestreview-1366903430",
      "submitted_at": "2023-03-31T13:12:23Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
    },
    {
      "event": "reviewed",
      "id": 1368140182,
      "node_id": "PRR_kwDOABII585RjCmW",
      "url": null,
      "actor": null,
      "commit_id": "5b4477d6296b4aa56f652077c7ae2ab5cc79f369",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Concept ACK, +1 on increased readability and reusability :100: (found my way here through #24748)\r\n\r\nThe slow-down is unfortunately pretty significant on the two x86_64 machines I tested, `feature_taproot.py` taking almost twice as long compared to master here. Results measured via `time`:\r\n\r\n| Machine / OS  | master      |  pr26222 (rebased) |\r\n|----------|:-------------:|:------:|\r\n| AMD EPYC 7702P (6) / Ubuntu 22.04.1 LTS |  40.496s | 1m16.587s |\r\n| Intel (Broadwell) (2) / OpenBSD 7.2 |    2m57.43s   |   5m45.90s |\r\n\r\nFor the fun of it, I looked a bit into other ways how to compensate the performance loss. Considering that scalar multiplication with G is a frequent operation, precomputing G's doubled-up values (G, 2G, 4G, ..., (2^254)G, (2^255)G) in a lookup table seemed promising, with the goal of needing only ~128 point additions on average (one for each bit set in the scalar), without any extra double operations. Using that, the execution time is still not matching, but at least pretty close to the master branch (45.334s for first, 3m23.48s for second machine), without too much additional code (~25 LOC):\r\n\r\n<details>\r\n<summary>diff for commit \"test: EC: optimize scalar multiplication of G by using lookup table\"</summary>\r\n\r\n```diff\r\nindex 7434ba49e..1ad1bc3e4 100644\r\n--- a/test/functional/test_framework/key.py\r\n+++ b/test/functional/test_framework/key.py\r\n@@ -233,6 +233,8 @@ class GE:\r\n \r\n     def __mul__(self, a):\r\n         \"\"\"Multiply a point with an integer (scalar multiplication).\"\"\"\r\n+        if self == SECP256K1_G:  # optimize generator multiplication using precomputed data\r\n+            return fast_g.mul(a)\r\n         r = None\r\n         for i in range(a.bit_length() - 1, -1, -1):\r\n             if r is not None:\r\n@@ -596,6 +598,31 @@ def sign_schnorr(key, msg, aux=None, flip_p=False, flip_r=False):\r\n     e = int.from_bytes(TaggedHash(\"BIP0340/challenge\", R.to_bytes_xonly() + P.to_bytes_xonly() + msg), 'big') % GE.ORDER\r\n     return R.to_bytes_xonly() + ((k + e * sec) % GE.ORDER).to_bytes(32, 'big')\r\n \r\n+\r\n+class FastG:\r\n+    \"\"\"Speed up scalar multiplication with the generator point G\r\n+       by using a precomputed lookup table with its powers of 2:\r\n+       g_table = [G, G*2, G*4, G*(2^3), G*(2^4), ..., G*(2^255)]\r\n+       The points corresponding to each bit set in the scalar are\r\n+       added up, i.e. on average ~128 point additions take place.\r\n+    \"\"\"\r\n+    def __init__(self):\r\n+        self.g_table = []  # g_table[i] = G * (2^i)\r\n+        g_i = SECP256K1_G\r\n+        for bit in range(256):\r\n+            self.g_table.append(g_i)\r\n+            g_i = g_i.double()\r\n+\r\n+    def mul(self, a):\r\n+        result = None\r\n+        for bit in range(a.bit_length()):\r\n+            if (a & (1 << bit)):\r\n+                result += self.g_table[bit]\r\n+        return result\r\n+\r\n+fast_g = FastG()\r\n+\r\n+\r\n class TestFrameworkKey(unittest.TestCase):\r\n     def test_schnorr(self):\r\n         \"\"\"Test the Python Schnorr implementation.\"\"\"\r\n```\r\n</details>\r\n\r\n(see branch https://github.com/theStack/bitcoin/tree/pr26222_followup_precompute_g_doubles)\r\n\r\nNot 100% sure if we even want optimizations like this in test framwork (also, immediately generating data at module import seems kind of hacky), but it may be worth it in this case? I'm pretty sure there are more efficient ways to pursue this idea (e.g. extending the lookup table for larger chunks than only 1-bit pieces to need even less additions), but probably the extra implementation / code clutter / maintenance effort is not worth it. Any other ideas? Happy to hear shadowy secp256k1 super-magicians' thoughts here :)",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#pullrequestreview-1368140182",
      "submitted_at": "2023-04-02T20:55:49Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
    },
    {
      "event": "labeled",
      "id": 9123521197,
      "node_id": "LE_lADOABII585TDtOFzwAAAAIfzeKt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9123521197",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-28T10:44:43Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9229840525,
      "node_id": "HRFPE_lADOABII585TDtOFzwAAAAImJDCN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9229840525",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-12T07:18:10Z"
    },
    {
      "event": "unlabeled",
      "id": 9229857230,
      "node_id": "UNLE_lADOABII585TDtOFzwAAAAImJHHO",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9229857230",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-12T07:20:04Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9230011895,
      "node_id": "HRFPE_lADOABII585TDtOFzwAAAAImJs33",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9230011895",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-12T07:35:00Z"
    },
    {
      "event": "commented",
      "id": 1545314256,
      "node_id": "IC_kwDOABII585cG5_Q",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1545314256",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-12T07:39:19Z",
      "updated_at": "2023-05-12T07:41:15Z",
      "author_association": "MEMBER",
      "body": "@theStack I've included your commit to add the precomputed G table. The speedup is significant enough that it's worth it, I think.\r\n\r\nYou've indeed discovered one of the techniques that are used for speeding up EC multiplications with precomputed tables. Libsecp256k1 today uses a more advanced version of that idea, where all multiples of the form `i*16^j*G` for all i=0..15, and j=0..63 are precomputed, leaving us with ~63 point additions. An even more advanced approach is discussed in https://github.com/bitcoin-core/secp256k1/pull/1058, if you're interested. All of that is IMO out of scope for the test framework, though.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1545314256",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26222"
    },
    {
      "event": "mentioned",
      "id": 9230047052,
      "node_id": "MEE_lADOABII585TDtOFzwAAAAImJ1dM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9230047052",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-12T07:39:19Z"
    },
    {
      "event": "subscribed",
      "id": 9230047062,
      "node_id": "SE_lADOABII585TDtOFzwAAAAImJ1dW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9230047062",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-12T07:39:19Z"
    },
    {
      "event": "review_requested",
      "id": 9230647321,
      "node_id": "RRE_lADOABII585TDtOFzwAAAAImMIAZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9230647321",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-12T08:48:16Z",
      "requested_reviewer": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "commented",
      "id": 1545399444,
      "node_id": "IC_kwDOABII585cHOyU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1545399444",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-12T08:48:29Z",
      "updated_at": "2023-05-12T08:48:29Z",
      "author_association": "MEMBER",
      "body": "cc @real-or-random ",
      "user": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1545399444",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26222"
    },
    {
      "event": "mentioned",
      "id": 9230649446,
      "node_id": "MEE_lADOABII585TDtOFzwAAAAImMIhm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9230649446",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-12T08:48:30Z"
    },
    {
      "event": "subscribed",
      "id": 9230649459,
      "node_id": "SE_lADOABII585TDtOFzwAAAAImMIhz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9230649459",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-12T08:48:30Z"
    },
    {
      "event": "reviewed",
      "id": 1424459844,
      "node_id": "PRR_kwDOABII585U54hE",
      "url": null,
      "actor": null,
      "commit_id": "28ab6c326a36f79bee5ede4ecca3e2baae760002",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "> To maximize readability...\r\n\r\nConcept ACK on that. At least, non-cryptography abstract algebra background is enough to review the code :)\r\n\r\nPartially reviewed. The `class FE` looks good.",
      "user": {
        "login": "hebasto",
        "id": 32963518,
        "node_id": "MDQ6VXNlcjMyOTYzNTE4",
        "avatar_url": "https://avatars.githubusercontent.com/u/32963518?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/hebasto",
        "html_url": "https://github.com/hebasto",
        "followers_url": "https://api.github.com/users/hebasto/followers",
        "following_url": "https://api.github.com/users/hebasto/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/hebasto/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/hebasto/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/hebasto/subscriptions",
        "organizations_url": "https://api.github.com/users/hebasto/orgs",
        "repos_url": "https://api.github.com/users/hebasto/repos",
        "events_url": "https://api.github.com/users/hebasto/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/hebasto/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#pullrequestreview-1424459844",
      "submitted_at": "2023-05-12T12:56:40Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
    },
    {
      "event": "reviewed",
      "id": 1424673767,
      "node_id": "PRR_kwDOABII585U6svn",
      "url": null,
      "actor": null,
      "commit_id": "28ab6c326a36f79bee5ede4ecca3e2baae760002",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "concept ACK\r\n\r\nDid as much code review as my tiny brain could handle. I agree that this implementation is easy to read and follow. I checked as much as I could against [NIST params](https://www.secg.org/sec2-v2.pdf) and equations from [Guide to Elliptic Curve Cryptography](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.394.3037&rep=rep1&type=pdf)\r\n\r\nComparing run time of `feature_taproot.py` between master and branch, over a few trials with and without RAM disk, the new code only cost me about 5 seconds or about 5% of total runtime.",
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#pullrequestreview-1424673767",
      "submitted_at": "2023-05-12T15:57:36Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
    },
    {
      "event": "commented",
      "id": 1546111610,
      "node_id": "IC_kwDOABII585cJ8p6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1546111610",
      "actor": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-12T18:15:05Z",
      "updated_at": "2023-05-12T18:15:38Z",
      "author_association": "MEMBER",
      "body": "Reads fine to me from my not-even-cryptographer-on-tv level of understanding.\r\n\r\nGoes from 27 to 31 seconds on my machine with the precomputed table, which is very easy to understand. Without the table it hikes up to 53 seconds.",
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1546111610",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26222"
    },
    {
      "event": "reviewed",
      "id": 1425172202,
      "node_id": "PRR_kwDOABII585U8mbq",
      "url": null,
      "actor": null,
      "commit_id": "28ab6c326a36f79bee5ede4ecca3e2baae760002",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Concept ACK on making the code simple \r\n\r\nSince this is something like a reference implementation, I think `GE` should get the infinity handling right.  If you agree that's a good idea, then it's perhaps better to have a more explicit representation for infinity than `None`. ",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#pullrequestreview-1425172202",
      "submitted_at": "2023-05-12T21:24:18Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9237941592,
      "node_id": "HRFPE_lADOABII585TDtOFzwAAAAImn81Y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9237941592",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-13T06:34:54Z"
    },
    {
      "event": "commented",
      "id": 1546544187,
      "node_id": "IC_kwDOABII585cLmQ7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1546544187",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-13T06:35:17Z",
      "updated_at": "2023-05-13T06:35:17Z",
      "author_association": "MEMBER",
      "body": "@real-or-random Makes sense, that simplifies some things too. Done.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1546544187",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26222"
    },
    {
      "event": "mentioned",
      "id": 9237942958,
      "node_id": "MEE_lADOABII585TDtOFzwAAAAImn9Ku",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9237942958",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-13T06:35:17Z"
    },
    {
      "event": "subscribed",
      "id": 9237942963,
      "node_id": "SE_lADOABII585TDtOFzwAAAAImn9Kz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9237942963",
      "actor": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-13T06:35:17Z"
    },
    {
      "event": "reviewed",
      "id": 1425361344,
      "node_id": "PRR_kwDOABII585U9UnA",
      "url": null,
      "actor": null,
      "commit_id": "b415ad49cf10096f9d32a2a88900f56b1d483421",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#pullrequestreview-1425361344",
      "submitted_at": "2023-05-13T08:38:29Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9238444053,
      "node_id": "HRFPE_lADOABII585TDtOFzwAAAAImp3gV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9238444053",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-13T12:04:16Z"
    },
    {
      "event": "commented",
      "id": 1546636677,
      "node_id": "IC_kwDOABII585cL82F",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1546636677",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-13T12:14:57Z",
      "updated_at": "2023-05-13T12:28:07Z",
      "author_association": "MEMBER",
      "body": "I've made a number of changes.\r\n\r\n* (Done earlier) Made the `GE` class represent infinity explicitly.\r\n* The new classes / code are in a new module `test_framework.secp256k1`, which removes the implementation details from `test_framework.key`, and also feels a bit better namespace-wise (`secp256k1.GE` is probably more informative to an unfamiliar reviewer than just `GE`, at least indicating it has something to do with elliptic curve cryptography).\r\n* Dropped a number of unused functions / operators.\r\n* Swapped the order of arguments in scalar multiplication (it's `int * GE` now instead of `GE * int`).\r\n* Renamed `GE.mmul` to just `GE.mul`, as it can be used for both single or multi-multiplication.\r\n* Shortened/simplified the `FE.__init__` method a bit.\r\n* Some simplifications that may worsen performance slightly, but help readability:\r\n  * `GE.__rmul__` is now written in function of `GE.mul`, avoiding duplication of logic.\r\n  * `GE.double` is gone; to perform doubling, simply add a point to itself.\r\n  * `GE.mul` (and thus also `GE.__rmul__`) now reduces the input scalars mod the curve order, which means it can deal with negative inputs or inputs exceeding the order. This makes the ECDSA and Schnorr verification formula closer to its typical mathematical description.\r\n* Added/rewrote a lot of comments.\r\n\r\nI'm now benchmarking `feature_taproot.py` on a test machine as:\r\n* master: ~42s \r\n* this PR (just first commit): ~79s\r\n* this PR (both commits): ~49s",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1546636677",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26222"
    },
    {
      "event": "renamed",
      "id": 9238460758,
      "node_id": "RTE_lADOABII585TDtOFzwAAAAImp7lW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9238460758",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-13T12:15:47Z",
      "rename": {
        "from": "Introduce field element and group element classes to test_framework/key.py",
        "to": "Introduce secp256k1 module with field and group classes to test framework"
      }
    },
    {
      "event": "reviewed",
      "id": 1446591335,
      "node_id": "PRR_kwDOABII585WOTtn",
      "url": null,
      "actor": null,
      "commit_id": "112928c08a18e57f04b63177c578695fa080b3ee",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#pullrequestreview-1446591335",
      "submitted_at": "2023-05-26T19:37:39Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
    },
    {
      "event": "reviewed",
      "id": 1447142151,
      "node_id": "PRR_kwDOABII585WQaMH",
      "url": null,
      "actor": null,
      "commit_id": "112928c08a18e57f04b63177c578695fa080b3ee",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#pullrequestreview-1447142151",
      "submitted_at": "2023-05-27T15:03:42Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
    },
    {
      "event": "reviewed",
      "id": 1452064815,
      "node_id": "PRR_kwDOABII585WjMAv",
      "url": null,
      "actor": null,
      "commit_id": "899066847359a8f16aded60814794fab9ea884e1",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#pullrequestreview-1452064815",
      "submitted_at": "2023-05-31T01:24:32Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
    },
    {
      "event": "reviewed",
      "id": 1453838769,
      "node_id": "PRR_kwDOABII585Wp9Gx",
      "url": null,
      "actor": null,
      "commit_id": "112928c08a18e57f04b63177c578695fa080b3ee",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#pullrequestreview-1453838769",
      "submitted_at": "2023-05-31T18:00:23Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9394064304,
      "node_id": "HRFPE_lADOABII585TDtOFzwAAAAIv7guw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9394064304",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-31T18:43:48Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGVlNmUyODlhNGNlYWFkYWM3NWIyMmMwNTdjM2FmMWU2YTNmNTlhZWM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ee6e289a4ceaadac75b22c057c3af1e6a3f59aec",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/ee6e289a4ceaadac75b22c057c3af1e6a3f59aec",
      "tree": {
        "sha": "f4e6ff7627b397608aa11117c33a0d7a40c74285",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f4e6ff7627b397608aa11117c33a0d7a40c74285"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f08bde7f715cf84ef050c3f6902bc75fb90cedb3",
          "sha": "f08bde7f715cf84ef050c3f6902bc75fb90cedb3",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/f08bde7f715cf84ef050c3f6902bc75fb90cedb3"
        }
      ],
      "message": "test: add secp256k1 module with FE (field element) and GE (group element) classes\n\nThese are primarily designed for ease of understanding, not performance.",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-05-31T18:49:16Z"
      },
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2022-10-01T15:35:28Z"
      },
      "sha": "ee6e289a4ceaadac75b22c057c3af1e6a3f59aec"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDI3NDVhYmYxN2E4NmJhYTMxOWM1NWFkOTZjN2ZlZjhlZWExNDVjNmY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "tree": {
        "sha": "4c11665e44f8fee0aece0735089d766b83d12177",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4c11665e44f8fee0aece0735089d766b83d12177"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ee6e289a4ceaadac75b22c057c3af1e6a3f59aec",
          "sha": "ee6e289a4ceaadac75b22c057c3af1e6a3f59aec",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/ee6e289a4ceaadac75b22c057c3af1e6a3f59aec"
        }
      ],
      "message": "test: EC: optimize scalar multiplication of G by using lookup table\n\nOn my machine, this speeds up the functional test feature_taproot.py by\na factor of >1.66x (runtime decrease from 1m16.587s to 45.334s).\n\nCo-authored-by: Pieter Wuille <pieter@wuille.net>",
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter@wuille.net",
        "date": "2023-05-31T18:49:20Z"
      },
      "author": {
        "name": "Sebastian Falbesoner",
        "email": "sebastian.falbesoner@gmail.com",
        "date": "2023-04-02T19:57:32Z"
      },
      "sha": "2745abf17a86baa319c55ad96c7fef8eea145c6f"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 9394131638,
      "node_id": "HRFPE_lADOABII585TDtOFzwAAAAIv7xK2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9394131638",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-31T18:49:31Z"
    },
    {
      "event": "commented",
      "id": 1570755789,
      "node_id": "IC_kwDOABII585dn9TN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1570755789",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-31T18:55:42Z",
      "updated_at": "2023-05-31T18:55:42Z",
      "author_association": "MEMBER",
      "body": "Addressed review comments. I've also renamed `FE.num` and `FE.den` to `FE._num` and `FE._den` to mark them as private (to the extent that Python allows that). All interactions with these objects should be done through their methods.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#issuecomment-1570755789",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26222"
    },
    {
      "event": "reviewed",
      "id": 1454810878,
      "node_id": "PRR_kwDOABII585Wtqb-",
      "url": null,
      "actor": null,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "",
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#pullrequestreview-1454810878",
      "submitted_at": "2023-06-01T10:33:27Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/985145050",
      "pull_request_review_id": 1127567653,
      "id": 985145050,
      "node_id": "PRRC_kwDOABII5846uB7a",
      "diff_hunk": "@@ -25,258 +25,329 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = a.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        else:\n+            return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        else:\n+            return FE(self.num + self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        else:\n+            return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * modinv(self.den, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 3) / 4.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r == 3 or r == 5)\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        else:\n+            return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to 32-byte big endian encoding.\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte big endian encoding of a field element to an FE.\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n             return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+        return FE(v)\n+\n+    def __str__(self):\n+        return \"0x%064x\" % int(self)\n+\n+class GE:\n+    \"\"\"Objects of this class represent points (group elements) on the secp256k1 curve.\n+\n+    The point at infinity is represented as None.\"\"\"\n+\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x, y):\n+        \"\"\"Initialize a group element with specified x and y coordinates (must be on curve).\"\"\"\n+        fx = FE(x)\n+        fy = FE(y)\n+        assert fy**2 == fx**3 + 7\n+        self.x = fx\n+        self.y = fy\n+\n+    def double(self):\n+        \"\"\"Compute the double of a point.\"\"\"\n+        l = 3 * self.x**2 / (2 * self.y)\n+        x3 = l**2 - 2 * self.x\n+        y3 = l * (self.x - x3) - self.y\n+        return GE(x3, y3)\n+\n+    def __add__(self, a):\n+        \"\"\"Add two points, or a point and infinity, together.\"\"\"\n+        if a is None:\n+            # Adding point at infinity\n+            return self\n+        if self.x != a.x:\n+            # Adding distinct x coordinates\n+            l = (a.y - self.y) / (a.x - self.x)\n+            x3 = l**2 - self.x - a.x\n+            y3 = l * (self.x - x3) - self.y\n+            return GE(x3, y3)\n+        elif self.y == a.y:\n+            # Adding point to itself\n+            return self.double()\n+        else:\n+            # Adding point to its negation\n             return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert(z2 == 1)\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n+\n+    def __radd__(self, a):\n+        \"\"\"Add infinity to a point.\"\"\"\n+        assert a is None\n+        return self\n+\n+    def __sub__(self, a):\n+        \"\"\"Subtract two points, or subtract infinity from a point.\"\"\"\n+        if a is None:\n+            return self\n+        return self + (-a)",
      "path": "test/functional/test_framework/key.py",
      "position": null,
      "original_position": 375,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "4d6be313362cd648db6b8d5a76ded771d61fdd33",
      "in_reply_to_id": null,
      "user": {
        "login": "amovfx",
        "id": 45839100,
        "node_id": "MDQ6VXNlcjQ1ODM5MTAw",
        "avatar_url": "https://avatars.githubusercontent.com/u/45839100?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/amovfx",
        "html_url": "https://github.com/amovfx",
        "followers_url": "https://api.github.com/users/amovfx/followers",
        "following_url": "https://api.github.com/users/amovfx/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/amovfx/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/amovfx/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/amovfx/subscriptions",
        "organizations_url": "https://api.github.com/users/amovfx/orgs",
        "repos_url": "https://api.github.com/users/amovfx/repos",
        "events_url": "https://api.github.com/users/amovfx/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/amovfx/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm curious as to why the return value isnt self - a?\r\nis it because this function calls the previously declared  `__add__ ` and requires a negative input to evaluate properly?\r\nor (-a) is calling the `__mul__`",
      "created_at": "2022-10-01T21:09:48Z",
      "updated_at": "2022-10-01T21:15:13Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r985145050",
      "author_association": "NONE",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/985145050"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": 214,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 226,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/985145867",
      "pull_request_review_id": 1127568198,
      "id": 985145867,
      "node_id": "PRRC_kwDOABII5846uCIL",
      "diff_hunk": "@@ -25,258 +25,329 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = a.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        else:\n+            return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        else:\n+            return FE(self.num + self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        else:\n+            return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * modinv(self.den, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 3) / 4.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r == 3 or r == 5)\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        else:\n+            return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to 32-byte big endian encoding.\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte big endian encoding of a field element to an FE.\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n             return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+        return FE(v)\n+\n+    def __str__(self):\n+        return \"0x%064x\" % int(self)\n+\n+class GE:\n+    \"\"\"Objects of this class represent points (group elements) on the secp256k1 curve.\n+\n+    The point at infinity is represented as None.\"\"\"\n+\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x, y):\n+        \"\"\"Initialize a group element with specified x and y coordinates (must be on curve).\"\"\"\n+        fx = FE(x)\n+        fy = FE(y)\n+        assert fy**2 == fx**3 + 7\n+        self.x = fx\n+        self.y = fy\n+\n+    def double(self):\n+        \"\"\"Compute the double of a point.\"\"\"\n+        l = 3 * self.x**2 / (2 * self.y)\n+        x3 = l**2 - 2 * self.x\n+        y3 = l * (self.x - x3) - self.y\n+        return GE(x3, y3)\n+\n+    def __add__(self, a):\n+        \"\"\"Add two points, or a point and infinity, together.\"\"\"\n+        if a is None:\n+            # Adding point at infinity\n+            return self\n+        if self.x != a.x:\n+            # Adding distinct x coordinates\n+            l = (a.y - self.y) / (a.x - self.x)\n+            x3 = l**2 - self.x - a.x\n+            y3 = l * (self.x - x3) - self.y\n+            return GE(x3, y3)\n+        elif self.y == a.y:\n+            # Adding point to itself\n+            return self.double()\n+        else:\n+            # Adding point to its negation\n             return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert(z2 == 1)\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n+\n+    def __radd__(self, a):\n+        \"\"\"Add infinity to a point.\"\"\"\n+        assert a is None\n+        return self\n+\n+    def __sub__(self, a):\n+        \"\"\"Subtract two points, or subtract infinity from a point.\"\"\"\n+        if a is None:\n+            return self\n+        return self + (-a)",
      "path": "test/functional/test_framework/key.py",
      "position": null,
      "original_position": 375,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "4d6be313362cd648db6b8d5a76ded771d61fdd33",
      "in_reply_to_id": 985145050,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`self - a` would just trigger infinite recursion, as it's equivalent to `self.__sub__(a)`.\r\n\r\nWriting `self + (-a)` on the other hand is `self.__add__(a.__neg__())`.\r\n\r\nThere is no \"negative input\"; these objects represent field elements (integers modulo 2^256 - 2^32 - 977), which have no concept of positive/negative. This function is implementing how to compute `self - a`; we do that by adding `self` to the negation of `a`.",
      "created_at": "2022-10-01T21:18:22Z",
      "updated_at": "2022-10-01T21:47:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r985145867",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/985145867"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": 214,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 226,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1055283752",
      "pull_request_review_id": 1227403349,
      "id": 1055283752,
      "node_id": "PRRC_kwDOABII584-5loo",
      "diff_hunk": "@@ -25,258 +25,346 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = a.num",
      "path": "test/functional/test_framework/key.py",
      "position": null,
      "original_position": 104,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "8851fea72aebedb53eb87e4eb07cc55a639c0432",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "shouldn't this be `b.num`?",
      "created_at": "2022-12-22T09:53:59Z",
      "updated_at": "2023-01-04T19:57:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1055283752",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1055283752"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 44,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1060520793",
      "pull_request_review_id": 1227403349,
      "id": 1060520793,
      "node_id": "PRRC_kwDOABII584_NkNZ",
      "diff_hunk": "@@ -25,258 +25,346 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = a.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * modinv(self.den, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 3) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0",
      "path": "test/functional/test_framework/key.py",
      "position": null,
      "original_position": 192,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "8851fea72aebedb53eb87e4eb07cc55a639c0432",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "i didn't understand how `n = (self.num * self.den) % FE.SIZE`?\r\n(and not `n = int(self) % FE.SIZE`)",
      "created_at": "2023-01-03T12:01:42Z",
      "updated_at": "2023-01-04T19:57:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1060520793",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1060520793"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 132,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1061852160",
      "pull_request_review_id": 1236432569,
      "id": 1061852160,
      "node_id": "PRRC_kwDOABII584_SpQA",
      "diff_hunk": "@@ -25,258 +25,346 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = a.num",
      "path": "test/functional/test_framework/key.py",
      "position": null,
      "original_position": 104,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "8851fea72aebedb53eb87e4eb07cc55a639c0432",
      "in_reply_to_id": 1055283752,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Indeed. Fixed!",
      "created_at": "2023-01-04T20:20:28Z",
      "updated_at": "2023-01-04T20:20:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1061852160",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1061852160"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 44,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1061852938",
      "pull_request_review_id": 1236433777,
      "id": 1061852938,
      "node_id": "PRRC_kwDOABII584_SpcK",
      "diff_hunk": "@@ -25,258 +25,346 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = a.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * modinv(self.den, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 3) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0",
      "path": "test/functional/test_framework/key.py",
      "position": null,
      "original_position": 192,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "8851fea72aebedb53eb87e4eb07cc55a639c0432",
      "in_reply_to_id": 1060520793,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ah!\r\n\r\nThe squareness of `num/den` = `(num*den) / den^2` is the same as that of `num*den`, because they're related by a factor `den^2`, which is always square.\r\n\r\nI've added a comment to clarify.",
      "created_at": "2023-01-04T20:21:40Z",
      "updated_at": "2023-01-04T20:21:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1061852938",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1061852938"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 132,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1154452161",
      "pull_request_review_id": 1366903430,
      "id": 1154452161,
      "node_id": "PRRC_kwDOABII585Ez4rB",
      "diff_hunk": "@@ -25,258 +25,348 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = b.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * modinv(self.den, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 3) / 4.",
      "path": "test/functional/test_framework/key.py",
      "position": null,
      "original_position": 173,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "5b4477d6296b4aa56f652077c7ae2ab5cc79f369",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That's a typo I guess?\r\n```suggestion\r\n        raising the argument to the power (p + 1) / 4.\r\n```",
      "created_at": "2023-03-31T13:04:54Z",
      "updated_at": "2023-03-31T13:12:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1154452161",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1154452161"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192016465",
      "pull_request_review_id": 1423941466,
      "id": 1192016465,
      "node_id": "PRRC_kwDOABII585HDLpR",
      "diff_hunk": "@@ -25,258 +25,348 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = modinv(z1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = b.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * modinv(self.den, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 3) / 4.",
      "path": "test/functional/test_framework/key.py",
      "position": null,
      "original_position": 173,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "5b4477d6296b4aa56f652077c7ae2ab5cc79f369",
      "in_reply_to_id": 1154452161,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nice catch, fixed.",
      "created_at": "2023-05-12T07:35:03Z",
      "updated_at": "2023-05-12T07:35:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192016465",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192016465"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 111,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192479969",
      "pull_request_review_id": 1424673767,
      "id": 1192479969,
      "node_id": "PRRC_kwDOABII585HE8zh",
      "diff_hunk": "@@ -23,258 +23,350 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = pow(z1, -1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = b.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to 32-byte big endian encoding.\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte big endian encoding of a field element to an FE.\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n             return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert z2 == 1\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+class GE:\n+    \"\"\"Objects of this class represent points (group elements) on the secp256k1 curve.\n+\n+    The point at infinity is represented as None.\"\"\"\n+\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x, y):\n+        \"\"\"Initialize a group element with specified x and y coordinates (must be on curve).\"\"\"\n+        fx = FE(x)\n+        fy = FE(y)\n+        assert fy**2 == fx**3 + 7\n+        self.x = fx\n+        self.y = fy\n+\n+    def double(self):\n+        \"\"\"Compute the double of a point.\"\"\"\n+        l = 3 * self.x**2 / (2 * self.y)\n+        x3 = l**2 - 2 * self.x\n+        y3 = l * (self.x - x3) - self.y\n+        return GE(x3, y3)\n+\n+    def __add__(self, a):\n+        \"\"\"Add two points, or a point and infinity, together.\"\"\"\n+        if a is None:\n+            # Adding point at infinity\n+            return self\n+        if self.x != a.x:\n+            # Adding distinct x coordinates\n+            l = (a.y - self.y) / (a.x - self.x)\n+            x3 = l**2 - self.x - a.x\n+            y3 = l * (self.x - x3) - self.y\n+            return GE(x3, y3)\n+        if self.y == a.y:\n+            # Adding point to itself\n+            return self.double()\n+        # Adding point to its negation\n+        return None\n+\n+    def __radd__(self, a):\n+        \"\"\"Add infinity to a point.\"\"\"\n+        assert a is None\n+        return self\n+\n+    def __sub__(self, a):\n+        \"\"\"Subtract two points, or subtract infinity from a point.\"\"\"\n+        if a is None:\n+            return self\n+        return self + (-a)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Subtract a point from infinity.\"\"\"\n+        assert a is None\n+        return -a\n+\n+    def __mul__(self, a):\n+        \"\"\"Multiply a point with an integer (scalar multiplication).\"\"\"\n+        if self == SECP256K1_G:  # optimize generator multiplication using precomputed data\n+            return fast_g.mul(a)\n+        r = None\n+        for i in range(a.bit_length() - 1, -1, -1):\n+            if r is not None:\n+                r = r.double()\n+            if (a >> i) & 1:\n+                r += self\n+        return r\n+\n+    def __rmul__(self, a):\n+        \"\"\"Multiply an integer with a point (scalar multiplication).\"\"\"\n+        return self * a\n+\n+    @staticmethod\n+    def mmul(*ps):\n+        \"\"\"Compute a (multi) point multiplication.\n+\n+        mmul((p1, a1), (p2, a2), (p3, a3)) is identical to p1*a1 + p2*a2 + p3*a3,\n+        but more efficient.\"\"\"\n+        r = None\n         for i in range(255, -1, -1):\n-            r = self.double(r)\n+            if r is not None:\n+                r = r.double()\n             for (p, n) in ps:\n                 if ((n >> i) & 1):\n-                    r = self.add(r, p)\n+                    r += p\n         return r\n \n-SECP256K1_FIELD_SIZE = 2**256 - 2**32 - 977\n-SECP256K1 = EllipticCurve(SECP256K1_FIELD_SIZE, 0, 7)\n-SECP256K1_G = (0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798, 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8, 1)\n-SECP256K1_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n-SECP256K1_ORDER_HALF = SECP256K1_ORDER // 2\n+    def __neg__(self):\n+        \"\"\"Compute the negation of a point.\"\"\"\n+        return GE(self.x, -self.y)\n+\n+    def to_bytes_compressed(self):\n+        \"\"\"Convert a point to 33-byte compressed encoding.\"\"\"\n+        return bytes([3 - self.y.is_even()]) + self.x.to_bytes()\n+\n+    def to_bytes_uncompressed(self):\n+        \"\"\"Convert a point to 65-byte uncompressed encoding.\"\"\"\n+        return b'\\x04' + self.x.to_bytes() + self.y.to_bytes()\n+\n+    def to_bytes_xonly(self):\n+        \"\"\"Convert (the X coordinate of) a point to 32-byte xonly encoding.\"\"\"\n+        return self.x.to_bytes()\n+\n+    @staticmethod\n+    def lift_x(x):\n+        \"\"\"Take an FE, and return the point with that as X coordinate, and even Y.\"\"\"\n+        y = (FE(x)**3 + 7).sqrt()\n+        if y is None:\n+            return None\n+        if not y.is_even():\n+            y = -y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a compressed or uncompressed encoding to a point.\"\"\"\n+        if len(b) == 33:\n+            if b[0] != 2 and b[0] != 3:\n+                return None\n+            x = FE.from_bytes(b[1:])\n+            if x is None:\n+                return None\n+            r = GE.lift_x(x)\n+            if r is None:\n+                return None\n+            if b[0] == 3:\n+                r = -r\n+            return r\n+        if len(b) == 65:\n+            if b[0] != 4:\n+                return None\n+            x = FE.from_bytes(b[1:33])\n+            y = FE.from_bytes(b[33:])\n+            if y**2 != x**3 + 7:\n+                return None\n+            return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes_xonly(b):\n+        \"\"\"Convert a point given in xonly encoding to a point.\"\"\"\n+        assert len(b) == 32\n+        x = FE.from_bytes(b)\n+        if x is None:\n+            return None\n+        return GE.lift_x(x)\n+\n+    @staticmethod\n+    def is_valid_x(x):\n+        \"\"\"Determine whether the provided field element is a valid X coordinate.\"\"\"\n+        return (FE(x)**3 + 7).is_square()\n+\n+    def __str__(self):\n+        \"\"\"Convert this group element to a string.\"\"\"\n+        return f\"({self.x},{self.y})\"",
      "path": "test/functional/test_framework/key.py",
      "position": null,
      "original_position": 496,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "28ab6c326a36f79bee5ede4ecca3e2baae760002",
      "in_reply_to_id": null,
      "user": {
        "login": "pinheadmz",
        "id": 2084648,
        "node_id": "MDQ6VXNlcjIwODQ2NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2084648?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/pinheadmz",
        "html_url": "https://github.com/pinheadmz",
        "followers_url": "https://api.github.com/users/pinheadmz/followers",
        "following_url": "https://api.github.com/users/pinheadmz/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/pinheadmz/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/pinheadmz/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/pinheadmz/subscriptions",
        "organizations_url": "https://api.github.com/users/pinheadmz/orgs",
        "repos_url": "https://api.github.com/users/pinheadmz/repos",
        "events_url": "https://api.github.com/users/pinheadmz/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/pinheadmz/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not using hex here?",
      "created_at": "2023-05-12T14:53:38Z",
      "updated_at": "2023-05-12T15:57:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192479969",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192479969"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 328,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192653577",
      "pull_request_review_id": 1424936684,
      "id": 1192653577,
      "node_id": "PRRC_kwDOABII585HFnMJ",
      "diff_hunk": "@@ -23,258 +23,350 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = pow(z1, -1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = b.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to 32-byte big endian encoding.\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte big endian encoding of a field element to an FE.\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n             return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert z2 == 1\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+class GE:\n+    \"\"\"Objects of this class represent points (group elements) on the secp256k1 curve.\n+\n+    The point at infinity is represented as None.\"\"\"\n+\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x, y):\n+        \"\"\"Initialize a group element with specified x and y coordinates (must be on curve).\"\"\"\n+        fx = FE(x)\n+        fy = FE(y)\n+        assert fy**2 == fx**3 + 7\n+        self.x = fx\n+        self.y = fy\n+\n+    def double(self):\n+        \"\"\"Compute the double of a point.\"\"\"\n+        l = 3 * self.x**2 / (2 * self.y)\n+        x3 = l**2 - 2 * self.x\n+        y3 = l * (self.x - x3) - self.y\n+        return GE(x3, y3)\n+\n+    def __add__(self, a):\n+        \"\"\"Add two points, or a point and infinity, together.\"\"\"\n+        if a is None:\n+            # Adding point at infinity\n+            return self\n+        if self.x != a.x:\n+            # Adding distinct x coordinates\n+            l = (a.y - self.y) / (a.x - self.x)\n+            x3 = l**2 - self.x - a.x\n+            y3 = l * (self.x - x3) - self.y\n+            return GE(x3, y3)\n+        if self.y == a.y:\n+            # Adding point to itself\n+            return self.double()\n+        # Adding point to its negation\n+        return None\n+\n+    def __radd__(self, a):\n+        \"\"\"Add infinity to a point.\"\"\"\n+        assert a is None\n+        return self\n+\n+    def __sub__(self, a):\n+        \"\"\"Subtract two points, or subtract infinity from a point.\"\"\"\n+        if a is None:\n+            return self\n+        return self + (-a)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Subtract a point from infinity.\"\"\"\n+        assert a is None\n+        return -a\n+\n+    def __mul__(self, a):\n+        \"\"\"Multiply a point with an integer (scalar multiplication).\"\"\"\n+        if self == SECP256K1_G:  # optimize generator multiplication using precomputed data\n+            return fast_g.mul(a)\n+        r = None\n+        for i in range(a.bit_length() - 1, -1, -1):\n+            if r is not None:\n+                r = r.double()\n+            if (a >> i) & 1:\n+                r += self\n+        return r\n+\n+    def __rmul__(self, a):\n+        \"\"\"Multiply an integer with a point (scalar multiplication).\"\"\"\n+        return self * a\n+\n+    @staticmethod\n+    def mmul(*ps):\n+        \"\"\"Compute a (multi) point multiplication.\n+\n+        mmul((p1, a1), (p2, a2), (p3, a3)) is identical to p1*a1 + p2*a2 + p3*a3,\n+        but more efficient.\"\"\"\n+        r = None\n         for i in range(255, -1, -1):\n-            r = self.double(r)\n+            if r is not None:\n+                r = r.double()\n             for (p, n) in ps:\n                 if ((n >> i) & 1):\n-                    r = self.add(r, p)\n+                    r += p\n         return r\n \n-SECP256K1_FIELD_SIZE = 2**256 - 2**32 - 977\n-SECP256K1 = EllipticCurve(SECP256K1_FIELD_SIZE, 0, 7)\n-SECP256K1_G = (0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798, 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8, 1)\n-SECP256K1_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n-SECP256K1_ORDER_HALF = SECP256K1_ORDER // 2\n+    def __neg__(self):\n+        \"\"\"Compute the negation of a point.\"\"\"\n+        return GE(self.x, -self.y)\n+\n+    def to_bytes_compressed(self):\n+        \"\"\"Convert a point to 33-byte compressed encoding.\"\"\"\n+        return bytes([3 - self.y.is_even()]) + self.x.to_bytes()\n+\n+    def to_bytes_uncompressed(self):\n+        \"\"\"Convert a point to 65-byte uncompressed encoding.\"\"\"\n+        return b'\\x04' + self.x.to_bytes() + self.y.to_bytes()\n+\n+    def to_bytes_xonly(self):\n+        \"\"\"Convert (the X coordinate of) a point to 32-byte xonly encoding.\"\"\"\n+        return self.x.to_bytes()\n+\n+    @staticmethod\n+    def lift_x(x):\n+        \"\"\"Take an FE, and return the point with that as X coordinate, and even Y.\"\"\"\n+        y = (FE(x)**3 + 7).sqrt()\n+        if y is None:\n+            return None\n+        if not y.is_even():\n+            y = -y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a compressed or uncompressed encoding to a point.\"\"\"\n+        if len(b) == 33:\n+            if b[0] != 2 and b[0] != 3:\n+                return None\n+            x = FE.from_bytes(b[1:])\n+            if x is None:\n+                return None\n+            r = GE.lift_x(x)\n+            if r is None:\n+                return None\n+            if b[0] == 3:\n+                r = -r\n+            return r\n+        if len(b) == 65:\n+            if b[0] != 4:\n+                return None\n+            x = FE.from_bytes(b[1:33])\n+            y = FE.from_bytes(b[33:])\n+            if y**2 != x**3 + 7:\n+                return None\n+            return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes_xonly(b):\n+        \"\"\"Convert a point given in xonly encoding to a point.\"\"\"\n+        assert len(b) == 32\n+        x = FE.from_bytes(b)\n+        if x is None:\n+            return None\n+        return GE.lift_x(x)\n+\n+    @staticmethod\n+    def is_valid_x(x):\n+        \"\"\"Determine whether the provided field element is a valid X coordinate.\"\"\"\n+        return (FE(x)**3 + 7).is_square()\n+\n+    def __str__(self):\n+        \"\"\"Convert this group element to a string.\"\"\"\n+        return f\"({self.x},{self.y})\"",
      "path": "test/functional/test_framework/key.py",
      "position": null,
      "original_position": 496,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "28ab6c326a36f79bee5ede4ecca3e2baae760002",
      "in_reply_to_id": 1192479969,
      "user": {
        "login": "instagibbs",
        "id": 5767891,
        "node_id": "MDQ6VXNlcjU3Njc4OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5767891?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/instagibbs",
        "html_url": "https://github.com/instagibbs",
        "followers_url": "https://api.github.com/users/instagibbs/followers",
        "following_url": "https://api.github.com/users/instagibbs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/instagibbs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/instagibbs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/instagibbs/subscriptions",
        "organizations_url": "https://api.github.com/users/instagibbs/orgs",
        "repos_url": "https://api.github.com/users/instagibbs/repos",
        "events_url": "https://api.github.com/users/instagibbs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/instagibbs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "it's defined by `FE` as hex, so should be fine?",
      "created_at": "2023-05-12T17:53:31Z",
      "updated_at": "2023-05-12T17:53:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192653577",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192653577"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 328,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192949389",
      "pull_request_review_id": 1425361344,
      "id": 1192949389,
      "node_id": "PRRC_kwDOABII585HGvaN",
      "diff_hunk": "@@ -23,258 +23,349 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = pow(z1, -1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = b.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to 32-byte big endian encoding.\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte big endian encoding of a field element to an FE.\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n             return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert z2 == 1\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+class GE:\n+    \"\"\"Objects of this class represent points (group elements) on the secp256k1 curve.\n+\n+    The point at infinity is represented as None.\"\"\"",
      "path": "test/functional/test_framework/key.py",
      "position": null,
      "original_position": 339,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "b415ad49cf10096f9d32a2a88900f56b1d483421",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "outdated comment",
      "created_at": "2023-05-13T08:34:57Z",
      "updated_at": "2023-05-13T08:38:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192949389",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192949389"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 179,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192949775",
      "pull_request_review_id": 1425361344,
      "id": 1192949775,
      "node_id": "PRRC_kwDOABII585HGvgP",
      "diff_hunk": "@@ -23,258 +23,349 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = pow(z1, -1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = b.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to 32-byte big endian encoding.\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte big endian encoding of a field element to an FE.\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n             return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert z2 == 1\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+class GE:\n+    \"\"\"Objects of this class represent points (group elements) on the secp256k1 curve.\n+\n+    The point at infinity is represented as None.\"\"\"\n+\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x=None, y=None):\n+        \"\"\"Initialize a group element with specified x and y coordinates, or infinity.\"\"\"\n+        if x is None:\n+            assert y is None\n+            self.infinity = True\n+        else:\n+            fx = FE(x)\n+            fy = FE(y)\n+            assert fy**2 == fx**3 + 7\n+            self.infinity = False\n+            self.x = fx\n+            self.y = fy\n+\n+    def double(self):\n+        \"\"\"Compute the double of a point.\"\"\"\n+        if self.infinity:\n+            return self\n+        l = 3 * self.x**2 / (2 * self.y)\n+        x3 = l**2 - 2 * self.x\n+        y3 = l * (self.x - x3) - self.y\n+        return GE(x3, y3)\n+\n+    def __add__(self, a):\n+        \"\"\"Add two points, or a point and infinity, together.\"\"\"",
      "path": "test/functional/test_framework/key.py",
      "position": null,
      "original_position": 367,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "b415ad49cf10096f9d32a2a88900f56b1d483421",
      "in_reply_to_id": null,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This one too. I suggest iterating over the all doc comments, also to make \"group element\" vs \"point\" consistent. (`__repr__` uses group element.)",
      "created_at": "2023-05-13T08:38:27Z",
      "updated_at": "2023-05-13T08:38:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192949775",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192949775"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 207,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192972870",
      "pull_request_review_id": 1425384774,
      "id": 1192972870,
      "node_id": "PRRC_kwDOABII585HG1JG",
      "diff_hunk": "@@ -23,258 +23,349 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = pow(z1, -1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = b.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to 32-byte big endian encoding.\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte big endian encoding of a field element to an FE.\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n             return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert z2 == 1\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+class GE:\n+    \"\"\"Objects of this class represent points (group elements) on the secp256k1 curve.\n+\n+    The point at infinity is represented as None.\"\"\"",
      "path": "test/functional/test_framework/key.py",
      "position": null,
      "original_position": 339,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "b415ad49cf10096f9d32a2a88900f56b1d483421",
      "in_reply_to_id": 1192949389,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-05-13T12:05:04Z",
      "updated_at": "2023-05-13T12:05:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192972870",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192972870"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 179,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192972961",
      "pull_request_review_id": 1425384904,
      "id": 1192972961,
      "node_id": "PRRC_kwDOABII585HG1Kh",
      "diff_hunk": "@@ -23,258 +23,349 @@ def TaggedHash(tag, data):\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n     \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = pow(z1, -1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n+\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize an FE as a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(b, FE):\n+            if isinstance(a, FE):\n+                self.num = (a.num * b.den) % FE.SIZE\n+                self.den = (a.den * b.num) % FE.SIZE\n+            else:\n+                self.num = (a * b.den) % FE.SIZE\n+                self.den = b.num\n+        else:\n+            b = b % FE.SIZE\n+            assert b != 0\n+            if isinstance(a, FE):\n+                self.num = a.num\n+                self.den = (a.den * b) % FE.SIZE\n+            else:\n+                self.num = a % FE.SIZE\n+                self.den = b\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __rsub__(self, a):\n+        \"\"\"Compute the difference between an integer and a field element.\"\"\"\n+        return FE(self.den * a - self.num, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __rtruediv__(self, a):\n+        \"\"\"Compute the ratio of an integer and a field element.\"\"\"\n+        return FE(a, self)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to a (positive) integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element.\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to 32-byte big endian encoding.\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte big endian encoding of a field element to an FE.\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n             return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert z2 == 1\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+class GE:\n+    \"\"\"Objects of this class represent points (group elements) on the secp256k1 curve.\n+\n+    The point at infinity is represented as None.\"\"\"\n+\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x=None, y=None):\n+        \"\"\"Initialize a group element with specified x and y coordinates, or infinity.\"\"\"\n+        if x is None:\n+            assert y is None\n+            self.infinity = True\n+        else:\n+            fx = FE(x)\n+            fy = FE(y)\n+            assert fy**2 == fx**3 + 7\n+            self.infinity = False\n+            self.x = fx\n+            self.y = fy\n+\n+    def double(self):\n+        \"\"\"Compute the double of a point.\"\"\"\n+        if self.infinity:\n+            return self\n+        l = 3 * self.x**2 / (2 * self.y)\n+        x3 = l**2 - 2 * self.x\n+        y3 = l * (self.x - x3) - self.y\n+        return GE(x3, y3)\n+\n+    def __add__(self, a):\n+        \"\"\"Add two points, or a point and infinity, together.\"\"\"",
      "path": "test/functional/test_framework/key.py",
      "position": null,
      "original_position": 367,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "b415ad49cf10096f9d32a2a88900f56b1d483421",
      "in_reply_to_id": 1192949775,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Done.",
      "created_at": "2023-05-13T12:05:39Z",
      "updated_at": "2023-05-13T12:05:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1192972961",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1192972961"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 207,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207054125",
      "pull_request_review_id": 1446591335,
      "id": 1207054125,
      "node_id": "PRRC_kwDOABII585H8i8t",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element if it exists (None otherwise).\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to a 32-byte array (big endian encoding).\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte array to a field element (big endian encoding).\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n+            return None\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a 64 character hex string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+\n+class GE:\n+    \"\"\"Objects of this class represent secp256k1 group elements (curve points or infinity)\n+\n+    Normal points on the curve have fields:\n+    * x: the x coordinate (a field element)\n+    * y: the y coordinate (a field element, satisfying y^2 = x^3 + 7)\n+    * infinity: False\n+\n+    The point at infinity has field:\n+    * infinity: True\n+    \"\"\"\n+\n+    # Order of the group (number of points on the curve, plus 1 for infinity)\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+\n+    # Number of valid distinct x coordinates on the curve.\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x=None, y=None):\n+        \"\"\"Initialize a group element with specified x and y coordinates, or infinity.\"\"\"\n+        if x is None:\n+            # Initialize as infinity.\n+            assert y is None\n+            self.infinity = True\n+        else:\n+            # Initialize as point on the curve (and check that it is).\n+            fx = FE(x)\n+            fy = FE(y)\n+            assert fy**2 == fx**3 + 7\n+            self.infinity = False\n+            self.x = fx\n+            self.y = fy\n+\n+    def __add__(self, a):\n+        \"\"\"Add two group elements together.\"\"\"\n+        # Deal with infinity: a + infinity == infinity + a == a.\n+        if self.infinity:\n+            return a\n+        if a.infinity:\n+            return self\n+        if self.x == a.x:\n+            if self.y != a.y:\n+                # A point added to its own negation is infinity.\n+                assert self.y + a.y == 0\n+                return GE()\n+            else:\n+                # For identical inputs, use the tangent (doubling formula).\n+                lam = (3 * self.x**2) / (2 * self.y)\n+        else:\n+            # For distinct inputs, use the line through both points (adding formula).\n+            lam = (self.y - a.y) / (self.x - a.x)\n+        # Determine point opposite to the intersection of that line with the curve.\n+        x = lam**2 - (self.x + a.x)\n+        y = lam * (self.x - x) - self.y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def mul(*aps):\n+        \"\"\"Compute a (batch) scalar group element multiplication.\n+\n+        GE.mul((a1, p1), (a2, p2), (a3, p3)) is identical to a1*p1 + a2*p2 + a3*p3,\n+        but more efficient.\"\"\"\n+        # Reduce all the scalars modulo order first (so we can deal with negatives etc).\n+        naps = [(a % GE.ORDER, p) for a, p in aps]\n+        # Start with point at infinity.\n+        r = GE()\n+        # Iterate over all bit positions, from high to low.\n+        for i in range(255, -1, -1):\n+            # Double what we have so far.\n+            r = r + r\n+            # Add then add the points for which the corresponding scalar bit is set.\n+            for (a, p) in naps:\n+                if (a >> i) & 1:\n+                    r += p\n+        return r\n+\n+    def __rmul__(self, a):\n+        \"\"\"Multiply an integer with a group element.\"\"\"\n+        return GE.mul((a, self))\n+\n+    def __neg__(self):\n+        \"\"\"Compute the negation of a group element.\"\"\"\n+        if self.infinity:\n+            return self\n+        return GE(self.x, -self.y)\n+\n+    def to_bytes_compressed(self):\n+        \"\"\"Convert a non-infinite group element to 33-byte compressed encoding.\"\"\"\n+        assert not self.infinity\n+        return bytes([3 - self.y.is_even()]) + self.x.to_bytes()\n+\n+    def to_bytes_uncompressed(self):\n+        \"\"\"Convert a non-infinite group element to 65-byte uncompressed encoding.\"\"\"\n+        assert not self.infinity\n+        return b'\\x04' + self.x.to_bytes() + self.y.to_bytes()\n+\n+    def to_bytes_xonly(self):\n+        \"\"\"Convert (the x coordinate of) a non-infinite group element to 32-byte xonly encoding.\"\"\"\n+        assert not self.infinity\n+        return self.x.to_bytes()\n+\n+    @staticmethod\n+    def lift_x(x):\n+        \"\"\"Return group element with specified field element as x coordinate (and even y).\"\"\"\n+        y = (FE(x)**3 + 7).sqrt()\n+        if y is None:\n+            return None\n+        if not y.is_even():\n+            y = -y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a compressed or uncompressed encoding to a group element.\"\"\"\n+        if len(b) == 33:\n+            if b[0] != 2 and b[0] != 3:\n+                return None\n+            x = FE.from_bytes(b[1:])\n+            if x is None:\n+                return None\n+            r = GE.lift_x(x)\n+            if r is None:\n+                return None\n+            if b[0] == 3:\n+                r = -r\n+            return r\n+        if len(b) == 65:\n+            if b[0] != 4:\n+                return None\n+            x = FE.from_bytes(b[1:33])\n+            y = FE.from_bytes(b[33:])\n+            if y**2 != x**3 + 7:\n+                return None\n+            return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes_xonly(b):\n+        \"\"\"Convert a point given in xonly encoding to a group element.\"\"\"\n+        assert len(b) == 32\n+        x = FE.from_bytes(b)\n+        if x is None:\n+            return None\n+        return GE.lift_x(x)\n+\n+    @staticmethod\n+    def is_valid_x(x):\n+        \"\"\"Determine whether the provided field element is a valid X coordinate.\"\"\"\n+        return (FE(x)**3 + 7).is_square()\n+\n+    def __str__(self):\n+        \"\"\"Convert this group element to a string.\"\"\"\n+        if self.infinite:",
      "path": "test/functional/test_framework/secp256k1.py",
      "position": null,
      "original_position": 310,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "899066847359a8f16aded60814794fab9ea884e1",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "8990668: s/infinite/infinity",
      "created_at": "2023-05-26T16:39:12Z",
      "updated_at": "2023-05-26T19:37:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207054125",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207054125"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 310,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207054357",
      "pull_request_review_id": 1446591335,
      "id": 1207054357,
      "node_id": "PRRC_kwDOABII585H8jAV",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element if it exists (None otherwise).\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to a 32-byte array (big endian encoding).\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte array to a field element (big endian encoding).\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n+            return None\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a 64 character hex string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+\n+class GE:\n+    \"\"\"Objects of this class represent secp256k1 group elements (curve points or infinity)\n+\n+    Normal points on the curve have fields:\n+    * x: the x coordinate (a field element)\n+    * y: the y coordinate (a field element, satisfying y^2 = x^3 + 7)\n+    * infinity: False\n+\n+    The point at infinity has field:\n+    * infinity: True\n+    \"\"\"\n+\n+    # Order of the group (number of points on the curve, plus 1 for infinity)\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+\n+    # Number of valid distinct x coordinates on the curve.\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x=None, y=None):\n+        \"\"\"Initialize a group element with specified x and y coordinates, or infinity.\"\"\"\n+        if x is None:\n+            # Initialize as infinity.\n+            assert y is None\n+            self.infinity = True\n+        else:\n+            # Initialize as point on the curve (and check that it is).\n+            fx = FE(x)\n+            fy = FE(y)\n+            assert fy**2 == fx**3 + 7\n+            self.infinity = False\n+            self.x = fx\n+            self.y = fy\n+\n+    def __add__(self, a):\n+        \"\"\"Add two group elements together.\"\"\"\n+        # Deal with infinity: a + infinity == infinity + a == a.\n+        if self.infinity:\n+            return a\n+        if a.infinity:\n+            return self\n+        if self.x == a.x:\n+            if self.y != a.y:\n+                # A point added to its own negation is infinity.\n+                assert self.y + a.y == 0\n+                return GE()\n+            else:\n+                # For identical inputs, use the tangent (doubling formula).\n+                lam = (3 * self.x**2) / (2 * self.y)\n+        else:\n+            # For distinct inputs, use the line through both points (adding formula).\n+            lam = (self.y - a.y) / (self.x - a.x)\n+        # Determine point opposite to the intersection of that line with the curve.\n+        x = lam**2 - (self.x + a.x)\n+        y = lam * (self.x - x) - self.y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def mul(*aps):\n+        \"\"\"Compute a (batch) scalar group element multiplication.\n+\n+        GE.mul((a1, p1), (a2, p2), (a3, p3)) is identical to a1*p1 + a2*p2 + a3*p3,\n+        but more efficient.\"\"\"\n+        # Reduce all the scalars modulo order first (so we can deal with negatives etc).\n+        naps = [(a % GE.ORDER, p) for a, p in aps]\n+        # Start with point at infinity.\n+        r = GE()\n+        # Iterate over all bit positions, from high to low.\n+        for i in range(255, -1, -1):\n+            # Double what we have so far.\n+            r = r + r\n+            # Add then add the points for which the corresponding scalar bit is set.\n+            for (a, p) in naps:\n+                if (a >> i) & 1:\n+                    r += p\n+        return r\n+\n+    def __rmul__(self, a):\n+        \"\"\"Multiply an integer with a group element.\"\"\"\n+        return GE.mul((a, self))\n+\n+    def __neg__(self):\n+        \"\"\"Compute the negation of a group element.\"\"\"\n+        if self.infinity:\n+            return self\n+        return GE(self.x, -self.y)\n+\n+    def to_bytes_compressed(self):\n+        \"\"\"Convert a non-infinite group element to 33-byte compressed encoding.\"\"\"\n+        assert not self.infinity\n+        return bytes([3 - self.y.is_even()]) + self.x.to_bytes()\n+\n+    def to_bytes_uncompressed(self):\n+        \"\"\"Convert a non-infinite group element to 65-byte uncompressed encoding.\"\"\"\n+        assert not self.infinity\n+        return b'\\x04' + self.x.to_bytes() + self.y.to_bytes()\n+\n+    def to_bytes_xonly(self):\n+        \"\"\"Convert (the x coordinate of) a non-infinite group element to 32-byte xonly encoding.\"\"\"\n+        assert not self.infinity\n+        return self.x.to_bytes()\n+\n+    @staticmethod\n+    def lift_x(x):\n+        \"\"\"Return group element with specified field element as x coordinate (and even y).\"\"\"\n+        y = (FE(x)**3 + 7).sqrt()\n+        if y is None:\n+            return None\n+        if not y.is_even():\n+            y = -y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a compressed or uncompressed encoding to a group element.\"\"\"\n+        if len(b) == 33:\n+            if b[0] != 2 and b[0] != 3:\n+                return None\n+            x = FE.from_bytes(b[1:])\n+            if x is None:\n+                return None\n+            r = GE.lift_x(x)\n+            if r is None:\n+                return None\n+            if b[0] == 3:\n+                r = -r\n+            return r\n+        if len(b) == 65:\n+            if b[0] != 4:\n+                return None\n+            x = FE.from_bytes(b[1:33])\n+            y = FE.from_bytes(b[33:])\n+            if y**2 != x**3 + 7:\n+                return None\n+            return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes_xonly(b):\n+        \"\"\"Convert a point given in xonly encoding to a group element.\"\"\"\n+        assert len(b) == 32\n+        x = FE.from_bytes(b)\n+        if x is None:\n+            return None\n+        return GE.lift_x(x)\n+\n+    @staticmethod\n+    def is_valid_x(x):\n+        \"\"\"Determine whether the provided field element is a valid X coordinate.\"\"\"\n+        return (FE(x)**3 + 7).is_square()\n+\n+    def __str__(self):\n+        \"\"\"Convert this group element to a string.\"\"\"\n+        if self.infinite:\n+            return \"(inf)\"\n+        return f\"({self.x},{self.y})\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation for this group element.\"\"\"\n+        if self.infinite:",
      "path": "test/functional/test_framework/secp256k1.py",
      "position": null,
      "original_position": 316,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "899066847359a8f16aded60814794fab9ea884e1",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "8990668: s/infinite/infinity\r\nmaybe make infinity representation in str and repr consistent too.",
      "created_at": "2023-05-26T16:39:22Z",
      "updated_at": "2023-05-26T19:37:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207054357",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207054357"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 316,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207066672",
      "pull_request_review_id": 1446591335,
      "id": 1207066672,
      "node_id": "PRRC_kwDOABII585H8mAw",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"",
      "path": "test/functional/test_framework/secp256k1.py",
      "position": 90,
      "original_position": 82,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "899066847359a8f16aded60814794fab9ea884e1",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "8990668: isn't the result updated and not cached here?",
      "created_at": "2023-05-26T16:48:51Z",
      "updated_at": "2023-05-26T19:37:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207066672",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207066672"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 90,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207067694",
      "pull_request_review_id": 1446591335,
      "id": 1207067694,
      "node_id": "PRRC_kwDOABII585H8mQu",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element if it exists (None otherwise).\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to a 32-byte array (big endian encoding).\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte array to a field element (big endian encoding).\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n+            return None",
      "path": "test/functional/test_framework/secp256k1.py",
      "position": 139,
      "original_position": 147,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "899066847359a8f16aded60814794fab9ea884e1",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "89906684: any particular reason why `v >= FE.SIZE` isn't supported? (have only thought about `ellswift_decode` [scenario](https://github.com/bitcoin/bips/blob/master/bip-0324/ellswift_decode_test_vectors.csv#L77) where v could be greater than `FE.SIZE`)",
      "created_at": "2023-05-26T16:49:47Z",
      "updated_at": "2023-05-26T19:37:39Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207067694",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207067694"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 139,
      "original_line": 139,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207264222",
      "pull_request_review_id": 1446854207,
      "id": 1207264222,
      "node_id": "PRRC_kwDOABII585H9WPe",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"",
      "path": "test/functional/test_framework/secp256k1.py",
      "position": 90,
      "original_position": 82,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "899066847359a8f16aded60814794fab9ea884e1",
      "in_reply_to_id": 1207066672,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't understand.",
      "created_at": "2023-05-26T19:49:50Z",
      "updated_at": "2023-05-26T19:49:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207264222",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207264222"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 90,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207265123",
      "pull_request_review_id": 1446855011,
      "id": 1207265123,
      "node_id": "PRRC_kwDOABII585H9Wdj",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element if it exists (None otherwise).\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to a 32-byte array (big endian encoding).\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte array to a field element (big endian encoding).\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n+            return None\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a 64 character hex string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+\n+class GE:\n+    \"\"\"Objects of this class represent secp256k1 group elements (curve points or infinity)\n+\n+    Normal points on the curve have fields:\n+    * x: the x coordinate (a field element)\n+    * y: the y coordinate (a field element, satisfying y^2 = x^3 + 7)\n+    * infinity: False\n+\n+    The point at infinity has field:\n+    * infinity: True\n+    \"\"\"\n+\n+    # Order of the group (number of points on the curve, plus 1 for infinity)\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+\n+    # Number of valid distinct x coordinates on the curve.\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x=None, y=None):\n+        \"\"\"Initialize a group element with specified x and y coordinates, or infinity.\"\"\"\n+        if x is None:\n+            # Initialize as infinity.\n+            assert y is None\n+            self.infinity = True\n+        else:\n+            # Initialize as point on the curve (and check that it is).\n+            fx = FE(x)\n+            fy = FE(y)\n+            assert fy**2 == fx**3 + 7\n+            self.infinity = False\n+            self.x = fx\n+            self.y = fy\n+\n+    def __add__(self, a):\n+        \"\"\"Add two group elements together.\"\"\"\n+        # Deal with infinity: a + infinity == infinity + a == a.\n+        if self.infinity:\n+            return a\n+        if a.infinity:\n+            return self\n+        if self.x == a.x:\n+            if self.y != a.y:\n+                # A point added to its own negation is infinity.\n+                assert self.y + a.y == 0\n+                return GE()\n+            else:\n+                # For identical inputs, use the tangent (doubling formula).\n+                lam = (3 * self.x**2) / (2 * self.y)\n+        else:\n+            # For distinct inputs, use the line through both points (adding formula).\n+            lam = (self.y - a.y) / (self.x - a.x)\n+        # Determine point opposite to the intersection of that line with the curve.\n+        x = lam**2 - (self.x + a.x)\n+        y = lam * (self.x - x) - self.y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def mul(*aps):\n+        \"\"\"Compute a (batch) scalar group element multiplication.\n+\n+        GE.mul((a1, p1), (a2, p2), (a3, p3)) is identical to a1*p1 + a2*p2 + a3*p3,\n+        but more efficient.\"\"\"\n+        # Reduce all the scalars modulo order first (so we can deal with negatives etc).\n+        naps = [(a % GE.ORDER, p) for a, p in aps]\n+        # Start with point at infinity.\n+        r = GE()\n+        # Iterate over all bit positions, from high to low.\n+        for i in range(255, -1, -1):\n+            # Double what we have so far.\n+            r = r + r\n+            # Add then add the points for which the corresponding scalar bit is set.\n+            for (a, p) in naps:\n+                if (a >> i) & 1:\n+                    r += p\n+        return r\n+\n+    def __rmul__(self, a):\n+        \"\"\"Multiply an integer with a group element.\"\"\"\n+        return GE.mul((a, self))\n+\n+    def __neg__(self):\n+        \"\"\"Compute the negation of a group element.\"\"\"\n+        if self.infinity:\n+            return self\n+        return GE(self.x, -self.y)\n+\n+    def to_bytes_compressed(self):\n+        \"\"\"Convert a non-infinite group element to 33-byte compressed encoding.\"\"\"\n+        assert not self.infinity\n+        return bytes([3 - self.y.is_even()]) + self.x.to_bytes()\n+\n+    def to_bytes_uncompressed(self):\n+        \"\"\"Convert a non-infinite group element to 65-byte uncompressed encoding.\"\"\"\n+        assert not self.infinity\n+        return b'\\x04' + self.x.to_bytes() + self.y.to_bytes()\n+\n+    def to_bytes_xonly(self):\n+        \"\"\"Convert (the x coordinate of) a non-infinite group element to 32-byte xonly encoding.\"\"\"\n+        assert not self.infinity\n+        return self.x.to_bytes()\n+\n+    @staticmethod\n+    def lift_x(x):\n+        \"\"\"Return group element with specified field element as x coordinate (and even y).\"\"\"\n+        y = (FE(x)**3 + 7).sqrt()\n+        if y is None:\n+            return None\n+        if not y.is_even():\n+            y = -y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a compressed or uncompressed encoding to a group element.\"\"\"\n+        if len(b) == 33:\n+            if b[0] != 2 and b[0] != 3:\n+                return None\n+            x = FE.from_bytes(b[1:])\n+            if x is None:\n+                return None\n+            r = GE.lift_x(x)\n+            if r is None:\n+                return None\n+            if b[0] == 3:\n+                r = -r\n+            return r\n+        if len(b) == 65:\n+            if b[0] != 4:\n+                return None\n+            x = FE.from_bytes(b[1:33])\n+            y = FE.from_bytes(b[33:])\n+            if y**2 != x**3 + 7:\n+                return None\n+            return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes_xonly(b):\n+        \"\"\"Convert a point given in xonly encoding to a group element.\"\"\"\n+        assert len(b) == 32\n+        x = FE.from_bytes(b)\n+        if x is None:\n+            return None\n+        return GE.lift_x(x)\n+\n+    @staticmethod\n+    def is_valid_x(x):\n+        \"\"\"Determine whether the provided field element is a valid X coordinate.\"\"\"\n+        return (FE(x)**3 + 7).is_square()\n+\n+    def __str__(self):\n+        \"\"\"Convert this group element to a string.\"\"\"\n+        if self.infinite:\n+            return \"(inf)\"\n+        return f\"({self.x},{self.y})\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation for this group element.\"\"\"\n+        if self.infinite:",
      "path": "test/functional/test_framework/secp256k1.py",
      "position": null,
      "original_position": 316,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "899066847359a8f16aded60814794fab9ea884e1",
      "in_reply_to_id": 1207054357,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "__repr__ is supposed to produce a string that is valid Python code.",
      "created_at": "2023-05-26T19:50:45Z",
      "updated_at": "2023-05-26T19:50:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207265123",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207265123"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 316,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207644980",
      "pull_request_review_id": 1447142151,
      "id": 1207644980,
      "node_id": "PRRC_kwDOABII585H-zM0",
      "diff_hunk": "@@ -13,268 +13,54 @@\n import random\n import unittest\n \n+from test_framework import secp256k1\n+\n # Point with no known discrete log.\n H_POINT = \"50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0\"\n \n+# Order of the secp256k1 curve\n+ORDER = secp256k1.GE.ORDER\n \n def TaggedHash(tag, data):\n     ss = hashlib.sha256(tag.encode('utf-8')).digest()\n     ss += ss\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n-    \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = pow(z1, -1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n-            return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert z2 == 1\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n-        for i in range(255, -1, -1):\n-            r = self.double(r)\n-            for (p, n) in ps:\n-                if ((n >> i) & 1):\n-                    r = self.add(r, p)\n-        return r\n-\n-SECP256K1_FIELD_SIZE = 2**256 - 2**32 - 977\n-SECP256K1 = EllipticCurve(SECP256K1_FIELD_SIZE, 0, 7)\n-SECP256K1_G = (0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798, 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8, 1)\n-SECP256K1_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n-SECP256K1_ORDER_HALF = SECP256K1_ORDER // 2\n \n class ECPubKey():",
      "path": "test/functional/test_framework/key.py",
      "position": null,
      "original_position": 224,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "899066847359a8f16aded60814794fab9ea884e1",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "when defining classes in python, don't we skip parentheses?\r\nusing `class ECPubKey:` and `class ECKey:` instead of `class ECPubKey():` and  `class ECKey():`",
      "created_at": "2023-05-27T04:04:39Z",
      "updated_at": "2023-05-31T14:42:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207644980",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207644980"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 31,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207758013",
      "pull_request_review_id": 1447142151,
      "id": 1207758013,
      "node_id": "PRRC_kwDOABII585H_Oy9",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"",
      "path": "test/functional/test_framework/secp256k1.py",
      "position": 90,
      "original_position": 82,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "899066847359a8f16aded60814794fab9ea884e1",
      "in_reply_to_id": 1207066672,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I thought of \"The result is cached.\" as:\r\n1.  someone calls `int()`\r\n2.  we do operations inside `int()`, compute what num and den should be and store it locally+lazily without updating actual `self.num`, `self.den` \r\n3.  someone calls another FE function\r\n4.  the newly computed value of `self.num`, `self.den` gets actually updated only here\r\n\r\nisn't this what caching a variable conceptually means? (even though it doesn't matter here where `self.num`, `self.den` gets actually updated) what did you actually mean by cached in this context?",
      "created_at": "2023-05-27T07:29:26Z",
      "updated_at": "2023-05-27T15:03:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207758013",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207758013"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 90,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207999486",
      "pull_request_review_id": 1447142151,
      "id": 1207999486,
      "node_id": "PRRC_kwDOABII585IAJv-",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element if it exists (None otherwise).\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to a 32-byte array (big endian encoding).\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte array to a field element (big endian encoding).\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n+            return None",
      "path": "test/functional/test_framework/secp256k1.py",
      "position": 139,
      "original_position": 147,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "899066847359a8f16aded60814794fab9ea884e1",
      "in_reply_to_id": 1207067694,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "never mind, just reviewed key.py and saw how this is being used in `verify_schnorr`, `tweak_add_pubkey`. agree that it's better/simpler to keep it as it is.",
      "created_at": "2023-05-27T14:07:24Z",
      "updated_at": "2023-05-27T15:03:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1207999486",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1207999486"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 139,
      "original_line": 139,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1209080001",
      "pull_request_review_id": 1449126701,
      "id": 1209080001,
      "node_id": "PRRC_kwDOABII585IERjB",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element if it exists (None otherwise).\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to a 32-byte array (big endian encoding).\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte array to a field element (big endian encoding).\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n+            return None",
      "path": "test/functional/test_framework/secp256k1.py",
      "position": 139,
      "original_position": 147,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "899066847359a8f16aded60814794fab9ea884e1",
      "in_reply_to_id": 1207067694,
      "user": {
        "login": "real-or-random",
        "id": 1071625,
        "node_id": "MDQ6VXNlcjEwNzE2MjU=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1071625?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/real-or-random",
        "html_url": "https://github.com/real-or-random",
        "followers_url": "https://api.github.com/users/real-or-random/followers",
        "following_url": "https://api.github.com/users/real-or-random/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/real-or-random/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/real-or-random/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/real-or-random/subscriptions",
        "organizations_url": "https://api.github.com/users/real-or-random/orgs",
        "repos_url": "https://api.github.com/users/real-or-random/repos",
        "events_url": "https://api.github.com/users/real-or-random/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/real-or-random/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Perhaps the comment should be explicit about the behavior when `v >= FE.SIZE`",
      "created_at": "2023-05-29T08:42:19Z",
      "updated_at": "2023-05-29T08:42:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1209080001",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1209080001"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 139,
      "original_line": 139,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1210987152",
      "pull_request_review_id": 1452064815,
      "id": 1210987152,
      "node_id": "PRRC_kwDOABII585ILjKQ",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element if it exists (None otherwise).\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to a 32-byte array (big endian encoding).\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte array to a field element (big endian encoding).\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n+            return None\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a 64 character hex string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+\n+class GE:\n+    \"\"\"Objects of this class represent secp256k1 group elements (curve points or infinity)\n+\n+    Normal points on the curve have fields:\n+    * x: the x coordinate (a field element)\n+    * y: the y coordinate (a field element, satisfying y^2 = x^3 + 7)\n+    * infinity: False\n+\n+    The point at infinity has field:\n+    * infinity: True\n+    \"\"\"\n+\n+    # Order of the group (number of points on the curve, plus 1 for infinity)\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+\n+    # Number of valid distinct x coordinates on the curve.\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x=None, y=None):\n+        \"\"\"Initialize a group element with specified x and y coordinates, or infinity.\"\"\"\n+        if x is None:\n+            # Initialize as infinity.\n+            assert y is None\n+            self.infinity = True\n+        else:\n+            # Initialize as point on the curve (and check that it is).\n+            fx = FE(x)\n+            fy = FE(y)\n+            assert fy**2 == fx**3 + 7\n+            self.infinity = False\n+            self.x = fx\n+            self.y = fy\n+\n+    def __add__(self, a):\n+        \"\"\"Add two group elements together.\"\"\"\n+        # Deal with infinity: a + infinity == infinity + a == a.\n+        if self.infinity:\n+            return a\n+        if a.infinity:\n+            return self\n+        if self.x == a.x:\n+            if self.y != a.y:\n+                # A point added to its own negation is infinity.\n+                assert self.y + a.y == 0\n+                return GE()\n+            else:\n+                # For identical inputs, use the tangent (doubling formula).\n+                lam = (3 * self.x**2) / (2 * self.y)\n+        else:\n+            # For distinct inputs, use the line through both points (adding formula).\n+            lam = (self.y - a.y) / (self.x - a.x)\n+        # Determine point opposite to the intersection of that line with the curve.\n+        x = lam**2 - (self.x + a.x)\n+        y = lam * (self.x - x) - self.y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def mul(*aps):\n+        \"\"\"Compute a (batch) scalar group element multiplication.\n+\n+        GE.mul((a1, p1), (a2, p2), (a3, p3)) is identical to a1*p1 + a2*p2 + a3*p3,\n+        but more efficient.\"\"\"\n+        # Reduce all the scalars modulo order first (so we can deal with negatives etc).\n+        naps = [(a % GE.ORDER, p) for a, p in aps]\n+        # Start with point at infinity.\n+        r = GE()\n+        # Iterate over all bit positions, from high to low.\n+        for i in range(255, -1, -1):\n+            # Double what we have so far.\n+            r = r + r\n+            # Add then add the points for which the corresponding scalar bit is set.\n+            for (a, p) in naps:\n+                if (a >> i) & 1:\n+                    r += p\n+        return r\n+\n+    def __rmul__(self, a):\n+        \"\"\"Multiply an integer with a group element.\"\"\"\n+        return GE.mul((a, self))\n+\n+    def __neg__(self):\n+        \"\"\"Compute the negation of a group element.\"\"\"\n+        if self.infinity:\n+            return self\n+        return GE(self.x, -self.y)\n+\n+    def to_bytes_compressed(self):\n+        \"\"\"Convert a non-infinite group element to 33-byte compressed encoding.\"\"\"\n+        assert not self.infinity\n+        return bytes([3 - self.y.is_even()]) + self.x.to_bytes()\n+\n+    def to_bytes_uncompressed(self):\n+        \"\"\"Convert a non-infinite group element to 65-byte uncompressed encoding.\"\"\"\n+        assert not self.infinity\n+        return b'\\x04' + self.x.to_bytes() + self.y.to_bytes()\n+\n+    def to_bytes_xonly(self):\n+        \"\"\"Convert (the x coordinate of) a non-infinite group element to 32-byte xonly encoding.\"\"\"\n+        assert not self.infinity\n+        return self.x.to_bytes()\n+\n+    @staticmethod\n+    def lift_x(x):\n+        \"\"\"Return group element with specified field element as x coordinate (and even y).\"\"\"\n+        y = (FE(x)**3 + 7).sqrt()\n+        if y is None:\n+            return None\n+        if not y.is_even():\n+            y = -y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a compressed or uncompressed encoding to a group element.\"\"\"\n+        if len(b) == 33:\n+            if b[0] != 2 and b[0] != 3:\n+                return None\n+            x = FE.from_bytes(b[1:])\n+            if x is None:\n+                return None\n+            r = GE.lift_x(x)\n+            if r is None:\n+                return None\n+            if b[0] == 3:\n+                r = -r\n+            return r\n+        if len(b) == 65:\n+            if b[0] != 4:\n+                return None\n+            x = FE.from_bytes(b[1:33])\n+            y = FE.from_bytes(b[33:])\n+            if y**2 != x**3 + 7:\n+                return None\n+            return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes_xonly(b):\n+        \"\"\"Convert a point given in xonly encoding to a group element.\"\"\"\n+        assert len(b) == 32\n+        x = FE.from_bytes(b)\n+        if x is None:\n+            return None\n+        return GE.lift_x(x)\n+\n+    @staticmethod\n+    def is_valid_x(x):\n+        \"\"\"Determine whether the provided field element is a valid X coordinate.\"\"\"\n+        return (FE(x)**3 + 7).is_square()",
      "path": "test/functional/test_framework/secp256k1.py",
      "position": 300,
      "original_position": 306,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "899066847359a8f16aded60814794fab9ea884e1",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Regarding the goal of simple implementation, is there a strong need to keep the `FE.is_square` method? Right now this is the only call-site, which I think could be replaced by\r\n```suggestion\r\n        return (FE(x)**3 + 7).sqrt() is not None\r\n```\r\nI assume trying to actually square is way slower than computing the Jacobi symbol, but since `is_valid_x` doesn't appear to be in a critical code-path, that's probably fine? At least for `feature_taproot.py` I didn't see a decrease in performance.",
      "created_at": "2023-05-31T01:24:31Z",
      "updated_at": "2023-05-31T01:24:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1210987152",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1210987152"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 300,
      "original_line": 300,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212094169",
      "pull_request_review_id": 1453838769,
      "id": 1212094169,
      "node_id": "PRRC_kwDOABII585IPxbZ",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):",
      "path": "test/functional/test_framework/secp256k1.py",
      "position": 47,
      "original_position": 47,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "899066847359a8f16aded60814794fab9ea884e1",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "8990668: it would be useful to have radd and rsub back for [these operations in `xswiftec_inv`](https://github.com/bitcoin/bips/blob/master/bip-0324/reference.py#L367-L370).\r\n(to keep #24005 consistent with BIP's reference python implementation for easy review.)",
      "created_at": "2023-05-31T17:56:31Z",
      "updated_at": "2023-05-31T18:00:23Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212094169",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212094169"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 47,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212129551",
      "pull_request_review_id": 1453892963,
      "id": 1212129551,
      "node_id": "PRRC_kwDOABII585IP6EP",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"",
      "path": "test/functional/test_framework/secp256k1.py",
      "position": 90,
      "original_position": 82,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "899066847359a8f16aded60814794fab9ea884e1",
      "in_reply_to_id": 1207066672,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I mean that the computation won't be repeated if called a second time (due to self.den being set to 1, which triggers the fast path). Whether that's accomplished through actually remembering the int-converted form or some other mechanism is an implementation detail a user of the class shouldn't need to care about.\r\n\r\nI realize I didn't mark the FE members `num` and `den` as private; I've done so now. Perhaps that helps? The way FE values are represented inside the class is an unobservable implementation detail, so calling `int(FE)` doesn't \"update\" the FE object in any observable way - it just makes future calls more efficient.",
      "created_at": "2023-05-31T18:23:20Z",
      "updated_at": "2023-05-31T18:43:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212129551",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212129551"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 90,
      "original_line": 90,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212163089",
      "pull_request_review_id": 1453933035,
      "id": 1212163089,
      "node_id": "PRRC_kwDOABII585IQCQR",
      "diff_hunk": "@@ -13,268 +13,54 @@\n import random\n import unittest\n \n+from test_framework import secp256k1\n+\n # Point with no known discrete log.\n H_POINT = \"50929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0\"\n \n+# Order of the secp256k1 curve\n+ORDER = secp256k1.GE.ORDER\n \n def TaggedHash(tag, data):\n     ss = hashlib.sha256(tag.encode('utf-8')).digest()\n     ss += ss\n     ss += data\n     return hashlib.sha256(ss).digest()\n \n-def jacobi_symbol(n, k):\n-    \"\"\"Compute the Jacobi symbol of n modulo k\n-\n-    See https://en.wikipedia.org/wiki/Jacobi_symbol\n-\n-    For our application k is always prime, so this is the same as the Legendre symbol.\"\"\"\n-    assert k > 0 and k & 1, \"jacobi symbol is only defined for positive odd k\"\n-    n %= k\n-    t = 0\n-    while n != 0:\n-        while n & 1 == 0:\n-            n >>= 1\n-            r = k & 7\n-            t ^= (r == 3 or r == 5)\n-        n, k = k, n\n-        t ^= (n & k & 3 == 3)\n-        n = n % k\n-    if k == 1:\n-        return -1 if t else 1\n-    return 0\n-\n-def modsqrt(a, p):\n-    \"\"\"Compute the square root of a modulo p when p % 4 = 3.\n-\n-    The Tonelli-Shanks algorithm can be used. See https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm\n-\n-    Limiting this function to only work for p % 4 = 3 means we don't need to\n-    iterate through the loop. The highest n such that p - 1 = 2^n Q with Q odd\n-    is n = 1. Therefore Q = (p-1)/2 and sqrt = a^((Q+1)/2) = a^((p+1)/4)\n-\n-    secp256k1's is defined over field of size 2**256 - 2**32 - 977, which is 3 mod 4.\n-    \"\"\"\n-    if p % 4 != 3:\n-        raise NotImplementedError(\"modsqrt only implemented for p % 4 = 3\")\n-    sqrt = pow(a, (p + 1)//4, p)\n-    if pow(sqrt, 2, p) == a % p:\n-        return sqrt\n-    return None\n-\n-class EllipticCurve:\n-    def __init__(self, p, a, b):\n-        \"\"\"Initialize elliptic curve y^2 = x^3 + a*x + b over GF(p).\"\"\"\n-        self.p = p\n-        self.a = a % p\n-        self.b = b % p\n-\n-    def affine(self, p1):\n-        \"\"\"Convert a Jacobian point tuple p1 to affine form, or None if at infinity.\n-\n-        An affine point is represented as the Jacobian (x, y, 1)\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return None\n-        inv = pow(z1, -1, self.p)\n-        inv_2 = (inv**2) % self.p\n-        inv_3 = (inv_2 * inv) % self.p\n-        return ((inv_2 * x1) % self.p, (inv_3 * y1) % self.p, 1)\n-\n-    def has_even_y(self, p1):\n-        \"\"\"Whether the point p1 has an even Y coordinate when expressed in affine coordinates.\"\"\"\n-        return not (p1[2] == 0 or self.affine(p1)[1] & 1)\n-\n-    def negate(self, p1):\n-        \"\"\"Negate a Jacobian point tuple p1.\"\"\"\n-        x1, y1, z1 = p1\n-        return (x1, (self.p - y1) % self.p, z1)\n-\n-    def on_curve(self, p1):\n-        \"\"\"Determine whether a Jacobian tuple p is on the curve (and not infinity)\"\"\"\n-        x1, y1, z1 = p1\n-        z2 = pow(z1, 2, self.p)\n-        z4 = pow(z2, 2, self.p)\n-        return z1 != 0 and (pow(x1, 3, self.p) + self.a * x1 * z4 + self.b * z2 * z4 - pow(y1, 2, self.p)) % self.p == 0\n-\n-    def is_x_coord(self, x):\n-        \"\"\"Test whether x is a valid X coordinate on the curve.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        return jacobi_symbol(x_3 + self.a * x + self.b, self.p) != -1\n-\n-    def lift_x(self, x):\n-        \"\"\"Given an X coordinate on the curve, return a corresponding affine point for which the Y coordinate is even.\"\"\"\n-        x_3 = pow(x, 3, self.p)\n-        v = x_3 + self.a * x + self.b\n-        y = modsqrt(v, self.p)\n-        if y is None:\n-            return None\n-        return (x, self.p - y if y & 1 else y, 1)\n-\n-    def double(self, p1):\n-        \"\"\"Double a Jacobian tuple p1\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Doubling\"\"\"\n-        x1, y1, z1 = p1\n-        if z1 == 0:\n-            return (0, 1, 0)\n-        y1_2 = (y1**2) % self.p\n-        y1_4 = (y1_2**2) % self.p\n-        x1_2 = (x1**2) % self.p\n-        s = (4*x1*y1_2) % self.p\n-        m = 3*x1_2\n-        if self.a:\n-            m += self.a * pow(z1, 4, self.p)\n-        m = m % self.p\n-        x2 = (m**2 - 2*s) % self.p\n-        y2 = (m*(s - x2) - 8*y1_4) % self.p\n-        z2 = (2*y1*z1) % self.p\n-        return (x2, y2, z2)\n-\n-    def add_mixed(self, p1, p2):\n-        \"\"\"Add a Jacobian tuple p1 and an affine tuple p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition (with affine point)\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        assert z2 == 1\n-        # Adding to the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if x1 == u2:\n-            if (y1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - x1\n-        r = s2 - y1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (x1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - y1*h_3) % self.p\n-        z3 = (h*z1) % self.p\n-        return (x3, y3, z3)\n-\n-    def add(self, p1, p2):\n-        \"\"\"Add two Jacobian tuples p1 and p2\n-\n-        See https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates - Point Addition\"\"\"\n-        x1, y1, z1 = p1\n-        x2, y2, z2 = p2\n-        # Adding the point at infinity is a no-op\n-        if z1 == 0:\n-            return p2\n-        if z2 == 0:\n-            return p1\n-        # Adding an Affine to a Jacobian is more efficient since we save field multiplications and squarings when z = 1\n-        if z1 == 1:\n-            return self.add_mixed(p2, p1)\n-        if z2 == 1:\n-            return self.add_mixed(p1, p2)\n-        z1_2 = (z1**2) % self.p\n-        z1_3 = (z1_2 * z1) % self.p\n-        z2_2 = (z2**2) % self.p\n-        z2_3 = (z2_2 * z2) % self.p\n-        u1 = (x1 * z2_2) % self.p\n-        u2 = (x2 * z1_2) % self.p\n-        s1 = (y1 * z2_3) % self.p\n-        s2 = (y2 * z1_3) % self.p\n-        if u1 == u2:\n-            if (s1 != s2):\n-                # p1 and p2 are inverses. Return the point at infinity.\n-                return (0, 1, 0)\n-            # p1 == p2. The formulas below fail when the two points are equal.\n-            return self.double(p1)\n-        h = u2 - u1\n-        r = s2 - s1\n-        h_2 = (h**2) % self.p\n-        h_3 = (h_2 * h) % self.p\n-        u1_h_2 = (u1 * h_2) % self.p\n-        x3 = (r**2 - h_3 - 2*u1_h_2) % self.p\n-        y3 = (r*(u1_h_2 - x3) - s1*h_3) % self.p\n-        z3 = (h*z1*z2) % self.p\n-        return (x3, y3, z3)\n-\n-    def mul(self, ps):\n-        \"\"\"Compute a (multi) point multiplication\n-\n-        ps is a list of (Jacobian tuple, scalar) pairs.\n-        \"\"\"\n-        r = (0, 1, 0)\n-        for i in range(255, -1, -1):\n-            r = self.double(r)\n-            for (p, n) in ps:\n-                if ((n >> i) & 1):\n-                    r = self.add(r, p)\n-        return r\n-\n-SECP256K1_FIELD_SIZE = 2**256 - 2**32 - 977\n-SECP256K1 = EllipticCurve(SECP256K1_FIELD_SIZE, 0, 7)\n-SECP256K1_G = (0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798, 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8, 1)\n-SECP256K1_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n-SECP256K1_ORDER_HALF = SECP256K1_ORDER // 2\n \n class ECPubKey():",
      "path": "test/functional/test_framework/key.py",
      "position": null,
      "original_position": 224,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "899066847359a8f16aded60814794fab9ea884e1",
      "in_reply_to_id": 1207644980,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I guess we should; the parentheses are for listing parent classes, but I believe that an empty list or no parentheses at all don't make a difference.\r\n\r\nFixed.",
      "created_at": "2023-05-31T18:49:33Z",
      "updated_at": "2023-05-31T18:52:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212163089",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212163089"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 31,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212163658",
      "pull_request_review_id": 1453933035,
      "id": 1212163658,
      "node_id": "PRRC_kwDOABII585IQCZK",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):",
      "path": "test/functional/test_framework/secp256k1.py",
      "position": 47,
      "original_position": 47,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "899066847359a8f16aded60814794fab9ea884e1",
      "in_reply_to_id": 1212094169,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Ok, I added back.",
      "created_at": "2023-05-31T18:49:53Z",
      "updated_at": "2023-05-31T18:52:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212163658",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212163658"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 47,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212164841",
      "pull_request_review_id": 1453933035,
      "id": 1212164841,
      "node_id": "PRRC_kwDOABII585IQCrp",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element if it exists (None otherwise).\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to a 32-byte array (big endian encoding).\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte array to a field element (big endian encoding).\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n+            return None",
      "path": "test/functional/test_framework/secp256k1.py",
      "position": 139,
      "original_position": 147,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "899066847359a8f16aded60814794fab9ea884e1",
      "in_reply_to_id": 1207067694,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've added a `\"no overflow allowed\"` to the comment.",
      "created_at": "2023-05-31T18:50:37Z",
      "updated_at": "2023-05-31T18:52:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212164841",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212164841"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 139,
      "original_line": 139,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212166978",
      "pull_request_review_id": 1453933035,
      "id": 1212166978,
      "node_id": "PRRC_kwDOABII585IQDNC",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element if it exists (None otherwise).\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to a 32-byte array (big endian encoding).\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte array to a field element (big endian encoding).\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n+            return None\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a 64 character hex string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+\n+class GE:\n+    \"\"\"Objects of this class represent secp256k1 group elements (curve points or infinity)\n+\n+    Normal points on the curve have fields:\n+    * x: the x coordinate (a field element)\n+    * y: the y coordinate (a field element, satisfying y^2 = x^3 + 7)\n+    * infinity: False\n+\n+    The point at infinity has field:\n+    * infinity: True\n+    \"\"\"\n+\n+    # Order of the group (number of points on the curve, plus 1 for infinity)\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+\n+    # Number of valid distinct x coordinates on the curve.\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x=None, y=None):\n+        \"\"\"Initialize a group element with specified x and y coordinates, or infinity.\"\"\"\n+        if x is None:\n+            # Initialize as infinity.\n+            assert y is None\n+            self.infinity = True\n+        else:\n+            # Initialize as point on the curve (and check that it is).\n+            fx = FE(x)\n+            fy = FE(y)\n+            assert fy**2 == fx**3 + 7\n+            self.infinity = False\n+            self.x = fx\n+            self.y = fy\n+\n+    def __add__(self, a):\n+        \"\"\"Add two group elements together.\"\"\"\n+        # Deal with infinity: a + infinity == infinity + a == a.\n+        if self.infinity:\n+            return a\n+        if a.infinity:\n+            return self\n+        if self.x == a.x:\n+            if self.y != a.y:\n+                # A point added to its own negation is infinity.\n+                assert self.y + a.y == 0\n+                return GE()\n+            else:\n+                # For identical inputs, use the tangent (doubling formula).\n+                lam = (3 * self.x**2) / (2 * self.y)\n+        else:\n+            # For distinct inputs, use the line through both points (adding formula).\n+            lam = (self.y - a.y) / (self.x - a.x)\n+        # Determine point opposite to the intersection of that line with the curve.\n+        x = lam**2 - (self.x + a.x)\n+        y = lam * (self.x - x) - self.y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def mul(*aps):\n+        \"\"\"Compute a (batch) scalar group element multiplication.\n+\n+        GE.mul((a1, p1), (a2, p2), (a3, p3)) is identical to a1*p1 + a2*p2 + a3*p3,\n+        but more efficient.\"\"\"\n+        # Reduce all the scalars modulo order first (so we can deal with negatives etc).\n+        naps = [(a % GE.ORDER, p) for a, p in aps]\n+        # Start with point at infinity.\n+        r = GE()\n+        # Iterate over all bit positions, from high to low.\n+        for i in range(255, -1, -1):\n+            # Double what we have so far.\n+            r = r + r\n+            # Add then add the points for which the corresponding scalar bit is set.\n+            for (a, p) in naps:\n+                if (a >> i) & 1:\n+                    r += p\n+        return r\n+\n+    def __rmul__(self, a):\n+        \"\"\"Multiply an integer with a group element.\"\"\"\n+        return GE.mul((a, self))\n+\n+    def __neg__(self):\n+        \"\"\"Compute the negation of a group element.\"\"\"\n+        if self.infinity:\n+            return self\n+        return GE(self.x, -self.y)\n+\n+    def to_bytes_compressed(self):\n+        \"\"\"Convert a non-infinite group element to 33-byte compressed encoding.\"\"\"\n+        assert not self.infinity\n+        return bytes([3 - self.y.is_even()]) + self.x.to_bytes()\n+\n+    def to_bytes_uncompressed(self):\n+        \"\"\"Convert a non-infinite group element to 65-byte uncompressed encoding.\"\"\"\n+        assert not self.infinity\n+        return b'\\x04' + self.x.to_bytes() + self.y.to_bytes()\n+\n+    def to_bytes_xonly(self):\n+        \"\"\"Convert (the x coordinate of) a non-infinite group element to 32-byte xonly encoding.\"\"\"\n+        assert not self.infinity\n+        return self.x.to_bytes()\n+\n+    @staticmethod\n+    def lift_x(x):\n+        \"\"\"Return group element with specified field element as x coordinate (and even y).\"\"\"\n+        y = (FE(x)**3 + 7).sqrt()\n+        if y is None:\n+            return None\n+        if not y.is_even():\n+            y = -y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a compressed or uncompressed encoding to a group element.\"\"\"\n+        if len(b) == 33:\n+            if b[0] != 2 and b[0] != 3:\n+                return None\n+            x = FE.from_bytes(b[1:])\n+            if x is None:\n+                return None\n+            r = GE.lift_x(x)\n+            if r is None:\n+                return None\n+            if b[0] == 3:\n+                r = -r\n+            return r\n+        if len(b) == 65:\n+            if b[0] != 4:\n+                return None\n+            x = FE.from_bytes(b[1:33])\n+            y = FE.from_bytes(b[33:])\n+            if y**2 != x**3 + 7:\n+                return None\n+            return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes_xonly(b):\n+        \"\"\"Convert a point given in xonly encoding to a group element.\"\"\"\n+        assert len(b) == 32\n+        x = FE.from_bytes(b)\n+        if x is None:\n+            return None\n+        return GE.lift_x(x)\n+\n+    @staticmethod\n+    def is_valid_x(x):\n+        \"\"\"Determine whether the provided field element is a valid X coordinate.\"\"\"\n+        return (FE(x)**3 + 7).is_square()",
      "path": "test/functional/test_framework/secp256k1.py",
      "position": 300,
      "original_position": 306,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "899066847359a8f16aded60814794fab9ea884e1",
      "in_reply_to_id": 1210987152,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I've kept the `FE.is_square()` function, but replaced it with just a `x.sqrt() is not None` plus a comment that a more efficient algorithm is possible.\r\n\r\nThis leaves the option of easily adding a more efficient implementation back later if really worth it.",
      "created_at": "2023-05-31T18:51:19Z",
      "updated_at": "2023-05-31T18:52:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212166978",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212166978"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 300,
      "original_line": 300,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212172722",
      "pull_request_review_id": 1453946859,
      "id": 1212172722,
      "node_id": "PRRC_kwDOABII585IQEmy",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"\n+        if self.den != 1:\n+            self.num = (self.num * pow(self.den, -1, FE.SIZE)) % FE.SIZE\n+            self.den = 1\n+        return self.num\n+\n+    def sqrt(self):\n+        \"\"\"Compute the square root of a field element if it exists (None otherwise).\n+\n+        Due to the fact that our modulus is of the form (p % 4) == 3, the Tonelli-Shanks\n+        algorithm (https://en.wikipedia.org/wiki/Tonelli-Shanks_algorithm) is simply\n+        raising the argument to the power (p + 1) / 4.\n+\n+        To see why: (p-1) % 2 = 0, so 2 divides the order of the multiplicative group,\n+        and thus only half of the non-zero field elements are squares. An element a is\n+        a (nonzero) square when Euler's criterion, a^((p-1)/2) = 1 (mod p), holds. We're\n+        looking for x such that x^2 = a (mod p). Given a^((p-1)/2) = 1, that is equivalent\n+        to x^2 = a^(1 + (p-1)/2) mod p. As (1 + (p-1)/2) is even, this is equivalent to\n+        x = a^((1 + (p-1)/2)/2) mod p, or x = a^((p+1)/4) mod p.\"\"\"\n+        v = int(self)\n+        s = pow(v, (FE.SIZE + 1) // 4, FE.SIZE)\n+        if s**2 % FE.SIZE == v:\n+            return FE(s)\n+        return None\n+\n+    def is_square(self):\n+        \"\"\"Determine if this field element has a square root.\"\"\"\n+        # Compute the Jacobi symbol of (self / p). Since our modulus is prime, this\n+        # is the same as the Legendre symbol, which determines quadratic residuosity.\n+        # See https://en.wikipedia.org/wiki/Jacobi_symbol for the algorithm.\n+        # Note that num*den = (num/den) * den^2 has the same squareness as num/den,\n+        # because they are related by a factor that is definitely square.\n+        n, k, t = (self.num * self.den) % FE.SIZE, FE.SIZE, 0\n+        if n == 0:\n+            return True\n+        while n != 0:\n+            while n & 1 == 0:\n+                n >>= 1\n+                r = k & 7\n+                t ^= (r in (3, 5))\n+            n, k = k, n\n+            t ^= (n & k & 3 == 3)\n+            n = n % k\n+        assert k == 1\n+        return not t\n+\n+    def is_even(self):\n+        \"\"\"Determine whether this field element, represented as integer in 0..p-1, is even.\"\"\"\n+        return int(self) & 1 == 0\n+\n+    def __eq__(self, a):\n+        \"\"\"Check whether two field elements are equal (second may be an int).\"\"\"\n+        if isinstance(a, FE):\n+            return (self.num * a.den - self.den * a.num) % FE.SIZE == 0\n+        return (self.num - self.den * a) % FE.SIZE == 0\n+\n+    def to_bytes(self):\n+        \"\"\"Convert a field element to a 32-byte array (big endian encoding).\"\"\"\n+        return int(self).to_bytes(32, 'big')\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a 32-byte array to a field element (big endian encoding).\"\"\"\n+        v = int.from_bytes(b, 'big')\n+        if v >= FE.SIZE:\n+            return None\n+        return FE(v)\n+\n+    def __str__(self):\n+        \"\"\"Convert this field element to a 64 character hex string.\"\"\"\n+        return f\"{int(self):064x}\"\n+\n+    def __repr__(self):\n+        \"\"\"Get a string representation of this field element.\"\"\"\n+        return f\"FE(0x{int(self):x})\"\n+\n+\n+class GE:\n+    \"\"\"Objects of this class represent secp256k1 group elements (curve points or infinity)\n+\n+    Normal points on the curve have fields:\n+    * x: the x coordinate (a field element)\n+    * y: the y coordinate (a field element, satisfying y^2 = x^3 + 7)\n+    * infinity: False\n+\n+    The point at infinity has field:\n+    * infinity: True\n+    \"\"\"\n+\n+    # Order of the group (number of points on the curve, plus 1 for infinity)\n+    ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n+\n+    # Number of valid distinct x coordinates on the curve.\n+    ORDER_HALF = ORDER // 2\n+\n+    def __init__(self, x=None, y=None):\n+        \"\"\"Initialize a group element with specified x and y coordinates, or infinity.\"\"\"\n+        if x is None:\n+            # Initialize as infinity.\n+            assert y is None\n+            self.infinity = True\n+        else:\n+            # Initialize as point on the curve (and check that it is).\n+            fx = FE(x)\n+            fy = FE(y)\n+            assert fy**2 == fx**3 + 7\n+            self.infinity = False\n+            self.x = fx\n+            self.y = fy\n+\n+    def __add__(self, a):\n+        \"\"\"Add two group elements together.\"\"\"\n+        # Deal with infinity: a + infinity == infinity + a == a.\n+        if self.infinity:\n+            return a\n+        if a.infinity:\n+            return self\n+        if self.x == a.x:\n+            if self.y != a.y:\n+                # A point added to its own negation is infinity.\n+                assert self.y + a.y == 0\n+                return GE()\n+            else:\n+                # For identical inputs, use the tangent (doubling formula).\n+                lam = (3 * self.x**2) / (2 * self.y)\n+        else:\n+            # For distinct inputs, use the line through both points (adding formula).\n+            lam = (self.y - a.y) / (self.x - a.x)\n+        # Determine point opposite to the intersection of that line with the curve.\n+        x = lam**2 - (self.x + a.x)\n+        y = lam * (self.x - x) - self.y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def mul(*aps):\n+        \"\"\"Compute a (batch) scalar group element multiplication.\n+\n+        GE.mul((a1, p1), (a2, p2), (a3, p3)) is identical to a1*p1 + a2*p2 + a3*p3,\n+        but more efficient.\"\"\"\n+        # Reduce all the scalars modulo order first (so we can deal with negatives etc).\n+        naps = [(a % GE.ORDER, p) for a, p in aps]\n+        # Start with point at infinity.\n+        r = GE()\n+        # Iterate over all bit positions, from high to low.\n+        for i in range(255, -1, -1):\n+            # Double what we have so far.\n+            r = r + r\n+            # Add then add the points for which the corresponding scalar bit is set.\n+            for (a, p) in naps:\n+                if (a >> i) & 1:\n+                    r += p\n+        return r\n+\n+    def __rmul__(self, a):\n+        \"\"\"Multiply an integer with a group element.\"\"\"\n+        return GE.mul((a, self))\n+\n+    def __neg__(self):\n+        \"\"\"Compute the negation of a group element.\"\"\"\n+        if self.infinity:\n+            return self\n+        return GE(self.x, -self.y)\n+\n+    def to_bytes_compressed(self):\n+        \"\"\"Convert a non-infinite group element to 33-byte compressed encoding.\"\"\"\n+        assert not self.infinity\n+        return bytes([3 - self.y.is_even()]) + self.x.to_bytes()\n+\n+    def to_bytes_uncompressed(self):\n+        \"\"\"Convert a non-infinite group element to 65-byte uncompressed encoding.\"\"\"\n+        assert not self.infinity\n+        return b'\\x04' + self.x.to_bytes() + self.y.to_bytes()\n+\n+    def to_bytes_xonly(self):\n+        \"\"\"Convert (the x coordinate of) a non-infinite group element to 32-byte xonly encoding.\"\"\"\n+        assert not self.infinity\n+        return self.x.to_bytes()\n+\n+    @staticmethod\n+    def lift_x(x):\n+        \"\"\"Return group element with specified field element as x coordinate (and even y).\"\"\"\n+        y = (FE(x)**3 + 7).sqrt()\n+        if y is None:\n+            return None\n+        if not y.is_even():\n+            y = -y\n+        return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes(b):\n+        \"\"\"Convert a compressed or uncompressed encoding to a group element.\"\"\"\n+        if len(b) == 33:\n+            if b[0] != 2 and b[0] != 3:\n+                return None\n+            x = FE.from_bytes(b[1:])\n+            if x is None:\n+                return None\n+            r = GE.lift_x(x)\n+            if r is None:\n+                return None\n+            if b[0] == 3:\n+                r = -r\n+            return r\n+        if len(b) == 65:\n+            if b[0] != 4:\n+                return None\n+            x = FE.from_bytes(b[1:33])\n+            y = FE.from_bytes(b[33:])\n+            if y**2 != x**3 + 7:\n+                return None\n+            return GE(x, y)\n+\n+    @staticmethod\n+    def from_bytes_xonly(b):\n+        \"\"\"Convert a point given in xonly encoding to a group element.\"\"\"\n+        assert len(b) == 32\n+        x = FE.from_bytes(b)\n+        if x is None:\n+            return None\n+        return GE.lift_x(x)\n+\n+    @staticmethod\n+    def is_valid_x(x):\n+        \"\"\"Determine whether the provided field element is a valid X coordinate.\"\"\"\n+        return (FE(x)**3 + 7).is_square()\n+\n+    def __str__(self):\n+        \"\"\"Convert this group element to a string.\"\"\"\n+        if self.infinite:",
      "path": "test/functional/test_framework/secp256k1.py",
      "position": null,
      "original_position": 310,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "899066847359a8f16aded60814794fab9ea884e1",
      "in_reply_to_id": 1207054125,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2023-05-31T18:54:25Z",
      "updated_at": "2023-05-31T18:54:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212172722",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212172722"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 310,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212736489",
      "pull_request_review_id": 1454810878,
      "id": 1212736489,
      "node_id": "PRRC_kwDOABII585ISOPp",
      "diff_hunk": "@@ -0,0 +1,313 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a._num\n+            den = a._den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b._num) % FE.SIZE\n+            num = (num * b._den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self._num = num\n+        self._den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self._num * a._den + self._den * a._num, self._den * a._den)\n+        return FE(self._num + self._den * a, self._den)\n+\n+    def __radd__(self, a):\n+        \"\"\"Compute the sum of an integer and a field element.\"\"\"\n+        return FE(a) + self\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self._num * a._den - self._den * a._num, self._den * a._den)\n+        return FE(self._num - self._den * a, self._den)\n+\n+    def __rsub(self, a):",
      "path": "test/functional/test_framework/secp256k1.py",
      "position": 63,
      "original_position": 63,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "ee6e289a4ceaadac75b22c057c3af1e6a3f59aec",
      "in_reply_to_id": null,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "ee6e289:\r\n```suggestion\r\n    def __rsub__(self, a):\r\n```",
      "created_at": "2023-06-01T07:46:48Z",
      "updated_at": "2023-06-01T10:33:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212736489",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212736489"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 63,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212950016",
      "pull_request_review_id": 1454810878,
      "id": 1212950016,
      "node_id": "PRRC_kwDOABII585ITCYA",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+# Copyright (c) 2022-2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+\"\"\"Test-only implementation of low-level secp256k1 field and group arithmetic\n+\n+It is designed for ease of understanding, not performance.\n+\n+WARNING: This code is slow and trivially vulnerable to side channel attacks. Do not use for\n+anything but tests.\n+\n+Exports:\n+* FE: class for secp256k1 field elements\n+* GE: class for secp256k1 group elements\n+* G: the secp256k1 generator point\n+\"\"\"\n+\n+\n+class FE:\n+    \"\"\"Objects of this class represent elements of the field GF(2**256 - 2**32 - 977).\n+\n+    They are represented internally in numerator / denominator form, in order to delay inversions.\n+    \"\"\"\n+\n+    # The size of the field (also its modulus and characteristic).\n+    SIZE = 2**256 - 2**32 - 977\n+\n+    def __init__(self, a=0, b=1):\n+        \"\"\"Initialize a field element a/b; both a and b can be ints or field elements.\"\"\"\n+        if isinstance(a, FE):\n+            num = a.num\n+            den = a.den\n+        else:\n+            num = a % FE.SIZE\n+            den = 1\n+        if isinstance(b, FE):\n+            den = (den * b.num) % FE.SIZE\n+            num = (num * b.den) % FE.SIZE\n+        else:\n+            den = (den * b) % FE.SIZE\n+        assert den != 0\n+        if num == 0:\n+            den = 1\n+        self.num = num\n+        self.den = den\n+\n+    def __add__(self, a):\n+        \"\"\"Compute the sum of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den + self.den * a.num, self.den * a.den)\n+        return FE(self.num + self.den * a, self.den)\n+\n+    def __sub__(self, a):\n+        \"\"\"Compute the difference of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.den - self.den * a.num, self.den * a.den)\n+        return FE(self.num - self.den * a, self.den)\n+\n+    def __mul__(self, a):\n+        \"\"\"Compute the product of two field elements (second may be int).\"\"\"\n+        if isinstance(a, FE):\n+            return FE(self.num * a.num, self.den * a.den)\n+        return FE(self.num * a, self.den)\n+\n+    def __rmul__(self, a):\n+        \"\"\"Compute the product of an integer with a field element.\"\"\"\n+        return FE(self.num * a, self.den)\n+\n+    def __truediv__(self, a):\n+        \"\"\"Compute the ratio of two field elements (second may be int).\"\"\"\n+        return FE(self, a)\n+\n+    def __pow__(self, a):\n+        \"\"\"Raise a field element to an integer power.\"\"\"\n+        return FE(pow(self.num, a, FE.SIZE), pow(self.den, a, FE.SIZE))\n+\n+    def __neg__(self):\n+        \"\"\"Negate a field element.\"\"\"\n+        return FE(-self.num, self.den)\n+\n+    def __int__(self):\n+        \"\"\"Convert a field element to an integer in range 0..p-1. The result is cached.\"\"\"",
      "path": "test/functional/test_framework/secp256k1.py",
      "position": 90,
      "original_position": 82,
      "commit_id": "2745abf17a86baa319c55ad96c7fef8eea145c6f",
      "original_commit_id": "899066847359a8f16aded60814794fab9ea884e1",
      "in_reply_to_id": 1207066672,
      "user": {
        "login": "stratospher",
        "id": 44024636,
        "node_id": "MDQ6VXNlcjQ0MDI0NjM2",
        "avatar_url": "https://avatars.githubusercontent.com/u/44024636?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stratospher",
        "html_url": "https://github.com/stratospher",
        "followers_url": "https://api.github.com/users/stratospher/followers",
        "following_url": "https://api.github.com/users/stratospher/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stratospher/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stratospher/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stratospher/subscriptions",
        "organizations_url": "https://api.github.com/users/stratospher/orgs",
        "repos_url": "https://api.github.com/users/stratospher/repos",
        "events_url": "https://api.github.com/users/stratospher/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stratospher/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> The way FE values are represented inside the class is an unobservable implementation detail, so calling int(FE) doesn't \"update\" the FE object in any observable way - it just makes future calls more efficient.\r\n\r\nthinking of it this way makes sense. thanks!",
      "created_at": "2023-06-01T10:32:49Z",
      "updated_at": "2023-06-01T10:33:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26222#discussion_r1212950016",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1212950016"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26222"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 90,
      "original_line": 90,
      "side": "RIGHT"
    }
  ]
}