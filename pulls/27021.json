{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021",
    "id": 1225738378,
    "node_id": "PR_kwDOABII585JD0iK",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/27021",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/27021.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/27021.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
    "number": 27021,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "Implement Mini version of BlockAssembler to calculate mining scores",
    "user": {
      "login": "Xekyo",
      "id": 4060799,
      "node_id": "MDQ6VXNlcjQwNjA3OTk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/Xekyo",
      "html_url": "https://github.com/Xekyo",
      "followers_url": "https://api.github.com/users/Xekyo/followers",
      "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
      "organizations_url": "https://api.github.com/users/Xekyo/orgs",
      "repos_url": "https://api.github.com/users/Xekyo/repos",
      "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/Xekyo/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Implement Mini version of BlockAssembler to calculate mining scores\r\n    \r\nRun the mining algorithm on a subset of the mempool, only disturbing the\r\nmempool to copy out fee information for relevant entries. Intended to be\r\nused by wallet to calculate amounts needed for fee-bumping unconfirmed\r\ntransactions.\r\n\r\nFrom comments of sipa and glozow below:\r\n\r\n> > In what way does the code added here differ from the real block assembly code?\r\n> \r\n>    * Only operates on the relevant transactions rather than full mempool\r\n>    * Has the ability to remove transactions that will be replaced so they don't impact their ancestors\r\n>    * Does not hold mempool lock outside of the constructor, makes copies of the entries it needs instead (though I'm not sure if this has an effect in practice)\r\n>    * Doesn't do the sanity checks like keeping weight within max block weight and `IsFinalTx()`\r\n>    * After the block template is built, additionally calculates fees to bump remaining ancestor packages to target feerate\r\n\r\n",
    "labels": [
      {
        "id": 164208572,
        "node_id": "MDU6TGFiZWwxNjQyMDg1NzI=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Mempool",
        "name": "Mempool",
        "color": "fef2c0",
        "default": false
      }
    ],
    "created_at": "2023-02-02T00:25:13Z",
    "updated_at": "2023-05-30T11:10:23Z",
    "closed_at": "2023-05-19T14:28:06Z",
    "mergeable": false,
    "mergeable_state": "dirty",
    "merged_at": "2023-05-19T14:28:06Z",
    "merge_commit_sha": "0f8c95dccd120ad5fd371f81025137b855796f13",
    "assignee": {
      "login": "glozow",
      "id": 25183001,
      "node_id": "MDQ6VXNlcjI1MTgzMDAx",
      "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/glozow",
      "html_url": "https://github.com/glozow",
      "followers_url": "https://api.github.com/users/glozow/followers",
      "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
      "organizations_url": "https://api.github.com/users/glozow/orgs",
      "repos_url": "https://api.github.com/users/glozow/repos",
      "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/glozow/received_events",
      "type": "User",
      "site_admin": false
    },
    "assignees": [
      {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "requested_reviewers": [
      {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      }
    ],
    "requested_teams": [],
    "rebaseable": false,
    "head": {
      "label": "Xekyo:add-mini-miner",
      "ref": "add-mini-miner",
      "sha": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 23979970,
        "node_id": "MDEwOlJlcG9zaXRvcnkyMzk3OTk3MA==",
        "name": "bitcoin",
        "full_name": "Xekyo/bitcoin",
        "owner": {
          "login": "Xekyo",
          "id": 4060799,
          "node_id": "MDQ6VXNlcjQwNjA3OTk=",
          "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/Xekyo",
          "html_url": "https://github.com/Xekyo",
          "followers_url": "https://api.github.com/users/Xekyo/followers",
          "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
          "organizations_url": "https://api.github.com/users/Xekyo/orgs",
          "repos_url": "https://api.github.com/users/Xekyo/repos",
          "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/Xekyo/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/Xekyo/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/Xekyo/bitcoin",
        "archive_url": "https://api.github.com/repos/Xekyo/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/Xekyo/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/Xekyo/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/Xekyo/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/Xekyo/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/Xekyo/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/Xekyo/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/Xekyo/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/Xekyo/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/Xekyo/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/Xekyo/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/Xekyo/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/Xekyo/bitcoin/events",
        "forks_url": "https://api.github.com/repos/Xekyo/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/Xekyo/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/Xekyo/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/Xekyo/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/Xekyo/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/Xekyo/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/Xekyo/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/Xekyo/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/Xekyo/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/Xekyo/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/Xekyo/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/Xekyo/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/Xekyo/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/Xekyo/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/Xekyo/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/Xekyo/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:Xekyo/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/Xekyo/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/Xekyo/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/Xekyo/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/Xekyo/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/Xekyo/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/Xekyo/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/Xekyo/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/Xekyo/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/Xekyo/bitcoin/hooks",
        "svn_url": "https://github.com/Xekyo/bitcoin",
        "homepage": "https://bitcoin.org/en/download",
        "language": "C++",
        "forks_count": 1,
        "stargazers_count": 1,
        "watchers_count": 1,
        "size": 200902,
        "default_branch": "master",
        "open_issues_count": 1,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-06-05T22:31:39Z",
        "created_at": "2014-09-12T23:11:53Z",
        "updated_at": "2023-05-11T06:24:44Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "5a8bd4505687a7ec76d731b1a8249ee04d641990",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 34325,
        "stargazers_count": 69818,
        "watchers_count": 69818,
        "size": 233879,
        "default_branch": "master",
        "open_issues_count": 626,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-06-07T07:29:24Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2023-06-07T06:49:43Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 1215,
    "deletions": 2,
    "changed_files": 8,
    "commits": 4,
    "review_comments": 128,
    "comments": 33
  },
  "events": [
    {
      "event": "commented",
      "id": 1412956940,
      "node_id": "IC_kwDOABII585UOAMM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1412956940",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-02T00:25:15Z",
      "updated_at": "2023-05-16T15:02:41Z",
      "author_association": "MEMBER",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [achow101](https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1533510937), [furszy](https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1417018318), [theStack](https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1428805458) |\n| Concept ACK | [glozow](https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1326000785) |\n| Stale ACK | [LarryRuane](https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1361682595) |\n\nIf your review is incorrectly listed, please react with 👎 to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1412956940",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "reviewed",
      "id": 1281801274,
      "node_id": "PRR_kwDOABII585MZrw6",
      "url": null,
      "actor": null,
      "commit_id": "183558952177e0ba9b8a534939eb473519030cb3",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Wrote some more tests for this, please feel free to take: https://github.com/glozow/bitcoin/commit/6761c5935c34079fdd55904e025c9e19d80955d8",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1281801274",
      "submitted_at": "2023-02-02T19:50:07Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8425216310,
      "node_id": "HRFPE_lADOABII585dZ-4OzwAAAAH2Lpk2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8425216310",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-02T20:21:50Z"
    },
    {
      "event": "labeled",
      "id": 8429697227,
      "node_id": "LE_lADOABII585dZ-4OzwAAAAH2cvjL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8429697227",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-03T08:57:19Z",
      "label": {
        "name": "Mempool",
        "color": "fef2c0"
      }
    },
    {
      "event": "reviewed",
      "id": 1282756155,
      "node_id": "PRR_kwDOABII585MdU47",
      "url": null,
      "actor": null,
      "commit_id": "daf023a49ce812417a36ec201e19d4272abc790a",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1282756155",
      "submitted_at": "2023-02-03T10:47:33Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "commented",
      "id": 1416044406,
      "node_id": "IC_kwDOABII585UZx92",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1416044406",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-03T15:41:43Z",
      "updated_at": "2023-02-03T15:41:43Z",
      "author_association": "MEMBER",
      "body": "I wrote a fuzz test for the `MiniMiner` and it crashes on some of the `Assume`s: https://github.com/dergoegge/bitcoin/tree/2023-01-fuzz-mini-miner\r\n\r\n```sh\r\n$ echo \"AQEWCQEBAAEACf//////////////CBwAAgAAlRwB7QEA/wAAAAL7AAEAAAEB7QEA/wAAAAL7AAAA\r\nAAAAXAD//w==\" | base64 -d > mini_miner_crash.input\r\n$ FUZZ=mini_miner ./src/test/fuzz/fuzz ./mini_miner_crash.input\r\n```\r\n\r\nNow that could just mean that my assumptions about what should be passed into the `MiniMiner` are wrong (i.e. my fuzz target is using the `MiniMiner` incorrectly). In that case it might make sense to add documentation that outlines what is expected from a `MiniMiner` user.\r\n\r\nTwo questions:\r\n* Are the assumptions (i.e. `Assume`s in mini_miner.cpp) internal to the `MiniMiner` or do they rely on external assumptions as well? e.g. Does the mini miner expect the mempool it receives in its constructor to only hold transactions that passed out ATMP checks?\r\n* Since this is a \"mini\" version of the `BlockAssembler`, would it be possible to differentially fuzz the two? Or using one as an oracle to test the other? e.g. Checking if transactions bumped with the help of `MiniMiner` make it into the next block constructed by the actual `BlockAssembler`.",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1416044406",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "commented",
      "id": 1416085883,
      "node_id": "IC_kwDOABII585UZ8F7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1416085883",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-03T16:13:03Z",
      "updated_at": "2023-02-03T16:13:03Z",
      "author_association": "MEMBER",
      "body": "In what way does the code added here differ from the real block assembly code?",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1416085883",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "commented",
      "id": 1416087441,
      "node_id": "IC_kwDOABII585UZ8eR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1416087441",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-03T16:14:18Z",
      "updated_at": "2023-02-03T16:14:18Z",
      "author_association": "MEMBER",
      "body": "Thanks for fuzzing :100:\r\nIt's fully possible the crashing is due to real bugs, I hit a crash yesterday while testing as well. I think there is something wrong with the way it's handling to-be-replaced outputs.\r\n\r\n> Does the mini miner expect the mempool it receives in its constructor to only hold transactions that passed out ATMP checks?\r\n\r\nActually no. It just uses what's cached in the mempool entries. The fees don't even need to match inputs - outputs, and mini miner definitely doesn't require ATMP checks.\r\n\r\n> Since this is a \"mini\" version of the BlockAssembler, would it be possible to differentially fuzz the two?\r\n\r\nDifferential fuzzing is perfect for this really.`MiniMiner::BuildMockTemplate(target_feerate)` is supposed to do the exact same thing as `BlockAssembler::addPackageTxs` with `blockmintxfee` = target feerate.\r\n\r\n> Checking if transactions bumped with the help of MiniMiner make it into the next block constructed by the actual BlockAssembler.\r\n\r\nThat would also be a really good way of testing the results (after the wallet stuff is added?). Add the bumping tx, mine another block with the target feerate as min feerate, and see that they all get mined.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1416087441",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "commented",
      "id": 1416097704,
      "node_id": "IC_kwDOABII585UZ--o",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1416097704",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-03T16:21:26Z",
      "updated_at": "2023-02-03T16:21:26Z",
      "author_association": "MEMBER",
      "body": "> In what way does the code added here differ from the real block assembly code?\r\n\r\n- Only operates on the relevant transactions rather than full mempool\r\n- Has the ability to remove transactions that will be replaced so they don't impact their ancestors\r\n- Does not hold mempool lock outside of the constructor, makes copies of the entries it needs instead (though I'm not sure if this has an effect in practice)\r\n- Doesn't do the sanity checks like keeping weight within max block weight and `IsFinalTx()`\r\n- After the block template is built, additionally calculates fees to bump remaining ancestor packages to target feerate",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1416097704",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "commented",
      "id": 1416422200,
      "node_id": "IC_kwDOABII585UbOM4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1416422200",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-03T21:29:41Z",
      "updated_at": "2023-02-03T21:29:41Z",
      "author_association": "MEMBER",
      "body": "Added tests from glozow’s branch",
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1416422200",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8436473279,
      "node_id": "HRFPE_lADOABII585dZ-4OzwAAAAH22l2_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8436473279",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-03T21:32:04Z"
    },
    {
      "event": "commented",
      "id": 1418834753,
      "node_id": "IC_kwDOABII585UkbNB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1418834753",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-06T10:14:15Z",
      "updated_at": "2023-02-06T10:14:15Z",
      "author_association": "MEMBER",
      "body": "Is there a reason to leave the `CalculateTotalBumpFee` commit out of this PR?",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1418834753",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "commented",
      "id": 1419869444,
      "node_id": "IC_kwDOABII585UoX0E",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1419869444",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-06T22:26:39Z",
      "updated_at": "2023-02-06T22:26:39Z",
      "author_association": "MEMBER",
      "body": "Oh good point, that just grew organically, but really it could be part of the mini-miner changes. I’ll squash it in there.",
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1419869444",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8471048358,
      "node_id": "HRFPE_lADOABII585dZ-4OzwAAAAH46fCm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8471048358",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-08T16:57:03Z"
    },
    {
      "event": "commented",
      "id": 1422942684,
      "node_id": "IC_kwDOABII585U0GHc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1422942684",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-08T16:58:22Z",
      "updated_at": "2023-02-08T16:58:22Z",
      "author_association": "MEMBER",
      "body": "I’ve amended this branch to include the `CalculateTotalBumpFee` method from #26152 in the mini-miner code here.",
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1422942684",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8472360787,
      "node_id": "HRFPE_lADOABII585dZ-4OzwAAAAH4_fdT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8472360787",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-08T19:35:37Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8472610365,
      "node_id": "HRFPE_lADOABII585dZ-4OzwAAAAH5AcY9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8472610365",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-08T20:09:15Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8538488566,
      "node_id": "HRFPE_lADOABII585dZ-4OzwAAAAH87v72",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8538488566",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-16T15:49:30Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8538615675,
      "node_id": "HRFPE_lADOABII585dZ-4OzwAAAAH88O97",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8538615675",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-16T16:00:30Z"
    },
    {
      "event": "commented",
      "id": 1433329273,
      "node_id": "IC_kwDOABII585Vbt55",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1433329273",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-16T16:06:44Z",
      "updated_at": "2023-02-16T16:06:44Z",
      "author_association": "MEMBER",
      "body": "I pushed some changes (with @Xekyo's permission, thanks):\r\n- Capped traversal at 500 items in `CalculateCluster()`. Number is arbitrary, open for commentary\r\n- Fixed up a few things in the MiniMiner implementation, mostly shuffling things around and updating comments\r\n- Dropped the chain interface changes (I think those can go in #26152)\r\n- Expanded unit tests\r\n- Added a fuzzer (expanded from @dergoegge's, thanks)\r\n- Added a fuzzer to differentially test block templates built by `BlockAssembler` and `MiniMiner`. Hopefully this gives reviewers a bit more confidence that they are doing the same thing even if the implementations are difficult to review/compare.",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1433329273",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "mentioned",
      "id": 8538686261,
      "node_id": "MEE_lADOABII585dZ-4OzwAAAAH88gM1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8538686261",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-16T16:06:44Z"
    },
    {
      "event": "subscribed",
      "id": 8538686290,
      "node_id": "SE_lADOABII585dZ-4OzwAAAAH88gNS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8538686290",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-16T16:06:44Z"
    },
    {
      "event": "mentioned",
      "id": 8538686321,
      "node_id": "MEE_lADOABII585dZ-4OzwAAAAH88gNx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8538686321",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-16T16:06:45Z"
    },
    {
      "event": "subscribed",
      "id": 8538686332,
      "node_id": "SE_lADOABII585dZ-4OzwAAAAH88gN8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8538686332",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-16T16:06:45Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8540600063,
      "node_id": "HRFPE_lADOABII585dZ-4OzwAAAAH9Dzb_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8540600063",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-16T19:43:06Z"
    },
    {
      "event": "commented",
      "id": 1433738562,
      "node_id": "IC_kwDOABII585VdR1C",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1433738562",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-16T21:29:52Z",
      "updated_at": "2023-02-16T21:29:52Z",
      "author_association": "MEMBER",
      "body": "Awesome, thanks for the reworking this, @glozow, and the work on the fuzzer, @dergoegge. I've fixed a minor `tidy` issue and I’ll pick the chain interface changes into #26152 and rebase on this shortly.\r\n\r\nReady for review\r\n\r\n",
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1433738562",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "mentioned",
      "id": 8541369501,
      "node_id": "MEE_lADOABII585dZ-4OzwAAAAH9GvSd",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8541369501",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-16T21:29:53Z"
    },
    {
      "event": "subscribed",
      "id": 8541369512,
      "node_id": "SE_lADOABII585dZ-4OzwAAAAH9GvSo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8541369512",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-16T21:29:53Z"
    },
    {
      "event": "mentioned",
      "id": 8541369521,
      "node_id": "MEE_lADOABII585dZ-4OzwAAAAH9GvSx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8541369521",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-16T21:29:53Z"
    },
    {
      "event": "subscribed",
      "id": 8541369529,
      "node_id": "SE_lADOABII585dZ-4OzwAAAAH9GvS5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8541369529",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-16T21:29:53Z"
    },
    {
      "event": "ready_for_review",
      "id": 8541369764,
      "node_id": "RFRE_lADOABII585dZ-4OzwAAAAH9GvWk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8541369764",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-16T21:29:56Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8541707940,
      "node_id": "HRFPE_lADOABII585dZ-4OzwAAAAH9IB6k",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8541707940",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-16T22:23:58Z"
    },
    {
      "event": "commented",
      "id": 1433798783,
      "node_id": "IC_kwDOABII585Vdgh_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1433798783",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-16T22:26:03Z",
      "updated_at": "2023-02-16T22:26:03Z",
      "author_association": "MEMBER",
      "body": "Pushed again to provide signed commits",
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1433798783",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "commented",
      "id": 1434870979,
      "node_id": "IC_kwDOABII585VhmTD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1434870979",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-17T16:19:40Z",
      "updated_at": "2023-02-17T16:19:40Z",
      "author_association": "MEMBER",
      "body": "review-beg-pinging @LarryRuane @josibake @stickies-v who have looked at `MiniMiner` previously",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1434870979",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "mentioned",
      "id": 8548778387,
      "node_id": "MEE_lADOABII585dZ-4OzwAAAAH9jAGT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8548778387",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-17T16:19:41Z"
    },
    {
      "event": "subscribed",
      "id": 8548778405,
      "node_id": "SE_lADOABII585dZ-4OzwAAAAH9jAGl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8548778405",
      "actor": {
        "login": "josibake",
        "id": 7444140,
        "node_id": "MDQ6VXNlcjc0NDQxNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7444140?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/josibake",
        "html_url": "https://github.com/josibake",
        "followers_url": "https://api.github.com/users/josibake/followers",
        "following_url": "https://api.github.com/users/josibake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/josibake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/josibake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/josibake/subscriptions",
        "organizations_url": "https://api.github.com/users/josibake/orgs",
        "repos_url": "https://api.github.com/users/josibake/repos",
        "events_url": "https://api.github.com/users/josibake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/josibake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-17T16:19:41Z"
    },
    {
      "event": "mentioned",
      "id": 8548778423,
      "node_id": "MEE_lADOABII585dZ-4OzwAAAAH9jAG3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8548778423",
      "actor": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-17T16:19:41Z"
    },
    {
      "event": "subscribed",
      "id": 8548778440,
      "node_id": "SE_lADOABII585dZ-4OzwAAAAH9jAHI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8548778440",
      "actor": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-17T16:19:41Z"
    },
    {
      "event": "mentioned",
      "id": 8548778462,
      "node_id": "MEE_lADOABII585dZ-4OzwAAAAH9jAHe",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8548778462",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-17T16:19:41Z"
    },
    {
      "event": "subscribed",
      "id": 8548778480,
      "node_id": "SE_lADOABII585dZ-4OzwAAAAH9jAHw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8548778480",
      "actor": {
        "login": "stickies-v",
        "id": 69010457,
        "node_id": "MDQ6VXNlcjY5MDEwNDU3",
        "avatar_url": "https://avatars.githubusercontent.com/u/69010457?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/stickies-v",
        "html_url": "https://github.com/stickies-v",
        "followers_url": "https://api.github.com/users/stickies-v/followers",
        "following_url": "https://api.github.com/users/stickies-v/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/stickies-v/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/stickies-v/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/stickies-v/subscriptions",
        "organizations_url": "https://api.github.com/users/stickies-v/orgs",
        "repos_url": "https://api.github.com/users/stickies-v/repos",
        "events_url": "https://api.github.com/users/stickies-v/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/stickies-v/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-17T16:19:41Z"
    },
    {
      "event": "commented",
      "id": 1435034303,
      "node_id": "IC_kwDOABII585ViOK_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1435034303",
      "actor": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-17T17:53:33Z",
      "updated_at": "2023-02-17T17:53:33Z",
      "author_association": "CONTRIBUTOR",
      "body": "For anyone wanting to review this PR and would like some help with basic mempool concepts, I made a video: https://youtu.be/sQ05azzTp9o -- it mentions 26152 but I think would be helpful for reviewers here as well.",
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1435034303",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "milestoned",
      "id": 8595089840,
      "node_id": "MIE_lADOABII585dZ-4OzwAAAAIATqmw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8595089840",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-23T19:09:28Z",
      "milestone": {
        "title": "25.0"
      }
    },
    {
      "event": "commented",
      "id": 1442452427,
      "node_id": "IC_kwDOABII585V-hPL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1442452427",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-23T21:25:18Z",
      "updated_at": "2023-02-23T21:25:18Z",
      "author_association": "MEMBER",
      "body": "ACK ce882ef0cf338d390733dd85e339a1c0da73072c",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1442452427",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "reviewed",
      "id": 1316134729,
      "node_id": "PRR_kwDOABII585Ocp9J",
      "url": null,
      "actor": null,
      "commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ce882ef0cf338d390733dd85e339a1c0da73072c Some comments for the first commit only (I'll review the other commits soon). Suggestion, mention the name `CalculateCluster()` in this first commit's first line, or somewhere within the commit comment. Also, it might make sense to move the `CalculateCluster` unit test from the third commit to this commit.",
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1316134729",
      "submitted_at": "2023-02-27T19:35:14Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "reviewed",
      "id": 1318211679,
      "node_id": "PRR_kwDOABII585OklBf",
      "url": null,
      "actor": null,
      "commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "Here are a few more, but I'm going to continue to review.",
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1318211679",
      "submitted_at": "2023-03-01T06:46:32Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "reviewed",
      "id": 1319599774,
      "node_id": "PRR_kwDOABII585Op36e",
      "url": null,
      "actor": null,
      "commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "The fuzz targets are looking good but I think we can/should improve the performance. Right now, the input parsing appears to be the bottleneck.",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1319599774",
      "submitted_at": "2023-03-01T11:44:40Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "reviewed",
      "id": 1321674784,
      "node_id": "PRR_kwDOABII585Oxygg",
      "url": null,
      "actor": null,
      "commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1321674784",
      "submitted_at": "2023-03-02T12:08:09Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "reviewed",
      "id": 1321745788,
      "node_id": "PRR_kwDOABII585OyD18",
      "url": null,
      "actor": null,
      "commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1321745788",
      "submitted_at": "2023-03-02T12:41:50Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "reviewed",
      "id": 1322708525,
      "node_id": "PRR_kwDOABII585O1u4t",
      "url": null,
      "actor": null,
      "commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Changes since https://github.com/bitcoin/bitcoin/commit/ce882ef0cf338d390733dd85e339a1c0da73072c:\r\n\r\n- rename `CalculateCluster(…)` to `GatherClusters(…)`, mention function name in commit message\r\n- clarify that `GatherClusters(…)` collects all transactions pertaining to multiple clusters, not just one\r\n- simplified outpoint addition to `m_requested_outpoints_by_txid` in MiniMiner as suggested by @LarryRuane\r\n- prefer `count` over `find` in some spots when we only want to know whether an element appears in a sequence\r\n- fix crash in fuzzer due to creating two identical outpoints\r\n- Remove size reservation for `clustered_txs` when we in fact cannot predict how large it will be",
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1322708525",
      "submitted_at": "2023-03-03T22:28:04Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8664005149,
      "node_id": "HRFPE_lADOABII585dZ-4OzwAAAAIEajod",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8664005149",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-03T22:28:29Z"
    },
    {
      "event": "reviewed",
      "id": 1326000785,
      "node_id": "PRR_kwDOABII585PCSqR",
      "url": null,
      "actor": null,
      "commit_id": "32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "fwiw, \"ACK.\" I have reviewed the code including the latest changes and been running the fuzzers for a couple days",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1326000785",
      "submitted_at": "2023-03-06T12:27:20Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "commented",
      "id": 1456601450,
      "node_id": "IC_kwDOABII585W0flq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1456601450",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-06T17:36:48Z",
      "updated_at": "2023-03-06T17:36:48Z",
      "author_association": "MEMBER",
      "body": "Another crash from the `mini_miner` target:\r\n```\r\nYFxlvAD6+fv7+/8BAADYAAAPZWVlZWVlZV9lZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVl\r\nZWVlZWVlZWUgAGVlEWQX7AjobniKnjZtdcp6KPeFnFv/C89XAtDnqxwRFkNlZWVlZWVlZWVlZWVl\r\nZWVlZWVlZWVlZWVlZWVlZWVlZSVlZWVlZWVlY2VlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVl\r\nZWVlZWVlZWVlZWVlZ2VlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWNtZWVlZWXNUm8gQwAAAGVl\r\nZWVlZWVlZWVlZWVlZWVlZWVlZWVclwAAtf//ZWVlAAAAAAY=\r\n```",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1456601450",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8677670557,
      "node_id": "HRFPE_lADOABII585dZ-4OzwAAAAIFOr6d",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8677670557",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-06T18:45:19Z"
    },
    {
      "event": "commented",
      "id": 1456759368,
      "node_id": "IC_kwDOABII585W1GJI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1456759368",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-06T18:50:17Z",
      "updated_at": "2023-03-06T18:50:17Z",
      "author_association": "MEMBER",
      "body": "Moved rename of `GatherClusters(…)` to the right commit. Looking into the crash of the fuzzer.",
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1456759368",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "reviewed",
      "id": 1326682860,
      "node_id": "PRR_kwDOABII585PE5Ls",
      "url": null,
      "actor": null,
      "commit_id": "7e5ca57996ba629b88e436f0aa1adce759bad64a",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Just started, need to go over it in more detail still. Left few nits.",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1326682860",
      "submitted_at": "2023-03-06T19:40:30Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8679301076,
      "node_id": "HRFPE_lADOABII585dZ-4OzwAAAAIFU5_U",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8679301076",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-06T22:05:27Z"
    },
    {
      "event": "commented",
      "id": 1457092354,
      "node_id": "IC_kwDOABII585W2XcC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1457092354",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-06T22:15:02Z",
      "updated_at": "2023-03-06T22:16:19Z",
      "author_association": "MEMBER",
      "body": "Changes since https://github.com/bitcoin/bitcoin/commit/32123cfc11ad22cdd7fe5ef26ac0550e1ab2fe7b:\r\n- Addressed remaining review from @LarryRuane\r\n- Fixed renaming of GatherClusters(…) being in the wrong commit\r\n- Fixed crash bug surfaced by @dergoegge\r\n- Addressed review by @furszy ",
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1457092354",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "mentioned",
      "id": 8679374548,
      "node_id": "MEE_lADOABII585dZ-4OzwAAAAIFVL7U",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8679374548",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-06T22:15:02Z"
    },
    {
      "event": "subscribed",
      "id": 8679374565,
      "node_id": "SE_lADOABII585dZ-4OzwAAAAIFVL7l",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8679374565",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-06T22:15:02Z"
    },
    {
      "event": "mentioned",
      "id": 8679374584,
      "node_id": "MEE_lADOABII585dZ-4OzwAAAAIFVL74",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8679374584",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-06T22:15:03Z"
    },
    {
      "event": "subscribed",
      "id": 8679374597,
      "node_id": "SE_lADOABII585dZ-4OzwAAAAIFVL8F",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8679374597",
      "actor": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-06T22:15:03Z"
    },
    {
      "event": "mentioned",
      "id": 8679374617,
      "node_id": "MEE_lADOABII585dZ-4OzwAAAAIFVL8Z",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8679374617",
      "actor": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-06T22:15:03Z"
    },
    {
      "event": "subscribed",
      "id": 8679374629,
      "node_id": "SE_lADOABII585dZ-4OzwAAAAIFVL8l",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8679374629",
      "actor": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-06T22:15:03Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8685089126,
      "node_id": "HRFPE_lADOABII585dZ-4OzwAAAAIFq_Fm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8685089126",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-07T12:19:31Z"
    },
    {
      "event": "commented",
      "id": 1458076661,
      "node_id": "IC_kwDOABII585W6Hv1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1458076661",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-07T12:20:34Z",
      "updated_at": "2023-03-07T12:20:34Z",
      "author_association": "MEMBER",
      "body": "Added myself as co-author to some commits per invitation of @glozow ",
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1458076661",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "mentioned",
      "id": 8685098189,
      "node_id": "MEE_lADOABII585dZ-4OzwAAAAIFrBTN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8685098189",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-07T12:20:35Z"
    },
    {
      "event": "subscribed",
      "id": 8685098231,
      "node_id": "SE_lADOABII585dZ-4OzwAAAAIFrBT3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8685098231",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-07T12:20:35Z"
    },
    {
      "event": "reviewed",
      "id": 1332819517,
      "node_id": "PRR_kwDOABII585PcTY9",
      "url": null,
      "actor": null,
      "commit_id": "d227d394cdfc377169888dcf1d9f574f02903065",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "I'm still wrapping my head around this work but left few comments on the way.",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1332819517",
      "submitted_at": "2023-03-09T21:30:58Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "reviewed",
      "id": 1326746650,
      "node_id": "PRR_kwDOABII585PFIwa",
      "url": null,
      "actor": null,
      "commit_id": "d227d394cdfc377169888dcf1d9f574f02903065",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1326746650",
      "submitted_at": "2023-03-09T21:37:46Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "reviewed",
      "id": 1333993280,
      "node_id": "PRR_kwDOABII585Pgx9A",
      "url": null,
      "actor": null,
      "commit_id": "d227d394cdfc377169888dcf1d9f574f02903065",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1333993280",
      "submitted_at": "2023-03-10T00:08:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8713999101,
      "node_id": "HRFPE_lADOABII585dZ-4OzwAAAAIHZRL9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8713999101",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-10T02:01:41Z"
    },
    {
      "event": "commented",
      "id": 1463100208,
      "node_id": "IC_kwDOABII585XNSMw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1463100208",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-10T02:03:52Z",
      "updated_at": "2023-03-10T02:03:52Z",
      "author_association": "MEMBER",
      "body": "Thanks, I’m just seeing the review comments, I will continue looking into them tomorrow. I just pushed a documentation change for `CalculateBumpFees(…)`, after I spent large parts of the day figuring out _why_ the fuzzer had produced a crash and convincing myself that the fix was actually correct.",
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1463100208",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "reviewed",
      "id": 1335963809,
      "node_id": "PRR_kwDOABII585PoTCh",
      "url": null,
      "actor": null,
      "commit_id": "cf1636078f7e97110cab15646110fcc1ce935136",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1335963809",
      "submitted_at": "2023-03-12T04:43:13Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "reviewed",
      "id": 1340199248,
      "node_id": "PRR_kwDOABII585P4dFQ",
      "url": null,
      "actor": null,
      "commit_id": "cf1636078f7e97110cab15646110fcc1ce935136",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1340199248",
      "submitted_at": "2023-03-14T20:10:18Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "reviewed",
      "id": 1340290546,
      "node_id": "PRR_kwDOABII585P4zXy",
      "url": null,
      "actor": null,
      "commit_id": "cf1636078f7e97110cab15646110fcc1ce935136",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "[Changes](https://github.com/bitcoin/bitcoin/compare/e5b382a3db5167c118329f1885660d16e0192d22..730bff20c1f76c46a7ab6c8d981126fe3ad2cec9) between e5b382a3db5167c118329f1885660d16e0192d22 and https://github.com/bitcoin/bitcoin/commit/730bff20c1f76c46a7ab6c8d981126fe3ad2cec9:\r\n\r\n- Addressed review comments by @furszy, @LarryRuane, and @mzumsande. Thanks!\r\n- Added more documentation to `CalculateBumpFee()`\r\n- Moved mempool.exists check to the front to reduce potential calls to `GetConflictTx()`\r\n- Fixed overflow bug in ancestor_package_size accumulator\r\n- Elaborate on `AncestorFeerateComparator`\r\n- Build MiniMinerMempoolEntries with CTransactionRefs instead of copies\r\n- Check in fuzzer that `CalculateTotalBumpFees() <= sum(CalculateBumpFees())`\r\n- Improved documentation for `GatherClusters()`",
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1340290546",
      "submitted_at": "2023-03-14T22:56:15Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8749259258,
      "node_id": "HRFPE_lADOABII585dZ-4OzwAAAAIJfxn6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8749259258",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-14T23:02:05Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8749284272,
      "node_id": "HRFPE_lADOABII585dZ-4OzwAAAAIJf3uw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8749284272",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-14T23:05:43Z"
    },
    {
      "event": "commented",
      "id": 1470194229,
      "node_id": "IC_kwDOABII585XoWI1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1470194229",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-15T15:17:11Z",
      "updated_at": "2023-03-15T15:17:11Z",
      "author_association": "MEMBER",
      "body": "I’ve run both of the fuzz targets for 48-CPU-hours last night, and have not seen another crash bug.",
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1470194229",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "reviewed",
      "id": 1343085715,
      "node_id": "PRR_kwDOABII585QDdyT",
      "url": null,
      "actor": null,
      "commit_id": "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Concept ACK\r\n\r\nI'm wondering if there's a strong need to put zero-bump entries into the `m_bump_fees` map for UTXOs which are not relevant for further processing (i.e. if they are confirmed / not yet submitted to mempool / outputs of a to-be-replaced tx)? If not, here's a suggestion for simplification (note that the used variant of std::map::erase doesn't do any harm if the passed key doesn't exist), non-blocking of course:\r\n```diff\r\ndiff --git a/src/node/mini_miner.cpp b/src/node/mini_miner.cpp\r\nindex a41c8610b..87ee488d9 100644\r\n--- a/src/node/mini_miner.cpp\r\n+++ b/src/node/mini_miner.cpp\r\n@@ -27,8 +27,7 @@ MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& ou\r\n         if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\r\n             // This UTXO is either confirmed or not yet submitted to mempool.\r\n             // If it's confirmed, no bump fee is required.\r\n-            // If it's not yet submitted, we have no information, so return 0.\r\n-            m_bump_fees.emplace(outpoint, 0);\r\n+            // If it's not yet submitted, we have no information.\r\n             continue;\r\n         }\r\n \r\n@@ -76,15 +75,9 @@ MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& ou\r\n             auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\r\n             m_entries.push_back(mapiter);\r\n         } else {\r\n-            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\r\n-            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\r\n-                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\r\n-                // this UTXO is impossible as it will no longer exist after the replacement.\r\n-                for (const auto& outpoint : outpoints_it->second) {\r\n-                    m_bump_fees.emplace(outpoint, 0);\r\n-                }\r\n-                m_requested_outpoints_by_txid.erase(outpoints_it);\r\n-            }\r\n+            // This UTXO is the output of a to-be-replaced transaction. Spending\r\n+            // this UTXO is impossible as it will no longer exist after the replacement.\r\n+            m_requested_outpoints_by_txid.erase(txiter->GetTx().GetHash());\r\n         }\r\n     }\r\n \r\ndiff --git a/src/test/miniminer_tests.cpp b/src/test/miniminer_tests.cpp\r\nindex 1f4c1862a..3e066d621 100644\r\n--- a/src/test/miniminer_tests.cpp\r\n+++ b/src/test/miniminer_tests.cpp\r\n@@ -153,12 +153,7 @@ BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\r\n         auto bump_fees = mini_miner.CalculateBumpFees(feerate);\r\n         BOOST_CHECK(!mini_miner.IsReadyToCalculate());\r\n         BOOST_CHECK(sanity_check(all_transactions, bump_fees));\r\n-        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\r\n-        for (const auto& outpoint: nonexistent_outpoints) {\r\n-            auto it = bump_fees.find(outpoint);\r\n-            BOOST_CHECK(it != bump_fees.end());\r\n-            BOOST_CHECK_EQUAL(it->second, 0);\r\n-        }\r\n+        BOOST_CHECK(bump_fees.size() == 0);\r\n     }\r\n \r\n     // Gather bump fees for all available UTXOs.\r\n```",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1343085715",
      "submitted_at": "2023-03-16T07:50:01Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "commented",
      "id": 1472679470,
      "node_id": "IC_kwDOABII585Xx04u",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1472679470",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-16T20:17:23Z",
      "updated_at": "2023-03-16T20:17:23Z",
      "author_association": "MEMBER",
      "body": "@theStack: Thanks for the suggestion. I tried implementing this and found that it does save the six lines here, but it also required special casing two places downstream in my follow-up PR. While the fixes were simple, I feel that it makes the interface slightly worse for the downstream consumer, so I’m ambivalent on the change.",
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1472679470",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "mentioned",
      "id": 8771738773,
      "node_id": "MEE_lADOABII585dZ-4OzwAAAAIK1hyV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8771738773",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-16T20:17:24Z"
    },
    {
      "event": "subscribed",
      "id": 8771738785,
      "node_id": "SE_lADOABII585dZ-4OzwAAAAIK1hyh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8771738785",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-16T20:17:24Z"
    },
    {
      "event": "review_requested",
      "id": 8808783394,
      "node_id": "RRE_lADOABII585dZ-4OzwAAAAINC14i",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8808783394",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-21T18:00:22Z",
      "requested_reviewer": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 8808784038,
      "node_id": "RRE_lADOABII585dZ-4OzwAAAAINC2Cm",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8808784038",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-21T18:00:27Z",
      "requested_reviewer": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 8808784460,
      "node_id": "RRE_lADOABII585dZ-4OzwAAAAINC2JM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8808784460",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-21T18:00:30Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 8808785470,
      "node_id": "RRRE_lADOABII585dZ-4OzwAAAAINC2Y-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8808785470",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-21T18:00:36Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 8808785500,
      "node_id": "RRE_lADOABII585dZ-4OzwAAAAINC2Zc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8808785500",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-21T18:00:36Z",
      "requested_reviewer": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 8808787595,
      "node_id": "RRE_lADOABII585dZ-4OzwAAAAINC26L",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8808787595",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-21T18:00:50Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "commented",
      "id": 1478541182,
      "node_id": "IC_kwDOABII585YIL9-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1478541182",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-21T20:30:59Z",
      "updated_at": "2023-03-21T20:30:59Z",
      "author_association": "MEMBER",
      "body": "ACK 730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1478541182",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "review_request_removed",
      "id": 8809994339,
      "node_id": "RRRE_lADOABII585dZ-4OzwAAAAINHdhj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8809994339",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-21T20:31:03Z",
      "requested_reviewer": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 8809994348,
      "node_id": "RRRE_lADOABII585dZ-4OzwAAAAINHdhs",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8809994348",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-21T20:31:03Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "reviewed",
      "id": 1353401668,
      "node_id": "PRR_kwDOABII585Qq0VE",
      "url": null,
      "actor": null,
      "commit_id": "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "left few questions, will keep moving",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1353401668",
      "submitted_at": "2023-03-22T21:09:55Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "reviewed",
      "id": 1355048144,
      "node_id": "PRR_kwDOABII585QxGTQ",
      "url": null,
      "actor": null,
      "commit_id": "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1355048144",
      "submitted_at": "2023-03-23T16:41:50Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "reviewed",
      "id": 1355741768,
      "node_id": "PRR_kwDOABII585QzvpI",
      "url": null,
      "actor": null,
      "commit_id": "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1355741768",
      "submitted_at": "2023-03-23T22:13:35Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "reviewed",
      "id": 1355735961,
      "node_id": "PRR_kwDOABII585QzuOZ",
      "url": null,
      "actor": null,
      "commit_id": "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1355735961",
      "submitted_at": "2023-03-23T22:30:12Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "reviewed",
      "id": 1355761439,
      "node_id": "PRR_kwDOABII585Qz0cf",
      "url": null,
      "actor": null,
      "commit_id": "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Left few more comments.\r\n\r\nPlus, while was checking the 1p1c test, couldn't resist myself and made it more friendly https://github.com/furszy/bitcoin-core/commit/5dc4b8957c7a65746666cb5f3e7bd6270b21f8c2. Feel free to take it if you like it.",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1355761439",
      "submitted_at": "2023-03-23T23:31:00Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "reviewed",
      "id": 1355882419,
      "node_id": "PRR_kwDOABII585Q0R-z",
      "url": null,
      "actor": null,
      "commit_id": "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1355882419",
      "submitted_at": "2023-03-24T01:49:26Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "reviewed",
      "id": 1340087246,
      "node_id": "PRR_kwDOABII585P4BvO",
      "url": null,
      "actor": null,
      "commit_id": "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "A few small things, I'll continue to review...",
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1340087246",
      "submitted_at": "2023-03-24T21:57:29Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "reviewed",
      "id": 1357885542,
      "node_id": "PRR_kwDOABII585Q77Bm",
      "url": null,
      "actor": null,
      "commit_id": "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1357885542",
      "submitted_at": "2023-03-25T19:12:10Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDU2NDg0ZjBmZGM0NDI2MWU3MjM1NjNmNTlkZjg4NmQ1YWNkZDg1MWY",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/56484f0fdc44261e723563f59df886d5acdd851f",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/56484f0fdc44261e723563f59df886d5acdd851f",
      "tree": {
        "sha": "354fbe250f28b741424519a6b9118e88dba5317f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/354fbe250f28b741424519a6b9118e88dba5317f"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 354fbe250f28b741424519a6b9118e88dba5317f\nparent 68e484afbbc2e43ad7f2140275cf4e09e45b80ae\nauthor glozow <gloriajzhao@gmail.com> 1645444090 +0000\ncommitter Murch <murch@murch.one> 1679952912 -0400\n\n[mempool] find connected mempool entries with GatherClusters(…)\n\nWe limit GatherClusters’s result to a maximum of 500 transactions as\nclusters can be made arbitrarily large by third parties.\n\nCo-authored-by: Murch <murch@murch.one>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEENfStpiPrn+OjvH72e6A1yluQFxMFAmQiDBAACgkQe6A1yluQ\nFxO8Sw//Vhl62Z7bO3q+/89Sx2LTFC86jqA4fL1AmAkvIx7Jhj/na5YLMCjD1eih\nSU9kJa9YXLU1aDF1YovSaSRjUAFND8Z9UJrZwAv9ZGGHAkNd9La0sJVoOGhRhC60\n/9wVqRrFjlChTejUVqsDZ8d65ronMMBOnUq66Tjv0qiVLcFpS7U998NiCRuVbUec\n57+p9fyzevYNggaopMJ580XgOv/hHX9PMwdtbMMDgEq3XR9kIP+xtRBWbFW5ULjJ\nNK6ANRusSWcVruTM7eW6iB45p6Zg+lhJN79PgfB42KUWPyhNOT9scYY3AiCFsY5I\nsXSmCkkEncenYD9rXCA7KqFg6HuC/nkRTIyDcVV7CKuPcuItIkgOj88M3FFQZsai\nYZHPaH6jPZd2fEsKWkIJ8VS27Lv77u34Rjp+xfdwro/w7+gmGTJOA0OIOfp5iE8s\nugegWM+a1ph1uHdYSVqNUGqTACErwjZHoDouPYkEFwIaYHID9K01QBOgeX2gIG4u\nFSziena33UFhAHK03pMa/dqY43mtBGVR3Tt3qvnIryPGtUsF9cK6NkVRe34ktntD\nfEyZV2OlIoZzGphA1O6KIMYxG9qYrKYC9Z0Md1/y1BhhtRDEzS4YwVTb86ClxYR3\nLK9BToaPZuZ5eQy1y5fr3s1LCm+9Eft3Deo/9JcADar4+JjMX4Q=\n=S7mj\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/68e484afbbc2e43ad7f2140275cf4e09e45b80ae",
          "sha": "68e484afbbc2e43ad7f2140275cf4e09e45b80ae",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/68e484afbbc2e43ad7f2140275cf4e09e45b80ae"
        }
      ],
      "message": "[mempool] find connected mempool entries with GatherClusters(…)\n\nWe limit GatherClusters’s result to a maximum of 500 transactions as\nclusters can be made arbitrarily large by third parties.\n\nCo-authored-by: Murch <murch@murch.one>",
      "committer": {
        "name": "Murch",
        "email": "murch@murch.one",
        "date": "2023-03-27T21:35:12Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2022-02-21T11:48:10Z"
      },
      "sha": "56484f0fdc44261e723563f59df886d5acdd851f"
    },
    {
      "event": "reviewed",
      "id": 1359286170,
      "node_id": "PRR_kwDOABII585RBQ-a",
      "url": null,
      "actor": null,
      "commit_id": "730bff20c1f76c46a7ab6c8d981126fe3ad2cec9",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Addressed feedback of Larry, Furszy, and theStack\r\n\r\n• Removed unnecessary curly braces, unimplemented method header, unnecessary variables in test and code\r\n• Improved explanation around tx5+tx6 in tests\r\n• Removed unnecessary special casing in GatherClusters",
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1359286170",
      "submitted_at": "2023-03-27T21:37:58Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8858691873,
      "node_id": "HRFPE_lADOABII585dZ-4OzwAAAAIQBOkh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8858691873",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-27T21:39:05Z"
    },
    {
      "event": "commented",
      "id": 1485975148,
      "node_id": "IC_kwDOABII585Yki5s",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1485975148",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-27T23:05:05Z",
      "updated_at": "2023-03-27T23:05:05Z",
      "author_association": "MEMBER",
      "body": "> Left few more comments.\r\n> \r\n> Plus, while was checking the 1p1c test, couldn't resist myself and made it more friendly [furszy@5dc4b89](https://github.com/furszy/bitcoin-core/commit/5dc4b8957c7a65746666cb5f3e7bd6270b21f8c2). Feel free to take it if you like it.\r\n\r\nSorry, I was just going through the commits one by one and only rediscovered this suggestion this evening. It looks like there is some good stuff there. I’ll aim to incorporate it shortly, but it might not be tonight.",
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1485975148",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "reviewed",
      "id": 1361682595,
      "node_id": "PRR_kwDOABII585RKaCj",
      "url": null,
      "actor": null,
      "commit_id": "fa8432aeeca39641da6e9bbb9fbf1c52ec5efa72",
      "commit_url": null,
      "created_at": null,
      "author_association": "CONTRIBUTOR",
      "body": "ACK fa8432aeeca39641da6e9bbb9fbf1c52ec5efa72\r\nI code-reviewed pretty carefully, the unit tests pass, but I didn't study the unit or fuzz tests in detail, I'll continue with that (but this PR can merge as is). I also ran both fuzzers on 16 cores each for 8 hours, and had no failures.",
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1361682595",
      "submitted_at": "2023-03-29T05:17:35Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "review_requested",
      "id": 8871981373,
      "node_id": "RRE_lADOABII585dZ-4OzwAAAAIQz7E9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8871981373",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-29T05:17:40Z",
      "requested_reviewer": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "reviewed",
      "id": 1364933315,
      "node_id": "PRR_kwDOABII585RWzrD",
      "url": null,
      "actor": null,
      "commit_id": "fa8432aeeca39641da6e9bbb9fbf1c52ec5efa72",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1364933315",
      "submitted_at": "2023-03-30T11:46:27Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDU5YWZjYzgzNTQ4ZWE2N2E4NjNkYWM3Yjc1ZDAwMGJjOGY2YTcwMjM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/59afcc83548ea67a863dac7b75d000bc8f6a7023",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/59afcc83548ea67a863dac7b75d000bc8f6a7023",
      "tree": {
        "sha": "705f187a3f8300c3202751ac35b76ce67e7a1b4e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/705f187a3f8300c3202751ac35b76ce67e7a1b4e"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 705f187a3f8300c3202751ac35b76ce67e7a1b4e\nparent 56484f0fdc44261e723563f59df886d5acdd851f\nauthor glozow <gloriajzhao@gmail.com> 1659623870 +0100\ncommitter Murch <murch@murch.one> 1680210184 -0400\n\nImplement Mini version of BlockAssembler to calculate mining scores\n\nRewrite the same algo instead of reusing BlockAssembler because we have\na few extra requirements that would make the changes invasive and\ndifficult to review:\n\n- Only operate on the relevant transactions rather than full mempool\n- Remove transactions that will be replaced so they can't bump their ancestors\n- Don't hold mempool lock outside of the constructor\n- Skip things like max block weight and IsFinalTx\n- Additionally calculate fees to bump remaining ancestor packages to target feerate\n\nCo-authored-by: Murch <murch@murch.one>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEENfStpiPrn+OjvH72e6A1yluQFxMFAmQl+QgACgkQe6A1yluQ\nFxO0/RAAu0P2M6fAA/9jNcDWrmwKC/q3aneC7wnAcgiG5nJbMGbwnmqvw4y6FQ9V\nVL29edha+QggfR9W+LT6DSav7BCYyU/FPWYa8owFNY7Ct5VWF4inU3l2IKtZwODh\nOGAO30E1U5SGwHSqSBhfzeZ7O8WdaRwymwgMY33ZLOge5KK3IfZy9dXilPmKos2q\nVXLoy1AaX58d2I6oL0wGvXhMnS7naWZsm62Ws6qvgcH2fg2vSzwK18BWCTDPJ5kY\nK8Qpeq1NpTK1nL0yFgAnCB6hKdm/RPZ1Ws4TdlwD72j1GDW+3aloG3oC8upvdVD/\nqa0KVC3bkvnzs09IqtXdsEfRfFe4EuKXDzWSfUk6L/FIKR2KYIauP3jLumswLOs1\nDQ9baHrkzqb7AJWTkco/ysRrZ7jhV1rA+eXhE8Z4ARkmWr+YBjN8u2cZ5ZnC7ktM\nWIto3h1tjyflaBXwvfLmQkNwPlIWwrwYaieQ2KSuFcr/RQK5lwWIg7pBddsf+Vnu\n41XznkGnVKmP4lX7imDo0WRgYdU+h/0BDL0EFEjCwFY7LnG4cijc9A6ykTBvZUx8\nUctGVh0v94eAkJTMVNn6nSmLmhH2AjcyVrs9+uNJXrLxM5HrpAdcbNuW3SGKP9MW\ng5ksrGe2ki9rpkh2UV7Bg4FH0JUOCLS07QRDN4ZrDipNxWZIV/0=\n=Ivp5\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/56484f0fdc44261e723563f59df886d5acdd851f",
          "sha": "56484f0fdc44261e723563f59df886d5acdd851f",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/56484f0fdc44261e723563f59df886d5acdd851f"
        }
      ],
      "message": "Implement Mini version of BlockAssembler to calculate mining scores\n\nRewrite the same algo instead of reusing BlockAssembler because we have\na few extra requirements that would make the changes invasive and\ndifficult to review:\n\n- Only operate on the relevant transactions rather than full mempool\n- Remove transactions that will be replaced so they can't bump their ancestors\n- Don't hold mempool lock outside of the constructor\n- Skip things like max block weight and IsFinalTx\n- Additionally calculate fees to bump remaining ancestor packages to target feerate\n\nCo-authored-by: Murch <murch@murch.one>",
      "committer": {
        "name": "Murch",
        "email": "murch@murch.one",
        "date": "2023-03-30T21:03:04Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2022-08-04T14:37:50Z"
      },
      "sha": "59afcc83548ea67a863dac7b75d000bc8f6a7023"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8892006061,
      "node_id": "HRFPE_lADOABII585dZ-4OzwAAAAISAT6t",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8892006061",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-30T21:23:48Z"
    },
    {
      "event": "commented",
      "id": 1490986943,
      "node_id": "IC_kwDOABII585Y3qe_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1490986943",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-30T21:26:42Z",
      "updated_at": "2023-03-30T21:36:06Z",
      "author_association": "MEMBER",
      "body": "Pushed the change to make tidy happy.\r\n\r\n@furszy: I put my take on your suggested changes in https://github.com/Xekyo/bitcoin/commits/furszy-minmintests, but I haven’t been able to bring myself to merge it yet, because I was hoping to keep the changes small with the feature freeze on Saturday. Haven’t given up the hope completely yet. (^_^)/\r\nIf I have to touch it up a bit more, I’m thinking to do it, but otherwise maybe in a follow-up?\r\n\r\n----\r\n\r\nEdit: Ah whatever, #27021 doesn’t do much without #26152 anyway, so I’ve pushed the changes inspired by furszy’s refactor of the miniminer-tests as well, since I just touched the file to fix the tidy check anyway.\r\n\r\nSo relevant changes are therefore: \r\nhttps://github.com/bitcoin/bitcoin/compare/fa8432aeeca39641da6e9bbb9fbf1c52ec5efa72..b6e4dafa8de15d97927c4d807091c82b0557c104\r\n",
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1490986943",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "mentioned",
      "id": 8892026951,
      "node_id": "MEE_lADOABII585dZ-4OzwAAAAISAZBH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8892026951",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-30T21:26:43Z"
    },
    {
      "event": "subscribed",
      "id": 8892026965,
      "node_id": "SE_lADOABII585dZ-4OzwAAAAISAZBV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8892026965",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-30T21:26:43Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8892066468,
      "node_id": "HRFPE_lADOABII585dZ-4OzwAAAAISAiqk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8892066468",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-30T21:33:35Z"
    },
    {
      "event": "commented",
      "id": 1497285538,
      "node_id": "IC_kwDOABII585ZPsOi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1497285538",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-05T10:47:38Z",
      "updated_at": "2023-04-05T10:47:38Z",
      "author_association": "MEMBER",
      "body": "> Edit: Ah whatever, https://github.com/bitcoin/bitcoin/pull/27021 doesn’t do much without https://github.com/bitcoin/bitcoin/pull/26152 anyway\r\n\r\nSeeing as this has missed the feature freeze date, I'm removing both from 25.0 milestone (sorry :cry: )",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1497285538",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "demilestoned",
      "id": 8933712990,
      "node_id": "DEME_lADOABII585dZ-4OzwAAAAIUfaRe",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8933712990",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-05T10:47:45Z",
      "milestone": {
        "title": "25.0"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8948965238,
      "node_id": "HRFPE_lADOABII585dZ-4OzwAAAAIVZl92",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8948965238",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-06T19:09:24Z"
    },
    {
      "event": "commented",
      "id": 1499500913,
      "node_id": "IC_kwDOABII585ZYJFx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1499500913",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-06T19:09:48Z",
      "updated_at": "2023-04-06T19:09:48Z",
      "author_association": "MEMBER",
      "body": "Fixed co-authorship attribution to @furszy, no other changes.",
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1499500913",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "mentioned",
      "id": 8948968022,
      "node_id": "MEE_lADOABII585dZ-4OzwAAAAIVZmpW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8948968022",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-06T19:09:48Z"
    },
    {
      "event": "subscribed",
      "id": 8948968039,
      "node_id": "SE_lADOABII585dZ-4OzwAAAAIVZmpn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8948968039",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-06T19:09:48Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDNmM2YyZDU5ZWEyOTQ2YTdiN2NjOGNiMDIyMmZiNjAyZDYyNjQ1ZDA",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3f3f2d59ea2946a7b7cc8cb0222fb602d62645d0",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/3f3f2d59ea2946a7b7cc8cb0222fb602d62645d0",
      "tree": {
        "sha": "9b4001e0954c2454831266e1bcd441416bb3bb8f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9b4001e0954c2454831266e1bcd441416bb3bb8f"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree 9b4001e0954c2454831266e1bcd441416bb3bb8f\nparent 59afcc83548ea67a863dac7b75d000bc8f6a7023\nauthor glozow <gloriajzhao@gmail.com> 1660208319 +0100\ncommitter Murch <murch@murch.one> 1680808534 -0400\n\n[unit test] GatherClusters and MiniMiner unit tests\n\nCo-authored-by: Murch <murch@murch.one>\nCo-authored-by: theStack <sebastian.falbesoner@gmail.com>\nCo-authored-by: furszy <matiasfurszyfer@protonmail.com>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEENfStpiPrn+OjvH72e6A1yluQFxMFAmQvGlgACgkQe6A1yluQ\nFxORrxAAp1EL5J64Gb174LOlzPJmbC234xWfCOF6bvrK4tLzx+4jmrC6X7qFlgj9\nDu+0uA/zuJNBp2XsStiLjJJfZhtfm6CHfw1/QO6DvN5Ycc8O7l1goipwqECkMrVh\nMx8dXQLmJOtsR/fazrTZWfADXCGpFn54eU6a8EGs0K9x43ZoVcr5esZ826jmXe+v\n4fikKrUYXcljwhNJJYSzZRIAx/InYm4ihJClWyssyhINHUKtVzO7mjGTeYs6T/S6\nvZeOLwiirv/wvbDNFeA/J9ZsKG45Fz+oZT3/ixEZd9JjoYQ8E+aBKqq94AQTNypE\nA/jzvWFa6DXIAxNy0MUckZ/HQ54uhA2iyecYztokQEgBEqSQfky+YcwIE4m90Uyt\nsUCEMBaK9FYrSBs83Mo+DgfWkdkhWiiMGX0dYrnQrzEX06gJKAv952eyBVs9SYEQ\n5ujj4v5WZ3193ypmPuUJbtXbehBpsZZ7TE4Y1RGwlrLp9RNIOBdMDC0KcSsBOF3k\nBiuxV7Q7kCopIC2KBZVDNNajXOeA8JcBOPZEL0AYO1NkpS8XHht8Q4Qyabm+k/BK\nUnvQjBXxwr4MBTs/mpZCgpAGTVW74hjQmYlrn/4mfQ9OilxVQoaeGt9qQMkUhu+4\nS5/q3uAusLKTPiFKgCN1dODs4OWejmrQLuh2ZXeqS3nW2RSh13o=\n=z7wT\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/59afcc83548ea67a863dac7b75d000bc8f6a7023",
          "sha": "59afcc83548ea67a863dac7b75d000bc8f6a7023",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/59afcc83548ea67a863dac7b75d000bc8f6a7023"
        }
      ],
      "message": "[unit test] GatherClusters and MiniMiner unit tests\n\nCo-authored-by: Murch <murch@murch.one>\nCo-authored-by: theStack <sebastian.falbesoner@gmail.com>\nCo-authored-by: furszy <matiasfurszyfer@protonmail.com>",
      "committer": {
        "name": "Murch",
        "email": "murch@murch.one",
        "date": "2023-04-06T19:15:34Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2022-08-11T08:58:39Z"
      },
      "sha": "3f3f2d59ea2946a7b7cc8cb0222fb602d62645d0"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDZiNjA1YjkxYzFmYWYyYzdmN2NjMGM5ZDM5YjRmY2ZkNjZkYzI5NjU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "tree": {
        "sha": "fba2ac3d51c419bf8a5028d358876ac12e063dbc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fba2ac3d51c419bf8a5028d358876ac12e063dbc"
      },
      "verification": {
        "verified": true,
        "reason": "valid",
        "payload": "tree fba2ac3d51c419bf8a5028d358876ac12e063dbc\nparent 3f3f2d59ea2946a7b7cc8cb0222fb602d62645d0\nauthor glozow <gloriajzhao@gmail.com> 1676561504 +0000\ncommitter Murch <murch@murch.one> 1680808539 -0400\n\n[fuzz] Add MiniMiner target + diff fuzz against BlockAssembler\n\nCo-authored-by: dergoegge <n.goeggi@gmail.com>\nCo-authored-by: mzumsande <mzumsande@gmail.com>\nCo-authored-by: Murch <murch@murch.one>\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEENfStpiPrn+OjvH72e6A1yluQFxMFAmQvGlsACgkQe6A1yluQ\nFxP0DQ//XdYZQ1gAcnjmAR03UUFfL8LRXUWrSTBmYAQUtBqDregxgQWiIEAOFZ7Y\nm/XtH4pw35yw+zBB73XDzEBqx886JN3/Mt8NG67e241klcjLNuz0j0dVSPeRoLgQ\nPHzqpCRw/N1w1cFVqjIAtf/3PE8hThw6WaJ1u39Wqv9C6epqQQVNx9UGSwr9eO0C\nJLV/q5TGDKnWyyQlhJsZJ21ocqUa7tTo8nwCdGTZb8tIQ6kzxSHtPvE0O+9Cf0Br\nVZWGzXDESEvRo/WL5ERUn5HEbedY1IJmGPDQG6NmD7EWlGrxPR0uvl9HAqVHLHZq\nM9f2PYYsPzTS5rGzLEQSPMuP/JsRprmEnXAXGmDWk+0KKfMhBtj4dnO7cbvdRtus\nlF5V+wkcJFRAtVlsvzfWm032pA3L9FG/wE+FqkU/huTm+OzkTtTifnCQG18EzF9V\nCeDGpgRHKx7ScVQZcctOT+gCJBIZda69cP+oSZcxJ0M7dVZSSv/CxAy65q/1ourv\nuQ4HrKEUj1qIBoyegRPeWwc42Pwu6ZuDHfkCTZd0snchYlr1eopC+C7FgGeVqCRD\nqlGdxOCSXR+veGH/23bSpAjVPb+O0K0mkXrJot0RWJ9b1XHV8tmexiZx/nkB/t+z\nlouUHnlSL6tGvF1m4P2pKzWJ9Wt50naK6akaPxbP/UU+M5jGCE8=\n=ekm5\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3f3f2d59ea2946a7b7cc8cb0222fb602d62645d0",
          "sha": "3f3f2d59ea2946a7b7cc8cb0222fb602d62645d0",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/3f3f2d59ea2946a7b7cc8cb0222fb602d62645d0"
        }
      ],
      "message": "[fuzz] Add MiniMiner target + diff fuzz against BlockAssembler\n\nCo-authored-by: dergoegge <n.goeggi@gmail.com>\nCo-authored-by: mzumsande <mzumsande@gmail.com>\nCo-authored-by: Murch <murch@murch.one>",
      "committer": {
        "name": "Murch",
        "email": "murch@murch.one",
        "date": "2023-04-06T19:15:39Z"
      },
      "author": {
        "name": "glozow",
        "email": "gloriajzhao@gmail.com",
        "date": "2023-02-16T15:31:44Z"
      },
      "sha": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8949007731,
      "node_id": "HRFPE_lADOABII585dZ-4OzwAAAAIVZwVz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8949007731",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-04-06T19:16:00Z"
    },
    {
      "event": "commented",
      "id": 1533510937,
      "node_id": "IC_kwDOABII585bZ4UZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1533510937",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-03T18:27:43Z",
      "updated_at": "2023-05-03T18:27:43Z",
      "author_association": "MEMBER",
      "body": "ACK 6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1533510937",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "review_request_removed",
      "id": 9158714415,
      "node_id": "RRRE_lADOABII585dZ-4OzwAAAAIh5uQv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9158714415",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-03T18:27:49Z",
      "requested_reviewer": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 9158714526,
      "node_id": "RRE_lADOABII585dZ-4OzwAAAAIh5uSe",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9158714526",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-03T18:27:50Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 9185499128,
      "node_id": "RRE_lADOABII585dZ-4OzwAAAAIjf5f4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9185499128",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-08T01:38:50Z",
      "requested_reviewer": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 9185499282,
      "node_id": "RRE_lADOABII585dZ-4OzwAAAAIjf5iS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9185499282",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-08T01:38:52Z",
      "requested_reviewer": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 9185499600,
      "node_id": "RRE_lADOABII585dZ-4OzwAAAAIjf5nQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9185499600",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-08T01:38:58Z",
      "requested_reviewer": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "reviewed",
      "id": 1417018318,
      "node_id": "PRR_kwDOABII585UdfvO",
      "url": null,
      "actor": null,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "ACK 6b605b91 modulo `miniminer_overlap` test.\r\n\r\nNot really blocking, I'm planning to go deeper later. And probably add some explanatory comments and code simplifications. I think that has a readability barrier that will be a maintenance issue moving forward. ",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1417018318",
      "submitted_at": "2023-05-08T15:24:12Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "review_request_removed",
      "id": 9191658499,
      "node_id": "RRRE_lADOABII585dZ-4OzwAAAAIj3ZQD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9191658499",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-08T15:24:18Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 9191658619,
      "node_id": "RRE_lADOABII585dZ-4OzwAAAAIj3ZR7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9191658619",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-08T15:24:18Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 9191937647,
      "node_id": "RRRE_lADOABII585dZ-4OzwAAAAIj4dZv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9191937647",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-08T15:57:15Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 9191937771,
      "node_id": "RRE_lADOABII585dZ-4OzwAAAAIj4dbr",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9191937771",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-08T15:57:15Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "reviewed",
      "id": 1419015473,
      "node_id": "PRR_kwDOABII585UlHUx",
      "url": null,
      "actor": null,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Looks good to me overall, planning to do another review round within the next days.\r\n\r\nFor the `miniminer_overlap` test, I crafted some diagram and (ancestor) fee-rate calculation notes to get a better picture what's going on there in the mempool; will just dump it here, maybe it helps other reviewers or it even makes sense to include the diagram in a follow-up.\r\n\r\n```\r\nTx graph for `miniminer_overlap` unit test:\r\n\r\n   coinbase_tx [mined]        ... block-chain\r\n-------------------------------------------------\r\n    /   |   \\          \\      ... mempool\r\n   /    |    \\         |\r\n tx1   tx2   tx3      tx5\r\n[low] [med] [high]   [high]\r\n   \\    |    /         |\r\n    \\   |   /         tx6\r\n     \\  |  /         [low]\r\n       tx4          /     \\\r\n      [high]       tx7    tx8\r\n                  [med]  [high]\r\n\r\nNOTE:\r\n-> \"low\"/\"med\"/\"high\" denote the _absolute_ fee of each tx\r\n-> tx4 has 3 unspent ouputs, all other txs have 1 unspent output\r\n-> tx4's fee-rate is lower than tx3's, as tx4 has more weight (due to having more outputs)\r\n\r\n-> tx3_FR = high / tx3_vsize\r\n-> tx4_FR = high / tx4_vsize\r\n-> tx4_ASFR = (low+med+high+high) / (tx1_vsize + tx2_vsize + tx3_vsize + tx4_vsize)\r\n-> tx5_FR = high / tx5_vsize\r\n-> tx7_ASFR = (high+low+med) / (tx5_vsize + tx6_vsize + tx7_vsize)\r\n-> tx8_ASFR = (high+low+high) / (tx5_vsize + tx6_vsize + tx8_vsize)\r\n```\r\n\r\nAlso left some nits below.",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1419015473",
      "submitted_at": "2023-05-09T17:41:41Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "review_request_removed",
      "id": 9203397622,
      "node_id": "RRRE_lADOABII585dZ-4OzwAAAAIkkLP2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9203397622",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-09T17:41:45Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 9203397732,
      "node_id": "RRE_lADOABII585dZ-4OzwAAAAIkkLRk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9203397732",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-09T17:41:45Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 9203398138,
      "node_id": "RRRE_lADOABII585dZ-4OzwAAAAIkkLX6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9203398138",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-09T17:41:48Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 9203398243,
      "node_id": "RRE_lADOABII585dZ-4OzwAAAAIkkLZj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9203398243",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-09T17:41:49Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "reviewed",
      "id": 1428805458,
      "node_id": "PRR_kwDOABII585VKddS",
      "url": null,
      "actor": null,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Code-review ACK 6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1428805458",
      "submitted_at": "2023-05-16T15:02:35Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
    },
    {
      "event": "review_request_removed",
      "id": 9259299232,
      "node_id": "RRRE_lADOABII585dZ-4OzwAAAAIn5bGg",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9259299232",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-16T15:02:42Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 9259299403,
      "node_id": "RRE_lADOABII585dZ-4OzwAAAAIn5bJL",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9259299403",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-16T15:02:43Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "commented",
      "id": 1550491250,
      "node_id": "IC_kwDOABII585cap5y",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1550491250",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-16T23:42:06Z",
      "updated_at": "2023-05-17T02:25:48Z",
      "author_association": "MEMBER",
      "body": "Super, thanks for the review, @theStack. As I already have a follow-up PR with #26152, since this PR has three ACKs now, and all the open comments are nits, I would like to include those changes as a new commit in the follow-up #26152.\r\n\r\nWhat do you think, @glozow?",
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1550491250",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "mentioned",
      "id": 9263286454,
      "node_id": "MEE_lADOABII585dZ-4OzwAAAAIoIoi2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9263286454",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-16T23:42:07Z"
    },
    {
      "event": "subscribed",
      "id": 9263286467,
      "node_id": "SE_lADOABII585dZ-4OzwAAAAIoIojD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9263286467",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-16T23:42:07Z"
    },
    {
      "event": "mentioned",
      "id": 9263286479,
      "node_id": "MEE_lADOABII585dZ-4OzwAAAAIoIojP",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9263286479",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-16T23:42:07Z"
    },
    {
      "event": "subscribed",
      "id": 9263286486,
      "node_id": "SE_lADOABII585dZ-4OzwAAAAIoIojW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9263286486",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-16T23:42:07Z"
    },
    {
      "event": "review_request_removed",
      "id": 9263286633,
      "node_id": "RRRE_lADOABII585dZ-4OzwAAAAIoIolp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9263286633",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-16T23:42:10Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 9263286669,
      "node_id": "RRE_lADOABII585dZ-4OzwAAAAIoIomN",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9263286669",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-16T23:42:11Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_request_removed",
      "id": 9263981610,
      "node_id": "RRRE_lADOABII585dZ-4OzwAAAAIoLSQq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9263981610",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-17T02:25:52Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 9263981659,
      "node_id": "RRE_lADOABII585dZ-4OzwAAAAIoLSRb",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9263981659",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-17T02:25:53Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "commented",
      "id": 1550595711,
      "node_id": "IC_kwDOABII585cbDZ_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1550595711",
      "actor": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-17T02:26:29Z",
      "updated_at": "2023-05-17T02:26:29Z",
      "author_association": "MEMBER",
      "body": "> ACK [6b605b9](https://github.com/bitcoin/bitcoin/commit/6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965) modulo `miniminer_overlap` test.\r\n> \r\n> Not really blocking, I'm planning to go deeper later. And probably add some explanatory comments and code simplifications. I think that has a readability barrier that will be a maintenance issue moving forward.\r\n\r\nPerhaps we can address that in #26152 as well",
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1550595711",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "review_request_removed",
      "id": 9263984357,
      "node_id": "RRRE_lADOABII585dZ-4OzwAAAAIoLS7l",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9263984357",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-17T02:26:32Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 9263984407,
      "node_id": "RRE_lADOABII585dZ-4OzwAAAAIoLS8X",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9263984407",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-17T02:26:33Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "assigned",
      "id": 9267806005,
      "node_id": "AE_lADOABII585dZ-4OzwAAAAIoZ381",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9267806005",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-17T10:59:25Z",
      "assignee": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "commented",
      "id": 1551366404,
      "node_id": "IC_kwDOABII585cd_kE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1551366404",
      "actor": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-17T13:10:41Z",
      "updated_at": "2023-05-17T13:10:41Z",
      "author_association": "MEMBER",
      "body": "> > ACK [6b605b9](https://github.com/bitcoin/bitcoin/commit/6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965) modulo `miniminer_overlap` test.\r\n> > Not really blocking, I'm planning to go deeper later. And probably add some explanatory comments and code simplifications. I think that has a readability barrier that will be a maintenance issue moving forward.\r\n> \r\n> Perhaps we can address that in #26152 as well\r\n\r\nAbsolutely. Loved @theStack diagram.",
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1551366404",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "mentioned",
      "id": 9269235844,
      "node_id": "MEE_lADOABII585dZ-4OzwAAAAIofVCE",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9269235844",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-17T13:10:41Z"
    },
    {
      "event": "subscribed",
      "id": 9269235862,
      "node_id": "SE_lADOABII585dZ-4OzwAAAAIofVCW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9269235862",
      "actor": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-17T13:10:41Z"
    },
    {
      "event": "review_request_removed",
      "id": 9269236478,
      "node_id": "RRRE_lADOABII585dZ-4OzwAAAAIofVL-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9269236478",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-17T13:10:45Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "review_requested",
      "id": 9269236636,
      "node_id": "RRE_lADOABII585dZ-4OzwAAAAIofVOc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9269236636",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-17T13:10:46Z",
      "requested_reviewer": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "review_requester": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      }
    },
    {
      "event": "merged",
      "id": 9289959475,
      "node_id": "ME_lADOABII585dZ-4OzwAAAAIpuYgz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9289959475",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "0f8c95dccd120ad5fd371f81025137b855796f13",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0f8c95dccd120ad5fd371f81025137b855796f13",
      "created_at": "2023-05-19T14:28:06Z"
    },
    {
      "event": "closed",
      "id": 9289959529,
      "node_id": "CE_lADOABII585dZ-4OzwAAAAIpuYhp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9289959529",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-19T14:28:07Z"
    },
    {
      "event": "commented",
      "id": 1554675156,
      "node_id": "IC_kwDOABII585cqnXU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1554675156",
      "actor": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-19T14:28:48Z",
      "updated_at": "2023-05-19T14:29:18Z",
      "author_association": "MEMBER",
      "body": "> As I already have a follow-up PR with https://github.com/bitcoin/bitcoin/pull/26152, since this PR has three ACKs now, and all the open comments are nits, I would like to include those changes as a new commit in the follow-up https://github.com/bitcoin/bitcoin/pull/26152.\r\n\r\nYep, I'll look for these in #26152:\r\nhttps://github.com/bitcoin/bitcoin/pull/27021#discussion_r1188846506\r\nhttps://github.com/bitcoin/bitcoin/pull/27021#discussion_r1188865405\r\nhttps://github.com/bitcoin/bitcoin/pull/27021#discussion_r1188884884\r\nhttps://github.com/bitcoin/bitcoin/pull/27021#discussion_r1188935619\r\nhttps://github.com/bitcoin/bitcoin/pull/27021#pullrequestreview-1417018318",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1554675156",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    },
    {
      "event": "referenced",
      "id": 9292008884,
      "node_id": "REFE_lADOABII585dZ-4OzwAAAAIp2M20",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9292008884",
      "actor": {
        "login": "sidhujag",
        "id": 6238042,
        "node_id": "MDQ6VXNlcjYyMzgwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6238042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sidhujag",
        "html_url": "https://github.com/sidhujag",
        "followers_url": "https://api.github.com/users/sidhujag/followers",
        "following_url": "https://api.github.com/users/sidhujag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sidhujag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sidhujag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sidhujag/subscriptions",
        "organizations_url": "https://api.github.com/users/sidhujag/orgs",
        "repos_url": "https://api.github.com/users/sidhujag/repos",
        "events_url": "https://api.github.com/users/sidhujag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sidhujag/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "dbb3e9a78b70578a3eb0fa0b83b93f1b82d8f1be",
      "commit_url": "https://api.github.com/repos/syscoin/syscoin/commits/dbb3e9a78b70578a3eb0fa0b83b93f1b82d8f1be",
      "created_at": "2023-05-19T19:01:03Z"
    },
    {
      "event": "referenced",
      "id": 9292167657,
      "node_id": "REFE_lADOABII585dZ-4OzwAAAAIp2znp",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/9292167657",
      "actor": {
        "login": "sidhujag",
        "id": 6238042,
        "node_id": "MDQ6VXNlcjYyMzgwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6238042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sidhujag",
        "html_url": "https://github.com/sidhujag",
        "followers_url": "https://api.github.com/users/sidhujag/followers",
        "following_url": "https://api.github.com/users/sidhujag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sidhujag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sidhujag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sidhujag/subscriptions",
        "organizations_url": "https://api.github.com/users/sidhujag/orgs",
        "repos_url": "https://api.github.com/users/sidhujag/repos",
        "events_url": "https://api.github.com/users/sidhujag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sidhujag/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "0f6d450b2bdc3a622bc74412500b1cd5e574e9fd",
      "commit_url": "https://api.github.com/repos/syscoin/syscoin/commits/0f6d450b2bdc3a622bc74412500b1cd5e574e9fd",
      "created_at": "2023-05-19T19:24:49Z"
    },
    {
      "event": "commented",
      "id": 1568242621,
      "node_id": "IC_kwDOABII585deXu9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1568242621",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-05-30T11:10:23Z",
      "updated_at": "2023-05-30T11:10:23Z",
      "author_association": "MEMBER",
      "body": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=59285",
      "user": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#issuecomment-1568242621",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/27021"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1095658967",
      "pull_request_review_id": 1282756155,
      "id": 1095658967,
      "node_id": "PRRC_kwDOABII585BTm3X",
      "diff_hunk": "@@ -1140,3 +1153,47 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    // Reserve total ancestor + descendant counts of each transaction.  This is an approximation; it\n+    // may overestimate because transactions may share ancestors/descendants, and may underestimate\n+    // because the cluster may include more than just ancestors and descendants.\n+    cluster.reserve(std::accumulate(cluster.cbegin(), cluster.cend(), 0, [](size_t sum, const auto it) {\n+        return sum + it->GetCountWithAncestors() + it->GetCountWithDescendants() - 1; }));\n+    {\n+        // Use epoch: visiting an entry means we have added it to the cluster vector. It does not\n+        // necessarily mean the entry has been processed.\n+        WITH_FRESH_EPOCH(m_epoch);\n+        for (const auto& it : cluster) {\n+            visited(it);\n+        }\n+        // i = index of where the list of entries to process starts\n+        for (size_t i{0}, to_process_count{txids.size()}; i < to_process_count; ++i) {\n+            for (const CTxMemPoolEntry& parent_entry : cluster.at(i)->GetMemPoolParentsConst()) {\n+                const auto parent_it = mapTx.iterator_to(parent_entry);\n+                if (!visited(parent_it)) {\n+                    cluster.push_back(parent_it);\n+                    // we still need to process this\n+                    ++to_process_count;",
      "path": "src/txmempool.cpp",
      "position": null,
      "original_position": 69,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "daf023a49ce812417a36ec201e19d4272abc790a",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "(IIRC we discussed this offline a while ago) We probably want to check here that `to_process_count` doesn't get too large. It's not really feasible to run MiniMiner with a cluster == entire mempool...\r\nPerhaps add a check here so that if we see a cluster size > 1000 (or something), we maybe want to tell the wallet to calculate bump fees in batches, maybe look at fewer UTXOS, or some kind of safe fallback.",
      "created_at": "2023-02-03T10:43:45Z",
      "updated_at": "2023-02-03T10:47:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1095658967",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1095658967"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1119099044",
      "pull_request_review_id": 1316134729,
      "id": 1119099044,
      "node_id": "PRRC_kwDOABII585CtBik",
      "diff_hunk": "@@ -898,6 +899,19 @@ CTxMemPool::setEntries CTxMemPool::GetIterSet(const std::set<uint256>& hashes) c\n     return ret;\n }\n \n+std::vector<CTxMemPool::txiter> CTxMemPool::GetIterVec(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> ret;\n+    ret.reserve(txids.size());\n+    for (const auto& txid : txids) {\n+        const auto it{GetIter(txid)};\n+        if (!it) return {};\n+        ret.push_back(*it);",
      "path": "src/txmempool.cpp",
      "position": 20,
      "original_position": 20,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit\r\n```suggestion\r\n        ret.push_back(it.value());\r\n```\r\nThis may help the reader know that `it` is a `std::optional`; at first, I thought `GetIter()` may be returning a pointer. But if you prefer `*`, which is more concise, that's fine too.",
      "created_at": "2023-02-27T17:57:35Z",
      "updated_at": "2023-02-27T19:35:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1119099044",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1119099044"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 910,
      "original_line": 910,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1119107935",
      "pull_request_review_id": 1316134729,
      "id": 1119107935,
      "node_id": "PRRC_kwDOABII585CtDtf",
      "diff_hunk": "@@ -898,6 +899,19 @@ CTxMemPool::setEntries CTxMemPool::GetIterSet(const std::set<uint256>& hashes) c\n     return ret;\n }\n \n+std::vector<CTxMemPool::txiter> CTxMemPool::GetIterVec(const std::vector<uint256>& txids) const",
      "path": "src/txmempool.cpp",
      "position": 12,
      "original_position": 12,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nstd::optional<std::vector<CTxMemPool::txiter>> CTxMemPool::GetIterVec(const std::vector<uint256>& txids) const\r\n```\r\nWould this be better than giving a special meaning to an empty vector? I'm unsure, but may be worth considering.",
      "created_at": "2023-02-27T18:05:53Z",
      "updated_at": "2023-02-27T19:35:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1119107935",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1119107935"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 902,
      "original_line": 902,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1119109899",
      "pull_request_review_id": 1316134729,
      "id": 1119109899,
      "node_id": "PRRC_kwDOABII585CtEML",
      "diff_hunk": "@@ -1140,3 +1153,49 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const",
      "path": "src/txmempool.cpp",
      "position": null,
      "original_position": 41,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\nstd::optional<std::vector<CTxMemPool::txiter>> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\r\n```",
      "created_at": "2023-02-27T18:07:58Z",
      "updated_at": "2023-02-27T19:35:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1119109899",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1119109899"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1157,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1119134160",
      "pull_request_review_id": 1316134729,
      "id": 1119134160,
      "node_id": "PRRC_kwDOABII585CtKHQ",
      "diff_hunk": "@@ -1140,3 +1153,49 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};",
      "path": "src/txmempool.cpp",
      "position": null,
      "original_position": 48,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "aad0c09ab6fb38e6d0a3e4d9eb764d84a2913f15",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Should this function return `std::nullopt` instead?",
      "created_at": "2023-02-27T18:28:45Z",
      "updated_at": "2023-02-27T19:35:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1119134160",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1119134160"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1165,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1119202243",
      "pull_request_review_id": 1316134729,
      "id": 1119202243,
      "node_id": "PRRC_kwDOABII585CtavD",
      "diff_hunk": "@@ -1140,3 +1153,49 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    // Reserve total ancestor + descendant counts of each transaction.  This is an approximation; it\n+    // may overestimate because transactions may share ancestors/descendants, and may underestimate\n+    // because the cluster may include more than just ancestors and descendants.\n+    cluster.reserve(std::accumulate(cluster.cbegin(), cluster.cend(), 0, [](size_t sum, const auto it) {\n+        return sum + it->GetCountWithAncestors() + it->GetCountWithDescendants() - 1; }));",
      "path": "src/txmempool.cpp",
      "position": null,
      "original_position": 54,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm concerned about the possible over-estimation here. In theory, there could be a combinatorial explosion if the DAG is highly interconnected and deep. I would consider removing this code, because vector `push_back()` is highly optimized when growth is needed. Or at least make sure there's a problem before adding this optimization.\r\n\r\nIf you do keep this, consider calling `cluster.shrink_to_fit()` before returning, so at least any high memory usage is temporary.",
      "created_at": "2023-02-27T19:20:02Z",
      "updated_at": "2023-02-27T19:35:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1119202243",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1119202243"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 1166,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1170,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1120543538",
      "pull_request_review_id": 1318211679,
      "id": 1120543538,
      "node_id": "PRRC_kwDOABII585CyiMy",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 1,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n// Copyright (c) 2023 The Bitcoin Core developers\r\n```",
      "created_at": "2023-02-28T18:00:17Z",
      "updated_at": "2023-03-01T06:46:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1120543538",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1120543538"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1120948639",
      "pull_request_review_id": 1318211679,
      "id": 1120948639,
      "node_id": "PRRC_kwDOABII585C0FGf",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 52,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nit, more efficient to not make a copy\r\n```suggestion\r\n                std::vector<COutPoint> outpoints_of_tx({outpoint});\r\n                m_requested_outpoints_by_txid.emplace(outpoint.hash, std::move(outpoints_of_tx));\r\n```\r\nor (I didn't test this, but I'm pretty sure that since the vector argument is an rvalue, the compiler will do a move)\r\n```suggestion\r\n                m_requested_outpoints_by_txid.emplace(outpoint.hash, std::vector<COutPoint>{outpoint});\r\n```",
      "created_at": "2023-02-28T23:58:17Z",
      "updated_at": "2023-03-01T06:46:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1120948639",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1120948639"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 51,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 52,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1120964573",
      "pull_request_review_id": 1318211679,
      "id": 1120964573,
      "node_id": "PRRC_kwDOABII585C0I_d",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 53,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nit, simpler. I don't know if the comment is necessary (the reader is expected to know this about maps), but it may help to document that we're taking advantage of that behavior.\r\n\r\nThe developer notes do [say](https://github.com/bitcoin/bitcoin/blob/master/doc/developer-notes.md#c-data-structures) not to use the `std::map []` syntax, but only for reading.\r\n```suggestion\r\n            // This creates the map entry if it doesn't already exist.\r\n            m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\r\n```",
      "created_at": "2023-03-01T00:22:44Z",
      "updated_at": "2023-03-01T06:46:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1120964573",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1120964573"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 47,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1120992192",
      "pull_request_review_id": 1318211679,
      "id": 1120992192,
      "node_id": "PRRC_kwDOABII585C0PvA",
      "diff_hunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_MINI_MINER_H\n+#define BITCOIN_NODE_MINI_MINER_H\n+\n+#include <txmempool.h>\n+\n+#include <memory>\n+#include <optional>\n+#include <stdint.h>\n+\n+namespace node {\n+\n+// Container for tracking updates to ancestor feerate as we include ancestors in the \"block\"\n+class MiniMinerMempoolEntry\n+{\n+    const CAmount fee_individual;\n+    const CTransaction tx;\n+    const int64_t vsize_individual;\n+\n+// This class must be constructed while holding mempool.cs. After construction, the object's\n+// methods can be called without holding that lock.\n+public:\n+    CAmount fee_with_ancestors;\n+    int64_t vsize_with_ancestors;\n+    explicit MiniMinerMempoolEntry(CTxMemPool::txiter entry) :\n+        fee_individual{entry->GetModifiedFee()},\n+        tx{entry->GetTx()},\n+        vsize_individual(entry->GetTxSize()),\n+        fee_with_ancestors{entry->GetModFeesWithAncestors()},\n+        vsize_with_ancestors(entry->GetSizeWithAncestors())\n+    { }\n+\n+    CAmount GetModifiedFee() const { return fee_individual; }\n+    CAmount GetModFeesWithAncestors() const { return fee_with_ancestors; }\n+    int64_t GetTxSize() const { return vsize_individual; }\n+    int64_t GetSizeWithAncestors() const { return vsize_with_ancestors; }\n+    const CTransaction& GetTx() const LIFETIMEBOUND { return tx; }\n+};\n+\n+void UpdateForMinedAncestor(const MiniMinerMempoolEntry& ancestor, const MiniMinerMempoolEntry& descendant);\n+\n+// Comparator needed for std::set<MockEntryMap::iterator>\n+struct IteratorComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const\n+    {\n+        return &(*a) < &(*b);\n+    }\n+};\n+\n+/** A minimal version of BlockAssembler. Allows us to run the mining algorithm on a subset of\n+ * mempool transactions, ignoring consensus rules, to calculate mining scores. */\n+class MiniMiner\n+{\n+    // When true, a caller may use CalculateBumpFees(). Becomes false if we failed to retrieve\n+    // mempool entries (i.e. cluster size too large) or bump fees have already been calculated.\n+    bool m_ready_to_calculate{true};\n+\n+    // Original outpoints requested\n+    std::vector<COutPoint> m_requested_outpoints;\n+\n+    // Set once per lifetime, fill in during initialization.\n+    // txids of to-be-replaced transactions\n+    std::set<uint256> m_to_be_replaced;",
      "path": "src/node/mini_miner.h",
      "position": 63,
      "original_position": 68,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not a bug, but I noticed that the only reference to `m_to_be_replaced` outside the constructor is an `Assume` in `SanityCheck()`, I wonder if it's worth `m_to_be_replaced` being a class member. If we give up the `Assume`, which doesn't seem to be doing that much heavy lifting, then `m_to_be_replaced` could be a local variable in the constructor.\r\n\r\nAnother nice thing about making `m_to_be_replaced` a local variable is that its entries can be pointers to transactions, instead of entire txid hashes. I wanted to make sure that would work, so here's a patch that does that and passes the tests. (It includes my other suggestions for the constructor, because I wanted to test all of them.)\r\n\r\n<details>\r\n<summary>patch, click to expand</summary>\r\n\r\n```diff\r\n--- a/src/node/mini_miner.cpp\r\n+++ b/src/node/mini_miner.cpp\r\n@@ -21,6 +21,7 @@ MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& ou\r\n {\r\n     LOCK(mempool.cs);\r\n     m_requested_outpoints = outpoints;\r\n+    std::set<const CTransaction*> to_be_replaced;\r\n     // Find which outpoints to calculate bump fees for.\r\n     // Anything that's spent by the mempool is to-be-replaced\r\n     // Anything otherwise unavailable just has a bump fee of 0\r\n@@ -32,25 +33,19 @@ MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& ou\r\n             // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\r\n             // removing the to-be-replaced entries. Note that this is only calculating bump fees.\r\n             // RBF fee rules should be handled separately.\r\n-            m_to_be_replaced.insert(ptx->GetHash());\r\n+            to_be_replaced.insert(ptx);\r\n             // Remove descendants because they will be replaced as well. This case should be rare\r\n             // as the wallet won't normally attempt to replace transactions with descendants.\r\n             CTxMemPool::setEntries descendants;\r\n             mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\r\n             for (const auto& desc_txiter : descendants) {\r\n-                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\r\n+                to_be_replaced.insert(&desc_txiter->GetTx());\r\n             }\r\n         }\r\n \r\n         if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\r\n             // This UTXO is unconfirmed and in the mempool.\r\n-            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\r\n-            if (it != m_requested_outpoints_by_txid.end()) {\r\n-                it->second.push_back(outpoint);\r\n-            } else {\r\n-                std::vector<COutPoint> outpoints_of_tx({outpoint});\r\n-                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\r\n-            }\r\n+            m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\r\n         } else {\r\n             // This UTXO is either confirmed or not yet submitted to mempool.\r\n             // If it's confirmed, no bump fee is required.\r\n@@ -77,7 +72,7 @@ MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& ou\r\n \r\n     // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\r\n     for (const auto& txiter : cluster) {\r\n-        if (m_to_be_replaced.find(txiter->GetTx().GetHash()) == m_to_be_replaced.end()) {\r\n+        if (to_be_replaced.find(&txiter->GetTx()) == to_be_replaced.end()) {\r\n             auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\r\n             m_entries.push_back(mapiter);\r\n         } else {\r\n@@ -95,18 +90,19 @@ MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& ou\r\n \r\n     // Build the m_descendant_set_by_txid cache.\r\n     for (const auto& txiter : cluster) {\r\n-        const auto& txid = txiter->GetTx().GetHash();\r\n+        const CTransaction& tx{txiter->GetTx()};\r\n+        const auto& txid{tx.GetHash()};\r\n         // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\r\n         // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\r\n         std::vector<MockEntryMap::iterator> cached_descendants;\r\n-        const bool remove = m_to_be_replaced.find(txid) != m_to_be_replaced.end();\r\n+        const bool remove{to_be_replaced.find(&tx) != to_be_replaced.end()};\r\n         CTxMemPool::setEntries descendants;\r\n         mempool.CalculateDescendants(txiter, descendants);\r\n         Assume(descendants.find(txiter) != descendants.end());\r\n         for (const auto& desc_txiter : descendants) {\r\n-            const auto txid_desc = desc_txiter->GetTx().GetHash();\r\n-            const bool remove_desc = m_to_be_replaced.find(txid_desc) != m_to_be_replaced.end();\r\n-            auto desc_it{m_entries_by_txid.find(txid_desc)};\r\n+            const CTransaction& tx_desc{desc_txiter->GetTx()};\r\n+            const bool remove_desc{to_be_replaced.find(&tx_desc) != to_be_replaced.end()};\r\n+            auto desc_it{m_entries_by_txid.find(tx_desc.GetHash())};\r\n             Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\r\n             if (remove) Assume(remove_desc);\r\n             // It's possible that remove=false but remove_desc=true.\r\n@@ -194,9 +190,6 @@ void MiniMiner::SanityCheck() const\r\n     Assume(std::all_of(m_entries.begin(), m_entries.end(), [](const auto& entry) {\r\n         return entry->second.GetSizeWithAncestors() >= entry->second.GetTxSize() &&\r\n                entry->second.GetModFeesWithAncestors() >= entry->second.GetModifiedFee();}));\r\n-    // None of the entries should be to-be-replaced transactions\r\n-    Assume(std::all_of(m_to_be_replaced.begin(), m_to_be_replaced.end(),\r\n-        [&](const auto& txid){return m_entries_by_txid.find(txid) == m_entries_by_txid.end();}));\r\n }\r\n \r\n void MiniMiner::BuildMockTemplate(const CFeeRate& target_feerate)\r\n```\r\n</details>",
      "created_at": "2023-03-01T01:05:40Z",
      "updated_at": "2023-03-01T06:46:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1120992192",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1120992192"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": 61,
      "original_start_line": 66,
      "start_side": "RIGHT",
      "line": 63,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121184614",
      "pull_request_review_id": 1318211679,
      "id": 1121184614,
      "node_id": "PRRC_kwDOABII585C0-tm",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;",
      "path": "src/node/mini_miner.cpp",
      "position": 58,
      "original_position": 63,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can we remove this code? (I prefer avoiding special cases.) The only effect difference I can see by eliminating this is that, with it, `m_ready_to_calculate` will remain `true`, whereas without it, it will be `false`. Does that matter? I'm unsure of the purpose of `m_ready_to_calculate` (in this PR it's only used by test code, although I understand it may be used in the follow-on PR). Seems like once the constructor runs, it should be ready to calculate, no matter what. There's nothing else that can be done to make it ready to calculate.\r\n\r\nIs `m_ready_to_calculate` an error indication, since it seems it can be `false` only If we hit the DoS limit? If so, how might it used? I think in this case we recover by just not bumping any fees, which is not the end of the world (it's what happens today). The error indication may be useful in tests (to verify that we hit the DoS limit when expected), but then maybe it should have a better name, like `dos_limit_reached`.\r\n\r\nBut it may be better still to just test the actual effect, i.e., that all the bump fees are zero.",
      "created_at": "2023-03-01T05:52:50Z",
      "updated_at": "2023-03-01T06:46:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121184614",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121184614"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": 57,
      "original_start_line": 62,
      "start_side": "RIGHT",
      "line": 58,
      "original_line": 58,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121191113",
      "pull_request_review_id": 1318211679,
      "id": 1121191113,
      "node_id": "PRRC_kwDOABII585C1ATJ",
      "diff_hunk": "@@ -1140,3 +1153,49 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    // Reserve total ancestor + descendant counts of each transaction.  This is an approximation; it\n+    // may overestimate because transactions may share ancestors/descendants, and may underestimate\n+    // because the cluster may include more than just ancestors and descendants.\n+    cluster.reserve(std::accumulate(cluster.cbegin(), cluster.cend(), 0, [](size_t sum, const auto it) {\n+        return sum + it->GetCountWithAncestors() + it->GetCountWithDescendants() - 1; }));\n+    {\n+        // Use epoch: visiting an entry means we have added it to the cluster vector. It does not\n+        // necessarily mean the entry has been processed.\n+        WITH_FRESH_EPOCH(m_epoch);\n+        for (const auto& it : cluster) {\n+            visited(it);\n+        }\n+        // i = index of where the list of entries to process starts\n+        for (size_t i{0}, to_process_count{txids.size()}; i < to_process_count; ++i) {\n+            // DoS protection: if not finished after processing 500 entries, just quit.\n+            if (to_process_count > 500) return {};",
      "path": "src/txmempool.cpp",
      "position": null,
      "original_position": 65,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe this 500 can be a `constexpr` in the `MiniMiner` class? I probably wouldn't suggest this if this is the only place it occurs, but the tests specify this value too. It might be nice to be able to change this limit by changing a single line of code.",
      "created_at": "2023-03-01T06:01:52Z",
      "updated_at": "2023-03-01T06:46:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121191113",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121191113"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 1180,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1177,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121215437",
      "pull_request_review_id": 1318211679,
      "id": 1121215437,
      "node_id": "PRRC_kwDOABII585C1GPN",
      "diff_hunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_MINI_MINER_H\n+#define BITCOIN_NODE_MINI_MINER_H\n+\n+#include <txmempool.h>\n+\n+#include <memory>\n+#include <optional>\n+#include <stdint.h>\n+\n+namespace node {\n+\n+// Container for tracking updates to ancestor feerate as we include ancestors in the \"block\"\n+class MiniMinerMempoolEntry\n+{\n+    const CAmount fee_individual;\n+    const CTransaction tx;\n+    const int64_t vsize_individual;\n+\n+// This class must be constructed while holding mempool.cs. After construction, the object's\n+// methods can be called without holding that lock.\n+public:\n+    CAmount fee_with_ancestors;\n+    int64_t vsize_with_ancestors;\n+    explicit MiniMinerMempoolEntry(CTxMemPool::txiter entry) :\n+        fee_individual{entry->GetModifiedFee()},\n+        tx{entry->GetTx()},\n+        vsize_individual(entry->GetTxSize()),\n+        fee_with_ancestors{entry->GetModFeesWithAncestors()},\n+        vsize_with_ancestors(entry->GetSizeWithAncestors())\n+    { }\n+\n+    CAmount GetModifiedFee() const { return fee_individual; }\n+    CAmount GetModFeesWithAncestors() const { return fee_with_ancestors; }\n+    int64_t GetTxSize() const { return vsize_individual; }\n+    int64_t GetSizeWithAncestors() const { return vsize_with_ancestors; }\n+    const CTransaction& GetTx() const LIFETIMEBOUND { return tx; }\n+};\n+\n+void UpdateForMinedAncestor(const MiniMinerMempoolEntry& ancestor, const MiniMinerMempoolEntry& descendant);\n+\n+// Comparator needed for std::set<MockEntryMap::iterator>\n+struct IteratorComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const\n+    {\n+        return &(*a) < &(*b);\n+    }\n+};\n+\n+/** A minimal version of BlockAssembler. Allows us to run the mining algorithm on a subset of\n+ * mempool transactions, ignoring consensus rules, to calculate mining scores. */\n+class MiniMiner\n+{\n+    // When true, a caller may use CalculateBumpFees(). Becomes false if we failed to retrieve\n+    // mempool entries (i.e. cluster size too large) or bump fees have already been calculated.\n+    bool m_ready_to_calculate{true};\n+\n+    // Original outpoints requested\n+    std::vector<COutPoint> m_requested_outpoints;\n+\n+    // Set once per lifetime, fill in during initialization.\n+    // txids of to-be-replaced transactions\n+    std::set<uint256> m_to_be_replaced;\n+\n+    // If multiple argument outpoints correspond to the same transaction, cache them together in\n+    // a single entry indexed by txid. Then we can just work with txids since all outpoints from\n+    // the same tx will have the same bumpfee. Excludes non-mempool transactions.\n+    std::map<uint256, std::vector<COutPoint>> m_requested_outpoints_by_txid;",
      "path": "src/node/mini_miner.h",
      "position": 68,
      "original_position": 73,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This isn't a very efficient data structure, because each entry's key, the txid, is repeated in all of its vector's entries (because a `COutPoint` includes the txid). All you need is the index (`COutPoint::n`) So this could be:\r\n```\r\n    std::map<uint256, std::vector<uint32_t>> m_requested_outpoints_by_txid;\r\n```\r\nalthough the name would be wrong, it's no longer \"requested outpoints\". Elsewhere in the code where you need a `COutPoint` (I think there are only two places), you can construct it from the key (txid) and this index. ",
      "created_at": "2023-03-01T06:32:29Z",
      "updated_at": "2023-03-01T06:46:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121215437",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121215437"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": 65,
      "original_start_line": 70,
      "start_side": "RIGHT",
      "line": 68,
      "original_line": 68,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121220463",
      "pull_request_review_id": 1318211679,
      "id": 1121220463,
      "node_id": "PRRC_kwDOABII585C1Hdv",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, outpoints]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.CalculateCluster(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (m_to_be_replaced.find(txiter->GetTx().GetHash()) == m_to_be_replaced.end()) {",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 80,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\r\n```",
      "created_at": "2023-03-01T06:38:41Z",
      "updated_at": "2023-03-01T06:46:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121220463",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121220463"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 80,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121222211",
      "pull_request_review_id": 1318211679,
      "id": 1121222211,
      "node_id": "PRRC_kwDOABII585C1H5D",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, outpoints]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.CalculateCluster(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (m_to_be_replaced.find(txiter->GetTx().GetHash()) == m_to_be_replaced.end()) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove = m_to_be_replaced.find(txid) != m_to_be_replaced.end();",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 102,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        const bool remove{m_to_be_replaced.count(txid) > 0};\r\n```",
      "created_at": "2023-03-01T06:40:46Z",
      "updated_at": "2023-03-01T06:46:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121222211",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121222211"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121223393",
      "pull_request_review_id": 1318211679,
      "id": 1121223393,
      "node_id": "PRRC_kwDOABII585C1ILh",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, outpoints]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.CalculateCluster(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (m_to_be_replaced.find(txiter->GetTx().GetHash()) == m_to_be_replaced.end()) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove = m_to_be_replaced.find(txid) != m_to_be_replaced.end();\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.find(txiter) != descendants.end());\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc = m_to_be_replaced.find(txid_desc) != m_to_be_replaced.end();",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 108,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n            const bool remove_desc{to_be_replaced.count(&tx_desc) > 0};\r\n```",
      "created_at": "2023-03-01T06:42:14Z",
      "updated_at": "2023-03-01T06:46:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121223393",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121223393"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 108,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121225418",
      "pull_request_review_id": 1318211679,
      "id": 1121225418,
      "node_id": "PRRC_kwDOABII585C1IrK",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, outpoints]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.CalculateCluster(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (m_to_be_replaced.find(txiter->GetTx().GetHash()) == m_to_be_replaced.end()) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove = m_to_be_replaced.find(txid) != m_to_be_replaced.end();\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.find(txiter) != descendants.end());",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 105,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        Assume(descendants.count(txiter) > 0);\r\n```",
      "created_at": "2023-03-01T06:44:43Z",
      "updated_at": "2023-03-01T06:46:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121225418",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121225418"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 105,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121483332",
      "pull_request_review_id": 1319542147,
      "id": 1121483332,
      "node_id": "PRRC_kwDOABII585C2HpE",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, outpoints]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.CalculateCluster(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (m_to_be_replaced.find(txiter->GetTx().GetHash()) == m_to_be_replaced.end()) {",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 80,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1121220463,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can you explain why using `count` is better?",
      "created_at": "2023-03-01T10:27:18Z",
      "updated_at": "2023-03-01T10:38:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121483332",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121483332"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 80,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121487831",
      "pull_request_review_id": 1319542147,
      "id": 1121487831,
      "node_id": "PRRC_kwDOABII585C2IvX",
      "diff_hunk": "@@ -1140,3 +1153,49 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    // Reserve total ancestor + descendant counts of each transaction.  This is an approximation; it\n+    // may overestimate because transactions may share ancestors/descendants, and may underestimate\n+    // because the cluster may include more than just ancestors and descendants.\n+    cluster.reserve(std::accumulate(cluster.cbegin(), cluster.cend(), 0, [](size_t sum, const auto it) {\n+        return sum + it->GetCountWithAncestors() + it->GetCountWithDescendants() - 1; }));",
      "path": "src/txmempool.cpp",
      "position": null,
      "original_position": 54,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1119202243,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I agree it might just be better to not reserve anything. We have no idea what the cluster size is going to be, so might as well let the stdlib magic do its work.",
      "created_at": "2023-03-01T10:30:33Z",
      "updated_at": "2023-03-01T10:38:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121487831",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121487831"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 1166,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1170,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121488980",
      "pull_request_review_id": 1319542147,
      "id": 1121488980,
      "node_id": "PRRC_kwDOABII585C2JBU",
      "diff_hunk": "@@ -1140,3 +1153,47 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    // Reserve total ancestor + descendant counts of each transaction.  This is an approximation; it\n+    // may overestimate because transactions may share ancestors/descendants, and may underestimate\n+    // because the cluster may include more than just ancestors and descendants.\n+    cluster.reserve(std::accumulate(cluster.cbegin(), cluster.cend(), 0, [](size_t sum, const auto it) {\n+        return sum + it->GetCountWithAncestors() + it->GetCountWithDescendants() - 1; }));\n+    {\n+        // Use epoch: visiting an entry means we have added it to the cluster vector. It does not\n+        // necessarily mean the entry has been processed.\n+        WITH_FRESH_EPOCH(m_epoch);\n+        for (const auto& it : cluster) {\n+            visited(it);\n+        }\n+        // i = index of where the list of entries to process starts\n+        for (size_t i{0}, to_process_count{txids.size()}; i < to_process_count; ++i) {\n+            for (const CTxMemPoolEntry& parent_entry : cluster.at(i)->GetMemPoolParentsConst()) {\n+                const auto parent_it = mapTx.iterator_to(parent_entry);\n+                if (!visited(parent_it)) {\n+                    cluster.push_back(parent_it);\n+                    // we still need to process this\n+                    ++to_process_count;",
      "path": "src/txmempool.cpp",
      "position": null,
      "original_position": 69,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "daf023a49ce812417a36ec201e19d4272abc790a",
      "in_reply_to_id": 1095658967,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Marking as resolved as this has been implemented",
      "created_at": "2023-03-01T10:31:18Z",
      "updated_at": "2023-03-01T10:38:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121488980",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121488980"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121498816",
      "pull_request_review_id": 1319542147,
      "id": 1121498816,
      "node_id": "PRRC_kwDOABII585C2LbA",
      "diff_hunk": "@@ -1140,3 +1153,49 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    // Reserve total ancestor + descendant counts of each transaction.  This is an approximation; it\n+    // may overestimate because transactions may share ancestors/descendants, and may underestimate\n+    // because the cluster may include more than just ancestors and descendants.\n+    cluster.reserve(std::accumulate(cluster.cbegin(), cluster.cend(), 0, [](size_t sum, const auto it) {\n+        return sum + it->GetCountWithAncestors() + it->GetCountWithDescendants() - 1; }));\n+    {\n+        // Use epoch: visiting an entry means we have added it to the cluster vector. It does not\n+        // necessarily mean the entry has been processed.\n+        WITH_FRESH_EPOCH(m_epoch);\n+        for (const auto& it : cluster) {\n+            visited(it);\n+        }\n+        // i = index of where the list of entries to process starts\n+        for (size_t i{0}, to_process_count{txids.size()}; i < to_process_count; ++i) {\n+            // DoS protection: if not finished after processing 500 entries, just quit.\n+            if (to_process_count > 500) return {};",
      "path": "src/txmempool.cpp",
      "position": null,
      "original_position": 65,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1121191113,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Disagree with txmempool getting this value from mini_miner, as that would create a circular dependency.\r\nThis kind of constant should live in src/kernel/mempool_options.h.",
      "created_at": "2023-03-01T10:38:37Z",
      "updated_at": "2023-03-01T10:38:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121498816",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121498816"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 1180,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1177,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121528999",
      "pull_request_review_id": 1319599774,
      "id": 1121528999,
      "node_id": "PRRC_kwDOABII585C2Syn",
      "diff_hunk": "@@ -0,0 +1,180 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_front(COutPoint{tx->GetHash(), n});\n+            } else {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }",
      "path": "src/test/fuzz/mini_miner.cpp",
      "position": null,
      "original_position": 67,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The `mini_miner` target will always produce a cluster of 500 txs right now, because we always add outputs to `available_coins`. So my suggestion would be to let the fuzzer choose which outputs are added to `available_coins`.\r\n\r\n```suggestion\r\n        for (uint32_t n{0}; n < num_outputs; ++n) {\r\n            if (fuzzed_data_provider.ConsumeBool()) {\r\n                available_coins.push_back(COutPoint{tx->GetHash(), n});\r\n            }\r\n        }\r\n```\r\n ",
      "created_at": "2023-03-01T11:02:01Z",
      "updated_at": "2023-03-01T11:44:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121528999",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121528999"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 61,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121540528",
      "pull_request_review_id": 1319599774,
      "id": 1121540528,
      "node_id": "PRRC_kwDOABII585C2Vmw",
      "diff_hunk": "@@ -0,0 +1,180 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_front(COutPoint{tx->GetHash(), n});\n+            } else {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool() && !tx->vout.empty()) {\n+            // Add outpoint from this tx (may or not be spent by a later tx)\n+            outpoints.push_back(COutPoint{tx->GetHash(),\n+                                          (uint32_t)fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, tx->vout.size())});\n+        } else {\n+            // Add some random outpoint (will be interpreted as confirmed or not yet submitted\n+            // to mempool).\n+            auto outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+            if (outpoint) outpoints.push_back(*outpoint);\n+        }\n+\n+    }\n+\n+    node::MiniMiner mini_miner{pool, outpoints};\n+    assert(mini_miner.IsReadyToCalculate());\n+    const CFeeRate target_feerate{CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/1000)}};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        assert(bump_fees.size() == outpoints.size());\n+        for (const auto& [outpoint, fee] : bump_fees) assert(fee >= 0);\n+    } else {\n+        const auto bump_fee = mini_miner.CalculateTotalBumpFees(target_feerate);\n+        assert(bump_fee.has_value());\n+    }\n+    assert(!mini_miner.IsReadyToCalculate());\n+}\n+\n+// Test that MiniMiner and BlockAssembler build the same block given the same transactions and constraints.\n+FUZZ_TARGET_INIT(mini_miner_selection, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    // Make a copy to preserve determinism.\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    std::vector<CTransactionRef> transactions;\n+\n+    LOCK2(::cs_main, pool.cs);\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 100)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = 2;\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(2, 5);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+\n+        // First 2 outputs are available to spend. The rest are added to outpoints to calculate bumpfees.\n+        // There is no overlap between spendable coins and outpoints passed to MiniMiner because the\n+        // MiniMiner interprets spent coins as to-be-replaced and excludes them.\n+        for (uint32_t n{0}; n < num_outputs - 1; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool() && fuzzed_data_provider.ConsumeBool()) {",
      "path": "src/test/fuzz/mini_miner.cpp",
      "position": null,
      "original_position": 125,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n            if (fuzzed_data_provider.ConsumeBool()) {\r\n```\r\n\r\nShouldn't really make a difference since the fuzzer picks both bools.",
      "created_at": "2023-03-01T11:10:25Z",
      "updated_at": "2023-03-01T11:44:40Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121540528",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121540528"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 125,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121607436",
      "pull_request_review_id": 1319698544,
      "id": 1121607436,
      "node_id": "PRRC_kwDOABII585C2l8M",
      "diff_hunk": "@@ -0,0 +1,180 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_front(COutPoint{tx->GetHash(), n});\n+            } else {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }",
      "path": "src/test/fuzz/mini_miner.cpp",
      "position": null,
      "original_position": 67,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1121528999,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Alternatively, the `LIMITED_WHILE` condition could be changed.",
      "created_at": "2023-03-01T12:01:11Z",
      "updated_at": "2023-03-01T12:01:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121607436",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121607436"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 61,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121611301",
      "pull_request_review_id": 1319704290,
      "id": 1121611301,
      "node_id": "PRRC_kwDOABII585C2m4l",
      "diff_hunk": "@@ -0,0 +1,180 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_front(COutPoint{tx->GetHash(), n});\n+            } else {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }",
      "path": "src/test/fuzz/mini_miner.cpp",
      "position": null,
      "original_position": 67,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1121528999,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Also, with my suggested modification there is a crash, which I don't think is the modifications fault:\r\n\r\n```\r\n/wCqamFv0GgmkfHCTmPQeMXAul83pioRsGwGcWUbQCYRX/BcVADDAQm0wQAAAAAAAAAAAAAPAAAA\r\nAAAAAA8AAAAAAAAAAAAAAGPQeMXAul83pioRsGwGcWUbKUAGcWUbQCYRX/BcVADDAQm0wQAAAAAA\r\nAAAAAAAPAAAAAAAAAA8AAAAAAAAAAAAAAGPQeMXAul83pioRsGwGcWUbKUAmEV/wVFwAwwG0CQAA\r\nAAAAAAAA//////+mKhGwbAZxZRtAJhFf8FRcAMMBCbTBAAAAAAAAAAAAAA///////////////2Zm\r\nZmZmZmZmZmZmZgAAAAAAAFw=\r\n```",
      "created_at": "2023-03-01T12:04:22Z",
      "updated_at": "2023-03-01T12:05:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1121611301",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1121611301"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 61,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1122981731",
      "pull_request_review_id": 1321674784,
      "id": 1122981731,
      "node_id": "PRRC_kwDOABII585C71dj",
      "diff_hunk": "@@ -0,0 +1,180 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_front(COutPoint{tx->GetHash(), n});\n+            } else {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool() && !tx->vout.empty()) {\n+            // Add outpoint from this tx (may or not be spent by a later tx)\n+            outpoints.push_back(COutPoint{tx->GetHash(),\n+                                          (uint32_t)fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, tx->vout.size())});\n+        } else {\n+            // Add some random outpoint (will be interpreted as confirmed or not yet submitted\n+            // to mempool).\n+            auto outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+            if (outpoint) outpoints.push_back(*outpoint);",
      "path": "src/test/fuzz/mini_miner.cpp",
      "position": null,
      "original_position": 77,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Sorry ignore my previous review, it was wrong. But this should work:\r\n\r\n```suggestion\r\n            if (outpoint.has_value() && std::find(outpoints.begin(), outpoints.end(), *outpoint) == outpoints.end()) {\r\n                outpoints.push_back(*outpoint);\r\n            }\r\n```",
      "created_at": "2023-03-02T11:53:40Z",
      "updated_at": "2023-03-02T12:08:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1122981731",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1122981731"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1122983669",
      "pull_request_review_id": 1321674784,
      "id": 1122983669,
      "node_id": "PRRC_kwDOABII585C7171",
      "diff_hunk": "@@ -0,0 +1,180 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_front(COutPoint{tx->GetHash(), n});\n+            } else {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }",
      "path": "src/test/fuzz/mini_miner.cpp",
      "position": null,
      "original_position": 67,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1121528999,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This input produces an `outpoints` vector with 2 of the same outpoint, which is what causes it to crash on the line `assert(bump_fees.size() == outpoints.size()`.",
      "created_at": "2023-03-02T11:55:19Z",
      "updated_at": "2023-03-02T12:08:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1122983669",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1122983669"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 61,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1122985863",
      "pull_request_review_id": 1321674784,
      "id": 1122985863,
      "node_id": "PRRC_kwDOABII585C72eH",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 23,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Just noticed this was added for `CalculateTotalBumpFees()` - it is redundant with `m_requested_outpoints_by_txid`, so I think you should remove it and have `CalculateTotalBumpFees()` iterate through `m_requested_outpoints_by_txid`'s keys instead.",
      "created_at": "2023-03-02T11:57:11Z",
      "updated_at": "2023-03-02T12:08:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1122985863",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1122985863"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123037832",
      "pull_request_review_id": 1321745788,
      "id": 1123037832,
      "node_id": "PRRC_kwDOABII585C8DKI",
      "diff_hunk": "@@ -0,0 +1,180 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_front(COutPoint{tx->GetHash(), n});\n+            } else {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool() && !tx->vout.empty()) {\n+            // Add outpoint from this tx (may or not be spent by a later tx)\n+            outpoints.push_back(COutPoint{tx->GetHash(),\n+                                          (uint32_t)fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, tx->vout.size())});\n+        } else {\n+            // Add some random outpoint (will be interpreted as confirmed or not yet submitted\n+            // to mempool).\n+            auto outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+            if (outpoint) outpoints.push_back(*outpoint);\n+        }\n+\n+    }\n+\n+    node::MiniMiner mini_miner{pool, outpoints};\n+    assert(mini_miner.IsReadyToCalculate());\n+    const CFeeRate target_feerate{CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/1000)}};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        assert(bump_fees.size() == outpoints.size());\n+        for (const auto& [outpoint, fee] : bump_fees) assert(fee >= 0);",
      "path": "src/test/fuzz/mini_miner.cpp",
      "position": null,
      "original_position": 88,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is more precise than making sure the lengths are the same (and would also fix the crash):\r\n```suggestion\r\n        for (const auto& outpoint : outpoints) {\r\n            auto it = bump_fees.find(outpoint);\r\n            assert(it != bump_fees.end());\r\n            assert(it->second >= 0);\r\n        }\r\n```",
      "created_at": "2023-03-02T12:41:50Z",
      "updated_at": "2023-03-02T12:41:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1123037832",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123037832"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 87,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123754749",
      "pull_request_review_id": 1322708525,
      "id": 1123754749,
      "node_id": "PRRC_kwDOABII585C-yL9",
      "diff_hunk": "@@ -1140,3 +1153,49 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    // Reserve total ancestor + descendant counts of each transaction.  This is an approximation; it\n+    // may overestimate because transactions may share ancestors/descendants, and may underestimate\n+    // because the cluster may include more than just ancestors and descendants.\n+    cluster.reserve(std::accumulate(cluster.cbegin(), cluster.cend(), 0, [](size_t sum, const auto it) {\n+        return sum + it->GetCountWithAncestors() + it->GetCountWithDescendants() - 1; }));",
      "path": "src/txmempool.cpp",
      "position": null,
      "original_position": 54,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1119202243,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I’ve removed the `reserve(…)` call here.",
      "created_at": "2023-03-02T21:48:57Z",
      "updated_at": "2023-03-03T22:28:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1123754749",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123754749"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 1166,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1170,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123811383",
      "pull_request_review_id": 1322708525,
      "id": 1123811383,
      "node_id": "PRRC_kwDOABII585C_AA3",
      "diff_hunk": "@@ -898,6 +899,19 @@ CTxMemPool::setEntries CTxMemPool::GetIterSet(const std::set<uint256>& hashes) c\n     return ret;\n }\n \n+std::vector<CTxMemPool::txiter> CTxMemPool::GetIterVec(const std::vector<uint256>& txids) const",
      "path": "src/txmempool.cpp",
      "position": 12,
      "original_position": 12,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1119107935,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, agreed using an optional would be more explicit, however handling the optional return value would touch a bunch of lines here, and given that the result should never be empty unless something went wrong or the function got called with an empty `txids` input, I feel it’s a bit of a cosmetic improvement here.",
      "created_at": "2023-03-02T22:41:10Z",
      "updated_at": "2023-03-03T22:28:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1123811383",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123811383"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 902,
      "original_line": 902,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123812481",
      "pull_request_review_id": 1322708525,
      "id": 1123812481,
      "node_id": "PRRC_kwDOABII585C_ASB",
      "diff_hunk": "@@ -898,6 +899,19 @@ CTxMemPool::setEntries CTxMemPool::GetIterSet(const std::set<uint256>& hashes) c\n     return ret;\n }\n \n+std::vector<CTxMemPool::txiter> CTxMemPool::GetIterVec(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> ret;\n+    ret.reserve(txids.size());\n+    for (const auto& txid : txids) {\n+        const auto it{GetIter(txid)};\n+        if (!it) return {};\n+        ret.push_back(*it);",
      "path": "src/txmempool.cpp",
      "position": 20,
      "original_position": 20,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1119099044,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I’d probably prefer using `.value()` for new code I’d write, but the asterisk-variant seems prevalent throughout this code.",
      "created_at": "2023-03-02T22:42:39Z",
      "updated_at": "2023-03-03T22:28:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1123812481",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123812481"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 910,
      "original_line": 910,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123819758",
      "pull_request_review_id": 1322708525,
      "id": 1123819758,
      "node_id": "PRRC_kwDOABII585C_CDu",
      "diff_hunk": "@@ -1140,3 +1153,49 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const",
      "path": "src/txmempool.cpp",
      "position": null,
      "original_position": 41,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1119109899,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "As above with `GetIterVec()`, an empty vector is not a valid outcome for a call, so I tend to leave as is.",
      "created_at": "2023-03-02T22:50:47Z",
      "updated_at": "2023-03-03T22:28:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1123819758",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123819758"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1157,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123823270",
      "pull_request_review_id": 1322708525,
      "id": 1123823270,
      "node_id": "PRRC_kwDOABII585C_C6m",
      "diff_hunk": "@@ -1140,3 +1153,49 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};",
      "path": "src/txmempool.cpp",
      "position": null,
      "original_position": 48,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "aad0c09ab6fb38e6d0a3e4d9eb764d84a2913f15",
      "in_reply_to_id": 1119134160,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks, will consider, change but feel it’s okay at this time.",
      "created_at": "2023-03-02T22:54:02Z",
      "updated_at": "2023-03-03T22:28:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1123823270",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1123823270"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1165,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124907930",
      "pull_request_review_id": 1322708525,
      "id": 1124907930,
      "node_id": "PRRC_kwDOABII585DDLua",
      "diff_hunk": "@@ -1140,3 +1153,49 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    // Reserve total ancestor + descendant counts of each transaction.  This is an approximation; it\n+    // may overestimate because transactions may share ancestors/descendants, and may underestimate\n+    // because the cluster may include more than just ancestors and descendants.\n+    cluster.reserve(std::accumulate(cluster.cbegin(), cluster.cend(), 0, [](size_t sum, const auto it) {\n+        return sum + it->GetCountWithAncestors() + it->GetCountWithDescendants() - 1; }));\n+    {\n+        // Use epoch: visiting an entry means we have added it to the cluster vector. It does not\n+        // necessarily mean the entry has been processed.\n+        WITH_FRESH_EPOCH(m_epoch);\n+        for (const auto& it : cluster) {\n+            visited(it);\n+        }\n+        // i = index of where the list of entries to process starts\n+        for (size_t i{0}, to_process_count{txids.size()}; i < to_process_count; ++i) {\n+            // DoS protection: if not finished after processing 500 entries, just quit.\n+            if (to_process_count > 500) return {};",
      "path": "src/txmempool.cpp",
      "position": null,
      "original_position": 65,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1121191113,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I’m not sure in how far this needs to be widely visible, since it only affects one function and the corresponding tests.",
      "created_at": "2023-03-03T19:10:44Z",
      "updated_at": "2023-03-03T22:28:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124907930",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124907930"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 1180,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1177,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124908789",
      "pull_request_review_id": 1322708525,
      "id": 1124908789,
      "node_id": "PRRC_kwDOABII585DDL71",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 1,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1120543538,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Updated",
      "created_at": "2023-03-03T19:11:45Z",
      "updated_at": "2023-03-03T22:28:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124908789",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124908789"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124938942",
      "pull_request_review_id": 1322708525,
      "id": 1124938942,
      "node_id": "PRRC_kwDOABII585DDTS-",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 23,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1122985863,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Removed `m_requested_outpoints`",
      "created_at": "2023-03-03T19:46:09Z",
      "updated_at": "2023-03-03T22:28:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124938942",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124938942"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 23,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124956187",
      "pull_request_review_id": 1322708525,
      "id": 1124956187,
      "node_id": "PRRC_kwDOABII585DDXgb",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 53,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1120964573,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks that’s much nicer",
      "created_at": "2023-03-03T20:05:53Z",
      "updated_at": "2023-03-03T22:28:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124956187",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124956187"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 47,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124966759",
      "pull_request_review_id": 1322708525,
      "id": 1124966759,
      "node_id": "PRRC_kwDOABII585DDaFn",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, outpoints]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.CalculateCluster(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (m_to_be_replaced.find(txiter->GetTx().GetHash()) == m_to_be_replaced.end()) {",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 80,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1121220463,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It seems to me that if we don’t use the result of `find`, it’s clearer that we just care about whether a key is present instead of where in the sequence it appears",
      "created_at": "2023-03-03T20:18:19Z",
      "updated_at": "2023-03-03T22:28:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124966759",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124966759"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 80,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124995387",
      "pull_request_review_id": 1322708525,
      "id": 1124995387,
      "node_id": "PRRC_kwDOABII585DDhE7",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, outpoints]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.CalculateCluster(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (m_to_be_replaced.find(txiter->GetTx().GetHash()) == m_to_be_replaced.end()) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove = m_to_be_replaced.find(txid) != m_to_be_replaced.end();",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 102,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1121222211,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks, adopted",
      "created_at": "2023-03-03T20:49:39Z",
      "updated_at": "2023-03-03T22:28:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124995387",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124995387"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124995611",
      "pull_request_review_id": 1322708525,
      "id": 1124995611,
      "node_id": "PRRC_kwDOABII585DDhIb",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, outpoints]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.CalculateCluster(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (m_to_be_replaced.find(txiter->GetTx().GetHash()) == m_to_be_replaced.end()) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove = m_to_be_replaced.find(txid) != m_to_be_replaced.end();\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.find(txiter) != descendants.end());",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 105,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1121225418,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks",
      "created_at": "2023-03-03T20:49:46Z",
      "updated_at": "2023-03-03T22:28:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124995611",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124995611"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 105,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124997795",
      "pull_request_review_id": 1322708525,
      "id": 1124997795,
      "node_id": "PRRC_kwDOABII585DDhqj",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, outpoints]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.CalculateCluster(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (m_to_be_replaced.find(txiter->GetTx().GetHash()) == m_to_be_replaced.end()) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove = m_to_be_replaced.find(txid) != m_to_be_replaced.end();\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.find(txiter) != descendants.end());\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc = m_to_be_replaced.find(txid_desc) != m_to_be_replaced.end();",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 108,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1121223393,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks",
      "created_at": "2023-03-03T20:52:23Z",
      "updated_at": "2023-03-03T22:28:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124997795",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124997795"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 108,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124999961",
      "pull_request_review_id": 1322708525,
      "id": 1124999961,
      "node_id": "PRRC_kwDOABII585DDiMZ",
      "diff_hunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_MINI_MINER_H\n+#define BITCOIN_NODE_MINI_MINER_H\n+\n+#include <txmempool.h>\n+\n+#include <memory>\n+#include <optional>\n+#include <stdint.h>\n+\n+namespace node {\n+\n+// Container for tracking updates to ancestor feerate as we include ancestors in the \"block\"\n+class MiniMinerMempoolEntry\n+{\n+    const CAmount fee_individual;\n+    const CTransaction tx;\n+    const int64_t vsize_individual;\n+\n+// This class must be constructed while holding mempool.cs. After construction, the object's\n+// methods can be called without holding that lock.\n+public:\n+    CAmount fee_with_ancestors;\n+    int64_t vsize_with_ancestors;\n+    explicit MiniMinerMempoolEntry(CTxMemPool::txiter entry) :\n+        fee_individual{entry->GetModifiedFee()},\n+        tx{entry->GetTx()},\n+        vsize_individual(entry->GetTxSize()),\n+        fee_with_ancestors{entry->GetModFeesWithAncestors()},\n+        vsize_with_ancestors(entry->GetSizeWithAncestors())\n+    { }\n+\n+    CAmount GetModifiedFee() const { return fee_individual; }\n+    CAmount GetModFeesWithAncestors() const { return fee_with_ancestors; }\n+    int64_t GetTxSize() const { return vsize_individual; }\n+    int64_t GetSizeWithAncestors() const { return vsize_with_ancestors; }\n+    const CTransaction& GetTx() const LIFETIMEBOUND { return tx; }\n+};\n+\n+void UpdateForMinedAncestor(const MiniMinerMempoolEntry& ancestor, const MiniMinerMempoolEntry& descendant);\n+\n+// Comparator needed for std::set<MockEntryMap::iterator>\n+struct IteratorComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const\n+    {\n+        return &(*a) < &(*b);\n+    }\n+};\n+\n+/** A minimal version of BlockAssembler. Allows us to run the mining algorithm on a subset of\n+ * mempool transactions, ignoring consensus rules, to calculate mining scores. */\n+class MiniMiner\n+{\n+    // When true, a caller may use CalculateBumpFees(). Becomes false if we failed to retrieve\n+    // mempool entries (i.e. cluster size too large) or bump fees have already been calculated.\n+    bool m_ready_to_calculate{true};\n+\n+    // Original outpoints requested\n+    std::vector<COutPoint> m_requested_outpoints;\n+\n+    // Set once per lifetime, fill in during initialization.\n+    // txids of to-be-replaced transactions\n+    std::set<uint256> m_to_be_replaced;\n+\n+    // If multiple argument outpoints correspond to the same transaction, cache them together in\n+    // a single entry indexed by txid. Then we can just work with txids since all outpoints from\n+    // the same tx will have the same bumpfee. Excludes non-mempool transactions.\n+    std::map<uint256, std::vector<COutPoint>> m_requested_outpoints_by_txid;",
      "path": "src/node/mini_miner.h",
      "position": 68,
      "original_position": 73,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1121215437,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "While true, it seems more readable to use the type in the value that I later want than to remember reconstructing it later.",
      "created_at": "2023-03-03T20:54:54Z",
      "updated_at": "2023-03-03T22:28:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1124999961",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1124999961"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": 65,
      "original_start_line": 70,
      "start_side": "RIGHT",
      "line": 68,
      "original_line": 68,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125015732",
      "pull_request_review_id": 1322708525,
      "id": 1125015732,
      "node_id": "PRRC_kwDOABII585DDmC0",
      "diff_hunk": "@@ -0,0 +1,180 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_front(COutPoint{tx->GetHash(), n});\n+            } else {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }",
      "path": "src/test/fuzz/mini_miner.cpp",
      "position": null,
      "original_position": 67,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1121528999,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks, I changed it to use outpoints only sometimes depending on the consumed boolean as @dergoegge suggested.",
      "created_at": "2023-03-03T21:13:53Z",
      "updated_at": "2023-03-03T22:28:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1125015732",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125015732"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 61,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 65,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125018960",
      "pull_request_review_id": 1322708525,
      "id": 1125018960,
      "node_id": "PRRC_kwDOABII585DDm1Q",
      "diff_hunk": "@@ -0,0 +1,180 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_front(COutPoint{tx->GetHash(), n});\n+            } else {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool() && !tx->vout.empty()) {\n+            // Add outpoint from this tx (may or not be spent by a later tx)\n+            outpoints.push_back(COutPoint{tx->GetHash(),\n+                                          (uint32_t)fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, tx->vout.size())});\n+        } else {\n+            // Add some random outpoint (will be interpreted as confirmed or not yet submitted\n+            // to mempool).\n+            auto outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+            if (outpoint) outpoints.push_back(*outpoint);\n+        }\n+\n+    }\n+\n+    node::MiniMiner mini_miner{pool, outpoints};\n+    assert(mini_miner.IsReadyToCalculate());\n+    const CFeeRate target_feerate{CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/1000)}};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        assert(bump_fees.size() == outpoints.size());\n+        for (const auto& [outpoint, fee] : bump_fees) assert(fee >= 0);",
      "path": "src/test/fuzz/mini_miner.cpp",
      "position": null,
      "original_position": 88,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1123037832,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks, adopted your suggestion.",
      "created_at": "2023-03-03T21:17:41Z",
      "updated_at": "2023-03-03T22:28:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1125018960",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125018960"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 87,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125019174",
      "pull_request_review_id": 1322708525,
      "id": 1125019174,
      "node_id": "PRRC_kwDOABII585DDm4m",
      "diff_hunk": "@@ -0,0 +1,180 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_front(COutPoint{tx->GetHash(), n});\n+            } else {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool() && !tx->vout.empty()) {\n+            // Add outpoint from this tx (may or not be spent by a later tx)\n+            outpoints.push_back(COutPoint{tx->GetHash(),\n+                                          (uint32_t)fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, tx->vout.size())});\n+        } else {\n+            // Add some random outpoint (will be interpreted as confirmed or not yet submitted\n+            // to mempool).\n+            auto outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+            if (outpoint) outpoints.push_back(*outpoint);",
      "path": "src/test/fuzz/mini_miner.cpp",
      "position": null,
      "original_position": 77,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1122981731,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks for finding this!",
      "created_at": "2023-03-03T21:17:55Z",
      "updated_at": "2023-03-03T22:28:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1125019174",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125019174"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 77,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125026197",
      "pull_request_review_id": 1322708525,
      "id": 1125026197,
      "node_id": "PRRC_kwDOABII585DDomV",
      "diff_hunk": "@@ -0,0 +1,180 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_front(COutPoint{tx->GetHash(), n});\n+            } else {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool() && !tx->vout.empty()) {\n+            // Add outpoint from this tx (may or not be spent by a later tx)\n+            outpoints.push_back(COutPoint{tx->GetHash(),\n+                                          (uint32_t)fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, tx->vout.size())});\n+        } else {\n+            // Add some random outpoint (will be interpreted as confirmed or not yet submitted\n+            // to mempool).\n+            auto outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+            if (outpoint) outpoints.push_back(*outpoint);\n+        }\n+\n+    }\n+\n+    node::MiniMiner mini_miner{pool, outpoints};\n+    assert(mini_miner.IsReadyToCalculate());\n+    const CFeeRate target_feerate{CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/1000)}};\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        const auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        assert(bump_fees.size() == outpoints.size());\n+        for (const auto& [outpoint, fee] : bump_fees) assert(fee >= 0);\n+    } else {\n+        const auto bump_fee = mini_miner.CalculateTotalBumpFees(target_feerate);\n+        assert(bump_fee.has_value());\n+    }\n+    assert(!mini_miner.IsReadyToCalculate());\n+}\n+\n+// Test that MiniMiner and BlockAssembler build the same block given the same transactions and constraints.\n+FUZZ_TARGET_INIT(mini_miner_selection, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    // Make a copy to preserve determinism.\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    std::vector<CTransactionRef> transactions;\n+\n+    LOCK2(::cs_main, pool.cs);\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 100)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = 2;\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(2, 5);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+\n+        // First 2 outputs are available to spend. The rest are added to outpoints to calculate bumpfees.\n+        // There is no overlap between spendable coins and outpoints passed to MiniMiner because the\n+        // MiniMiner interprets spent coins as to-be-replaced and excludes them.\n+        for (uint32_t n{0}; n < num_outputs - 1; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool() && fuzzed_data_provider.ConsumeBool()) {",
      "path": "src/test/fuzz/mini_miner.cpp",
      "position": null,
      "original_position": 125,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1121540528,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Removed second boolean",
      "created_at": "2023-03-03T21:25:47Z",
      "updated_at": "2023-03-03T22:28:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1125026197",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125026197"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 125,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125071450",
      "pull_request_review_id": 1322708525,
      "id": 1125071450,
      "node_id": "PRRC_kwDOABII585DDzpa",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 52,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1120948639,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks, I’m not going to interfere here, because outpoints are tiny anyway, and it seems more readable without the move or constructor.",
      "created_at": "2023-03-03T22:16:27Z",
      "updated_at": "2023-03-03T22:28:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1125071450",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125071450"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 51,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 52,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125071911",
      "pull_request_review_id": 1322708525,
      "id": 1125071911,
      "node_id": "PRRC_kwDOABII585DDzwn",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;",
      "path": "src/node/mini_miner.cpp",
      "position": 58,
      "original_position": 63,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1121184614,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I’ll have to revisit this one.",
      "created_at": "2023-03-03T22:17:00Z",
      "updated_at": "2023-03-03T22:28:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1125071911",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125071911"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": 57,
      "original_start_line": 62,
      "start_side": "RIGHT",
      "line": 58,
      "original_line": 58,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125072522",
      "pull_request_review_id": 1322708525,
      "id": 1125072522,
      "node_id": "PRRC_kwDOABII585DDz6K",
      "diff_hunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_MINI_MINER_H\n+#define BITCOIN_NODE_MINI_MINER_H\n+\n+#include <txmempool.h>\n+\n+#include <memory>\n+#include <optional>\n+#include <stdint.h>\n+\n+namespace node {\n+\n+// Container for tracking updates to ancestor feerate as we include ancestors in the \"block\"\n+class MiniMinerMempoolEntry\n+{\n+    const CAmount fee_individual;\n+    const CTransaction tx;\n+    const int64_t vsize_individual;\n+\n+// This class must be constructed while holding mempool.cs. After construction, the object's\n+// methods can be called without holding that lock.\n+public:\n+    CAmount fee_with_ancestors;\n+    int64_t vsize_with_ancestors;\n+    explicit MiniMinerMempoolEntry(CTxMemPool::txiter entry) :\n+        fee_individual{entry->GetModifiedFee()},\n+        tx{entry->GetTx()},\n+        vsize_individual(entry->GetTxSize()),\n+        fee_with_ancestors{entry->GetModFeesWithAncestors()},\n+        vsize_with_ancestors(entry->GetSizeWithAncestors())\n+    { }\n+\n+    CAmount GetModifiedFee() const { return fee_individual; }\n+    CAmount GetModFeesWithAncestors() const { return fee_with_ancestors; }\n+    int64_t GetTxSize() const { return vsize_individual; }\n+    int64_t GetSizeWithAncestors() const { return vsize_with_ancestors; }\n+    const CTransaction& GetTx() const LIFETIMEBOUND { return tx; }\n+};\n+\n+void UpdateForMinedAncestor(const MiniMinerMempoolEntry& ancestor, const MiniMinerMempoolEntry& descendant);\n+\n+// Comparator needed for std::set<MockEntryMap::iterator>\n+struct IteratorComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const\n+    {\n+        return &(*a) < &(*b);\n+    }\n+};\n+\n+/** A minimal version of BlockAssembler. Allows us to run the mining algorithm on a subset of\n+ * mempool transactions, ignoring consensus rules, to calculate mining scores. */\n+class MiniMiner\n+{\n+    // When true, a caller may use CalculateBumpFees(). Becomes false if we failed to retrieve\n+    // mempool entries (i.e. cluster size too large) or bump fees have already been calculated.\n+    bool m_ready_to_calculate{true};\n+\n+    // Original outpoints requested\n+    std::vector<COutPoint> m_requested_outpoints;\n+\n+    // Set once per lifetime, fill in during initialization.\n+    // txids of to-be-replaced transactions\n+    std::set<uint256> m_to_be_replaced;",
      "path": "src/node/mini_miner.h",
      "position": 63,
      "original_position": 68,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1120992192,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks for the suggestion, going to think about this some more, but don’t feel very strongly about it.",
      "created_at": "2023-03-03T22:17:55Z",
      "updated_at": "2023-03-03T22:28:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1125072522",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1125072522"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": 61,
      "original_start_line": 66,
      "start_side": "RIGHT",
      "line": 63,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126270559",
      "pull_request_review_id": 1326000785,
      "id": 1126270559,
      "node_id": "PRRC_kwDOABII585DIYZf",
      "diff_hunk": "@@ -0,0 +1,321 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    m_requested_outpoints = outpoints;\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is unconfirmed and in the mempool.\n+            auto it = m_requested_outpoints_by_txid.find(outpoint.hash);\n+            if (it != m_requested_outpoints_by_txid.end()) {\n+                it->second.push_back(outpoint);\n+            } else {\n+                std::vector<COutPoint> outpoints_of_tx({outpoint});\n+                m_requested_outpoints_by_txid.emplace(outpoint.hash, outpoints_of_tx);\n+            }\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;",
      "path": "src/node/mini_miner.cpp",
      "position": 58,
      "original_position": 63,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1121184614,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Is m_ready_to_calculate an error indication, since it seems it can be false only If we hit the DoS limit?\r\n\r\nNo it's not just for indicating DoS limit reached, notice that it is also set to false after `BuildMockTemplate` is called. It prevents somebody from constructing a `MiniMiner` and calling `CalculateBumpFees()` or `CalculateTotalBumpFees()` multiple times, which could result in very incorrect results if the target feerate changes.",
      "created_at": "2023-03-06T11:20:53Z",
      "updated_at": "2023-03-06T12:27:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1126270559",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126270559"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": 57,
      "original_start_line": 62,
      "start_side": "RIGHT",
      "line": 58,
      "original_line": 58,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126320439",
      "pull_request_review_id": 1326000785,
      "id": 1126320439,
      "node_id": "PRRC_kwDOABII585DIkk3",
      "diff_hunk": "@@ -1154,43 +1154,43 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     assert(false);\n }\n \n-std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+std::vector<CTxMemPool::txiter> CTxMemPool::GatherClusters(const std::vector<uint256>& txids) const",
      "path": "src/txmempool.cpp",
      "position": 41,
      "original_position": 5,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "5ee6f89e4057e56514a036995a014e2a0fe64166",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: It seems the rename to `GatherClusters` should have been squashed into efeee8b51d, but is in 5ee6f89e40 instead?",
      "created_at": "2023-03-06T11:59:54Z",
      "updated_at": "2023-03-06T12:27:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1126320439",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126320439"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1157,
      "original_line": 1157,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126716115",
      "pull_request_review_id": 1326682860,
      "id": 1126716115,
      "node_id": "PRRC_kwDOABII585DKFLT",
      "diff_hunk": "@@ -1140,3 +1153,44 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    {\n+        // Use epoch: visiting an entry means we have added it to the cluster vector. It does not\n+        // necessarily mean the entry has been processed.\n+        WITH_FRESH_EPOCH(m_epoch);\n+        for (const auto& it : cluster) {\n+            visited(it);\n+        }\n+        // i = index of where the list of entries to process starts\n+        for (size_t i{0}, to_process_count{txids.size()}; i < to_process_count; ++i) {\n+            // DoS protection: if not finished after processing 500 entries, just quit.\n+            if (to_process_count > 500) return {};\n+            for (const CTxMemPoolEntry& parent_entry : cluster.at(i)->GetMemPoolParentsConst()) {\n+                const auto parent_it = mapTx.iterator_to(parent_entry);\n+                if (!visited(parent_it)) {\n+                    cluster.push_back(parent_it);\n+                    // we still need to process this\n+                    ++to_process_count;\n+                }\n+            }\n+            for (const CTxMemPoolEntry& child_entry : cluster.at(i)->GetMemPoolChildrenConst()) {\n+                const auto child_it = mapTx.iterator_to(child_entry);\n+                if (!visited(child_it)) {\n+                    cluster.push_back(child_it);\n+                    // we still need to process this\n+                    ++to_process_count;\n+                }\n+            }",
      "path": "src/txmempool.cpp",
      "position": null,
      "original_position": 76,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "efeee8b51dfb77774540c8afd106b90ce695f9dd",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit:\r\n```c++\r\nconst txiter& tx_iter = clustered_txs.at(i);\r\nfor (const auto& entries : {tx_iter->GetMemPoolParentsConst(), tx_iter->GetMemPoolChildrenConst()}) {\r\n     for (const CTxMemPoolEntry& entry : entries) {\r\n          const auto entry_it = mapTx.iterator_to(entry);\r\n          if (!visited(entry_it)) {\r\n              clustered_txs.push_back(entry_it);\r\n              ++to_process_count;  // we still need to process this\r\n           }\r\n     }\r\n}\r\n```",
      "created_at": "2023-03-06T16:28:55Z",
      "updated_at": "2023-03-06T19:40:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1126716115",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126716115"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 1177,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1178,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126719573",
      "pull_request_review_id": 1326682860,
      "id": 1126719573,
      "node_id": "PRRC_kwDOABII585DKGBV",
      "diff_hunk": "@@ -1140,3 +1153,44 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {",
      "path": "src/txmempool.cpp",
      "position": null,
      "original_position": 45,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "efeee8b51dfb77774540c8afd106b90ce695f9dd",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: this can just be `cluster.empty()`",
      "created_at": "2023-03-06T16:31:02Z",
      "updated_at": "2023-03-06T19:40:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1126719573",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126719573"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1161,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126727129",
      "pull_request_review_id": 1326682860,
      "id": 1126727129,
      "node_id": "PRRC_kwDOABII585DKH3Z",
      "diff_hunk": "@@ -1140,3 +1153,44 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};",
      "path": "src/txmempool.cpp",
      "position": null,
      "original_position": 44,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "efeee8b51dfb77774540c8afd106b90ce695f9dd",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could add above this line an early return:\r\n```c++\r\nif (txids.size > 500) return {};\r\n```",
      "created_at": "2023-03-06T16:35:39Z",
      "updated_at": "2023-03-06T19:40:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1126727129",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126727129"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1160,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126736075",
      "pull_request_review_id": 1326682860,
      "id": 1126736075,
      "node_id": "PRRC_kwDOABII585DKKDL",
      "diff_hunk": "@@ -0,0 +1,314 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // UXTO is created by transaction in mempool, add to map.\n+            // Note: This will either create a missing entry or add the outpoint to an existing entry\n+            m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, outpoints]: m_requested_outpoints_by_txid) {",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 61,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "5ee6f89e4057e56514a036995a014e2a0fe64166",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "'outpoints' naming shadows the function's arg. Could\r\n```c++\r\nfor (const auto& [txid, _] : m_requested_outpoints_by_txid) {\r\n```",
      "created_at": "2023-03-06T16:41:42Z",
      "updated_at": "2023-03-06T19:40:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1126736075",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126736075"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126752055",
      "pull_request_review_id": 1326746650,
      "id": 1126752055,
      "node_id": "PRRC_kwDOABII585DKN83",
      "diff_hunk": "@@ -585,6 +592,10 @@ class CTxMemPool\n         const Limits& limits,\n         bool fSearchForParents = true) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n+    /** Get entire list of connected transactions for all transactions in txids. All txids must\n+     * correspond to transactions in the mempool, otherwise this returns an empty vector. */",
      "path": "src/txmempool.h",
      "position": null,
      "original_position": 23,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "efeee8b51dfb77774540c8afd106b90ce695f9dd",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think that it would be good to mention the 500 entries DoS limit here, plus the fact that we also return an empty vector if that is limit is breached - since that's something possible future users of this function would want to know about.",
      "created_at": "2023-03-06T16:51:57Z",
      "updated_at": "2023-03-09T21:37:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1126752055",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126752055"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 596,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126878745",
      "pull_request_review_id": 1326996214,
      "id": 1126878745,
      "node_id": "PRRC_kwDOABII585DKs4Z",
      "diff_hunk": "@@ -1154,43 +1154,43 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     assert(false);\n }\n \n-std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+std::vector<CTxMemPool::txiter> CTxMemPool::GatherClusters(const std::vector<uint256>& txids) const",
      "path": "src/txmempool.cpp",
      "position": 41,
      "original_position": 5,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "5ee6f89e4057e56514a036995a014e2a0fe64166",
      "in_reply_to_id": 1126320439,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, the rename was meant to be in the first commit. Thanks",
      "created_at": "2023-03-06T18:44:52Z",
      "updated_at": "2023-03-06T18:44:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1126878745",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1126878745"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1157,
      "original_line": 1157,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127069573",
      "pull_request_review_id": 1327244857,
      "id": 1127069573,
      "node_id": "PRRC_kwDOABII585DLbeF",
      "diff_hunk": "@@ -1140,3 +1153,44 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    {\n+        // Use epoch: visiting an entry means we have added it to the cluster vector. It does not\n+        // necessarily mean the entry has been processed.\n+        WITH_FRESH_EPOCH(m_epoch);\n+        for (const auto& it : cluster) {\n+            visited(it);\n+        }\n+        // i = index of where the list of entries to process starts\n+        for (size_t i{0}, to_process_count{txids.size()}; i < to_process_count; ++i) {\n+            // DoS protection: if not finished after processing 500 entries, just quit.\n+            if (to_process_count > 500) return {};\n+            for (const CTxMemPoolEntry& parent_entry : cluster.at(i)->GetMemPoolParentsConst()) {\n+                const auto parent_it = mapTx.iterator_to(parent_entry);\n+                if (!visited(parent_it)) {\n+                    cluster.push_back(parent_it);\n+                    // we still need to process this\n+                    ++to_process_count;\n+                }\n+            }\n+            for (const CTxMemPoolEntry& child_entry : cluster.at(i)->GetMemPoolChildrenConst()) {\n+                const auto child_it = mapTx.iterator_to(child_entry);\n+                if (!visited(child_it)) {\n+                    cluster.push_back(child_it);\n+                    // we still need to process this\n+                    ++to_process_count;\n+                }\n+            }",
      "path": "src/txmempool.cpp",
      "position": null,
      "original_position": 76,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "efeee8b51dfb77774540c8afd106b90ce695f9dd",
      "in_reply_to_id": 1126716115,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Great, thanks",
      "created_at": "2023-03-06T21:49:13Z",
      "updated_at": "2023-03-06T21:49:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1127069573",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127069573"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 1177,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1178,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127076941",
      "pull_request_review_id": 1327256950,
      "id": 1127076941,
      "node_id": "PRRC_kwDOABII585DLdRN",
      "diff_hunk": "@@ -1140,3 +1153,44 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {",
      "path": "src/txmempool.cpp",
      "position": null,
      "original_position": 45,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "efeee8b51dfb77774540c8afd106b90ce695f9dd",
      "in_reply_to_id": 1126719573,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good catch",
      "created_at": "2023-03-06T21:56:48Z",
      "updated_at": "2023-03-06T21:56:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1127076941",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127076941"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1161,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127077341",
      "pull_request_review_id": 1327257336,
      "id": 1127077341,
      "node_id": "PRRC_kwDOABII585DLdXd",
      "diff_hunk": "@@ -1140,3 +1153,44 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};",
      "path": "src/txmempool.cpp",
      "position": null,
      "original_position": 44,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "efeee8b51dfb77774540c8afd106b90ce695f9dd",
      "in_reply_to_id": 1126727129,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Okay, added",
      "created_at": "2023-03-06T21:57:06Z",
      "updated_at": "2023-03-06T21:57:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1127077341",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127077341"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1160,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127079196",
      "pull_request_review_id": 1327259392,
      "id": 1127079196,
      "node_id": "PRRC_kwDOABII585DLd0c",
      "diff_hunk": "@@ -0,0 +1,314 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // UXTO is created by transaction in mempool, add to map.\n+            // Note: This will either create a missing entry or add the outpoint to an existing entry\n+            m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, outpoints]: m_requested_outpoints_by_txid) {",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 61,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "5ee6f89e4057e56514a036995a014e2a0fe64166",
      "in_reply_to_id": 1126736075,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You’re right, fixed",
      "created_at": "2023-03-06T21:58:45Z",
      "updated_at": "2023-03-06T21:58:45Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1127079196",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127079196"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127091583",
      "pull_request_review_id": 1327277550,
      "id": 1127091583,
      "node_id": "PRRC_kwDOABII585DLg1_",
      "diff_hunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_MINI_MINER_H\n+#define BITCOIN_NODE_MINI_MINER_H\n+\n+#include <txmempool.h>\n+\n+#include <memory>\n+#include <optional>\n+#include <stdint.h>\n+\n+namespace node {\n+\n+// Container for tracking updates to ancestor feerate as we include ancestors in the \"block\"\n+class MiniMinerMempoolEntry\n+{\n+    const CAmount fee_individual;\n+    const CTransaction tx;\n+    const int64_t vsize_individual;\n+\n+// This class must be constructed while holding mempool.cs. After construction, the object's\n+// methods can be called without holding that lock.\n+public:\n+    CAmount fee_with_ancestors;\n+    int64_t vsize_with_ancestors;\n+    explicit MiniMinerMempoolEntry(CTxMemPool::txiter entry) :\n+        fee_individual{entry->GetModifiedFee()},\n+        tx{entry->GetTx()},\n+        vsize_individual(entry->GetTxSize()),\n+        fee_with_ancestors{entry->GetModFeesWithAncestors()},\n+        vsize_with_ancestors(entry->GetSizeWithAncestors())\n+    { }\n+\n+    CAmount GetModifiedFee() const { return fee_individual; }\n+    CAmount GetModFeesWithAncestors() const { return fee_with_ancestors; }\n+    int64_t GetTxSize() const { return vsize_individual; }\n+    int64_t GetSizeWithAncestors() const { return vsize_with_ancestors; }\n+    const CTransaction& GetTx() const LIFETIMEBOUND { return tx; }\n+};\n+\n+void UpdateForMinedAncestor(const MiniMinerMempoolEntry& ancestor, const MiniMinerMempoolEntry& descendant);\n+\n+// Comparator needed for std::set<MockEntryMap::iterator>\n+struct IteratorComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const\n+    {\n+        return &(*a) < &(*b);\n+    }\n+};\n+\n+/** A minimal version of BlockAssembler. Allows us to run the mining algorithm on a subset of\n+ * mempool transactions, ignoring consensus rules, to calculate mining scores. */\n+class MiniMiner\n+{\n+    // When true, a caller may use CalculateBumpFees(). Becomes false if we failed to retrieve\n+    // mempool entries (i.e. cluster size too large) or bump fees have already been calculated.\n+    bool m_ready_to_calculate{true};\n+\n+    // Original outpoints requested\n+    std::vector<COutPoint> m_requested_outpoints;\n+\n+    // Set once per lifetime, fill in during initialization.\n+    // txids of to-be-replaced transactions\n+    std::set<uint256> m_to_be_replaced;",
      "path": "src/node/mini_miner.h",
      "position": 63,
      "original_position": 68,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1120992192,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I decided to leave it as is for now.",
      "created_at": "2023-03-06T22:13:27Z",
      "updated_at": "2023-03-06T22:13:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1127091583",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1127091583"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": 61,
      "original_start_line": 66,
      "start_side": "RIGHT",
      "line": 63,
      "original_line": 63,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128592892",
      "pull_request_review_id": 1326746650,
      "id": 1128592892,
      "node_id": "PRRC_kwDOABII585DRPX8",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<CTxMemPool::txiter> all_entries;\n+    std::map<uint256, int64_t> tx_vsizes;\n+    std::map<uint256, CAmount> tx_modified_fees;\n+    std::map<uint256, CFeeRate> tx_feerates;\n+    for (const auto& tx : all_transactions) {\n+        const auto entry = pool.GetIter(tx->GetHash()).value();\n+        all_entries.push_back(entry);\n+        tx_vsizes.emplace(tx->GetHash(), entry->GetTxSize());\n+        tx_modified_fees.emplace(tx->GetHash(), entry->GetModifiedFee());\n+        tx_feerates.emplace(tx->GetHash(), CFeeRate(entry->GetModifiedFee(), entry->GetTxSize()));\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        // Check tx1 bumpfee: no other bumper.\n+        const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+        auto it1_unspent = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(it1_unspent != bump_fees.end());\n+        if (target_feerate <= tx1_feerate) {\n+            BOOST_CHECK_EQUAL(it1_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(it1_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+    }",
      "path": "src/test/miniminer_tests.cpp",
      "position": null,
      "original_position": 182,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "5eb0158470da233dcc435b6284a2995e75037971",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Indentation is broken, here and below (I initially thought the for loop ended here).",
      "created_at": "2023-03-07T21:10:11Z",
      "updated_at": "2023-03-09T21:37:46Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1128592892",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1128592892"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 182,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1131024834",
      "pull_request_review_id": 1332819517,
      "id": 1131024834,
      "node_id": "PRRC_kwDOABII585DahHC",
      "diff_hunk": "@@ -0,0 +1,123 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_MINI_MINER_H\n+#define BITCOIN_NODE_MINI_MINER_H\n+\n+#include <txmempool.h>\n+\n+#include <memory>\n+#include <optional>\n+#include <stdint.h>\n+\n+namespace node {\n+\n+// Container for tracking updates to ancestor feerate as we include ancestors in the \"block\"\n+class MiniMinerMempoolEntry\n+{\n+    const CAmount fee_individual;\n+    const CTransaction tx;",
      "path": "src/node/mini_miner.h",
      "position": null,
      "original_position": 20,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "a0d54e6b8f8afab070de48911f3b11d4cdf289ff",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This can be a `CTransactionRef` (aka shared_ptr) and not a plain tx copy. Transaction data never changes.\r\n\r\nJust need to adapt the constructor to call `GetSharedTx` instead.",
      "created_at": "2023-03-09T13:23:30Z",
      "updated_at": "2023-03-09T21:30:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1131024834",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1131024834"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 20,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1131070331",
      "pull_request_review_id": 1332819517,
      "id": 1131070331,
      "node_id": "PRRC_kwDOABII585DasN7",
      "diff_hunk": "@@ -0,0 +1,318 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 34,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "a0d54e6b8f8afab070de48911f3b11d4cdf289ff",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In a0d54e6b:\r\n\r\n`mempool.CalculateDescendants` returns the base parent transaction. So you could remove this line and add a comment to remember it.\r\n",
      "created_at": "2023-03-09T14:00:12Z",
      "updated_at": "2023-03-09T21:30:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1131070331",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1131070331"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1131091527",
      "pull_request_review_id": 1332819517,
      "id": 1131091527,
      "node_id": "PRRC_kwDOABII585DaxZH",
      "diff_hunk": "@@ -0,0 +1,318 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // UXTO is created by transaction in mempool, add to map.\n+            // Note: This will either create a missing entry or add the outpoint to an existing entry\n+            m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 53,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "a0d54e6b8f8afab070de48911f3b11d4cdf289ff",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In https://github.com/bitcoin/bitcoin/commit/a0d54e6b8f8afab070de48911f3b11d4cdf289ff:\r\n\r\nnit:\r\nCould prevent extra `GetConflictTx` calls by moving the conflicting tx block of code inside the `mempool.exists` block.\r\ne.g.\r\n\r\n```c++\r\nfor (const auto& outpoint : outpoints) {\r\n     if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\r\n         // This UTXO is either confirmed or not yet submitted to mempool.\r\n         // If it's confirmed, no bump fee is required.\r\n         // If it's not yet submitted, we have no information, so return 0.\r\n         m_bump_fees.emplace(outpoint, 0);\r\n         continue;\r\n     }\r\n\r\n     // UXTO is created by transaction in mempool, add to map.\r\n     // Note: This will either create a missing entry or add the outpoint to an existing entry\r\n     m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\r\n\r\n     if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\r\n         // This outpoint is already being spent by another transaction in the mempool.\r\n         // We assume that the caller wants to replace this transaction (and its descendants).\r\n         // If the outpoint is from a mempool transaction, we still need to calculate its\r\n         // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\r\n         // removing the to-be-replaced entries. Note that this is only calculating bump fees.\r\n         // RBF fee rules should be handled separately.\r\n         \r\n         // Remove conflicting tx and descendants because they will be replaced as well. This case should be rare\r\n         // as the wallet won't normally attempt to replace transactions with descendants.\r\n         CTxMemPool::setEntries descendants;\r\n         mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\r\n         for (const auto& desc_txiter : descendants) {\r\n                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\r\n           }\r\n     }\r\n}\r\n```",
      "created_at": "2023-03-09T14:17:13Z",
      "updated_at": "2023-03-09T21:59:03Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1131091527",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1131091527"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 44,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1131618449",
      "pull_request_review_id": 1332819517,
      "id": 1131618449,
      "node_id": "PRRC_kwDOABII585DcyCR",
      "diff_hunk": "@@ -0,0 +1,318 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // UXTO is created by transaction in mempool, add to map.\n+            // Note: This will either create a missing entry or add the outpoint to an existing entry\n+            m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {",
      "path": "src/node/mini_miner.cpp",
      "position": 102,
      "original_position": 100,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "a0d54e6b8f8afab070de48911f3b11d4cdf289ff",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This has been puzzling me for a while.\r\n\r\nIt is not clear to me why need to calculate the descendants once more if the information is available in the cluster (it is just not accesible because data is unordered).\r\nCouldn't return from `GatherCluster` a map of tx id and its descendants instead? Like first going up into the DAG, starting with the highest parents, and then build the map<tx_id, vector<children>> with a recursive children call.\r\nIt looks like a heavy waste to recalculate the same twice.\r\n\r\nor well.. it is not that heavy because you set the 500 entries limit. hmm.. it still is duplicated work but it has a limit.\r\n\r\nAnother point is why continue traversing the children when the parent was marked to be removed? To double assert that the previous loop worked as expected? (if that is the case, what about decoupling the previous loop into a separate function and adding unit test coverage instead of all the runtime `Assume` calls?).",
      "created_at": "2023-03-09T21:19:43Z",
      "updated_at": "2023-03-12T13:39:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1131618449",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1131618449"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": 92,
      "original_start_line": 90,
      "start_side": "RIGHT",
      "line": 102,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1131782831",
      "pull_request_review_id": 1333993280,
      "id": 1131782831,
      "node_id": "PRRC_kwDOABII585DdaKv",
      "diff_hunk": "@@ -0,0 +1,318 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // UXTO is created by transaction in mempool, add to map.\n+            // Note: This will either create a missing entry or add the outpoint to an existing entry\n+            m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        const auto& ea = a->second;\n+        const CFeeRate a_feerate =\n+            ea.GetModFeesWithAncestors() * ea.GetTxSize() <= ea.GetModifiedFee() * ea.GetSizeWithAncestors() ?\n+            CFeeRate(ea.GetModFeesWithAncestors(), ea.GetSizeWithAncestors()) :\n+            CFeeRate(ea.GetModifiedFee(), ea.GetTxSize());\n+        const auto& eb = b->second;\n+        const CFeeRate b_feerate =\n+            eb.GetModFeesWithAncestors() * eb.GetTxSize() <= eb.GetModifiedFee() * eb.GetSizeWithAncestors() ?\n+            CFeeRate(eb.GetModFeesWithAncestors(), eb.GetSizeWithAncestors()) :\n+            CFeeRate(eb.GetModifiedFee(), eb.GetTxSize());\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Compare by txid\n+        return a->first < b->first;\n+    }\n+};",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 146,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "d227d394cdfc377169888dcf1d9f574f02903065",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This may be easier to comprehend:\r\n```\r\n// Compare by min(ancestor feerate, individual feerate), then iterator.\r\n//\r\n// The ancestor feerate of a high-feerate tx should be reduced by its\r\n// low-feerate ancestors, but the ancestor feerate of a low-feerate tx\r\n// should not be increased by its high-feerate ancestors.\r\nstruct AncestorFeerateComparator\r\n{\r\n    template<typename I>\r\n    bool operator()(const I& a, const I& b) const {\r\n        auto min_feerate = [](const MiniMinerMempoolEntry& e) -> CFeeRate {\r\n            const CAmount afee{e.GetModFeesWithAncestors()};\r\n            const int64_t asize{e.GetSizeWithAncestors()};\r\n            const CAmount fee{e.GetModifiedFee()};\r\n            const int64_t size{e.GetTxSize()};\r\n            // Comparing ancestor feerate with individual feerate:\r\n            //     afee / asize <= fee / size\r\n            // Avoid division and possible loss of precision by\r\n            // multiplying both sides by the sizes:\r\n            return afee * size < fee * asize ?\r\n                       CFeeRate(afee, asize) :\r\n                       CFeeRate(fee, size);\r\n        };\r\n        CFeeRate a_feerate{min_feerate(a->second)};\r\n        CFeeRate b_feerate{min_feerate(b->second)};\r\n        if (a_feerate != b_feerate) {\r\n            return a_feerate > b_feerate;\r\n        }\r\n        // Compare by txid\r\n        return a->first < b->first;\r\n    }\r\n};\r\n```",
      "created_at": "2023-03-10T00:08:50Z",
      "updated_at": "2023-03-10T00:08:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1131782831",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1131782831"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 125,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 157,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133185828",
      "pull_request_review_id": 1335963809,
      "id": 1133185828,
      "node_id": "PRRC_kwDOABII585Diwsk",
      "diff_hunk": "@@ -0,0 +1,183 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool() && !tx->vout.empty()) {\n+            // Add outpoint from this tx (may or not be spent by a later tx)\n+            outpoints.push_back(COutPoint{tx->GetHash(),\n+                                          (uint32_t)fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, tx->vout.size())});\n+        } else {\n+            // Add some random outpoint (will be interpreted as confirmed or not yet submitted\n+            // to mempool).\n+            auto outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+            if (outpoint.has_value() && std::find(outpoints.begin(), outpoints.end(), *outpoint) == outpoints.end()) {\n+                outpoints.push_back(*outpoint);\n+            }\n+        }\n+\n+    }\n+\n+    node::MiniMiner mini_miner{pool, outpoints};\n+    assert(mini_miner.IsReadyToCalculate());\n+    const CFeeRate target_feerate{CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/1000)}};\n+    if (fuzzed_data_provider.ConsumeBool()) {",
      "path": "src/test/fuzz/mini_miner.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "cf1636078f7e97110cab15646110fcc1ce935136",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I was curious about a possible relation between `sum(CalculateBumpFees)` over all outpoints, and `CalculateTotalBumpFees` for the same outpoints / target feerate.\r\nMy naive thought was that taking the sum over `CalculateBumpFees` might overestimate the total bump fee by counting the bumping of some mempool txs twice if there is a shared ancestry, and that the quantities should be equal if there is no shared ancestry. As a result, `CalculateTotalBumpFees` should never be larger than the sum of `CalculateBumpFees`.\r\nBut when I tried to test this hypothesis by changing the fuzz test here to not calculate just one but both quantities in each run (using two mini miners, see https://github.com/mzumsande/bitcoin/commit/e690c11a4c8e1d2d23037cc5439366ce722a9ef2) and then asserting that the above relation holds, it quickly fails - so where did I go wrong? ",
      "created_at": "2023-03-12T04:40:38Z",
      "updated_at": "2023-03-13T20:53:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1133185828",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1133185828"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1134606456",
      "pull_request_review_id": 1337937335,
      "id": 1134606456,
      "node_id": "PRRC_kwDOABII585DoLh4",
      "diff_hunk": "@@ -0,0 +1,183 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool() && !tx->vout.empty()) {\n+            // Add outpoint from this tx (may or not be spent by a later tx)\n+            outpoints.push_back(COutPoint{tx->GetHash(),\n+                                          (uint32_t)fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, tx->vout.size())});\n+        } else {\n+            // Add some random outpoint (will be interpreted as confirmed or not yet submitted\n+            // to mempool).\n+            auto outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+            if (outpoint.has_value() && std::find(outpoints.begin(), outpoints.end(), *outpoint) == outpoints.end()) {\n+                outpoints.push_back(*outpoint);\n+            }\n+        }\n+\n+    }\n+\n+    node::MiniMiner mini_miner{pool, outpoints};\n+    assert(mini_miner.IsReadyToCalculate());\n+    const CFeeRate target_feerate{CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/1000)}};\n+    if (fuzzed_data_provider.ConsumeBool()) {",
      "path": "src/test/fuzz/mini_miner.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "cf1636078f7e97110cab15646110fcc1ce935136",
      "in_reply_to_id": 1133185828,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks, that’s unexpected. I would also expect that `CalculateTotalBumpFees(…)` always is equal or smaller to the sum of individual bump fees. I’ll check it out.",
      "created_at": "2023-03-13T20:55:02Z",
      "updated_at": "2023-03-13T20:55:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1134606456",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1134606456"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136045597",
      "pull_request_review_id": 1340087246,
      "id": 1136045597,
      "node_id": "PRRC_kwDOABII585Dtq4d",
      "diff_hunk": "@@ -1140,3 +1153,39 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::GatherClusters(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    if (txids.size() > 500) return {}; // DoS protection, limit to 500 entries. We already have more than 500 txs, just quit.\n+    std::vector<txiter> clustered_txs{GetIterVec(txids)};\n+    if (clustered_txs.empty()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    {\n+        // Use epoch: visiting an entry means we have added it to the clustered_txs vector. It does not\n+        // necessarily mean the entry has been processed.\n+        WITH_FRESH_EPOCH(m_epoch);\n+        for (const auto& it : clustered_txs) {\n+            visited(it);\n+        }\n+        // i = index of where the list of entries to process starts\n+        for (size_t i{0}, to_process_count{txids.size()}; i < to_process_count; ++i) {\n+            // DoS protection: if not finished after processing 500 entries, just quit.\n+            if (to_process_count > 500) return {};",
      "path": "src/txmempool.cpp",
      "position": null,
      "original_position": 61,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "cf1636078f7e97110cab15646110fcc1ce935136",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit, it would be more logical for this check to be just after `to_process_count` is incremented below.",
      "created_at": "2023-03-14T18:51:59Z",
      "updated_at": "2023-03-24T21:57:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136045597",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136045597"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1177,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136047228",
      "pull_request_review_id": 1340087246,
      "id": 1136047228,
      "node_id": "PRRC_kwDOABII585DtrR8",
      "diff_hunk": "@@ -1140,3 +1153,39 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::GatherClusters(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    if (txids.size() > 500) return {}; // DoS protection, limit to 500 entries. We already have more than 500 txs, just quit.\n+    std::vector<txiter> clustered_txs{GetIterVec(txids)};\n+    if (clustered_txs.empty()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    {\n+        // Use epoch: visiting an entry means we have added it to the clustered_txs vector. It does not\n+        // necessarily mean the entry has been processed.\n+        WITH_FRESH_EPOCH(m_epoch);\n+        for (const auto& it : clustered_txs) {\n+            visited(it);\n+        }\n+        // i = index of where the list of entries to process starts\n+        for (size_t i{0}, to_process_count{txids.size()}; i < to_process_count; ++i) {",
      "path": "src/txmempool.cpp",
      "position": null,
      "original_position": 59,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "cf1636078f7e97110cab15646110fcc1ce935136",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit, I think you could eliminate the `to_process_count` variable, and just use the vector size instead.\r\n```suggestion\r\n        for (size_t i{0}; i < clustered_txs.size(); ++i) {\r\n```",
      "created_at": "2023-03-14T18:53:42Z",
      "updated_at": "2023-03-24T21:57:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136047228",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136047228"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1175,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136048292",
      "pull_request_review_id": 1340087246,
      "id": 1136048292,
      "node_id": "PRRC_kwDOABII585Dtrik",
      "diff_hunk": "@@ -1140,3 +1153,39 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::GatherClusters(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    if (txids.size() > 500) return {}; // DoS protection, limit to 500 entries. We already have more than 500 txs, just quit.\n+    std::vector<txiter> clustered_txs{GetIterVec(txids)};\n+    if (clustered_txs.empty()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }",
      "path": "src/txmempool.cpp",
      "position": null,
      "original_position": 50,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "cf1636078f7e97110cab15646110fcc1ce935136",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit, I think you can remove this code. (It's nice to eliminate special-case code, not only for simplicity, but to reduce testing.)",
      "created_at": "2023-03-14T18:54:41Z",
      "updated_at": "2023-03-24T21:57:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136048292",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136048292"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 1162,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1166,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136051666",
      "pull_request_review_id": 1340087246,
      "id": 1136051666,
      "node_id": "PRRC_kwDOABII585DtsXS",
      "diff_hunk": "@@ -1140,3 +1153,49 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::CalculateCluster(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> cluster{GetIterVec(txids)};\n+    if (cluster.size() != txids.size()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    // Reserve total ancestor + descendant counts of each transaction.  This is an approximation; it\n+    // may overestimate because transactions may share ancestors/descendants, and may underestimate\n+    // because the cluster may include more than just ancestors and descendants.\n+    cluster.reserve(std::accumulate(cluster.cbegin(), cluster.cend(), 0, [](size_t sum, const auto it) {\n+        return sum + it->GetCountWithAncestors() + it->GetCountWithDescendants() - 1; }));\n+    {\n+        // Use epoch: visiting an entry means we have added it to the cluster vector. It does not\n+        // necessarily mean the entry has been processed.\n+        WITH_FRESH_EPOCH(m_epoch);\n+        for (const auto& it : cluster) {\n+            visited(it);\n+        }\n+        // i = index of where the list of entries to process starts\n+        for (size_t i{0}, to_process_count{txids.size()}; i < to_process_count; ++i) {\n+            // DoS protection: if not finished after processing 500 entries, just quit.\n+            if (to_process_count > 500) return {};",
      "path": "src/txmempool.cpp",
      "position": null,
      "original_position": 65,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ce882ef0cf338d390733dd85e339a1c0da73072c",
      "in_reply_to_id": 1121191113,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "That's fine, suggestion withdrawn :)",
      "created_at": "2023-03-14T18:57:40Z",
      "updated_at": "2023-03-24T21:57:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136051666",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136051666"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 1180,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1177,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136136446",
      "pull_request_review_id": 1340199248,
      "id": 1136136446,
      "node_id": "PRRC_kwDOABII585DuBD-",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // UXTO is created by transaction in mempool, add to map.\n+            // Note: This will either create a missing entry or add the outpoint to an existing entry\n+            m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        const auto& ea = a->second;\n+        const CFeeRate a_feerate =\n+            ea.GetModFeesWithAncestors() * ea.GetTxSize() <= ea.GetModifiedFee() * ea.GetSizeWithAncestors() ?\n+            CFeeRate(ea.GetModFeesWithAncestors(), ea.GetSizeWithAncestors()) :\n+            CFeeRate(ea.GetModifiedFee(), ea.GetTxSize());\n+        const auto& eb = b->second;\n+        const CFeeRate b_feerate =\n+            eb.GetModFeesWithAncestors() * eb.GetTxSize() <= eb.GetModifiedFee() * eb.GetSizeWithAncestors() ?\n+            CFeeRate(eb.GetModFeesWithAncestors(), eb.GetSizeWithAncestors()) :\n+            CFeeRate(eb.GetModifiedFee(), eb.GetTxSize());\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Compare by txid\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entry’s descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());\n+            descendant->second.fee_with_ancestors -= anc->second.GetModifiedFee();\n+            descendant->second.vsize_with_ancestors -= anc->second.GetTxSize();\n+        }\n+    }\n+    // Delete these entries.\n+    for (const auto& anc : ancestors) {\n+        m_descendant_set_by_txid.erase(anc->first);\n+        // The above loop should have deducted each ancestor's size and fees from each of their\n+        // respective descendants exactly once.\n+        Assume(anc->second.GetModFeesWithAncestors() == 0);\n+        Assume(anc->second.GetSizeWithAncestors() == 0);\n+        auto vec_it = std::find(m_entries.begin(), m_entries.end(), anc);\n+        Assume(vec_it != m_entries.end());\n+        m_entries.erase(vec_it);\n+        m_entries_by_txid.erase(anc);\n+    }\n+}\n+\n+void MiniMiner::SanityCheck() const\n+{\n+    // m_entries, m_entries_by_txid, and m_descendant_set_by_txid all same size\n+    Assume(m_entries.size() == m_entries_by_txid.size());\n+    Assume(m_entries.size() == m_descendant_set_by_txid.size());\n+    // Cached ancestor values should be at least as large as the transaction's own fee and size\n+    Assume(std::all_of(m_entries.begin(), m_entries.end(), [](const auto& entry) {\n+        return entry->second.GetSizeWithAncestors() >= entry->second.GetTxSize() &&\n+               entry->second.GetModFeesWithAncestors() >= entry->second.GetModifiedFee();}));\n+    // None of the entries should be to-be-replaced transactions\n+    Assume(std::all_of(m_to_be_replaced.begin(), m_to_be_replaced.end(),\n+        [&](const auto& txid){return m_entries_by_txid.find(txid) == m_entries_by_txid.end();}));\n+}\n+\n+void MiniMiner::BuildMockTemplate(const CFeeRate& target_feerate)\n+{\n+    while (!m_entries_by_txid.empty()) {\n+        // Sort again, since transaction removal may change some m_entries' ancestor feerates.\n+        std::sort(m_entries.begin(), m_entries.end(), AncestorFeerateComparator());\n+\n+        // Pick highest ancestor feerate entry.\n+        auto best_iter = m_entries.begin();\n+        Assume(best_iter != m_entries.end());\n+        const auto ancestor_package_size = (*best_iter)->second.GetSizeWithAncestors();\n+        const auto ancestor_package_fee = (*best_iter)->second.GetModFeesWithAncestors();\n+        // Stop here. Everything that didn't \"make it into the block\" has bumpfee.\n+        if (ancestor_package_fee < target_feerate.GetFee(ancestor_package_size)) {\n+            break;\n+        }\n+\n+        // Calculate ancestors on the fly. This lookup should be fairly cheap, and ancestor sets\n+        // change at every iteration, so this is more efficient than maintaining a cache.\n+        std::set<MockEntryMap::iterator, IteratorComparator> ancestors;\n+        {\n+            std::set<MockEntryMap::iterator, IteratorComparator> to_process;\n+            to_process.insert(*best_iter);\n+            while (!to_process.empty()) {\n+                auto iter = to_process.begin();\n+                Assume(iter != to_process.end());\n+                ancestors.insert(*iter);\n+                for (const auto& input : (*iter)->second.GetTx().vin) {\n+                    if (auto parent_it{m_entries_by_txid.find(input.prevout.hash)}; parent_it != m_entries_by_txid.end()) {\n+                        if (ancestors.count(parent_it) == 0) {\n+                            to_process.insert(parent_it);\n+                        }\n+                    }\n+                }\n+                to_process.erase(iter);\n+            }\n+        }\n+        DeleteAncestorPackage(ancestors);\n+        SanityCheck();\n+    }\n+    Assume(m_in_block.empty() || m_total_fees >= target_feerate.GetFee(m_total_vsize));\n+    // Do not try to continue building the block template with a different feerate.\n+    m_ready_to_calculate = false;\n+}\n+\n+std::map<COutPoint, CAmount> MiniMiner::CalculateBumpFees(const CFeeRate& target_feerate)\n+{\n+    if (!m_ready_to_calculate) return {};\n+    // Build a block template until the target feerate is hit.\n+    BuildMockTemplate(target_feerate);\n+\n+    // Each transaction that \"made it into the block\" has a bumpfee of 0, i.e. they are part of an\n+    // ancestor package with at least the target feerate and don't need to be bumped.\n+    for (const auto& txid : m_in_block) {\n+        // Not all of the block transactions were necessarily requested.\n+        auto it = m_requested_outpoints_by_txid.find(txid);\n+        if (it != m_requested_outpoints_by_txid.end()) {\n+            for (const auto& outpoint : it->second) {\n+                m_bump_fees.emplace(outpoint, 0);\n+            }\n+            m_requested_outpoints_by_txid.erase(it);\n+        }\n+    }\n+\n+    // A transactions and its ancestors will only be picked into a block when\n+    // both the ancestor set feerate and the individual feerate meet the target\n+    // feerate.\n+    //\n+    // We had to convince ourselves that after running the mini miner and\n+    // picking all eligible transactions into our MockBlockTemplate, there\n+    // could still be transactions remaining that have a lower individual\n+    // feerate than their ancestor feerate. So here is an example:\n+    //\n+    //               ┌─────────────────┐\n+    //               │                 │\n+    //               │   Grandparent   │\n+    //               │    1700 vB      │\n+    //               │    1700 sats    │                    Target feerate: 10    s/vB\n+    //               │       1 s/vB    │    GP Ancestor Set Feerate (ASFR):  1    s/vB\n+    //               │                 │                           P1_ASFR:  9.84 s/vB\n+    //               └──────▲───▲──────┘                           P2_ASFR:  2.47 s/vB\n+    //                      │   │                                   C_ASFR: 10.27 s/vB\n+    // ┌───────────────┐    │   │    ┌──────────────┐\n+    // │               ├────┘   └────┤              │             ⇒ C_FR < TFR < C_ASFR\n+    // │   Parent 1    │             │   Parent 2   │\n+    // │    200 vB     │             │    200 vB    │\n+    // │  17000 sats   │             │   3000 sats  │\n+    // │     85 s/vB   │             │     15 s/vB  │\n+    // │               │             │              │\n+    // └───────────▲───┘             └───▲──────────┘\n+    //             │                     │\n+    //             │    ┌───────────┐    │\n+    //             └────┤           ├────┘\n+    //                  │   Child   │\n+    //                  │  100 vB   │\n+    //                  │  900 sats │\n+    //                  │    9 s/vB │\n+    //                  │           │\n+    //                  └───────────┘\n+    //\n+    // We therefore calculate both the bump fee that is necessary to elevate\n+    // the individual transaction to the target feerate:\n+    //         target_feerate × tx_size - tx_fees\n+    // and the bump fee that is necessary to bump the entire ancestor set to\n+    // the target feerate:\n+    //         target_feerate × ancestor_set_size - ancestor_set_fees\n+    // By picking the maximum from the two, we ensure that a transaction meets\n+    // both criteria.\n+    for (const auto& [txid, outpoints] : m_requested_outpoints_by_txid) {\n+        auto it = m_entries_by_txid.find(txid);\n+        Assume(it != m_entries_by_txid.end());\n+        if (it != m_entries_by_txid.end()) {\n+            Assume(target_feerate.GetFee(it->second.GetSizeWithAncestors()) > std::min(it->second.GetModifiedFee(), it->second.GetModFeesWithAncestors()));\n+            CAmount bump_fee_with_ancestors = target_feerate.GetFee(it->second.GetSizeWithAncestors()) - it->second.GetModFeesWithAncestors();\n+            CAmount bump_fee_individual = target_feerate.GetFee(it->second.GetTxSize()) - it->second.GetModifiedFee();\n+            const CAmount bump_fee{std::max(bump_fee_with_ancestors, bump_fee_individual)};\n+            Assume(bump_fee >= 0);\n+            for (const auto& outpoint : outpoints) {\n+                m_bump_fees.emplace(outpoint, bump_fee);\n+            }\n+        }\n+    }\n+    return m_bump_fees;\n+}\n+\n+std::optional<CAmount> MiniMiner::CalculateTotalBumpFees(const CFeeRate& target_feerate)\n+{\n+    if (!m_ready_to_calculate) return std::nullopt;\n+    // Build a block template until the target feerate is hit.\n+    BuildMockTemplate(target_feerate);\n+\n+    // All remaining ancestors that are not part of m_in_block must be bumped, but no other relatives\n+    std::set<MockEntryMap::iterator, IteratorComparator> ancestors;\n+    {\n+        std::set<MockEntryMap::iterator, IteratorComparator> to_process;\n+        for (const auto& [txid, outpoints] : m_requested_outpoints_by_txid) {\n+            // Skip any ancestors that already have a miner score higher than the target feerate\n+            // (already \"made it\" into the block)\n+            if (m_in_block.count(txid)) continue;\n+            auto iter = m_entries_by_txid.find(txid);\n+            if (iter == m_entries_by_txid.end()) continue;\n+            to_process.insert(iter);\n+            ancestors.insert(iter);\n+        }\n+        while (!to_process.empty()) {\n+            auto iter = to_process.begin();\n+            assert(iter != to_process.end());\n+            const CTransaction& tx = (*iter)->second.GetTx();\n+            for (const auto& input : tx.vin) {\n+                if (auto parent_it{m_entries_by_txid.find(input.prevout.hash)}; parent_it != m_entries_by_txid.end()) {\n+                    to_process.insert(parent_it);\n+                    ancestors.insert(parent_it);\n+                }\n+            }\n+            to_process.erase(iter);\n+        }\n+    }\n+    const auto ancestor_package_size = std::accumulate(ancestors.cbegin(), ancestors.cend(), 0,\n+        [](int64_t sum, const auto it) {return sum + it->second.GetTxSize();});\n+    const auto ancestor_package_fee = std::accumulate(ancestors.cbegin(), ancestors.cend(), 0,",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 354,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "82d068ea0e247e7deb3f4dd2c222db3d3eb6d0e4",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The init value should be `CAmount{0}`, not `0` which would convert the summed items to `int`, see [std::accumulate](https://en.cppreference.com/w/cpp/algorithm/accumulate) under \"Common mistakes\". This caused the unexpected fuzzer behavior I saw, because the `int` could overflow.\r\nAlso, for `ancestor_package_size`, the init value should be `int64_t{0}`;",
      "created_at": "2023-03-14T20:09:38Z",
      "updated_at": "2023-03-14T20:25:31Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136136446",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136136446"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 354,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136146262",
      "pull_request_review_id": 1340211226,
      "id": 1136146262,
      "node_id": "PRRC_kwDOABII585DuDdW",
      "diff_hunk": "@@ -0,0 +1,183 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool() && !tx->vout.empty()) {\n+            // Add outpoint from this tx (may or not be spent by a later tx)\n+            outpoints.push_back(COutPoint{tx->GetHash(),\n+                                          (uint32_t)fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, tx->vout.size())});\n+        } else {\n+            // Add some random outpoint (will be interpreted as confirmed or not yet submitted\n+            // to mempool).\n+            auto outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+            if (outpoint.has_value() && std::find(outpoints.begin(), outpoints.end(), *outpoint) == outpoints.end()) {\n+                outpoints.push_back(*outpoint);\n+            }\n+        }\n+\n+    }\n+\n+    node::MiniMiner mini_miner{pool, outpoints};\n+    assert(mini_miner.IsReadyToCalculate());\n+    const CFeeRate target_feerate{CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/1000)}};\n+    if (fuzzed_data_provider.ConsumeBool()) {",
      "path": "src/test/fuzz/mini_miner.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "cf1636078f7e97110cab15646110fcc1ce935136",
      "in_reply_to_id": 1133185828,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I commented below for this. After fixing this, the fuzzer doesn't crash anymore (at least not immediately, haven't run it for long). \r\nI wonder if it might make sense to adjust the fuzz test permanently similar to my branch above and assert `sum(CalculateBumpFees) >= CalculateTotalBumpFees()`, if that is really the expectation - in general, I like it if fuzz tests contain asserts that test actual non-trivial high-level expectations we have for the code, and don't just run over the code \"blindly\".",
      "created_at": "2023-03-14T20:18:26Z",
      "updated_at": "2023-03-14T21:47:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136146262",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136146262"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136214058",
      "pull_request_review_id": 1340290546,
      "id": 1136214058,
      "node_id": "PRRC_kwDOABII585DuUAq",
      "diff_hunk": "@@ -585,6 +592,10 @@ class CTxMemPool\n         const Limits& limits,\n         bool fSearchForParents = true) const EXCLUSIVE_LOCKS_REQUIRED(cs);\n \n+    /** Get entire list of connected transactions for all transactions in txids. All txids must\n+     * correspond to transactions in the mempool, otherwise this returns an empty vector. */",
      "path": "src/txmempool.h",
      "position": null,
      "original_position": 23,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "efeee8b51dfb77774540c8afd106b90ce695f9dd",
      "in_reply_to_id": 1126752055,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I’ve updated the comment to mention the 500 entry limit and the resulting empty vector.",
      "created_at": "2023-03-14T21:14:39Z",
      "updated_at": "2023-03-14T22:56:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136214058",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136214058"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 596,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136215648",
      "pull_request_review_id": 1340290546,
      "id": 1136215648,
      "node_id": "PRRC_kwDOABII585DuUZg",
      "diff_hunk": "@@ -0,0 +1,318 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 34,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "a0d54e6b8f8afab070de48911f3b11d4cdf289ff",
      "in_reply_to_id": 1131070331,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Good catch. I’ve removed the line and amended the comment to clarify that the transaction is part of the descendants.",
      "created_at": "2023-03-14T21:16:00Z",
      "updated_at": "2023-03-14T22:56:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136215648",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136215648"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 34,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136217858",
      "pull_request_review_id": 1340290546,
      "id": 1136217858,
      "node_id": "PRRC_kwDOABII585DuU8C",
      "diff_hunk": "@@ -0,0 +1,318 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // UXTO is created by transaction in mempool, add to map.\n+            // Note: This will either create a missing entry or add the outpoint to an existing entry\n+            m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 53,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "a0d54e6b8f8afab070de48911f3b11d4cdf289ff",
      "in_reply_to_id": 1131091527,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks, I’ve adopted your suggestion and moved `!mempool.exists` first.",
      "created_at": "2023-03-14T21:17:56Z",
      "updated_at": "2023-03-14T22:56:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136217858",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136217858"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 44,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 53,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136294354",
      "pull_request_review_id": 1340290546,
      "id": 1136294354,
      "node_id": "PRRC_kwDOABII585DunnS",
      "diff_hunk": "@@ -0,0 +1,318 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // UXTO is created by transaction in mempool, add to map.\n+            // Note: This will either create a missing entry or add the outpoint to an existing entry\n+            m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        const auto& ea = a->second;\n+        const CFeeRate a_feerate =\n+            ea.GetModFeesWithAncestors() * ea.GetTxSize() <= ea.GetModifiedFee() * ea.GetSizeWithAncestors() ?\n+            CFeeRate(ea.GetModFeesWithAncestors(), ea.GetSizeWithAncestors()) :\n+            CFeeRate(ea.GetModifiedFee(), ea.GetTxSize());\n+        const auto& eb = b->second;\n+        const CFeeRate b_feerate =\n+            eb.GetModFeesWithAncestors() * eb.GetTxSize() <= eb.GetModifiedFee() * eb.GetSizeWithAncestors() ?\n+            CFeeRate(eb.GetModFeesWithAncestors(), eb.GetSizeWithAncestors()) :\n+            CFeeRate(eb.GetModifiedFee(), eb.GetTxSize());\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Compare by txid\n+        return a->first < b->first;\n+    }\n+};",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 146,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "d227d394cdfc377169888dcf1d9f574f02903065",
      "in_reply_to_id": 1131782831,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks I took your suggestion with slightly more elaborate variable names.",
      "created_at": "2023-03-14T22:31:24Z",
      "updated_at": "2023-03-14T22:56:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136294354",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136294354"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 125,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 157,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136299879",
      "pull_request_review_id": 1340290546,
      "id": 1136299879,
      "node_id": "PRRC_kwDOABII585Duo9n",
      "diff_hunk": "@@ -0,0 +1,358 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // UXTO is created by transaction in mempool, add to map.\n+            // Note: This will either create a missing entry or add the outpoint to an existing entry\n+            m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        const auto& ea = a->second;\n+        const CFeeRate a_feerate =\n+            ea.GetModFeesWithAncestors() * ea.GetTxSize() <= ea.GetModifiedFee() * ea.GetSizeWithAncestors() ?\n+            CFeeRate(ea.GetModFeesWithAncestors(), ea.GetSizeWithAncestors()) :\n+            CFeeRate(ea.GetModifiedFee(), ea.GetTxSize());\n+        const auto& eb = b->second;\n+        const CFeeRate b_feerate =\n+            eb.GetModFeesWithAncestors() * eb.GetTxSize() <= eb.GetModifiedFee() * eb.GetSizeWithAncestors() ?\n+            CFeeRate(eb.GetModFeesWithAncestors(), eb.GetSizeWithAncestors()) :\n+            CFeeRate(eb.GetModifiedFee(), eb.GetTxSize());\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Compare by txid\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entry’s descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());\n+            descendant->second.fee_with_ancestors -= anc->second.GetModifiedFee();\n+            descendant->second.vsize_with_ancestors -= anc->second.GetTxSize();\n+        }\n+    }\n+    // Delete these entries.\n+    for (const auto& anc : ancestors) {\n+        m_descendant_set_by_txid.erase(anc->first);\n+        // The above loop should have deducted each ancestor's size and fees from each of their\n+        // respective descendants exactly once.\n+        Assume(anc->second.GetModFeesWithAncestors() == 0);\n+        Assume(anc->second.GetSizeWithAncestors() == 0);\n+        auto vec_it = std::find(m_entries.begin(), m_entries.end(), anc);\n+        Assume(vec_it != m_entries.end());\n+        m_entries.erase(vec_it);\n+        m_entries_by_txid.erase(anc);\n+    }\n+}\n+\n+void MiniMiner::SanityCheck() const\n+{\n+    // m_entries, m_entries_by_txid, and m_descendant_set_by_txid all same size\n+    Assume(m_entries.size() == m_entries_by_txid.size());\n+    Assume(m_entries.size() == m_descendant_set_by_txid.size());\n+    // Cached ancestor values should be at least as large as the transaction's own fee and size\n+    Assume(std::all_of(m_entries.begin(), m_entries.end(), [](const auto& entry) {\n+        return entry->second.GetSizeWithAncestors() >= entry->second.GetTxSize() &&\n+               entry->second.GetModFeesWithAncestors() >= entry->second.GetModifiedFee();}));\n+    // None of the entries should be to-be-replaced transactions\n+    Assume(std::all_of(m_to_be_replaced.begin(), m_to_be_replaced.end(),\n+        [&](const auto& txid){return m_entries_by_txid.find(txid) == m_entries_by_txid.end();}));\n+}\n+\n+void MiniMiner::BuildMockTemplate(const CFeeRate& target_feerate)\n+{\n+    while (!m_entries_by_txid.empty()) {\n+        // Sort again, since transaction removal may change some m_entries' ancestor feerates.\n+        std::sort(m_entries.begin(), m_entries.end(), AncestorFeerateComparator());\n+\n+        // Pick highest ancestor feerate entry.\n+        auto best_iter = m_entries.begin();\n+        Assume(best_iter != m_entries.end());\n+        const auto ancestor_package_size = (*best_iter)->second.GetSizeWithAncestors();\n+        const auto ancestor_package_fee = (*best_iter)->second.GetModFeesWithAncestors();\n+        // Stop here. Everything that didn't \"make it into the block\" has bumpfee.\n+        if (ancestor_package_fee < target_feerate.GetFee(ancestor_package_size)) {\n+            break;\n+        }\n+\n+        // Calculate ancestors on the fly. This lookup should be fairly cheap, and ancestor sets\n+        // change at every iteration, so this is more efficient than maintaining a cache.\n+        std::set<MockEntryMap::iterator, IteratorComparator> ancestors;\n+        {\n+            std::set<MockEntryMap::iterator, IteratorComparator> to_process;\n+            to_process.insert(*best_iter);\n+            while (!to_process.empty()) {\n+                auto iter = to_process.begin();\n+                Assume(iter != to_process.end());\n+                ancestors.insert(*iter);\n+                for (const auto& input : (*iter)->second.GetTx().vin) {\n+                    if (auto parent_it{m_entries_by_txid.find(input.prevout.hash)}; parent_it != m_entries_by_txid.end()) {\n+                        if (ancestors.count(parent_it) == 0) {\n+                            to_process.insert(parent_it);\n+                        }\n+                    }\n+                }\n+                to_process.erase(iter);\n+            }\n+        }\n+        DeleteAncestorPackage(ancestors);\n+        SanityCheck();\n+    }\n+    Assume(m_in_block.empty() || m_total_fees >= target_feerate.GetFee(m_total_vsize));\n+    // Do not try to continue building the block template with a different feerate.\n+    m_ready_to_calculate = false;\n+}\n+\n+std::map<COutPoint, CAmount> MiniMiner::CalculateBumpFees(const CFeeRate& target_feerate)\n+{\n+    if (!m_ready_to_calculate) return {};\n+    // Build a block template until the target feerate is hit.\n+    BuildMockTemplate(target_feerate);\n+\n+    // Each transaction that \"made it into the block\" has a bumpfee of 0, i.e. they are part of an\n+    // ancestor package with at least the target feerate and don't need to be bumped.\n+    for (const auto& txid : m_in_block) {\n+        // Not all of the block transactions were necessarily requested.\n+        auto it = m_requested_outpoints_by_txid.find(txid);\n+        if (it != m_requested_outpoints_by_txid.end()) {\n+            for (const auto& outpoint : it->second) {\n+                m_bump_fees.emplace(outpoint, 0);\n+            }\n+            m_requested_outpoints_by_txid.erase(it);\n+        }\n+    }\n+\n+    // A transactions and its ancestors will only be picked into a block when\n+    // both the ancestor set feerate and the individual feerate meet the target\n+    // feerate.\n+    //\n+    // We had to convince ourselves that after running the mini miner and\n+    // picking all eligible transactions into our MockBlockTemplate, there\n+    // could still be transactions remaining that have a lower individual\n+    // feerate than their ancestor feerate. So here is an example:\n+    //\n+    //               ┌─────────────────┐\n+    //               │                 │\n+    //               │   Grandparent   │\n+    //               │    1700 vB      │\n+    //               │    1700 sats    │                    Target feerate: 10    s/vB\n+    //               │       1 s/vB    │    GP Ancestor Set Feerate (ASFR):  1    s/vB\n+    //               │                 │                           P1_ASFR:  9.84 s/vB\n+    //               └──────▲───▲──────┘                           P2_ASFR:  2.47 s/vB\n+    //                      │   │                                   C_ASFR: 10.27 s/vB\n+    // ┌───────────────┐    │   │    ┌──────────────┐\n+    // │               ├────┘   └────┤              │             ⇒ C_FR < TFR < C_ASFR\n+    // │   Parent 1    │             │   Parent 2   │\n+    // │    200 vB     │             │    200 vB    │\n+    // │  17000 sats   │             │   3000 sats  │\n+    // │     85 s/vB   │             │     15 s/vB  │\n+    // │               │             │              │\n+    // └───────────▲───┘             └───▲──────────┘\n+    //             │                     │\n+    //             │    ┌───────────┐    │\n+    //             └────┤           ├────┘\n+    //                  │   Child   │\n+    //                  │  100 vB   │\n+    //                  │  900 sats │\n+    //                  │    9 s/vB │\n+    //                  │           │\n+    //                  └───────────┘\n+    //\n+    // We therefore calculate both the bump fee that is necessary to elevate\n+    // the individual transaction to the target feerate:\n+    //         target_feerate × tx_size - tx_fees\n+    // and the bump fee that is necessary to bump the entire ancestor set to\n+    // the target feerate:\n+    //         target_feerate × ancestor_set_size - ancestor_set_fees\n+    // By picking the maximum from the two, we ensure that a transaction meets\n+    // both criteria.\n+    for (const auto& [txid, outpoints] : m_requested_outpoints_by_txid) {\n+        auto it = m_entries_by_txid.find(txid);\n+        Assume(it != m_entries_by_txid.end());\n+        if (it != m_entries_by_txid.end()) {\n+            Assume(target_feerate.GetFee(it->second.GetSizeWithAncestors()) > std::min(it->second.GetModifiedFee(), it->second.GetModFeesWithAncestors()));\n+            CAmount bump_fee_with_ancestors = target_feerate.GetFee(it->second.GetSizeWithAncestors()) - it->second.GetModFeesWithAncestors();\n+            CAmount bump_fee_individual = target_feerate.GetFee(it->second.GetTxSize()) - it->second.GetModifiedFee();\n+            const CAmount bump_fee{std::max(bump_fee_with_ancestors, bump_fee_individual)};\n+            Assume(bump_fee >= 0);\n+            for (const auto& outpoint : outpoints) {\n+                m_bump_fees.emplace(outpoint, bump_fee);\n+            }\n+        }\n+    }\n+    return m_bump_fees;\n+}\n+\n+std::optional<CAmount> MiniMiner::CalculateTotalBumpFees(const CFeeRate& target_feerate)\n+{\n+    if (!m_ready_to_calculate) return std::nullopt;\n+    // Build a block template until the target feerate is hit.\n+    BuildMockTemplate(target_feerate);\n+\n+    // All remaining ancestors that are not part of m_in_block must be bumped, but no other relatives\n+    std::set<MockEntryMap::iterator, IteratorComparator> ancestors;\n+    {\n+        std::set<MockEntryMap::iterator, IteratorComparator> to_process;\n+        for (const auto& [txid, outpoints] : m_requested_outpoints_by_txid) {\n+            // Skip any ancestors that already have a miner score higher than the target feerate\n+            // (already \"made it\" into the block)\n+            if (m_in_block.count(txid)) continue;\n+            auto iter = m_entries_by_txid.find(txid);\n+            if (iter == m_entries_by_txid.end()) continue;\n+            to_process.insert(iter);\n+            ancestors.insert(iter);\n+        }\n+        while (!to_process.empty()) {\n+            auto iter = to_process.begin();\n+            assert(iter != to_process.end());\n+            const CTransaction& tx = (*iter)->second.GetTx();\n+            for (const auto& input : tx.vin) {\n+                if (auto parent_it{m_entries_by_txid.find(input.prevout.hash)}; parent_it != m_entries_by_txid.end()) {\n+                    to_process.insert(parent_it);\n+                    ancestors.insert(parent_it);\n+                }\n+            }\n+            to_process.erase(iter);\n+        }\n+    }\n+    const auto ancestor_package_size = std::accumulate(ancestors.cbegin(), ancestors.cend(), 0,\n+        [](int64_t sum, const auto it) {return sum + it->second.GetTxSize();});\n+    const auto ancestor_package_fee = std::accumulate(ancestors.cbegin(), ancestors.cend(), 0,",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 354,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "82d068ea0e247e7deb3f4dd2c222db3d3eb6d0e4",
      "in_reply_to_id": 1136136446,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Uff, great catch, thanks!",
      "created_at": "2023-03-14T22:34:01Z",
      "updated_at": "2023-03-14T22:56:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136299879",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136299879"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 354,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136311603",
      "pull_request_review_id": 1340290546,
      "id": 1136311603,
      "node_id": "PRRC_kwDOABII585Dur0z",
      "diff_hunk": "@@ -0,0 +1,123 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_MINI_MINER_H\n+#define BITCOIN_NODE_MINI_MINER_H\n+\n+#include <txmempool.h>\n+\n+#include <memory>\n+#include <optional>\n+#include <stdint.h>\n+\n+namespace node {\n+\n+// Container for tracking updates to ancestor feerate as we include ancestors in the \"block\"\n+class MiniMinerMempoolEntry\n+{\n+    const CAmount fee_individual;\n+    const CTransaction tx;",
      "path": "src/node/mini_miner.h",
      "position": null,
      "original_position": 20,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "a0d54e6b8f8afab070de48911f3b11d4cdf289ff",
      "in_reply_to_id": 1131024834,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks, I adopted your suggestion.",
      "created_at": "2023-03-14T22:42:48Z",
      "updated_at": "2023-03-14T22:56:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136311603",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136311603"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 20,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136319884",
      "pull_request_review_id": 1340290546,
      "id": 1136319884,
      "node_id": "PRRC_kwDOABII585Dut2M",
      "diff_hunk": "@@ -0,0 +1,183 @@\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+#include <test/fuzz/util/mempool.h>\n+#include <test/util/script.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+#include <test/util/mining.h>\n+\n+#include <node/mini_miner.h>\n+#include <node/miner.h>\n+#include <primitives/transaction.h>\n+#include <random.h>\n+#include <txmempool.h>\n+\n+#include <deque>\n+#include <vector>\n+\n+namespace {\n+\n+const TestingSetup* g_setup;\n+std::deque<COutPoint> g_available_coins;\n+void initialize_miner()\n+{\n+    static const auto testing_setup = MakeNoLogFileContext<const TestingSetup>();\n+    g_setup = testing_setup.get();\n+    for (uint32_t i = 0; i < uint32_t{100}; ++i) {\n+        g_available_coins.push_back(COutPoint{uint256::ZERO, i});\n+    }\n+}\n+\n+// Test that the MiniMiner can run with various outpoints and feerates.\n+FUZZ_TARGET_INIT(mini_miner, initialize_miner)\n+{\n+    FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n+    CTxMemPool pool{CTxMemPool::Options{}};\n+    std::vector<COutPoint> outpoints;\n+    std::deque<COutPoint> available_coins = g_available_coins;\n+    LOCK2(::cs_main, pool.cs);\n+    // Cluster size cannot exceed 500\n+    LIMITED_WHILE(!available_coins.empty(), 500)\n+    {\n+        CMutableTransaction mtx = CMutableTransaction();\n+        const size_t num_inputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, available_coins.size());\n+        const size_t num_outputs = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(1, 50);\n+        for (size_t n{0}; n < num_inputs; ++n) {\n+            auto prevout = available_coins.front();\n+            mtx.vin.push_back(CTxIn(prevout, CScript()));\n+            available_coins.pop_front();\n+        }\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            mtx.vout.push_back(CTxOut(100, P2WSH_OP_TRUE));\n+        }\n+        CTransactionRef tx = MakeTransactionRef(mtx);\n+        TestMemPoolEntryHelper entry;\n+        const CAmount fee{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/100000)};\n+        assert(MoneyRange(fee));\n+        pool.addUnchecked(entry.Fee(fee).FromTx(tx));\n+\n+        // All outputs are available to spend\n+        for (uint32_t n{0}; n < num_outputs; ++n) {\n+            if (fuzzed_data_provider.ConsumeBool()) {\n+                available_coins.push_back(COutPoint{tx->GetHash(), n});\n+            }\n+        }\n+\n+        if (fuzzed_data_provider.ConsumeBool() && !tx->vout.empty()) {\n+            // Add outpoint from this tx (may or not be spent by a later tx)\n+            outpoints.push_back(COutPoint{tx->GetHash(),\n+                                          (uint32_t)fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, tx->vout.size())});\n+        } else {\n+            // Add some random outpoint (will be interpreted as confirmed or not yet submitted\n+            // to mempool).\n+            auto outpoint = ConsumeDeserializable<COutPoint>(fuzzed_data_provider);\n+            if (outpoint.has_value() && std::find(outpoints.begin(), outpoints.end(), *outpoint) == outpoints.end()) {\n+                outpoints.push_back(*outpoint);\n+            }\n+        }\n+\n+    }\n+\n+    node::MiniMiner mini_miner{pool, outpoints};\n+    assert(mini_miner.IsReadyToCalculate());\n+    const CFeeRate target_feerate{CFeeRate{ConsumeMoney(fuzzed_data_provider, /*max=*/MAX_MONEY/1000)}};\n+    if (fuzzed_data_provider.ConsumeBool()) {",
      "path": "src/test/fuzz/mini_miner.cpp",
      "position": null,
      "original_position": 85,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "cf1636078f7e97110cab15646110fcc1ce935136",
      "in_reply_to_id": 1133185828,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks, this improves the fuzzer. I’ve adopted your suggested change.",
      "created_at": "2023-03-14T22:52:22Z",
      "updated_at": "2023-03-14T22:56:15Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136319884",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136319884"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 85,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136330617",
      "pull_request_review_id": 1340411560,
      "id": 1136330617,
      "node_id": "PRRC_kwDOABII585Duwd5",
      "diff_hunk": "@@ -0,0 +1,318 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool.\n+            // We assume that the caller wants to replace this transaction (and its descendants).\n+            // If the outpoint is from a mempool transaction, we still need to calculate its\n+            // ancestors bump fees (added to m_requested_outpoints_by_txid below), but after\n+            // removing the to-be-replaced entries. Note that this is only calculating bump fees.\n+            // RBF fee rules should be handled separately.\n+            m_to_be_replaced.insert(ptx->GetHash());\n+            // Remove descendants because they will be replaced as well. This case should be rare\n+            // as the wallet won't normally attempt to replace transactions with descendants.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+\n+        if (mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // UXTO is created by transaction in mempool, add to map.\n+            // Note: This will either create a missing entry or add the outpoint to an existing entry\n+            m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+        } else {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {",
      "path": "src/node/mini_miner.cpp",
      "position": 102,
      "original_position": 100,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "a0d54e6b8f8afab070de48911f3b11d4cdf289ff",
      "in_reply_to_id": 1131618449,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I see how this might be a performance improvement, but I don’t think this is going to be heavy enough to warrant this level of rewrite at this stage in the PR. Perhaps this could be done in a follow-up.",
      "created_at": "2023-03-14T23:05:27Z",
      "updated_at": "2023-03-14T23:05:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1136330617",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1136330617"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": 92,
      "original_start_line": 90,
      "start_side": "RIGHT",
      "line": 102,
      "original_line": 102,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145355201",
      "pull_request_review_id": 1353401668,
      "id": 1145355201,
      "node_id": "PRRC_kwDOABII585ERLvB",
      "diff_hunk": "@@ -0,0 +1,123 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_MINI_MINER_H\n+#define BITCOIN_NODE_MINI_MINER_H\n+\n+#include <txmempool.h>\n+\n+#include <memory>\n+#include <optional>\n+#include <stdint.h>\n+\n+namespace node {\n+\n+// Container for tracking updates to ancestor feerate as we include ancestors in the \"block\"\n+class MiniMinerMempoolEntry\n+{\n+    const CAmount fee_individual;\n+    const CTransactionRef tx;\n+    const int64_t vsize_individual;\n+\n+// This class must be constructed while holding mempool.cs. After construction, the object's\n+// methods can be called without holding that lock.\n+public:\n+    CAmount fee_with_ancestors;\n+    int64_t vsize_with_ancestors;\n+    explicit MiniMinerMempoolEntry(CTxMemPool::txiter entry) :\n+        fee_individual{entry->GetModifiedFee()},\n+        tx{entry->GetSharedTx()},\n+        vsize_individual(entry->GetTxSize()),\n+        fee_with_ancestors{entry->GetModFeesWithAncestors()},\n+        vsize_with_ancestors(entry->GetSizeWithAncestors())\n+    { }\n+\n+    CAmount GetModifiedFee() const { return fee_individual; }\n+    CAmount GetModFeesWithAncestors() const { return fee_with_ancestors; }\n+    int64_t GetTxSize() const { return vsize_individual; }\n+    int64_t GetSizeWithAncestors() const { return vsize_with_ancestors; }\n+    const CTransaction& GetTx() const LIFETIMEBOUND { return *tx; }\n+};\n+\n+void UpdateForMinedAncestor(const MiniMinerMempoolEntry& ancestor, const MiniMinerMempoolEntry& descendant);",
      "path": "src/node/mini_miner.h",
      "position": null,
      "original_position": 43,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ad34243f15d23d6adb66a07b39f86ce93baba253",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Unimplemented function",
      "created_at": "2023-03-22T20:09:35Z",
      "updated_at": "2023-03-22T21:09:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1145355201",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145355201"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 43,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145368125",
      "pull_request_review_id": 1353401668,
      "id": 1145368125,
      "node_id": "PRRC_kwDOABII585ERO49",
      "diff_hunk": "@@ -0,0 +1,368 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+            continue;\n+        }\n+\n+        // UXTO is created by transaction in mempool, add to map.\n+        // Note: This will either create a missing entry or add the outpoint to an existing entry\n+        m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool. We\n+            // assume that the caller wants to replace this transaction and its descendants. It\n+            // would be unusual for the transaction to have descendants as the wallet won’t normally\n+            // attempt to replace transactions with descendants. If the outpoint is from a mempool\n+            // transaction, we still need to calculate its ancestors bump fees (added to\n+            // m_requested_outpoints_by_txid below), but after removing the to-be-replaced entries.\n+            //\n+            // Note that the descendants of a transaction include the transaction itself. Also note,\n+            // that this is only calculating bump fees. RBF fee rules should be handled separately.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+//\n+// Under the ancestor-based mining approach, high-feerate children can pay for parents, but high-feerate\n+// parents do not incentive inclusion of their children. Therefore the mining algorithm only considers\n+// transactions for inclusion on basis of the minimum of their own feerate or their ancestor feerate.\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        auto min_feerate = [](const MiniMinerMempoolEntry& e) -> CFeeRate {\n+            const CAmount ancestor_fee{e.GetModFeesWithAncestors()};\n+            const int64_t ancestor_size{e.GetSizeWithAncestors()};\n+            const CAmount tx_fee{e.GetModifiedFee()};\n+            const int64_t tx_size{e.GetTxSize()};\n+            // Comparing ancestor feerate with individual feerate:\n+            //     ancestor_fee / ancestor_size <= tx_fee / tx_size\n+            // Avoid division and possible loss of precision by\n+            // multiplying both sides by the sizes:\n+            return ancestor_fee * tx_size < tx_fee * ancestor_size ?\n+                       CFeeRate(ancestor_fee, ancestor_size) :\n+                       CFeeRate(tx_fee, tx_size);\n+        };\n+        CFeeRate a_feerate{min_feerate(a->second)};\n+        CFeeRate b_feerate{min_feerate(b->second)};\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Use txid as tiebreaker for stable sorting\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entry’s descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());",
      "path": "src/node/mini_miner.cpp",
      "position": 174,
      "original_position": 173,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ad34243f15d23d6adb66a07b39f86ce93baba253",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Strictly speaking, the descendant size can only be greater than the ancestor size.\r\n\r\n```suggestion\r\n            Assume(descendant->second.vsize_with_ancestors > anc->second.GetTxSize());\r\n```",
      "created_at": "2023-03-22T20:21:53Z",
      "updated_at": "2023-03-22T21:09:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1145368125",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145368125"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 174,
      "original_line": 174,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145373839",
      "pull_request_review_id": 1353401668,
      "id": 1145373839,
      "node_id": "PRRC_kwDOABII585ERQSP",
      "diff_hunk": "@@ -0,0 +1,368 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+            continue;\n+        }\n+\n+        // UXTO is created by transaction in mempool, add to map.\n+        // Note: This will either create a missing entry or add the outpoint to an existing entry\n+        m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool. We\n+            // assume that the caller wants to replace this transaction and its descendants. It\n+            // would be unusual for the transaction to have descendants as the wallet won’t normally\n+            // attempt to replace transactions with descendants. If the outpoint is from a mempool\n+            // transaction, we still need to calculate its ancestors bump fees (added to\n+            // m_requested_outpoints_by_txid below), but after removing the to-be-replaced entries.\n+            //\n+            // Note that the descendants of a transaction include the transaction itself. Also note,\n+            // that this is only calculating bump fees. RBF fee rules should be handled separately.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+//\n+// Under the ancestor-based mining approach, high-feerate children can pay for parents, but high-feerate\n+// parents do not incentive inclusion of their children. Therefore the mining algorithm only considers\n+// transactions for inclusion on basis of the minimum of their own feerate or their ancestor feerate.\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        auto min_feerate = [](const MiniMinerMempoolEntry& e) -> CFeeRate {\n+            const CAmount ancestor_fee{e.GetModFeesWithAncestors()};\n+            const int64_t ancestor_size{e.GetSizeWithAncestors()};\n+            const CAmount tx_fee{e.GetModifiedFee()};\n+            const int64_t tx_size{e.GetTxSize()};\n+            // Comparing ancestor feerate with individual feerate:\n+            //     ancestor_fee / ancestor_size <= tx_fee / tx_size\n+            // Avoid division and possible loss of precision by\n+            // multiplying both sides by the sizes:\n+            return ancestor_fee * tx_size < tx_fee * ancestor_size ?\n+                       CFeeRate(ancestor_fee, ancestor_size) :\n+                       CFeeRate(tx_fee, tx_size);\n+        };\n+        CFeeRate a_feerate{min_feerate(a->second)};\n+        CFeeRate b_feerate{min_feerate(b->second)};\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Use txid as tiebreaker for stable sorting\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entry’s descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());",
      "path": "src/node/mini_miner.cpp",
      "position": 174,
      "original_position": 173,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ad34243f15d23d6adb66a07b39f86ce93baba253",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "As the ancestors structure is a set and we are merely looping over it, I don't see how this can realistically happen. Two different iterators pointing to the same object? (if that is the worry, then the problem is with the iterators usage approach)",
      "created_at": "2023-03-22T20:28:10Z",
      "updated_at": "2023-03-22T21:09:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1145373839",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145373839"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": 172,
      "original_start_line": 171,
      "start_side": "RIGHT",
      "line": 174,
      "original_line": 174,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145394065",
      "pull_request_review_id": 1353401668,
      "id": 1145394065,
      "node_id": "PRRC_kwDOABII585ERVOR",
      "diff_hunk": "@@ -0,0 +1,368 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+            continue;\n+        }\n+\n+        // UXTO is created by transaction in mempool, add to map.\n+        // Note: This will either create a missing entry or add the outpoint to an existing entry\n+        m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool. We\n+            // assume that the caller wants to replace this transaction and its descendants. It\n+            // would be unusual for the transaction to have descendants as the wallet won’t normally\n+            // attempt to replace transactions with descendants. If the outpoint is from a mempool\n+            // transaction, we still need to calculate its ancestors bump fees (added to\n+            // m_requested_outpoints_by_txid below), but after removing the to-be-replaced entries.\n+            //\n+            // Note that the descendants of a transaction include the transaction itself. Also note,\n+            // that this is only calculating bump fees. RBF fee rules should be handled separately.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+//\n+// Under the ancestor-based mining approach, high-feerate children can pay for parents, but high-feerate\n+// parents do not incentive inclusion of their children. Therefore the mining algorithm only considers\n+// transactions for inclusion on basis of the minimum of their own feerate or their ancestor feerate.\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        auto min_feerate = [](const MiniMinerMempoolEntry& e) -> CFeeRate {\n+            const CAmount ancestor_fee{e.GetModFeesWithAncestors()};\n+            const int64_t ancestor_size{e.GetSizeWithAncestors()};\n+            const CAmount tx_fee{e.GetModifiedFee()};\n+            const int64_t tx_size{e.GetTxSize()};\n+            // Comparing ancestor feerate with individual feerate:\n+            //     ancestor_fee / ancestor_size <= tx_fee / tx_size\n+            // Avoid division and possible loss of precision by\n+            // multiplying both sides by the sizes:\n+            return ancestor_fee * tx_size < tx_fee * ancestor_size ?\n+                       CFeeRate(ancestor_fee, ancestor_size) :\n+                       CFeeRate(tx_fee, tx_size);\n+        };\n+        CFeeRate a_feerate{min_feerate(a->second)};\n+        CFeeRate b_feerate{min_feerate(b->second)};\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Use txid as tiebreaker for stable sorting\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entry’s descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());\n+            descendant->second.fee_with_ancestors -= anc->second.GetModifiedFee();\n+            descendant->second.vsize_with_ancestors -= anc->second.GetTxSize();\n+        }\n+    }\n+    // Delete these entries.\n+    for (const auto& anc : ancestors) {\n+        m_descendant_set_by_txid.erase(anc->first);\n+        // The above loop should have deducted each ancestor's size and fees from each of their\n+        // respective descendants exactly once.\n+        Assume(anc->second.GetModFeesWithAncestors() == 0);\n+        Assume(anc->second.GetSizeWithAncestors() == 0);\n+        auto vec_it = std::find(m_entries.begin(), m_entries.end(), anc);\n+        Assume(vec_it != m_entries.end());\n+        m_entries.erase(vec_it);\n+        m_entries_by_txid.erase(anc);\n+    }",
      "path": "src/node/mini_miner.cpp",
      "position": 190,
      "original_position": 189,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ad34243f15d23d6adb66a07b39f86ce93baba253",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What is the reason behind this separate removal loop? Couldn't we merge it with the loop that is above?\r\n\r\nAre you worry about the `ancestors` set having a parent and a child so if first removes the child then the parent will not find it and then crash?",
      "created_at": "2023-03-22T20:49:50Z",
      "updated_at": "2023-03-22T21:09:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1145394065",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1145394065"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": 179,
      "original_start_line": 178,
      "start_side": "RIGHT",
      "line": 190,
      "original_line": 190,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146476492",
      "pull_request_review_id": 1355048144,
      "id": 1146476492,
      "node_id": "PRRC_kwDOABII585EVdfM",
      "diff_hunk": "@@ -0,0 +1,368 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+            continue;\n+        }\n+\n+        // UXTO is created by transaction in mempool, add to map.\n+        // Note: This will either create a missing entry or add the outpoint to an existing entry\n+        m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool. We\n+            // assume that the caller wants to replace this transaction and its descendants. It\n+            // would be unusual for the transaction to have descendants as the wallet won’t normally\n+            // attempt to replace transactions with descendants. If the outpoint is from a mempool\n+            // transaction, we still need to calculate its ancestors bump fees (added to\n+            // m_requested_outpoints_by_txid below), but after removing the to-be-replaced entries.\n+            //\n+            // Note that the descendants of a transaction include the transaction itself. Also note,\n+            // that this is only calculating bump fees. RBF fee rules should be handled separately.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+//\n+// Under the ancestor-based mining approach, high-feerate children can pay for parents, but high-feerate\n+// parents do not incentive inclusion of their children. Therefore the mining algorithm only considers\n+// transactions for inclusion on basis of the minimum of their own feerate or their ancestor feerate.\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        auto min_feerate = [](const MiniMinerMempoolEntry& e) -> CFeeRate {\n+            const CAmount ancestor_fee{e.GetModFeesWithAncestors()};\n+            const int64_t ancestor_size{e.GetSizeWithAncestors()};\n+            const CAmount tx_fee{e.GetModifiedFee()};\n+            const int64_t tx_size{e.GetTxSize()};\n+            // Comparing ancestor feerate with individual feerate:\n+            //     ancestor_fee / ancestor_size <= tx_fee / tx_size\n+            // Avoid division and possible loss of precision by\n+            // multiplying both sides by the sizes:\n+            return ancestor_fee * tx_size < tx_fee * ancestor_size ?\n+                       CFeeRate(ancestor_fee, ancestor_size) :\n+                       CFeeRate(tx_fee, tx_size);\n+        };\n+        CFeeRate a_feerate{min_feerate(a->second)};\n+        CFeeRate b_feerate{min_feerate(b->second)};\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Use txid as tiebreaker for stable sorting\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entry’s descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());\n+            descendant->second.fee_with_ancestors -= anc->second.GetModifiedFee();\n+            descendant->second.vsize_with_ancestors -= anc->second.GetTxSize();\n+        }\n+    }\n+    // Delete these entries.\n+    for (const auto& anc : ancestors) {\n+        m_descendant_set_by_txid.erase(anc->first);\n+        // The above loop should have deducted each ancestor's size and fees from each of their\n+        // respective descendants exactly once.\n+        Assume(anc->second.GetModFeesWithAncestors() == 0);\n+        Assume(anc->second.GetSizeWithAncestors() == 0);\n+        auto vec_it = std::find(m_entries.begin(), m_entries.end(), anc);\n+        Assume(vec_it != m_entries.end());\n+        m_entries.erase(vec_it);\n+        m_entries_by_txid.erase(anc);\n+    }\n+}\n+\n+void MiniMiner::SanityCheck() const\n+{\n+    // m_entries, m_entries_by_txid, and m_descendant_set_by_txid all same size\n+    Assume(m_entries.size() == m_entries_by_txid.size());\n+    Assume(m_entries.size() == m_descendant_set_by_txid.size());\n+    // Cached ancestor values should be at least as large as the transaction's own fee and size\n+    Assume(std::all_of(m_entries.begin(), m_entries.end(), [](const auto& entry) {\n+        return entry->second.GetSizeWithAncestors() >= entry->second.GetTxSize() &&\n+               entry->second.GetModFeesWithAncestors() >= entry->second.GetModifiedFee();}));\n+    // None of the entries should be to-be-replaced transactions\n+    Assume(std::all_of(m_to_be_replaced.begin(), m_to_be_replaced.end(),\n+        [&](const auto& txid){return m_entries_by_txid.find(txid) == m_entries_by_txid.end();}));\n+}\n+\n+void MiniMiner::BuildMockTemplate(const CFeeRate& target_feerate)\n+{\n+    while (!m_entries_by_txid.empty()) {\n+        // Sort again, since transaction removal may change some m_entries' ancestor feerates.\n+        std::sort(m_entries.begin(), m_entries.end(), AncestorFeerateComparator());\n+\n+        // Pick highest ancestor feerate entry.\n+        auto best_iter = m_entries.begin();\n+        Assume(best_iter != m_entries.end());\n+        const auto ancestor_package_size = (*best_iter)->second.GetSizeWithAncestors();\n+        const auto ancestor_package_fee = (*best_iter)->second.GetModFeesWithAncestors();\n+        // Stop here. Everything that didn't \"make it into the block\" has bumpfee.\n+        if (ancestor_package_fee < target_feerate.GetFee(ancestor_package_size)) {\n+            break;\n+        }\n+\n+        // Calculate ancestors on the fly. This lookup should be fairly cheap, and ancestor sets\n+        // change at every iteration, so this is more efficient than maintaining a cache.\n+        std::set<MockEntryMap::iterator, IteratorComparator> ancestors;\n+        {\n+            std::set<MockEntryMap::iterator, IteratorComparator> to_process;\n+            to_process.insert(*best_iter);\n+            while (!to_process.empty()) {\n+                auto iter = to_process.begin();\n+                Assume(iter != to_process.end());\n+                ancestors.insert(*iter);\n+                for (const auto& input : (*iter)->second.GetTx().vin) {\n+                    if (auto parent_it{m_entries_by_txid.find(input.prevout.hash)}; parent_it != m_entries_by_txid.end()) {\n+                        if (ancestors.count(parent_it) == 0) {\n+                            to_process.insert(parent_it);\n+                        }\n+                    }\n+                }\n+                to_process.erase(iter);\n+            }\n+        }\n+        DeleteAncestorPackage(ancestors);\n+        SanityCheck();\n+    }\n+    Assume(m_in_block.empty() || m_total_fees >= target_feerate.GetFee(m_total_vsize));\n+    // Do not try to continue building the block template with a different feerate.\n+    m_ready_to_calculate = false;\n+}\n+\n+std::map<COutPoint, CAmount> MiniMiner::CalculateBumpFees(const CFeeRate& target_feerate)\n+{\n+    if (!m_ready_to_calculate) return {};\n+    // Build a block template until the target feerate is hit.\n+    BuildMockTemplate(target_feerate);\n+\n+    // Each transaction that \"made it into the block\" has a bumpfee of 0, i.e. they are part of an\n+    // ancestor package with at least the target feerate and don't need to be bumped.\n+    for (const auto& txid : m_in_block) {\n+        // Not all of the block transactions were necessarily requested.\n+        auto it = m_requested_outpoints_by_txid.find(txid);\n+        if (it != m_requested_outpoints_by_txid.end()) {\n+            for (const auto& outpoint : it->second) {\n+                m_bump_fees.emplace(outpoint, 0);\n+            }\n+            m_requested_outpoints_by_txid.erase(it);\n+        }\n+    }\n+\n+    // A transactions and its ancestors will only be picked into a block when\n+    // both the ancestor set feerate and the individual feerate meet the target\n+    // feerate.\n+    //\n+    // We had to convince ourselves that after running the mini miner and\n+    // picking all eligible transactions into our MockBlockTemplate, there\n+    // could still be transactions remaining that have a lower individual\n+    // feerate than their ancestor feerate. So here is an example:\n+    //\n+    //               ┌─────────────────┐\n+    //               │                 │\n+    //               │   Grandparent   │\n+    //               │    1700 vB      │\n+    //               │    1700 sats    │                    Target feerate: 10    s/vB\n+    //               │       1 s/vB    │    GP Ancestor Set Feerate (ASFR):  1    s/vB\n+    //               │                 │                           P1_ASFR:  9.84 s/vB\n+    //               └──────▲───▲──────┘                           P2_ASFR:  2.47 s/vB\n+    //                      │   │                                   C_ASFR: 10.27 s/vB\n+    // ┌───────────────┐    │   │    ┌──────────────┐\n+    // │               ├────┘   └────┤              │             ⇒ C_FR < TFR < C_ASFR\n+    // │   Parent 1    │             │   Parent 2   │\n+    // │    200 vB     │             │    200 vB    │\n+    // │  17000 sats   │             │   3000 sats  │\n+    // │     85 s/vB   │             │     15 s/vB  │\n+    // │               │             │              │\n+    // └───────────▲───┘             └───▲──────────┘\n+    //             │                     │\n+    //             │    ┌───────────┐    │\n+    //             └────┤           ├────┘\n+    //                  │   Child   │\n+    //                  │  100 vB   │\n+    //                  │  900 sats │\n+    //                  │    9 s/vB │\n+    //                  │           │\n+    //                  └───────────┘\n+    //\n+    // We therefore calculate both the bump fee that is necessary to elevate\n+    // the individual transaction to the target feerate:\n+    //         target_feerate × tx_size - tx_fees\n+    // and the bump fee that is necessary to bump the entire ancestor set to\n+    // the target feerate:\n+    //         target_feerate × ancestor_set_size - ancestor_set_fees\n+    // By picking the maximum from the two, we ensure that a transaction meets\n+    // both criteria.\n+    for (const auto& [txid, outpoints] : m_requested_outpoints_by_txid) {\n+        auto it = m_entries_by_txid.find(txid);\n+        Assume(it != m_entries_by_txid.end());\n+        if (it != m_entries_by_txid.end()) {\n+            Assume(target_feerate.GetFee(it->second.GetSizeWithAncestors()) > std::min(it->second.GetModifiedFee(), it->second.GetModFeesWithAncestors()));\n+            CAmount bump_fee_with_ancestors = target_feerate.GetFee(it->second.GetSizeWithAncestors()) - it->second.GetModFeesWithAncestors();\n+            CAmount bump_fee_individual = target_feerate.GetFee(it->second.GetTxSize()) - it->second.GetModifiedFee();\n+            const CAmount bump_fee{std::max(bump_fee_with_ancestors, bump_fee_individual)};\n+            Assume(bump_fee >= 0);\n+            for (const auto& outpoint : outpoints) {\n+                m_bump_fees.emplace(outpoint, bump_fee);\n+            }\n+        }\n+    }\n+    return m_bump_fees;\n+}\n+\n+std::optional<CAmount> MiniMiner::CalculateTotalBumpFees(const CFeeRate& target_feerate)\n+{\n+    if (!m_ready_to_calculate) return std::nullopt;\n+    // Build a block template until the target feerate is hit.\n+    BuildMockTemplate(target_feerate);\n+\n+    // All remaining ancestors that are not part of m_in_block must be bumped, but no other relatives\n+    std::set<MockEntryMap::iterator, IteratorComparator> ancestors;\n+    {\n+        std::set<MockEntryMap::iterator, IteratorComparator> to_process;\n+        for (const auto& [txid, outpoints] : m_requested_outpoints_by_txid) {\n+            // Skip any ancestors that already have a miner score higher than the target feerate\n+            // (already \"made it\" into the block)\n+            if (m_in_block.count(txid)) continue;\n+            auto iter = m_entries_by_txid.find(txid);\n+            if (iter == m_entries_by_txid.end()) continue;\n+            to_process.insert(iter);\n+            ancestors.insert(iter);\n+        }\n+        while (!to_process.empty()) {\n+            auto iter = to_process.begin();\n+            assert(iter != to_process.end());",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 351,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ad34243f15d23d6adb66a07b39f86ce93baba253",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit:\r\nisn't this assertion redundant?\r\nIf `iter` would be equal to `end()`, then `to_process.empty()` would be true. Which breaks the loop.",
      "created_at": "2023-03-23T16:41:45Z",
      "updated_at": "2023-03-23T16:45:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1146476492",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146476492"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 349,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 351,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146927271",
      "pull_request_review_id": 1355735961,
      "id": 1146927271,
      "node_id": "PRRC_kwDOABII585EXLin",
      "diff_hunk": "@@ -0,0 +1,368 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+            continue;\n+        }\n+\n+        // UXTO is created by transaction in mempool, add to map.\n+        // Note: This will either create a missing entry or add the outpoint to an existing entry\n+        m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool. We\n+            // assume that the caller wants to replace this transaction and its descendants. It\n+            // would be unusual for the transaction to have descendants as the wallet won’t normally\n+            // attempt to replace transactions with descendants. If the outpoint is from a mempool\n+            // transaction, we still need to calculate its ancestors bump fees (added to\n+            // m_requested_outpoints_by_txid below), but after removing the to-be-replaced entries.\n+            //\n+            // Note that the descendants of a transaction include the transaction itself. Also note,\n+            // that this is only calculating bump fees. RBF fee rules should be handled separately.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+//\n+// Under the ancestor-based mining approach, high-feerate children can pay for parents, but high-feerate\n+// parents do not incentive inclusion of their children. Therefore the mining algorithm only considers\n+// transactions for inclusion on basis of the minimum of their own feerate or their ancestor feerate.\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        auto min_feerate = [](const MiniMinerMempoolEntry& e) -> CFeeRate {\n+            const CAmount ancestor_fee{e.GetModFeesWithAncestors()};\n+            const int64_t ancestor_size{e.GetSizeWithAncestors()};\n+            const CAmount tx_fee{e.GetModifiedFee()};\n+            const int64_t tx_size{e.GetTxSize()};\n+            // Comparing ancestor feerate with individual feerate:\n+            //     ancestor_fee / ancestor_size <= tx_fee / tx_size\n+            // Avoid division and possible loss of precision by\n+            // multiplying both sides by the sizes:\n+            return ancestor_fee * tx_size < tx_fee * ancestor_size ?\n+                       CFeeRate(ancestor_fee, ancestor_size) :\n+                       CFeeRate(tx_fee, tx_size);\n+        };\n+        CFeeRate a_feerate{min_feerate(a->second)};\n+        CFeeRate b_feerate{min_feerate(b->second)};\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Use txid as tiebreaker for stable sorting\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entry’s descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());\n+            descendant->second.fee_with_ancestors -= anc->second.GetModifiedFee();\n+            descendant->second.vsize_with_ancestors -= anc->second.GetTxSize();\n+        }\n+    }\n+    // Delete these entries.\n+    for (const auto& anc : ancestors) {\n+        m_descendant_set_by_txid.erase(anc->first);\n+        // The above loop should have deducted each ancestor's size and fees from each of their\n+        // respective descendants exactly once.\n+        Assume(anc->second.GetModFeesWithAncestors() == 0);\n+        Assume(anc->second.GetSizeWithAncestors() == 0);\n+        auto vec_it = std::find(m_entries.begin(), m_entries.end(), anc);\n+        Assume(vec_it != m_entries.end());\n+        m_entries.erase(vec_it);\n+        m_entries_by_txid.erase(anc);\n+    }\n+}\n+\n+void MiniMiner::SanityCheck() const\n+{\n+    // m_entries, m_entries_by_txid, and m_descendant_set_by_txid all same size\n+    Assume(m_entries.size() == m_entries_by_txid.size());\n+    Assume(m_entries.size() == m_descendant_set_by_txid.size());\n+    // Cached ancestor values should be at least as large as the transaction's own fee and size\n+    Assume(std::all_of(m_entries.begin(), m_entries.end(), [](const auto& entry) {\n+        return entry->second.GetSizeWithAncestors() >= entry->second.GetTxSize() &&\n+               entry->second.GetModFeesWithAncestors() >= entry->second.GetModifiedFee();}));\n+    // None of the entries should be to-be-replaced transactions\n+    Assume(std::all_of(m_to_be_replaced.begin(), m_to_be_replaced.end(),\n+        [&](const auto& txid){return m_entries_by_txid.find(txid) == m_entries_by_txid.end();}));\n+}\n+\n+void MiniMiner::BuildMockTemplate(const CFeeRate& target_feerate)\n+{\n+    while (!m_entries_by_txid.empty()) {\n+        // Sort again, since transaction removal may change some m_entries' ancestor feerates.\n+        std::sort(m_entries.begin(), m_entries.end(), AncestorFeerateComparator());\n+\n+        // Pick highest ancestor feerate entry.\n+        auto best_iter = m_entries.begin();\n+        Assume(best_iter != m_entries.end());\n+        const auto ancestor_package_size = (*best_iter)->second.GetSizeWithAncestors();\n+        const auto ancestor_package_fee = (*best_iter)->second.GetModFeesWithAncestors();\n+        // Stop here. Everything that didn't \"make it into the block\" has bumpfee.\n+        if (ancestor_package_fee < target_feerate.GetFee(ancestor_package_size)) {\n+            break;\n+        }\n+\n+        // Calculate ancestors on the fly. This lookup should be fairly cheap, and ancestor sets\n+        // change at every iteration, so this is more efficient than maintaining a cache.\n+        std::set<MockEntryMap::iterator, IteratorComparator> ancestors;\n+        {\n+            std::set<MockEntryMap::iterator, IteratorComparator> to_process;\n+            to_process.insert(*best_iter);\n+            while (!to_process.empty()) {\n+                auto iter = to_process.begin();\n+                Assume(iter != to_process.end());\n+                ancestors.insert(*iter);\n+                for (const auto& input : (*iter)->second.GetTx().vin) {\n+                    if (auto parent_it{m_entries_by_txid.find(input.prevout.hash)}; parent_it != m_entries_by_txid.end()) {\n+                        if (ancestors.count(parent_it) == 0) {\n+                            to_process.insert(parent_it);\n+                        }\n+                    }\n+                }\n+                to_process.erase(iter);\n+            }\n+        }\n+        DeleteAncestorPackage(ancestors);\n+        SanityCheck();\n+    }\n+    Assume(m_in_block.empty() || m_total_fees >= target_feerate.GetFee(m_total_vsize));\n+    // Do not try to continue building the block template with a different feerate.\n+    m_ready_to_calculate = false;\n+}\n+\n+std::map<COutPoint, CAmount> MiniMiner::CalculateBumpFees(const CFeeRate& target_feerate)\n+{\n+    if (!m_ready_to_calculate) return {};\n+    // Build a block template until the target feerate is hit.\n+    BuildMockTemplate(target_feerate);\n+\n+    // Each transaction that \"made it into the block\" has a bumpfee of 0, i.e. they are part of an\n+    // ancestor package with at least the target feerate and don't need to be bumped.\n+    for (const auto& txid : m_in_block) {\n+        // Not all of the block transactions were necessarily requested.\n+        auto it = m_requested_outpoints_by_txid.find(txid);\n+        if (it != m_requested_outpoints_by_txid.end()) {\n+            for (const auto& outpoint : it->second) {\n+                m_bump_fees.emplace(outpoint, 0);\n+            }\n+            m_requested_outpoints_by_txid.erase(it);\n+        }\n+    }\n+\n+    // A transactions and its ancestors will only be picked into a block when\n+    // both the ancestor set feerate and the individual feerate meet the target\n+    // feerate.\n+    //\n+    // We had to convince ourselves that after running the mini miner and\n+    // picking all eligible transactions into our MockBlockTemplate, there\n+    // could still be transactions remaining that have a lower individual\n+    // feerate than their ancestor feerate. So here is an example:\n+    //\n+    //               ┌─────────────────┐\n+    //               │                 │\n+    //               │   Grandparent   │\n+    //               │    1700 vB      │\n+    //               │    1700 sats    │                    Target feerate: 10    s/vB\n+    //               │       1 s/vB    │    GP Ancestor Set Feerate (ASFR):  1    s/vB\n+    //               │                 │                           P1_ASFR:  9.84 s/vB\n+    //               └──────▲───▲──────┘                           P2_ASFR:  2.47 s/vB\n+    //                      │   │                                   C_ASFR: 10.27 s/vB\n+    // ┌───────────────┐    │   │    ┌──────────────┐\n+    // │               ├────┘   └────┤              │             ⇒ C_FR < TFR < C_ASFR\n+    // │   Parent 1    │             │   Parent 2   │\n+    // │    200 vB     │             │    200 vB    │\n+    // │  17000 sats   │             │   3000 sats  │\n+    // │     85 s/vB   │             │     15 s/vB  │\n+    // │               │             │              │\n+    // └───────────▲───┘             └───▲──────────┘\n+    //             │                     │\n+    //             │    ┌───────────┐    │\n+    //             └────┤           ├────┘\n+    //                  │   Child   │\n+    //                  │  100 vB   │\n+    //                  │  900 sats │\n+    //                  │    9 s/vB │\n+    //                  │           │\n+    //                  └───────────┘\n+    //\n+    // We therefore calculate both the bump fee that is necessary to elevate\n+    // the individual transaction to the target feerate:\n+    //         target_feerate × tx_size - tx_fees\n+    // and the bump fee that is necessary to bump the entire ancestor set to\n+    // the target feerate:\n+    //         target_feerate × ancestor_set_size - ancestor_set_fees\n+    // By picking the maximum from the two, we ensure that a transaction meets\n+    // both criteria.\n+    for (const auto& [txid, outpoints] : m_requested_outpoints_by_txid) {\n+        auto it = m_entries_by_txid.find(txid);\n+        Assume(it != m_entries_by_txid.end());\n+        if (it != m_entries_by_txid.end()) {\n+            Assume(target_feerate.GetFee(it->second.GetSizeWithAncestors()) > std::min(it->second.GetModifiedFee(), it->second.GetModFeesWithAncestors()));\n+            CAmount bump_fee_with_ancestors = target_feerate.GetFee(it->second.GetSizeWithAncestors()) - it->second.GetModFeesWithAncestors();\n+            CAmount bump_fee_individual = target_feerate.GetFee(it->second.GetTxSize()) - it->second.GetModifiedFee();\n+            const CAmount bump_fee{std::max(bump_fee_with_ancestors, bump_fee_individual)};\n+            Assume(bump_fee >= 0);\n+            for (const auto& outpoint : outpoints) {\n+                m_bump_fees.emplace(outpoint, bump_fee);\n+            }\n+        }\n+    }\n+    return m_bump_fees;\n+}\n+\n+std::optional<CAmount> MiniMiner::CalculateTotalBumpFees(const CFeeRate& target_feerate)\n+{\n+    if (!m_ready_to_calculate) return std::nullopt;\n+    // Build a block template until the target feerate is hit.\n+    BuildMockTemplate(target_feerate);\n+\n+    // All remaining ancestors that are not part of m_in_block must be bumped, but no other relatives\n+    std::set<MockEntryMap::iterator, IteratorComparator> ancestors;\n+    {",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 338,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ad34243f15d23d6adb66a07b39f86ce93baba253",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: Seems like this pair of curly-braces and the extra-indent is a left-over from earlier code (probably involving a `LOCK`?) and can just be removed.",
      "created_at": "2023-03-23T22:08:13Z",
      "updated_at": "2023-03-23T22:30:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1146927271",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146927271"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 338,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146930797",
      "pull_request_review_id": 1355741768,
      "id": 1146930797,
      "node_id": "PRRC_kwDOABII585EXMZt",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<CTxMemPool::txiter> all_entries;\n+    std::map<uint256, int64_t> tx_vsizes;\n+    std::map<uint256, CAmount> tx_modified_fees;\n+    std::map<uint256, CFeeRate> tx_feerates;\n+    for (const auto& tx : all_transactions) {\n+        const auto entry = pool.GetIter(tx->GetHash()).value();\n+        all_entries.push_back(entry);\n+        tx_vsizes.emplace(tx->GetHash(), entry->GetTxSize());\n+        tx_modified_fees.emplace(tx->GetHash(), entry->GetModifiedFee());\n+        tx_feerates.emplace(tx->GetHash(), CFeeRate(entry->GetModifiedFee(), entry->GetTxSize()));\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        // Check tx1 bumpfee: no other bumper.\n+        const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+        auto it1_unspent = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(it1_unspent != bump_fees.end());\n+        if (target_feerate <= tx1_feerate) {\n+            BOOST_CHECK_EQUAL(it1_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(it1_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+        }\n+        // Check tx3 bumpfee: assisted by tx4.\n+        const auto tx3_feerate = CFeeRate(\n+            tx_modified_fees.find(tx3->GetHash())->second + tx_modified_fees.find(tx4->GetHash())->second,\n+            tx_vsizes.find(tx3->GetHash())->second + tx_vsizes.find(tx4->GetHash())->second);\n+        auto it3_unspent = bump_fees.find(COutPoint{tx3->GetHash(), 1});\n+        BOOST_CHECK(it3_unspent != bump_fees.end());\n+        if (target_feerate <= tx3_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it3_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+            BOOST_CHECK_EQUAL(it3_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+        }\n+        // Check tx5 bumpfee: assisted by tx6. Specifically, tx6's modified fees.\n+        const auto tx5_feerate = CFeeRate(\n+            tx_modified_fees.find(tx5->GetHash())->second + tx_modified_fees.find(tx6->GetHash())->second,\n+            tx_vsizes.find(tx5->GetHash())->second + tx_vsizes.find(tx6->GetHash())->second);\n+        auto it5_unspent = bump_fees.find(COutPoint{tx5->GetHash(), 1});\n+        BOOST_CHECK(it5_unspent != bump_fees.end());\n+        if (target_feerate <= tx5_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.",
      "path": "src/test/miniminer_tests.cpp",
      "position": null,
      "original_position": 204,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "in_reply_to_id": null,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n            // As long as target feerate is below tx6's ancestor feerate, there is no bump fee.\r\n```\t\r\n",
      "created_at": "2023-03-23T22:13:35Z",
      "updated_at": "2023-03-23T22:13:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1146930797",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146930797"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 204,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146941331",
      "pull_request_review_id": 1355735961,
      "id": 1146941331,
      "node_id": "PRRC_kwDOABII585EXO-T",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }",
      "path": "src/test/miniminer_tests.cpp",
      "position": null,
      "original_position": 45,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "minor suggestion: in the unit test's `sanity_check` function, could also check that all (positive) bumpfee entries refer to one of the passed tx's:\r\n```suggestion\r\n    // No negative bumpfees. All positive bumpfees must refer to one of the passed tx's outputs.\r\n    for (const auto& [outpoint, fee] : bumpfees) {\r\n        if (fee < 0) return false;\r\n        if (fee == 0) continue;\r\n        auto outpoint_ = outpoint; // structured bindings can't be captured in C++17, so we need to use a variable\r\n        const bool found = std::any_of(transactions.cbegin(), transactions.cend(), [&](const auto& tx) {\r\n            return outpoint_.hash == tx->GetHash() && outpoint_.n < tx->vout.size();\r\n        });\r\n        if (!found) return false;\r\n    }\r\n```\r\n(unfortunately a bit ugly with this extra variable needed... C++20 fixes this).",
      "created_at": "2023-03-23T22:29:51Z",
      "updated_at": "2023-03-23T22:30:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1146941331",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146941331"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 42,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146944495",
      "pull_request_review_id": 1355761439,
      "id": 1146944495,
      "node_id": "PRRC_kwDOABII585EXPvv",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<CTxMemPool::txiter> all_entries;\n+    std::map<uint256, int64_t> tx_vsizes;\n+    std::map<uint256, CAmount> tx_modified_fees;\n+    std::map<uint256, CFeeRate> tx_feerates;\n+    for (const auto& tx : all_transactions) {\n+        const auto entry = pool.GetIter(tx->GetHash()).value();\n+        all_entries.push_back(entry);\n+        tx_vsizes.emplace(tx->GetHash(), entry->GetTxSize());\n+        tx_modified_fees.emplace(tx->GetHash(), entry->GetModifiedFee());\n+        tx_feerates.emplace(tx->GetHash(), CFeeRate(entry->GetModifiedFee(), entry->GetTxSize()));\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        // Check tx1 bumpfee: no other bumper.\n+        const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+        auto it1_unspent = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(it1_unspent != bump_fees.end());\n+        if (target_feerate <= tx1_feerate) {\n+            BOOST_CHECK_EQUAL(it1_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(it1_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+        }\n+        // Check tx3 bumpfee: assisted by tx4.\n+        const auto tx3_feerate = CFeeRate(\n+            tx_modified_fees.find(tx3->GetHash())->second + tx_modified_fees.find(tx4->GetHash())->second,\n+            tx_vsizes.find(tx3->GetHash())->second + tx_vsizes.find(tx4->GetHash())->second);\n+        auto it3_unspent = bump_fees.find(COutPoint{tx3->GetHash(), 1});\n+        BOOST_CHECK(it3_unspent != bump_fees.end());\n+        if (target_feerate <= tx3_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it3_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+            BOOST_CHECK_EQUAL(it3_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+        }\n+        // Check tx5 bumpfee: assisted by tx6. Specifically, tx6's modified fees.\n+        const auto tx5_feerate = CFeeRate(\n+            tx_modified_fees.find(tx5->GetHash())->second + tx_modified_fees.find(tx6->GetHash())->second,\n+            tx_vsizes.find(tx5->GetHash())->second + tx_vsizes.find(tx6->GetHash())->second);\n+        auto it5_unspent = bump_fees.find(COutPoint{tx5->GetHash(), 1});\n+        BOOST_CHECK(it5_unspent != bump_fees.end());\n+        if (target_feerate <= tx5_feerate) {",
      "path": "src/test/miniminer_tests.cpp",
      "position": null,
      "original_position": 203,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is just a nit but I wouldn't call this `tx5_feerate`, it's the `tx5_tx6_package_feerate`.\r\n\r\nAt least in my head, when we talk about certain tx feerate, we talk about the relation between the tx ancestors fee and their size (including the tx itself). Which does not include the descendants (in this case, tx6)",
      "created_at": "2023-03-23T22:35:30Z",
      "updated_at": "2023-03-27T16:47:53Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1146944495",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146944495"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 197,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 216,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146945075",
      "pull_request_review_id": 1355761439,
      "id": 1146945075,
      "node_id": "PRRC_kwDOABII585EXP4z",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<CTxMemPool::txiter> all_entries;\n+    std::map<uint256, int64_t> tx_vsizes;\n+    std::map<uint256, CAmount> tx_modified_fees;\n+    std::map<uint256, CFeeRate> tx_feerates;\n+    for (const auto& tx : all_transactions) {\n+        const auto entry = pool.GetIter(tx->GetHash()).value();\n+        all_entries.push_back(entry);",
      "path": "src/test/miniminer_tests.cpp",
      "position": null,
      "original_position": 136,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "in_reply_to_id": null,
      "user": {
        "login": "furszy",
        "id": 5377650,
        "node_id": "MDQ6VXNlcjUzNzc2NTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/5377650?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/furszy",
        "html_url": "https://github.com/furszy",
        "followers_url": "https://api.github.com/users/furszy/followers",
        "following_url": "https://api.github.com/users/furszy/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/furszy/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/furszy/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/furszy/subscriptions",
        "organizations_url": "https://api.github.com/users/furszy/orgs",
        "repos_url": "https://api.github.com/users/furszy/repos",
        "events_url": "https://api.github.com/users/furszy/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/furszy/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`all_entries` is not used anywhere.",
      "created_at": "2023-03-23T22:36:35Z",
      "updated_at": "2023-03-23T23:31:00Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1146945075",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1146945075"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 130,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147030012",
      "pull_request_review_id": 1355882419,
      "id": 1147030012,
      "node_id": "PRRC_kwDOABII585EXkn8",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<CTxMemPool::txiter> all_entries;\n+    std::map<uint256, int64_t> tx_vsizes;\n+    std::map<uint256, CAmount> tx_modified_fees;\n+    std::map<uint256, CFeeRate> tx_feerates;\n+    for (const auto& tx : all_transactions) {\n+        const auto entry = pool.GetIter(tx->GetHash()).value();\n+        all_entries.push_back(entry);\n+        tx_vsizes.emplace(tx->GetHash(), entry->GetTxSize());\n+        tx_modified_fees.emplace(tx->GetHash(), entry->GetModifiedFee());\n+        tx_feerates.emplace(tx->GetHash(), CFeeRate(entry->GetModifiedFee(), entry->GetTxSize()));\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        // Check tx1 bumpfee: no other bumper.\n+        const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+        auto it1_unspent = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(it1_unspent != bump_fees.end());\n+        if (target_feerate <= tx1_feerate) {\n+            BOOST_CHECK_EQUAL(it1_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(it1_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+        }\n+        // Check tx3 bumpfee: assisted by tx4.\n+        const auto tx3_feerate = CFeeRate(\n+            tx_modified_fees.find(tx3->GetHash())->second + tx_modified_fees.find(tx4->GetHash())->second,\n+            tx_vsizes.find(tx3->GetHash())->second + tx_vsizes.find(tx4->GetHash())->second);\n+        auto it3_unspent = bump_fees.find(COutPoint{tx3->GetHash(), 1});\n+        BOOST_CHECK(it3_unspent != bump_fees.end());\n+        if (target_feerate <= tx3_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it3_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+            BOOST_CHECK_EQUAL(it3_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+        }\n+        // Check tx5 bumpfee: assisted by tx6. Specifically, tx6's modified fees.\n+        const auto tx5_feerate = CFeeRate(\n+            tx_modified_fees.find(tx5->GetHash())->second + tx_modified_fees.find(tx6->GetHash())->second,\n+            tx_vsizes.find(tx5->GetHash())->second + tx_vsizes.find(tx6->GetHash())->second);\n+        auto it5_unspent = bump_fees.find(COutPoint{tx5->GetHash(), 1});\n+        BOOST_CHECK(it5_unspent != bump_fees.end());\n+        if (target_feerate <= tx5_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it5_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+            BOOST_CHECK_EQUAL(it5_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx5->GetHash())->second) - tx_modified_fees.find(tx5->GetHash())->second);",
      "path": "src/test/miniminer_tests.cpp",
      "position": null,
      "original_position": 209,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This else-branch is currently dead code (as can easily be verified by putting an `assert(false)` inside); due to the huge modified fee-rate of tx6, tx5/tx6 are way above all of the tested fee-rate-targets (>1000sats/vbyte) and always get mini-mined, i.e. no fee-bump happens. See also [review comment below](https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1147032833).",
      "created_at": "2023-03-24T01:26:29Z",
      "updated_at": "2023-03-24T01:52:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1147030012",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147030012"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 207,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 217,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147032833",
      "pull_request_review_id": 1355882419,
      "id": 1147032833,
      "node_id": "PRRC_kwDOABII585EXlUB",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);",
      "path": "src/test/miniminer_tests.cpp",
      "position": null,
      "original_position": 89,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This fee delta seems excessive (leading to a fee-rate of >1 million sats/vbyte for tx6), I guess just using one of `{high,normal,low}_fee` should also be fine? Then the testing code-path of getting a bumpfee for tx5/tx6 would be hit (see also [comment above](https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1147030012)).",
      "created_at": "2023-03-24T01:32:27Z",
      "updated_at": "2023-03-24T01:51:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1147032833",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147032833"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 87,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 89,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147037874",
      "pull_request_review_id": 1355882419,
      "id": 1147037874,
      "node_id": "PRRC_kwDOABII585EXmiy",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;",
      "path": "src/test/miniminer_tests.cpp",
      "position": null,
      "original_position": 28,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n```\r\nnit: Not that it harms in any way, but wtxid seems not to be relevant for these unit tests, so could remove this.",
      "created_at": "2023-03-24T01:45:27Z",
      "updated_at": "2023-03-24T01:49:26Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1147037874",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1147037874"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 25,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 28,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1148418379",
      "pull_request_review_id": 1357885542,
      "id": 1148418379,
      "node_id": "PRRC_kwDOABII585Ec3lL",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<CTxMemPool::txiter> all_entries;\n+    std::map<uint256, int64_t> tx_vsizes;\n+    std::map<uint256, CAmount> tx_modified_fees;\n+    std::map<uint256, CFeeRate> tx_feerates;\n+    for (const auto& tx : all_transactions) {\n+        const auto entry = pool.GetIter(tx->GetHash()).value();\n+        all_entries.push_back(entry);\n+        tx_vsizes.emplace(tx->GetHash(), entry->GetTxSize());\n+        tx_modified_fees.emplace(tx->GetHash(), entry->GetModifiedFee());\n+        tx_feerates.emplace(tx->GetHash(), CFeeRate(entry->GetModifiedFee(), entry->GetTxSize()));\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        // Check tx1 bumpfee: no other bumper.\n+        const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+        auto it1_unspent = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(it1_unspent != bump_fees.end());\n+        if (target_feerate <= tx1_feerate) {\n+            BOOST_CHECK_EQUAL(it1_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(it1_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+        }\n+        // Check tx3 bumpfee: assisted by tx4.\n+        const auto tx3_feerate = CFeeRate(\n+            tx_modified_fees.find(tx3->GetHash())->second + tx_modified_fees.find(tx4->GetHash())->second,\n+            tx_vsizes.find(tx3->GetHash())->second + tx_vsizes.find(tx4->GetHash())->second);\n+        auto it3_unspent = bump_fees.find(COutPoint{tx3->GetHash(), 1});\n+        BOOST_CHECK(it3_unspent != bump_fees.end());\n+        if (target_feerate <= tx3_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it3_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+            BOOST_CHECK_EQUAL(it3_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+        }\n+        // Check tx5 bumpfee: assisted by tx6. Specifically, tx6's modified fees.\n+        const auto tx5_feerate = CFeeRate(\n+            tx_modified_fees.find(tx5->GetHash())->second + tx_modified_fees.find(tx6->GetHash())->second,\n+            tx_vsizes.find(tx5->GetHash())->second + tx_vsizes.find(tx6->GetHash())->second);\n+        auto it5_unspent = bump_fees.find(COutPoint{tx5->GetHash(), 1});\n+        BOOST_CHECK(it5_unspent != bump_fees.end());\n+        if (target_feerate <= tx5_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it5_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+            BOOST_CHECK_EQUAL(it5_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx5->GetHash())->second) - tx_modified_fees.find(tx5->GetHash())->second);\n+        }\n+    }\n+    // Spent outpoints should usually not be requested as they would not be\n+    // considered available. However, when they are explicitly requested, we\n+    // can calculate their bumpfee to facilitate RBF-replacements\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner_all_spent(pool, all_spent_outpoints);\n+        BOOST_CHECK(mini_miner_all_spent.IsReadyToCalculate());\n+        auto bump_fees_all_spent = mini_miner_all_spent.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_spent.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_spent.size(), all_spent_outpoints.size());\n+        node::MiniMiner mini_miner_all_parents(pool, all_parent_outputs);\n+        BOOST_CHECK(mini_miner_all_parents.IsReadyToCalculate());\n+        auto bump_fees_all_parents = mini_miner_all_parents.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_parents.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_parents.size(), all_parent_outputs.size());\n+        for (auto& bump_fees : {bump_fees_all_parents, bump_fees_all_spent}) {\n+            // For all_parents case, both outputs from the parent should have the same bump fee,\n+            // even though only one of them is in a to-be-replaced transaction.\n+            BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+            // Check tx1 bumpfee: no other bumper.\n+            const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+            auto it1_spent = bump_fees.find(COutPoint{tx1->GetHash(), 0});\n+            BOOST_CHECK(it1_spent != bump_fees.end());\n+            if (target_feerate <= tx1_feerate) {\n+                BOOST_CHECK_EQUAL(it1_spent->second, 0);\n+            } else {\n+                // Difference is fee to bump tx1 from current to target feerate.\n+                BOOST_CHECK_EQUAL(it1_spent->second,\n+                    target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+            }\n+            // Check tx3 bumpfee: no other bumper, because tx4 is to-be-replaced.\n+            const auto tx3_feerate_unbumped = tx_feerates.find(tx3->GetHash())->second;\n+            auto it3_spent = bump_fees.find(COutPoint{tx3->GetHash(), 0});\n+            BOOST_CHECK(it3_spent != bump_fees.end());\n+            if (target_feerate <= tx3_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it3_spent->second, 0);\n+            } else {\n+                // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+                BOOST_CHECK_EQUAL(it3_spent->second,\n+                    target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+            }\n+            // Check tx5 bumpfee: no other bumper, because tx6 is to-be-replaced.\n+            const auto tx5_feerate_unbumped = tx_feerates.find(tx5->GetHash())->second;\n+            auto it5_spent = bump_fees.find(COutPoint{tx5->GetHash(), 0});\n+            BOOST_CHECK(it5_spent != bump_fees.end());\n+            if (target_feerate <= tx5_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it5_spent->second, 0);\n+            } else {\n+                // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+                BOOST_CHECK_EQUAL(it5_spent->second,\n+                    target_feerate.GetFee(tx_vsizes.find(tx5->GetHash())->second) - tx_modified_fees.find(tx5->GetHash())->second);\n+            }\n+        }\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_overlap, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount med_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create 3 parents of different feerates, and 1 child spending from all 3.\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx2));\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx1->GetHash(), 0}, COutPoint{tx2->GetHash(), 0}, COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create 1 grandparent and 1 parent, then 2 children.\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    const auto tx7 = make_tx({COutPoint{tx6->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx6->GetHash(), 1}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<int64_t> tx_vsizes;\n+    tx_vsizes.reserve(all_transactions.size());\n+    for (const auto& tx : all_transactions) tx_vsizes.push_back(GetVirtualTransactionSize(*tx));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx4->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 2},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 2},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    const auto tx3_feerate = CFeeRate(high_fee, tx_vsizes[2]);\n+    const auto tx4_feerate = CFeeRate(high_fee, tx_vsizes[3]);\n+    // tx4's feerate is lower than tx3's. same fee, different weight.\n+    BOOST_CHECK(tx3_feerate > tx4_feerate);\n+    const auto tx4_anc_feerate = CFeeRate(low_fee + med_fee + high_fee, tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[3]);\n+    const auto tx5_feerate = CFeeRate(high_fee, tx_vsizes[4]);\n+    const auto tx7_anc_feerate = CFeeRate(low_fee + med_fee, tx_vsizes[5] + tx_vsizes[6]);\n+    const auto tx8_anc_feerate = CFeeRate(low_fee + high_fee, tx_vsizes[5] + tx_vsizes[7]);\n+    BOOST_CHECK(tx5_feerate > tx7_anc_feerate);\n+    BOOST_CHECK(tx5_feerate > tx8_anc_feerate);\n+\n+    // Extremely high feerate: everybody's bumpfee is from their full ancestor set.\n+    {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        const CFeeRate very_high_feerate(COIN);\n+        BOOST_CHECK(tx4_anc_feerate < very_high_feerate);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(very_high_feerate);\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        const auto tx1_bumpfee = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(tx1_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx1_bumpfee->second, very_high_feerate.GetFee(tx_vsizes[0]) - low_fee);\n+        const auto tx4_bumpfee = bump_fees.find(COutPoint{tx4->GetHash(), 0});\n+        BOOST_CHECK(tx4_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx4_bumpfee->second,\n+            very_high_feerate.GetFee(tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[2] + tx_vsizes[3]) - (low_fee + med_fee + high_fee + high_fee));\n+        const auto tx7_bumpfee = bump_fees.find(COutPoint{tx7->GetHash(), 0});\n+        BOOST_CHECK(tx7_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx7_bumpfee->second,\n+            very_high_feerate.GetFee(tx_vsizes[4] + tx_vsizes[5] + tx_vsizes[6]) - (high_fee + low_fee + med_fee));\n+        const auto tx8_bumpfee = bump_fees.find(COutPoint{tx8->GetHash(), 0});\n+        BOOST_CHECK(tx8_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx8_bumpfee->second,\n+            very_high_feerate.GetFee(tx_vsizes[4] + tx_vsizes[5] + tx_vsizes[7]) - (high_fee + low_fee + high_fee));\n+        // Total fees: if spending multiple outputs from tx4 don't double-count fees.\n+        node::MiniMiner mini_miner_total_tx4(pool, {COutPoint{tx4->GetHash(), 0}, COutPoint{tx4->GetHash(), 1}});\n+        BOOST_CHECK(mini_miner_total_tx4.IsReadyToCalculate());\n+        const auto tx4_bump_fee = mini_miner_total_tx4.CalculateTotalBumpFees(very_high_feerate);\n+        BOOST_CHECK(!mini_miner_total_tx4.IsReadyToCalculate());\n+        BOOST_CHECK(tx4_bump_fee.has_value());\n+        BOOST_CHECK_EQUAL(tx4_bump_fee.value(),\n+            very_high_feerate.GetFee(tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[2] + tx_vsizes[3]) - (low_fee + med_fee + high_fee + high_fee));\n+        // Total fees: if spending both tx7 and tx8, don't double-count fees.\n+        node::MiniMiner mini_miner_tx7_tx8(pool, {COutPoint{tx7->GetHash(), 0}, COutPoint{tx8->GetHash(), 0}});\n+        BOOST_CHECK(mini_miner_tx7_tx8.IsReadyToCalculate());\n+        const auto tx7_tx8_bumpfee = mini_miner_tx7_tx8.CalculateTotalBumpFees(very_high_feerate);\n+        BOOST_CHECK(!mini_miner_tx7_tx8.IsReadyToCalculate());\n+        BOOST_CHECK(tx7_tx8_bumpfee.has_value());\n+        BOOST_CHECK_EQUAL(tx7_tx8_bumpfee.value(),\n+            very_high_feerate.GetFee(tx_vsizes[4] + tx_vsizes[5] + tx_vsizes[6] + tx_vsizes[7]) - (high_fee + low_fee + med_fee + high_fee));\n+    }\n+    // Feerate just below tx5: tx7 and tx8 have different bump fees.\n+    {\n+        const auto just_below_tx5 = CFeeRate(tx5_feerate.GetFeePerK() - 5);\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(just_below_tx5);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        const auto tx7_bumpfee = bump_fees.find(COutPoint{tx7->GetHash(), 0});\n+        BOOST_CHECK(tx7_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx7_bumpfee->second, just_below_tx5.GetFee(tx_vsizes[5] + tx_vsizes[6]) - (low_fee + med_fee));\n+        const auto tx8_bumpfee = bump_fees.find(COutPoint{tx8->GetHash(), 0});\n+        BOOST_CHECK(tx8_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx8_bumpfee->second, just_below_tx5.GetFee(tx_vsizes[5] + tx_vsizes[7]) - (low_fee + high_fee));\n+        // Total fees: if spending both tx7 and tx8, don't double-count fees.\n+        node::MiniMiner mini_miner_tx7_tx8(pool, {COutPoint{tx7->GetHash(), 0}, COutPoint{tx8->GetHash(), 0}});\n+        BOOST_CHECK(mini_miner_tx7_tx8.IsReadyToCalculate());\n+        const auto tx7_tx8_bumpfee = mini_miner_tx7_tx8.CalculateTotalBumpFees(just_below_tx5);\n+        BOOST_CHECK(!mini_miner_tx7_tx8.IsReadyToCalculate());\n+        BOOST_CHECK(tx7_tx8_bumpfee.has_value());\n+        BOOST_CHECK_EQUAL(tx7_tx8_bumpfee.value(), just_below_tx5.GetFee(tx_vsizes[5] + tx_vsizes[6]) - (low_fee + med_fee));\n+    }\n+    // Feerate between tx7 and tx8's ancestor feerates: don't need to bump tx6 because tx8 already does.\n+    {\n+        const auto just_above_tx7 = CFeeRate(med_fee + 10, tx_vsizes[6]);\n+        BOOST_CHECK(just_above_tx7 <= CFeeRate(low_fee + high_fee, tx_vsizes[5] + tx_vsizes[7]));\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(just_above_tx7);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        const auto tx7_bumpfee = bump_fees.find(COutPoint{tx7->GetHash(), 0});\n+        BOOST_CHECK(tx7_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx7_bumpfee->second, just_above_tx7.GetFee(tx_vsizes[6]) - (med_fee));\n+        const auto tx8_bumpfee = bump_fees.find(COutPoint{tx8->GetHash(), 0});\n+        BOOST_CHECK(tx8_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx8_bumpfee->second, 0);\n+    }\n+}\n+BOOST_FIXTURE_TEST_CASE(calculate_cluster, TestChain100Setup)\n+{\n+    FastRandomContext det_rand{true};",
      "path": "src/test/miniminer_tests.cpp",
      "position": null,
      "original_position": 412,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: unused variable, can be removed\r\n```suggestion\r\n```",
      "created_at": "2023-03-25T19:06:56Z",
      "updated_at": "2023-03-25T19:12:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1148418379",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1148418379"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 412,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1148418808",
      "pull_request_review_id": 1357885542,
      "id": 1148418808,
      "node_id": "PRRC_kwDOABII585Ec3r4",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<CTxMemPool::txiter> all_entries;\n+    std::map<uint256, int64_t> tx_vsizes;\n+    std::map<uint256, CAmount> tx_modified_fees;\n+    std::map<uint256, CFeeRate> tx_feerates;\n+    for (const auto& tx : all_transactions) {\n+        const auto entry = pool.GetIter(tx->GetHash()).value();\n+        all_entries.push_back(entry);\n+        tx_vsizes.emplace(tx->GetHash(), entry->GetTxSize());\n+        tx_modified_fees.emplace(tx->GetHash(), entry->GetModifiedFee());\n+        tx_feerates.emplace(tx->GetHash(), CFeeRate(entry->GetModifiedFee(), entry->GetTxSize()));\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        // Check tx1 bumpfee: no other bumper.\n+        const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+        auto it1_unspent = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(it1_unspent != bump_fees.end());\n+        if (target_feerate <= tx1_feerate) {\n+            BOOST_CHECK_EQUAL(it1_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(it1_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+        }\n+        // Check tx3 bumpfee: assisted by tx4.\n+        const auto tx3_feerate = CFeeRate(\n+            tx_modified_fees.find(tx3->GetHash())->second + tx_modified_fees.find(tx4->GetHash())->second,\n+            tx_vsizes.find(tx3->GetHash())->second + tx_vsizes.find(tx4->GetHash())->second);\n+        auto it3_unspent = bump_fees.find(COutPoint{tx3->GetHash(), 1});\n+        BOOST_CHECK(it3_unspent != bump_fees.end());\n+        if (target_feerate <= tx3_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it3_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+            BOOST_CHECK_EQUAL(it3_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+        }\n+        // Check tx5 bumpfee: assisted by tx6. Specifically, tx6's modified fees.\n+        const auto tx5_feerate = CFeeRate(\n+            tx_modified_fees.find(tx5->GetHash())->second + tx_modified_fees.find(tx6->GetHash())->second,\n+            tx_vsizes.find(tx5->GetHash())->second + tx_vsizes.find(tx6->GetHash())->second);\n+        auto it5_unspent = bump_fees.find(COutPoint{tx5->GetHash(), 1});\n+        BOOST_CHECK(it5_unspent != bump_fees.end());\n+        if (target_feerate <= tx5_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it5_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+            BOOST_CHECK_EQUAL(it5_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx5->GetHash())->second) - tx_modified_fees.find(tx5->GetHash())->second);\n+        }\n+    }\n+    // Spent outpoints should usually not be requested as they would not be\n+    // considered available. However, when they are explicitly requested, we\n+    // can calculate their bumpfee to facilitate RBF-replacements\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner_all_spent(pool, all_spent_outpoints);\n+        BOOST_CHECK(mini_miner_all_spent.IsReadyToCalculate());\n+        auto bump_fees_all_spent = mini_miner_all_spent.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_spent.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_spent.size(), all_spent_outpoints.size());\n+        node::MiniMiner mini_miner_all_parents(pool, all_parent_outputs);\n+        BOOST_CHECK(mini_miner_all_parents.IsReadyToCalculate());\n+        auto bump_fees_all_parents = mini_miner_all_parents.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_parents.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_parents.size(), all_parent_outputs.size());\n+        for (auto& bump_fees : {bump_fees_all_parents, bump_fees_all_spent}) {\n+            // For all_parents case, both outputs from the parent should have the same bump fee,\n+            // even though only one of them is in a to-be-replaced transaction.\n+            BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+            // Check tx1 bumpfee: no other bumper.\n+            const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+            auto it1_spent = bump_fees.find(COutPoint{tx1->GetHash(), 0});\n+            BOOST_CHECK(it1_spent != bump_fees.end());\n+            if (target_feerate <= tx1_feerate) {\n+                BOOST_CHECK_EQUAL(it1_spent->second, 0);\n+            } else {\n+                // Difference is fee to bump tx1 from current to target feerate.\n+                BOOST_CHECK_EQUAL(it1_spent->second,\n+                    target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+            }\n+            // Check tx3 bumpfee: no other bumper, because tx4 is to-be-replaced.\n+            const auto tx3_feerate_unbumped = tx_feerates.find(tx3->GetHash())->second;\n+            auto it3_spent = bump_fees.find(COutPoint{tx3->GetHash(), 0});\n+            BOOST_CHECK(it3_spent != bump_fees.end());\n+            if (target_feerate <= tx3_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it3_spent->second, 0);\n+            } else {\n+                // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+                BOOST_CHECK_EQUAL(it3_spent->second,\n+                    target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+            }\n+            // Check tx5 bumpfee: no other bumper, because tx6 is to-be-replaced.\n+            const auto tx5_feerate_unbumped = tx_feerates.find(tx5->GetHash())->second;\n+            auto it5_spent = bump_fees.find(COutPoint{tx5->GetHash(), 0});\n+            BOOST_CHECK(it5_spent != bump_fees.end());\n+            if (target_feerate <= tx5_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it5_spent->second, 0);\n+            } else {\n+                // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+                BOOST_CHECK_EQUAL(it5_spent->second,\n+                    target_feerate.GetFee(tx_vsizes.find(tx5->GetHash())->second) - tx_modified_fees.find(tx5->GetHash())->second);\n+            }\n+        }\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_overlap, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount med_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create 3 parents of different feerates, and 1 child spending from all 3.\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx2));\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx1->GetHash(), 0}, COutPoint{tx2->GetHash(), 0}, COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create 1 grandparent and 1 parent, then 2 children.\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    const auto tx7 = make_tx({COutPoint{tx6->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx6->GetHash(), 1}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<int64_t> tx_vsizes;\n+    tx_vsizes.reserve(all_transactions.size());\n+    for (const auto& tx : all_transactions) tx_vsizes.push_back(GetVirtualTransactionSize(*tx));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx4->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 2},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 2},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    const auto tx3_feerate = CFeeRate(high_fee, tx_vsizes[2]);\n+    const auto tx4_feerate = CFeeRate(high_fee, tx_vsizes[3]);\n+    // tx4's feerate is lower than tx3's. same fee, different weight.\n+    BOOST_CHECK(tx3_feerate > tx4_feerate);\n+    const auto tx4_anc_feerate = CFeeRate(low_fee + med_fee + high_fee, tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[3]);\n+    const auto tx5_feerate = CFeeRate(high_fee, tx_vsizes[4]);\n+    const auto tx7_anc_feerate = CFeeRate(low_fee + med_fee, tx_vsizes[5] + tx_vsizes[6]);\n+    const auto tx8_anc_feerate = CFeeRate(low_fee + high_fee, tx_vsizes[5] + tx_vsizes[7]);\n+    BOOST_CHECK(tx5_feerate > tx7_anc_feerate);\n+    BOOST_CHECK(tx5_feerate > tx8_anc_feerate);\n+\n+    // Extremely high feerate: everybody's bumpfee is from their full ancestor set.\n+    {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        const CFeeRate very_high_feerate(COIN);\n+        BOOST_CHECK(tx4_anc_feerate < very_high_feerate);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(very_high_feerate);\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        const auto tx1_bumpfee = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(tx1_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx1_bumpfee->second, very_high_feerate.GetFee(tx_vsizes[0]) - low_fee);\n+        const auto tx4_bumpfee = bump_fees.find(COutPoint{tx4->GetHash(), 0});\n+        BOOST_CHECK(tx4_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx4_bumpfee->second,\n+            very_high_feerate.GetFee(tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[2] + tx_vsizes[3]) - (low_fee + med_fee + high_fee + high_fee));\n+        const auto tx7_bumpfee = bump_fees.find(COutPoint{tx7->GetHash(), 0});\n+        BOOST_CHECK(tx7_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx7_bumpfee->second,\n+            very_high_feerate.GetFee(tx_vsizes[4] + tx_vsizes[5] + tx_vsizes[6]) - (high_fee + low_fee + med_fee));\n+        const auto tx8_bumpfee = bump_fees.find(COutPoint{tx8->GetHash(), 0});\n+        BOOST_CHECK(tx8_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx8_bumpfee->second,\n+            very_high_feerate.GetFee(tx_vsizes[4] + tx_vsizes[5] + tx_vsizes[7]) - (high_fee + low_fee + high_fee));\n+        // Total fees: if spending multiple outputs from tx4 don't double-count fees.\n+        node::MiniMiner mini_miner_total_tx4(pool, {COutPoint{tx4->GetHash(), 0}, COutPoint{tx4->GetHash(), 1}});\n+        BOOST_CHECK(mini_miner_total_tx4.IsReadyToCalculate());\n+        const auto tx4_bump_fee = mini_miner_total_tx4.CalculateTotalBumpFees(very_high_feerate);\n+        BOOST_CHECK(!mini_miner_total_tx4.IsReadyToCalculate());\n+        BOOST_CHECK(tx4_bump_fee.has_value());\n+        BOOST_CHECK_EQUAL(tx4_bump_fee.value(),\n+            very_high_feerate.GetFee(tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[2] + tx_vsizes[3]) - (low_fee + med_fee + high_fee + high_fee));\n+        // Total fees: if spending both tx7 and tx8, don't double-count fees.\n+        node::MiniMiner mini_miner_tx7_tx8(pool, {COutPoint{tx7->GetHash(), 0}, COutPoint{tx8->GetHash(), 0}});\n+        BOOST_CHECK(mini_miner_tx7_tx8.IsReadyToCalculate());\n+        const auto tx7_tx8_bumpfee = mini_miner_tx7_tx8.CalculateTotalBumpFees(very_high_feerate);\n+        BOOST_CHECK(!mini_miner_tx7_tx8.IsReadyToCalculate());\n+        BOOST_CHECK(tx7_tx8_bumpfee.has_value());\n+        BOOST_CHECK_EQUAL(tx7_tx8_bumpfee.value(),\n+            very_high_feerate.GetFee(tx_vsizes[4] + tx_vsizes[5] + tx_vsizes[6] + tx_vsizes[7]) - (high_fee + low_fee + med_fee + high_fee));\n+    }\n+    // Feerate just below tx5: tx7 and tx8 have different bump fees.\n+    {\n+        const auto just_below_tx5 = CFeeRate(tx5_feerate.GetFeePerK() - 5);\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(just_below_tx5);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        const auto tx7_bumpfee = bump_fees.find(COutPoint{tx7->GetHash(), 0});\n+        BOOST_CHECK(tx7_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx7_bumpfee->second, just_below_tx5.GetFee(tx_vsizes[5] + tx_vsizes[6]) - (low_fee + med_fee));\n+        const auto tx8_bumpfee = bump_fees.find(COutPoint{tx8->GetHash(), 0});\n+        BOOST_CHECK(tx8_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx8_bumpfee->second, just_below_tx5.GetFee(tx_vsizes[5] + tx_vsizes[7]) - (low_fee + high_fee));\n+        // Total fees: if spending both tx7 and tx8, don't double-count fees.\n+        node::MiniMiner mini_miner_tx7_tx8(pool, {COutPoint{tx7->GetHash(), 0}, COutPoint{tx8->GetHash(), 0}});\n+        BOOST_CHECK(mini_miner_tx7_tx8.IsReadyToCalculate());\n+        const auto tx7_tx8_bumpfee = mini_miner_tx7_tx8.CalculateTotalBumpFees(just_below_tx5);\n+        BOOST_CHECK(!mini_miner_tx7_tx8.IsReadyToCalculate());\n+        BOOST_CHECK(tx7_tx8_bumpfee.has_value());\n+        BOOST_CHECK_EQUAL(tx7_tx8_bumpfee.value(), just_below_tx5.GetFee(tx_vsizes[5] + tx_vsizes[6]) - (low_fee + med_fee));\n+    }\n+    // Feerate between tx7 and tx8's ancestor feerates: don't need to bump tx6 because tx8 already does.\n+    {\n+        const auto just_above_tx7 = CFeeRate(med_fee + 10, tx_vsizes[6]);\n+        BOOST_CHECK(just_above_tx7 <= CFeeRate(low_fee + high_fee, tx_vsizes[5] + tx_vsizes[7]));\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(just_above_tx7);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        const auto tx7_bumpfee = bump_fees.find(COutPoint{tx7->GetHash(), 0});\n+        BOOST_CHECK(tx7_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx7_bumpfee->second, just_above_tx7.GetFee(tx_vsizes[6]) - (med_fee));\n+        const auto tx8_bumpfee = bump_fees.find(COutPoint{tx8->GetHash(), 0});\n+        BOOST_CHECK(tx8_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx8_bumpfee->second, 0);\n+    }\n+}\n+BOOST_FIXTURE_TEST_CASE(calculate_cluster, TestChain100Setup)\n+{\n+    FastRandomContext det_rand{true};\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+\n+    // Add chain of size 500\n+    TestMemPoolEntryHelper entry;\n+    std::vector<uint256> chain_txids;\n+    auto& lasttx = m_coinbase_txns[0];\n+    for (auto i{0}; i < 500; ++i) {\n+        const auto tx = make_tx({COutPoint{lasttx->GetHash(), 0}}, /*num_outputs=*/1);\n+        pool.addUnchecked(entry.Fee(CENT).FromTx(tx));\n+        chain_txids.push_back(tx->GetHash());\n+        lasttx = tx;\n+    }\n+    const auto cluster_500tx = pool.GatherClusters({lasttx->GetHash()});\n+    CTxMemPool::setEntries cluster_500tx_set{cluster_500tx.begin(), cluster_500tx.end()};\n+    BOOST_CHECK_EQUAL(cluster_500tx.size(), cluster_500tx_set.size());\n+    const auto vec_iters_500 = pool.GetIterVec(chain_txids);\n+    for (const auto& iter : vec_iters_500) BOOST_CHECK(cluster_500tx_set.count(iter));\n+\n+    // GatherClusters stops at 500 transactions.\n+    const auto tx_501 = make_tx({COutPoint{lasttx->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(CENT).FromTx(tx_501));\n+    const auto cluster_501 = pool.GatherClusters({tx_501->GetHash()});\n+    BOOST_CHECK_EQUAL(cluster_501.size(), 0);\n+\n+    // Zig Zag cluster:\n+    // txp0     txp1     txp2    ...  txp48  txp49\n+    //    \\    /    \\   /   \\            \\   /\n+    //     txc0     txc1    txc2  ...    txc48\n+    // Note that each transaction's ancestor size is 2 or 3, and each descendant size is 2 or 3.",
      "path": "src/test/miniminer_tests.cpp",
      "position": null,
      "original_position": 442,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "pedantic-nit:\r\n```suggestion\r\n    // Note that each transaction's ancestor size is 1 or 3, and each descendant size is 1, 2 or 3.\r\n```\r\nThe descendant count of 2 is the rare case here, only applying for parent-txs txp0 and txp49\r\n(for the fun of it, created a functional test for verifying this: https://github.com/theStack/bitcoin/blob/functional_test_mempool_zigzag_playground/test/functional/mempool_zigzag.py).",
      "created_at": "2023-03-25T19:10:19Z",
      "updated_at": "2023-03-25T19:12:10Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1148418808",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1148418808"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 442,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149399579",
      "pull_request_review_id": 1359286170,
      "id": 1149399579,
      "node_id": "PRRC_kwDOABII585EgnIb",
      "diff_hunk": "@@ -0,0 +1,368 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+            continue;\n+        }\n+\n+        // UXTO is created by transaction in mempool, add to map.\n+        // Note: This will either create a missing entry or add the outpoint to an existing entry\n+        m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool. We\n+            // assume that the caller wants to replace this transaction and its descendants. It\n+            // would be unusual for the transaction to have descendants as the wallet won’t normally\n+            // attempt to replace transactions with descendants. If the outpoint is from a mempool\n+            // transaction, we still need to calculate its ancestors bump fees (added to\n+            // m_requested_outpoints_by_txid below), but after removing the to-be-replaced entries.\n+            //\n+            // Note that the descendants of a transaction include the transaction itself. Also note,\n+            // that this is only calculating bump fees. RBF fee rules should be handled separately.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+//\n+// Under the ancestor-based mining approach, high-feerate children can pay for parents, but high-feerate\n+// parents do not incentive inclusion of their children. Therefore the mining algorithm only considers\n+// transactions for inclusion on basis of the minimum of their own feerate or their ancestor feerate.\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        auto min_feerate = [](const MiniMinerMempoolEntry& e) -> CFeeRate {\n+            const CAmount ancestor_fee{e.GetModFeesWithAncestors()};\n+            const int64_t ancestor_size{e.GetSizeWithAncestors()};\n+            const CAmount tx_fee{e.GetModifiedFee()};\n+            const int64_t tx_size{e.GetTxSize()};\n+            // Comparing ancestor feerate with individual feerate:\n+            //     ancestor_fee / ancestor_size <= tx_fee / tx_size\n+            // Avoid division and possible loss of precision by\n+            // multiplying both sides by the sizes:\n+            return ancestor_fee * tx_size < tx_fee * ancestor_size ?\n+                       CFeeRate(ancestor_fee, ancestor_size) :\n+                       CFeeRate(tx_fee, tx_size);\n+        };\n+        CFeeRate a_feerate{min_feerate(a->second)};\n+        CFeeRate b_feerate{min_feerate(b->second)};\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Use txid as tiebreaker for stable sorting\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entry’s descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());",
      "path": "src/node/mini_miner.cpp",
      "position": 174,
      "original_position": 173,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ad34243f15d23d6adb66a07b39f86ce93baba253",
      "in_reply_to_id": 1145368125,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I am not sure I follow. For historical reasons, transactions are included in their own ancestor set and their own descendant set. So while we are iterating over descendants, we could be evaluating a transaction itself that has no ancestors left after they were picked into our “virtual block”. If the evaluated transaction doesn’t have ancestors left, and we get its size with ancestors, we are comparing its own size with its own size in this inequality. Therefore, same size must be permitted.\r\n\r\nI tested my expectation that this would cause failures by turning the `Assume` into an `assert` and then running with either `>=` or `>`. The `assert` is triggered for `>`.",
      "created_at": "2023-03-27T15:10:22Z",
      "updated_at": "2023-03-27T21:37:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149399579",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149399579"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 174,
      "original_line": 174,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149422663",
      "pull_request_review_id": 1359286170,
      "id": 1149422663,
      "node_id": "PRRC_kwDOABII585EgsxH",
      "diff_hunk": "@@ -0,0 +1,368 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+            continue;\n+        }\n+\n+        // UXTO is created by transaction in mempool, add to map.\n+        // Note: This will either create a missing entry or add the outpoint to an existing entry\n+        m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool. We\n+            // assume that the caller wants to replace this transaction and its descendants. It\n+            // would be unusual for the transaction to have descendants as the wallet won’t normally\n+            // attempt to replace transactions with descendants. If the outpoint is from a mempool\n+            // transaction, we still need to calculate its ancestors bump fees (added to\n+            // m_requested_outpoints_by_txid below), but after removing the to-be-replaced entries.\n+            //\n+            // Note that the descendants of a transaction include the transaction itself. Also note,\n+            // that this is only calculating bump fees. RBF fee rules should be handled separately.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+//\n+// Under the ancestor-based mining approach, high-feerate children can pay for parents, but high-feerate\n+// parents do not incentive inclusion of their children. Therefore the mining algorithm only considers\n+// transactions for inclusion on basis of the minimum of their own feerate or their ancestor feerate.\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        auto min_feerate = [](const MiniMinerMempoolEntry& e) -> CFeeRate {\n+            const CAmount ancestor_fee{e.GetModFeesWithAncestors()};\n+            const int64_t ancestor_size{e.GetSizeWithAncestors()};\n+            const CAmount tx_fee{e.GetModifiedFee()};\n+            const int64_t tx_size{e.GetTxSize()};\n+            // Comparing ancestor feerate with individual feerate:\n+            //     ancestor_fee / ancestor_size <= tx_fee / tx_size\n+            // Avoid division and possible loss of precision by\n+            // multiplying both sides by the sizes:\n+            return ancestor_fee * tx_size < tx_fee * ancestor_size ?\n+                       CFeeRate(ancestor_fee, ancestor_size) :\n+                       CFeeRate(tx_fee, tx_size);\n+        };\n+        CFeeRate a_feerate{min_feerate(a->second)};\n+        CFeeRate b_feerate{min_feerate(b->second)};\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Use txid as tiebreaker for stable sorting\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entry’s descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());",
      "path": "src/node/mini_miner.cpp",
      "position": 174,
      "original_position": 173,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ad34243f15d23d6adb66a07b39f86ce93baba253",
      "in_reply_to_id": 1145373839,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "See response on prior comment",
      "created_at": "2023-03-27T15:26:24Z",
      "updated_at": "2023-03-27T21:37:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149422663",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149422663"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": 172,
      "original_start_line": 171,
      "start_side": "RIGHT",
      "line": 174,
      "original_line": 174,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149445980",
      "pull_request_review_id": 1359286170,
      "id": 1149445980,
      "node_id": "PRRC_kwDOABII585Egydc",
      "diff_hunk": "@@ -0,0 +1,368 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+            continue;\n+        }\n+\n+        // UXTO is created by transaction in mempool, add to map.\n+        // Note: This will either create a missing entry or add the outpoint to an existing entry\n+        m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool. We\n+            // assume that the caller wants to replace this transaction and its descendants. It\n+            // would be unusual for the transaction to have descendants as the wallet won’t normally\n+            // attempt to replace transactions with descendants. If the outpoint is from a mempool\n+            // transaction, we still need to calculate its ancestors bump fees (added to\n+            // m_requested_outpoints_by_txid below), but after removing the to-be-replaced entries.\n+            //\n+            // Note that the descendants of a transaction include the transaction itself. Also note,\n+            // that this is only calculating bump fees. RBF fee rules should be handled separately.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+//\n+// Under the ancestor-based mining approach, high-feerate children can pay for parents, but high-feerate\n+// parents do not incentive inclusion of their children. Therefore the mining algorithm only considers\n+// transactions for inclusion on basis of the minimum of their own feerate or their ancestor feerate.\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        auto min_feerate = [](const MiniMinerMempoolEntry& e) -> CFeeRate {\n+            const CAmount ancestor_fee{e.GetModFeesWithAncestors()};\n+            const int64_t ancestor_size{e.GetSizeWithAncestors()};\n+            const CAmount tx_fee{e.GetModifiedFee()};\n+            const int64_t tx_size{e.GetTxSize()};\n+            // Comparing ancestor feerate with individual feerate:\n+            //     ancestor_fee / ancestor_size <= tx_fee / tx_size\n+            // Avoid division and possible loss of precision by\n+            // multiplying both sides by the sizes:\n+            return ancestor_fee * tx_size < tx_fee * ancestor_size ?\n+                       CFeeRate(ancestor_fee, ancestor_size) :\n+                       CFeeRate(tx_fee, tx_size);\n+        };\n+        CFeeRate a_feerate{min_feerate(a->second)};\n+        CFeeRate b_feerate{min_feerate(b->second)};\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Use txid as tiebreaker for stable sorting\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entry’s descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());\n+            descendant->second.fee_with_ancestors -= anc->second.GetModifiedFee();\n+            descendant->second.vsize_with_ancestors -= anc->second.GetTxSize();\n+        }\n+    }\n+    // Delete these entries.\n+    for (const auto& anc : ancestors) {\n+        m_descendant_set_by_txid.erase(anc->first);\n+        // The above loop should have deducted each ancestor's size and fees from each of their\n+        // respective descendants exactly once.\n+        Assume(anc->second.GetModFeesWithAncestors() == 0);\n+        Assume(anc->second.GetSizeWithAncestors() == 0);\n+        auto vec_it = std::find(m_entries.begin(), m_entries.end(), anc);\n+        Assume(vec_it != m_entries.end());\n+        m_entries.erase(vec_it);\n+        m_entries_by_txid.erase(anc);\n+    }",
      "path": "src/node/mini_miner.cpp",
      "position": 190,
      "original_position": 189,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ad34243f15d23d6adb66a07b39f86ce93baba253",
      "in_reply_to_id": 1145394065,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, it felt safer to first update everything, then to start deleting things. I did try combining the loops and it did not break anything, though. Still deciding, maybe this could be a follow-up.",
      "created_at": "2023-03-27T15:42:00Z",
      "updated_at": "2023-03-27T21:37:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149445980",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149445980"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": 179,
      "original_start_line": 178,
      "start_side": "RIGHT",
      "line": 190,
      "original_line": 190,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149447519",
      "pull_request_review_id": 1359286170,
      "id": 1149447519,
      "node_id": "PRRC_kwDOABII585Egy1f",
      "diff_hunk": "@@ -0,0 +1,368 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+            continue;\n+        }\n+\n+        // UXTO is created by transaction in mempool, add to map.\n+        // Note: This will either create a missing entry or add the outpoint to an existing entry\n+        m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool. We\n+            // assume that the caller wants to replace this transaction and its descendants. It\n+            // would be unusual for the transaction to have descendants as the wallet won’t normally\n+            // attempt to replace transactions with descendants. If the outpoint is from a mempool\n+            // transaction, we still need to calculate its ancestors bump fees (added to\n+            // m_requested_outpoints_by_txid below), but after removing the to-be-replaced entries.\n+            //\n+            // Note that the descendants of a transaction include the transaction itself. Also note,\n+            // that this is only calculating bump fees. RBF fee rules should be handled separately.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+//\n+// Under the ancestor-based mining approach, high-feerate children can pay for parents, but high-feerate\n+// parents do not incentive inclusion of their children. Therefore the mining algorithm only considers\n+// transactions for inclusion on basis of the minimum of their own feerate or their ancestor feerate.\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        auto min_feerate = [](const MiniMinerMempoolEntry& e) -> CFeeRate {\n+            const CAmount ancestor_fee{e.GetModFeesWithAncestors()};\n+            const int64_t ancestor_size{e.GetSizeWithAncestors()};\n+            const CAmount tx_fee{e.GetModifiedFee()};\n+            const int64_t tx_size{e.GetTxSize()};\n+            // Comparing ancestor feerate with individual feerate:\n+            //     ancestor_fee / ancestor_size <= tx_fee / tx_size\n+            // Avoid division and possible loss of precision by\n+            // multiplying both sides by the sizes:\n+            return ancestor_fee * tx_size < tx_fee * ancestor_size ?\n+                       CFeeRate(ancestor_fee, ancestor_size) :\n+                       CFeeRate(tx_fee, tx_size);\n+        };\n+        CFeeRate a_feerate{min_feerate(a->second)};\n+        CFeeRate b_feerate{min_feerate(b->second)};\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Use txid as tiebreaker for stable sorting\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entry’s descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());\n+            descendant->second.fee_with_ancestors -= anc->second.GetModifiedFee();\n+            descendant->second.vsize_with_ancestors -= anc->second.GetTxSize();\n+        }\n+    }\n+    // Delete these entries.\n+    for (const auto& anc : ancestors) {\n+        m_descendant_set_by_txid.erase(anc->first);\n+        // The above loop should have deducted each ancestor's size and fees from each of their\n+        // respective descendants exactly once.\n+        Assume(anc->second.GetModFeesWithAncestors() == 0);\n+        Assume(anc->second.GetSizeWithAncestors() == 0);\n+        auto vec_it = std::find(m_entries.begin(), m_entries.end(), anc);\n+        Assume(vec_it != m_entries.end());\n+        m_entries.erase(vec_it);\n+        m_entries_by_txid.erase(anc);\n+    }\n+}\n+\n+void MiniMiner::SanityCheck() const\n+{\n+    // m_entries, m_entries_by_txid, and m_descendant_set_by_txid all same size\n+    Assume(m_entries.size() == m_entries_by_txid.size());\n+    Assume(m_entries.size() == m_descendant_set_by_txid.size());\n+    // Cached ancestor values should be at least as large as the transaction's own fee and size\n+    Assume(std::all_of(m_entries.begin(), m_entries.end(), [](const auto& entry) {\n+        return entry->second.GetSizeWithAncestors() >= entry->second.GetTxSize() &&\n+               entry->second.GetModFeesWithAncestors() >= entry->second.GetModifiedFee();}));\n+    // None of the entries should be to-be-replaced transactions\n+    Assume(std::all_of(m_to_be_replaced.begin(), m_to_be_replaced.end(),\n+        [&](const auto& txid){return m_entries_by_txid.find(txid) == m_entries_by_txid.end();}));\n+}\n+\n+void MiniMiner::BuildMockTemplate(const CFeeRate& target_feerate)\n+{\n+    while (!m_entries_by_txid.empty()) {\n+        // Sort again, since transaction removal may change some m_entries' ancestor feerates.\n+        std::sort(m_entries.begin(), m_entries.end(), AncestorFeerateComparator());\n+\n+        // Pick highest ancestor feerate entry.\n+        auto best_iter = m_entries.begin();\n+        Assume(best_iter != m_entries.end());\n+        const auto ancestor_package_size = (*best_iter)->second.GetSizeWithAncestors();\n+        const auto ancestor_package_fee = (*best_iter)->second.GetModFeesWithAncestors();\n+        // Stop here. Everything that didn't \"make it into the block\" has bumpfee.\n+        if (ancestor_package_fee < target_feerate.GetFee(ancestor_package_size)) {\n+            break;\n+        }\n+\n+        // Calculate ancestors on the fly. This lookup should be fairly cheap, and ancestor sets\n+        // change at every iteration, so this is more efficient than maintaining a cache.\n+        std::set<MockEntryMap::iterator, IteratorComparator> ancestors;\n+        {\n+            std::set<MockEntryMap::iterator, IteratorComparator> to_process;\n+            to_process.insert(*best_iter);\n+            while (!to_process.empty()) {\n+                auto iter = to_process.begin();\n+                Assume(iter != to_process.end());\n+                ancestors.insert(*iter);\n+                for (const auto& input : (*iter)->second.GetTx().vin) {\n+                    if (auto parent_it{m_entries_by_txid.find(input.prevout.hash)}; parent_it != m_entries_by_txid.end()) {\n+                        if (ancestors.count(parent_it) == 0) {\n+                            to_process.insert(parent_it);\n+                        }\n+                    }\n+                }\n+                to_process.erase(iter);\n+            }\n+        }\n+        DeleteAncestorPackage(ancestors);\n+        SanityCheck();\n+    }\n+    Assume(m_in_block.empty() || m_total_fees >= target_feerate.GetFee(m_total_vsize));\n+    // Do not try to continue building the block template with a different feerate.\n+    m_ready_to_calculate = false;\n+}\n+\n+std::map<COutPoint, CAmount> MiniMiner::CalculateBumpFees(const CFeeRate& target_feerate)\n+{\n+    if (!m_ready_to_calculate) return {};\n+    // Build a block template until the target feerate is hit.\n+    BuildMockTemplate(target_feerate);\n+\n+    // Each transaction that \"made it into the block\" has a bumpfee of 0, i.e. they are part of an\n+    // ancestor package with at least the target feerate and don't need to be bumped.\n+    for (const auto& txid : m_in_block) {\n+        // Not all of the block transactions were necessarily requested.\n+        auto it = m_requested_outpoints_by_txid.find(txid);\n+        if (it != m_requested_outpoints_by_txid.end()) {\n+            for (const auto& outpoint : it->second) {\n+                m_bump_fees.emplace(outpoint, 0);\n+            }\n+            m_requested_outpoints_by_txid.erase(it);\n+        }\n+    }\n+\n+    // A transactions and its ancestors will only be picked into a block when\n+    // both the ancestor set feerate and the individual feerate meet the target\n+    // feerate.\n+    //\n+    // We had to convince ourselves that after running the mini miner and\n+    // picking all eligible transactions into our MockBlockTemplate, there\n+    // could still be transactions remaining that have a lower individual\n+    // feerate than their ancestor feerate. So here is an example:\n+    //\n+    //               ┌─────────────────┐\n+    //               │                 │\n+    //               │   Grandparent   │\n+    //               │    1700 vB      │\n+    //               │    1700 sats    │                    Target feerate: 10    s/vB\n+    //               │       1 s/vB    │    GP Ancestor Set Feerate (ASFR):  1    s/vB\n+    //               │                 │                           P1_ASFR:  9.84 s/vB\n+    //               └──────▲───▲──────┘                           P2_ASFR:  2.47 s/vB\n+    //                      │   │                                   C_ASFR: 10.27 s/vB\n+    // ┌───────────────┐    │   │    ┌──────────────┐\n+    // │               ├────┘   └────┤              │             ⇒ C_FR < TFR < C_ASFR\n+    // │   Parent 1    │             │   Parent 2   │\n+    // │    200 vB     │             │    200 vB    │\n+    // │  17000 sats   │             │   3000 sats  │\n+    // │     85 s/vB   │             │     15 s/vB  │\n+    // │               │             │              │\n+    // └───────────▲───┘             └───▲──────────┘\n+    //             │                     │\n+    //             │    ┌───────────┐    │\n+    //             └────┤           ├────┘\n+    //                  │   Child   │\n+    //                  │  100 vB   │\n+    //                  │  900 sats │\n+    //                  │    9 s/vB │\n+    //                  │           │\n+    //                  └───────────┘\n+    //\n+    // We therefore calculate both the bump fee that is necessary to elevate\n+    // the individual transaction to the target feerate:\n+    //         target_feerate × tx_size - tx_fees\n+    // and the bump fee that is necessary to bump the entire ancestor set to\n+    // the target feerate:\n+    //         target_feerate × ancestor_set_size - ancestor_set_fees\n+    // By picking the maximum from the two, we ensure that a transaction meets\n+    // both criteria.\n+    for (const auto& [txid, outpoints] : m_requested_outpoints_by_txid) {\n+        auto it = m_entries_by_txid.find(txid);\n+        Assume(it != m_entries_by_txid.end());\n+        if (it != m_entries_by_txid.end()) {\n+            Assume(target_feerate.GetFee(it->second.GetSizeWithAncestors()) > std::min(it->second.GetModifiedFee(), it->second.GetModFeesWithAncestors()));\n+            CAmount bump_fee_with_ancestors = target_feerate.GetFee(it->second.GetSizeWithAncestors()) - it->second.GetModFeesWithAncestors();\n+            CAmount bump_fee_individual = target_feerate.GetFee(it->second.GetTxSize()) - it->second.GetModifiedFee();\n+            const CAmount bump_fee{std::max(bump_fee_with_ancestors, bump_fee_individual)};\n+            Assume(bump_fee >= 0);\n+            for (const auto& outpoint : outpoints) {\n+                m_bump_fees.emplace(outpoint, bump_fee);\n+            }\n+        }\n+    }\n+    return m_bump_fees;\n+}\n+\n+std::optional<CAmount> MiniMiner::CalculateTotalBumpFees(const CFeeRate& target_feerate)\n+{\n+    if (!m_ready_to_calculate) return std::nullopt;\n+    // Build a block template until the target feerate is hit.\n+    BuildMockTemplate(target_feerate);\n+\n+    // All remaining ancestors that are not part of m_in_block must be bumped, but no other relatives\n+    std::set<MockEntryMap::iterator, IteratorComparator> ancestors;\n+    {",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 338,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ad34243f15d23d6adb66a07b39f86ce93baba253",
      "in_reply_to_id": 1146927271,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks, removed extraneous curly braces",
      "created_at": "2023-03-27T15:43:07Z",
      "updated_at": "2023-03-27T21:37:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149447519",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149447519"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 338,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149653633",
      "pull_request_review_id": 1359286170,
      "id": 1149653633,
      "node_id": "PRRC_kwDOABII585EhlKB",
      "diff_hunk": "@@ -0,0 +1,368 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+            continue;\n+        }\n+\n+        // UXTO is created by transaction in mempool, add to map.\n+        // Note: This will either create a missing entry or add the outpoint to an existing entry\n+        m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool. We\n+            // assume that the caller wants to replace this transaction and its descendants. It\n+            // would be unusual for the transaction to have descendants as the wallet won’t normally\n+            // attempt to replace transactions with descendants. If the outpoint is from a mempool\n+            // transaction, we still need to calculate its ancestors bump fees (added to\n+            // m_requested_outpoints_by_txid below), but after removing the to-be-replaced entries.\n+            //\n+            // Note that the descendants of a transaction include the transaction itself. Also note,\n+            // that this is only calculating bump fees. RBF fee rules should be handled separately.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+//\n+// Under the ancestor-based mining approach, high-feerate children can pay for parents, but high-feerate\n+// parents do not incentive inclusion of their children. Therefore the mining algorithm only considers\n+// transactions for inclusion on basis of the minimum of their own feerate or their ancestor feerate.\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        auto min_feerate = [](const MiniMinerMempoolEntry& e) -> CFeeRate {\n+            const CAmount ancestor_fee{e.GetModFeesWithAncestors()};\n+            const int64_t ancestor_size{e.GetSizeWithAncestors()};\n+            const CAmount tx_fee{e.GetModifiedFee()};\n+            const int64_t tx_size{e.GetTxSize()};\n+            // Comparing ancestor feerate with individual feerate:\n+            //     ancestor_fee / ancestor_size <= tx_fee / tx_size\n+            // Avoid division and possible loss of precision by\n+            // multiplying both sides by the sizes:\n+            return ancestor_fee * tx_size < tx_fee * ancestor_size ?\n+                       CFeeRate(ancestor_fee, ancestor_size) :\n+                       CFeeRate(tx_fee, tx_size);\n+        };\n+        CFeeRate a_feerate{min_feerate(a->second)};\n+        CFeeRate b_feerate{min_feerate(b->second)};\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Use txid as tiebreaker for stable sorting\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entry’s descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());\n+            descendant->second.fee_with_ancestors -= anc->second.GetModifiedFee();\n+            descendant->second.vsize_with_ancestors -= anc->second.GetTxSize();\n+        }\n+    }\n+    // Delete these entries.\n+    for (const auto& anc : ancestors) {\n+        m_descendant_set_by_txid.erase(anc->first);\n+        // The above loop should have deducted each ancestor's size and fees from each of their\n+        // respective descendants exactly once.\n+        Assume(anc->second.GetModFeesWithAncestors() == 0);\n+        Assume(anc->second.GetSizeWithAncestors() == 0);\n+        auto vec_it = std::find(m_entries.begin(), m_entries.end(), anc);\n+        Assume(vec_it != m_entries.end());\n+        m_entries.erase(vec_it);\n+        m_entries_by_txid.erase(anc);\n+    }\n+}\n+\n+void MiniMiner::SanityCheck() const\n+{\n+    // m_entries, m_entries_by_txid, and m_descendant_set_by_txid all same size\n+    Assume(m_entries.size() == m_entries_by_txid.size());\n+    Assume(m_entries.size() == m_descendant_set_by_txid.size());\n+    // Cached ancestor values should be at least as large as the transaction's own fee and size\n+    Assume(std::all_of(m_entries.begin(), m_entries.end(), [](const auto& entry) {\n+        return entry->second.GetSizeWithAncestors() >= entry->second.GetTxSize() &&\n+               entry->second.GetModFeesWithAncestors() >= entry->second.GetModifiedFee();}));\n+    // None of the entries should be to-be-replaced transactions\n+    Assume(std::all_of(m_to_be_replaced.begin(), m_to_be_replaced.end(),\n+        [&](const auto& txid){return m_entries_by_txid.find(txid) == m_entries_by_txid.end();}));\n+}\n+\n+void MiniMiner::BuildMockTemplate(const CFeeRate& target_feerate)\n+{\n+    while (!m_entries_by_txid.empty()) {\n+        // Sort again, since transaction removal may change some m_entries' ancestor feerates.\n+        std::sort(m_entries.begin(), m_entries.end(), AncestorFeerateComparator());\n+\n+        // Pick highest ancestor feerate entry.\n+        auto best_iter = m_entries.begin();\n+        Assume(best_iter != m_entries.end());\n+        const auto ancestor_package_size = (*best_iter)->second.GetSizeWithAncestors();\n+        const auto ancestor_package_fee = (*best_iter)->second.GetModFeesWithAncestors();\n+        // Stop here. Everything that didn't \"make it into the block\" has bumpfee.\n+        if (ancestor_package_fee < target_feerate.GetFee(ancestor_package_size)) {\n+            break;\n+        }\n+\n+        // Calculate ancestors on the fly. This lookup should be fairly cheap, and ancestor sets\n+        // change at every iteration, so this is more efficient than maintaining a cache.\n+        std::set<MockEntryMap::iterator, IteratorComparator> ancestors;\n+        {\n+            std::set<MockEntryMap::iterator, IteratorComparator> to_process;\n+            to_process.insert(*best_iter);\n+            while (!to_process.empty()) {\n+                auto iter = to_process.begin();\n+                Assume(iter != to_process.end());\n+                ancestors.insert(*iter);\n+                for (const auto& input : (*iter)->second.GetTx().vin) {\n+                    if (auto parent_it{m_entries_by_txid.find(input.prevout.hash)}; parent_it != m_entries_by_txid.end()) {\n+                        if (ancestors.count(parent_it) == 0) {\n+                            to_process.insert(parent_it);\n+                        }\n+                    }\n+                }\n+                to_process.erase(iter);\n+            }\n+        }\n+        DeleteAncestorPackage(ancestors);\n+        SanityCheck();\n+    }\n+    Assume(m_in_block.empty() || m_total_fees >= target_feerate.GetFee(m_total_vsize));\n+    // Do not try to continue building the block template with a different feerate.\n+    m_ready_to_calculate = false;\n+}\n+\n+std::map<COutPoint, CAmount> MiniMiner::CalculateBumpFees(const CFeeRate& target_feerate)\n+{\n+    if (!m_ready_to_calculate) return {};\n+    // Build a block template until the target feerate is hit.\n+    BuildMockTemplate(target_feerate);\n+\n+    // Each transaction that \"made it into the block\" has a bumpfee of 0, i.e. they are part of an\n+    // ancestor package with at least the target feerate and don't need to be bumped.\n+    for (const auto& txid : m_in_block) {\n+        // Not all of the block transactions were necessarily requested.\n+        auto it = m_requested_outpoints_by_txid.find(txid);\n+        if (it != m_requested_outpoints_by_txid.end()) {\n+            for (const auto& outpoint : it->second) {\n+                m_bump_fees.emplace(outpoint, 0);\n+            }\n+            m_requested_outpoints_by_txid.erase(it);\n+        }\n+    }\n+\n+    // A transactions and its ancestors will only be picked into a block when\n+    // both the ancestor set feerate and the individual feerate meet the target\n+    // feerate.\n+    //\n+    // We had to convince ourselves that after running the mini miner and\n+    // picking all eligible transactions into our MockBlockTemplate, there\n+    // could still be transactions remaining that have a lower individual\n+    // feerate than their ancestor feerate. So here is an example:\n+    //\n+    //               ┌─────────────────┐\n+    //               │                 │\n+    //               │   Grandparent   │\n+    //               │    1700 vB      │\n+    //               │    1700 sats    │                    Target feerate: 10    s/vB\n+    //               │       1 s/vB    │    GP Ancestor Set Feerate (ASFR):  1    s/vB\n+    //               │                 │                           P1_ASFR:  9.84 s/vB\n+    //               └──────▲───▲──────┘                           P2_ASFR:  2.47 s/vB\n+    //                      │   │                                   C_ASFR: 10.27 s/vB\n+    // ┌───────────────┐    │   │    ┌──────────────┐\n+    // │               ├────┘   └────┤              │             ⇒ C_FR < TFR < C_ASFR\n+    // │   Parent 1    │             │   Parent 2   │\n+    // │    200 vB     │             │    200 vB    │\n+    // │  17000 sats   │             │   3000 sats  │\n+    // │     85 s/vB   │             │     15 s/vB  │\n+    // │               │             │              │\n+    // └───────────▲───┘             └───▲──────────┘\n+    //             │                     │\n+    //             │    ┌───────────┐    │\n+    //             └────┤           ├────┘\n+    //                  │   Child   │\n+    //                  │  100 vB   │\n+    //                  │  900 sats │\n+    //                  │    9 s/vB │\n+    //                  │           │\n+    //                  └───────────┘\n+    //\n+    // We therefore calculate both the bump fee that is necessary to elevate\n+    // the individual transaction to the target feerate:\n+    //         target_feerate × tx_size - tx_fees\n+    // and the bump fee that is necessary to bump the entire ancestor set to\n+    // the target feerate:\n+    //         target_feerate × ancestor_set_size - ancestor_set_fees\n+    // By picking the maximum from the two, we ensure that a transaction meets\n+    // both criteria.\n+    for (const auto& [txid, outpoints] : m_requested_outpoints_by_txid) {\n+        auto it = m_entries_by_txid.find(txid);\n+        Assume(it != m_entries_by_txid.end());\n+        if (it != m_entries_by_txid.end()) {\n+            Assume(target_feerate.GetFee(it->second.GetSizeWithAncestors()) > std::min(it->second.GetModifiedFee(), it->second.GetModFeesWithAncestors()));\n+            CAmount bump_fee_with_ancestors = target_feerate.GetFee(it->second.GetSizeWithAncestors()) - it->second.GetModFeesWithAncestors();\n+            CAmount bump_fee_individual = target_feerate.GetFee(it->second.GetTxSize()) - it->second.GetModifiedFee();\n+            const CAmount bump_fee{std::max(bump_fee_with_ancestors, bump_fee_individual)};\n+            Assume(bump_fee >= 0);\n+            for (const auto& outpoint : outpoints) {\n+                m_bump_fees.emplace(outpoint, bump_fee);\n+            }\n+        }\n+    }\n+    return m_bump_fees;\n+}\n+\n+std::optional<CAmount> MiniMiner::CalculateTotalBumpFees(const CFeeRate& target_feerate)\n+{\n+    if (!m_ready_to_calculate) return std::nullopt;\n+    // Build a block template until the target feerate is hit.\n+    BuildMockTemplate(target_feerate);\n+\n+    // All remaining ancestors that are not part of m_in_block must be bumped, but no other relatives\n+    std::set<MockEntryMap::iterator, IteratorComparator> ancestors;\n+    {\n+        std::set<MockEntryMap::iterator, IteratorComparator> to_process;\n+        for (const auto& [txid, outpoints] : m_requested_outpoints_by_txid) {\n+            // Skip any ancestors that already have a miner score higher than the target feerate\n+            // (already \"made it\" into the block)\n+            if (m_in_block.count(txid)) continue;\n+            auto iter = m_entries_by_txid.find(txid);\n+            if (iter == m_entries_by_txid.end()) continue;\n+            to_process.insert(iter);\n+            ancestors.insert(iter);\n+        }\n+        while (!to_process.empty()) {\n+            auto iter = to_process.begin();\n+            assert(iter != to_process.end());",
      "path": "src/node/mini_miner.cpp",
      "position": null,
      "original_position": 351,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ad34243f15d23d6adb66a07b39f86ce93baba253",
      "in_reply_to_id": 1146476492,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah, agreed. Gonna remove it",
      "created_at": "2023-03-27T18:36:32Z",
      "updated_at": "2023-03-27T21:37:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149653633",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149653633"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 349,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 351,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149659725",
      "pull_request_review_id": 1359286170,
      "id": 1149659725,
      "node_id": "PRRC_kwDOABII585EhmpN",
      "diff_hunk": "@@ -0,0 +1,123 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_MINI_MINER_H\n+#define BITCOIN_NODE_MINI_MINER_H\n+\n+#include <txmempool.h>\n+\n+#include <memory>\n+#include <optional>\n+#include <stdint.h>\n+\n+namespace node {\n+\n+// Container for tracking updates to ancestor feerate as we include ancestors in the \"block\"\n+class MiniMinerMempoolEntry\n+{\n+    const CAmount fee_individual;\n+    const CTransactionRef tx;\n+    const int64_t vsize_individual;\n+\n+// This class must be constructed while holding mempool.cs. After construction, the object's\n+// methods can be called without holding that lock.\n+public:\n+    CAmount fee_with_ancestors;\n+    int64_t vsize_with_ancestors;\n+    explicit MiniMinerMempoolEntry(CTxMemPool::txiter entry) :\n+        fee_individual{entry->GetModifiedFee()},\n+        tx{entry->GetSharedTx()},\n+        vsize_individual(entry->GetTxSize()),\n+        fee_with_ancestors{entry->GetModFeesWithAncestors()},\n+        vsize_with_ancestors(entry->GetSizeWithAncestors())\n+    { }\n+\n+    CAmount GetModifiedFee() const { return fee_individual; }\n+    CAmount GetModFeesWithAncestors() const { return fee_with_ancestors; }\n+    int64_t GetTxSize() const { return vsize_individual; }\n+    int64_t GetSizeWithAncestors() const { return vsize_with_ancestors; }\n+    const CTransaction& GetTx() const LIFETIMEBOUND { return *tx; }\n+};\n+\n+void UpdateForMinedAncestor(const MiniMinerMempoolEntry& ancestor, const MiniMinerMempoolEntry& descendant);",
      "path": "src/node/mini_miner.h",
      "position": null,
      "original_position": 43,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "ad34243f15d23d6adb66a07b39f86ce93baba253",
      "in_reply_to_id": 1145355201,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Removed unimplemented function",
      "created_at": "2023-03-27T18:41:45Z",
      "updated_at": "2023-03-27T21:37:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149659725",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149659725"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 43,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149709427",
      "pull_request_review_id": 1359286170,
      "id": 1149709427,
      "node_id": "PRRC_kwDOABII585Ehyxz",
      "diff_hunk": "@@ -1140,3 +1153,39 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::GatherClusters(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    if (txids.size() > 500) return {}; // DoS protection, limit to 500 entries. We already have more than 500 txs, just quit.\n+    std::vector<txiter> clustered_txs{GetIterVec(txids)};\n+    if (clustered_txs.empty()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    {\n+        // Use epoch: visiting an entry means we have added it to the clustered_txs vector. It does not\n+        // necessarily mean the entry has been processed.\n+        WITH_FRESH_EPOCH(m_epoch);\n+        for (const auto& it : clustered_txs) {\n+            visited(it);\n+        }\n+        // i = index of where the list of entries to process starts\n+        for (size_t i{0}, to_process_count{txids.size()}; i < to_process_count; ++i) {\n+            // DoS protection: if not finished after processing 500 entries, just quit.\n+            if (to_process_count > 500) return {};",
      "path": "src/txmempool.cpp",
      "position": null,
      "original_position": 61,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "cf1636078f7e97110cab15646110fcc1ce935136",
      "in_reply_to_id": 1136045597,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Since I’ve removed the special casing that makes us bail if we start with 500 in the first place, I have left it at the start of the loop.",
      "created_at": "2023-03-27T19:33:46Z",
      "updated_at": "2023-03-27T21:37:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149709427",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149709427"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1177,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149709631",
      "pull_request_review_id": 1359286170,
      "id": 1149709631,
      "node_id": "PRRC_kwDOABII585Ehy0_",
      "diff_hunk": "@@ -1140,3 +1153,39 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::GatherClusters(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    if (txids.size() > 500) return {}; // DoS protection, limit to 500 entries. We already have more than 500 txs, just quit.\n+    std::vector<txiter> clustered_txs{GetIterVec(txids)};\n+    if (clustered_txs.empty()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }\n+    {\n+        // Use epoch: visiting an entry means we have added it to the clustered_txs vector. It does not\n+        // necessarily mean the entry has been processed.\n+        WITH_FRESH_EPOCH(m_epoch);\n+        for (const auto& it : clustered_txs) {\n+            visited(it);\n+        }\n+        // i = index of where the list of entries to process starts\n+        for (size_t i{0}, to_process_count{txids.size()}; i < to_process_count; ++i) {",
      "path": "src/txmempool.cpp",
      "position": null,
      "original_position": 59,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "cf1636078f7e97110cab15646110fcc1ce935136",
      "in_reply_to_id": 1136047228,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I’ve adopted your suggestion, thanks",
      "created_at": "2023-03-27T19:34:01Z",
      "updated_at": "2023-03-27T21:37:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149709631",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149709631"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1175,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149712008",
      "pull_request_review_id": 1359286170,
      "id": 1149712008,
      "node_id": "PRRC_kwDOABII585EhzaI",
      "diff_hunk": "@@ -1140,3 +1153,39 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::GatherClusters(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    if (txids.size() > 500) return {}; // DoS protection, limit to 500 entries. We already have more than 500 txs, just quit.\n+    std::vector<txiter> clustered_txs{GetIterVec(txids)};\n+    if (clustered_txs.empty()) {\n+        // We can't continue because the caller specified a tx that doesn't exist in the mempool.\n+        // Return an empty vector to let them know this failed.\n+        return {};\n+    }",
      "path": "src/txmempool.cpp",
      "position": null,
      "original_position": 50,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "cf1636078f7e97110cab15646110fcc1ce935136",
      "in_reply_to_id": 1136048292,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Right, if txids is empty, we already return an empty vector anyway, and the 500 limit is already checked at the start of the loop. Sorry, @furszy, I changed my mind about [your prior suggestion to add an early exit](https://github.com/bitcoin/bitcoin/pull/27021/files#diff-c065d4cd2398ad0dbcef393c5dfc53f465bf44723348892395fffd2fb3bac522).",
      "created_at": "2023-03-27T19:36:45Z",
      "updated_at": "2023-03-27T21:37:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149712008",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149712008"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 1162,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 1166,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149719267",
      "pull_request_review_id": 1359286170,
      "id": 1149719267,
      "node_id": "PRRC_kwDOABII585Eh1Lj",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }",
      "path": "src/test/miniminer_tests.cpp",
      "position": null,
      "original_position": 45,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "in_reply_to_id": 1146941331,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks that sounds like a good idea.",
      "created_at": "2023-03-27T19:44:39Z",
      "updated_at": "2023-03-27T21:37:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149719267",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149719267"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 42,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 47,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149727812",
      "pull_request_review_id": 1359286170,
      "id": 1149727812,
      "node_id": "PRRC_kwDOABII585Eh3RE",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<CTxMemPool::txiter> all_entries;\n+    std::map<uint256, int64_t> tx_vsizes;\n+    std::map<uint256, CAmount> tx_modified_fees;\n+    std::map<uint256, CFeeRate> tx_feerates;\n+    for (const auto& tx : all_transactions) {\n+        const auto entry = pool.GetIter(tx->GetHash()).value();\n+        all_entries.push_back(entry);\n+        tx_vsizes.emplace(tx->GetHash(), entry->GetTxSize());\n+        tx_modified_fees.emplace(tx->GetHash(), entry->GetModifiedFee());\n+        tx_feerates.emplace(tx->GetHash(), CFeeRate(entry->GetModifiedFee(), entry->GetTxSize()));\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        // Check tx1 bumpfee: no other bumper.\n+        const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+        auto it1_unspent = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(it1_unspent != bump_fees.end());\n+        if (target_feerate <= tx1_feerate) {\n+            BOOST_CHECK_EQUAL(it1_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(it1_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+        }\n+        // Check tx3 bumpfee: assisted by tx4.\n+        const auto tx3_feerate = CFeeRate(\n+            tx_modified_fees.find(tx3->GetHash())->second + tx_modified_fees.find(tx4->GetHash())->second,\n+            tx_vsizes.find(tx3->GetHash())->second + tx_vsizes.find(tx4->GetHash())->second);\n+        auto it3_unspent = bump_fees.find(COutPoint{tx3->GetHash(), 1});\n+        BOOST_CHECK(it3_unspent != bump_fees.end());\n+        if (target_feerate <= tx3_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it3_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+            BOOST_CHECK_EQUAL(it3_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+        }\n+        // Check tx5 bumpfee: assisted by tx6. Specifically, tx6's modified fees.\n+        const auto tx5_feerate = CFeeRate(\n+            tx_modified_fees.find(tx5->GetHash())->second + tx_modified_fees.find(tx6->GetHash())->second,\n+            tx_vsizes.find(tx5->GetHash())->second + tx_vsizes.find(tx6->GetHash())->second);\n+        auto it5_unspent = bump_fees.find(COutPoint{tx5->GetHash(), 1});\n+        BOOST_CHECK(it5_unspent != bump_fees.end());\n+        if (target_feerate <= tx5_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it5_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+            BOOST_CHECK_EQUAL(it5_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx5->GetHash())->second) - tx_modified_fees.find(tx5->GetHash())->second);\n+        }\n+    }\n+    // Spent outpoints should usually not be requested as they would not be\n+    // considered available. However, when they are explicitly requested, we\n+    // can calculate their bumpfee to facilitate RBF-replacements\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner_all_spent(pool, all_spent_outpoints);\n+        BOOST_CHECK(mini_miner_all_spent.IsReadyToCalculate());\n+        auto bump_fees_all_spent = mini_miner_all_spent.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_spent.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_spent.size(), all_spent_outpoints.size());\n+        node::MiniMiner mini_miner_all_parents(pool, all_parent_outputs);\n+        BOOST_CHECK(mini_miner_all_parents.IsReadyToCalculate());\n+        auto bump_fees_all_parents = mini_miner_all_parents.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_parents.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_parents.size(), all_parent_outputs.size());\n+        for (auto& bump_fees : {bump_fees_all_parents, bump_fees_all_spent}) {\n+            // For all_parents case, both outputs from the parent should have the same bump fee,\n+            // even though only one of them is in a to-be-replaced transaction.\n+            BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+            // Check tx1 bumpfee: no other bumper.\n+            const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+            auto it1_spent = bump_fees.find(COutPoint{tx1->GetHash(), 0});\n+            BOOST_CHECK(it1_spent != bump_fees.end());\n+            if (target_feerate <= tx1_feerate) {\n+                BOOST_CHECK_EQUAL(it1_spent->second, 0);\n+            } else {\n+                // Difference is fee to bump tx1 from current to target feerate.\n+                BOOST_CHECK_EQUAL(it1_spent->second,\n+                    target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+            }\n+            // Check tx3 bumpfee: no other bumper, because tx4 is to-be-replaced.\n+            const auto tx3_feerate_unbumped = tx_feerates.find(tx3->GetHash())->second;\n+            auto it3_spent = bump_fees.find(COutPoint{tx3->GetHash(), 0});\n+            BOOST_CHECK(it3_spent != bump_fees.end());\n+            if (target_feerate <= tx3_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it3_spent->second, 0);\n+            } else {\n+                // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+                BOOST_CHECK_EQUAL(it3_spent->second,\n+                    target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+            }\n+            // Check tx5 bumpfee: no other bumper, because tx6 is to-be-replaced.\n+            const auto tx5_feerate_unbumped = tx_feerates.find(tx5->GetHash())->second;\n+            auto it5_spent = bump_fees.find(COutPoint{tx5->GetHash(), 0});\n+            BOOST_CHECK(it5_spent != bump_fees.end());\n+            if (target_feerate <= tx5_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it5_spent->second, 0);\n+            } else {\n+                // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+                BOOST_CHECK_EQUAL(it5_spent->second,\n+                    target_feerate.GetFee(tx_vsizes.find(tx5->GetHash())->second) - tx_modified_fees.find(tx5->GetHash())->second);\n+            }\n+        }\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_overlap, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount med_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create 3 parents of different feerates, and 1 child spending from all 3.\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx2));\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx1->GetHash(), 0}, COutPoint{tx2->GetHash(), 0}, COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create 1 grandparent and 1 parent, then 2 children.\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    const auto tx7 = make_tx({COutPoint{tx6->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx6->GetHash(), 1}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<int64_t> tx_vsizes;\n+    tx_vsizes.reserve(all_transactions.size());\n+    for (const auto& tx : all_transactions) tx_vsizes.push_back(GetVirtualTransactionSize(*tx));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx4->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 2},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 2},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    const auto tx3_feerate = CFeeRate(high_fee, tx_vsizes[2]);\n+    const auto tx4_feerate = CFeeRate(high_fee, tx_vsizes[3]);\n+    // tx4's feerate is lower than tx3's. same fee, different weight.\n+    BOOST_CHECK(tx3_feerate > tx4_feerate);\n+    const auto tx4_anc_feerate = CFeeRate(low_fee + med_fee + high_fee, tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[3]);\n+    const auto tx5_feerate = CFeeRate(high_fee, tx_vsizes[4]);\n+    const auto tx7_anc_feerate = CFeeRate(low_fee + med_fee, tx_vsizes[5] + tx_vsizes[6]);\n+    const auto tx8_anc_feerate = CFeeRate(low_fee + high_fee, tx_vsizes[5] + tx_vsizes[7]);\n+    BOOST_CHECK(tx5_feerate > tx7_anc_feerate);\n+    BOOST_CHECK(tx5_feerate > tx8_anc_feerate);\n+\n+    // Extremely high feerate: everybody's bumpfee is from their full ancestor set.\n+    {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        const CFeeRate very_high_feerate(COIN);\n+        BOOST_CHECK(tx4_anc_feerate < very_high_feerate);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(very_high_feerate);\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        const auto tx1_bumpfee = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(tx1_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx1_bumpfee->second, very_high_feerate.GetFee(tx_vsizes[0]) - low_fee);\n+        const auto tx4_bumpfee = bump_fees.find(COutPoint{tx4->GetHash(), 0});\n+        BOOST_CHECK(tx4_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx4_bumpfee->second,\n+            very_high_feerate.GetFee(tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[2] + tx_vsizes[3]) - (low_fee + med_fee + high_fee + high_fee));\n+        const auto tx7_bumpfee = bump_fees.find(COutPoint{tx7->GetHash(), 0});\n+        BOOST_CHECK(tx7_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx7_bumpfee->second,\n+            very_high_feerate.GetFee(tx_vsizes[4] + tx_vsizes[5] + tx_vsizes[6]) - (high_fee + low_fee + med_fee));\n+        const auto tx8_bumpfee = bump_fees.find(COutPoint{tx8->GetHash(), 0});\n+        BOOST_CHECK(tx8_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx8_bumpfee->second,\n+            very_high_feerate.GetFee(tx_vsizes[4] + tx_vsizes[5] + tx_vsizes[7]) - (high_fee + low_fee + high_fee));\n+        // Total fees: if spending multiple outputs from tx4 don't double-count fees.\n+        node::MiniMiner mini_miner_total_tx4(pool, {COutPoint{tx4->GetHash(), 0}, COutPoint{tx4->GetHash(), 1}});\n+        BOOST_CHECK(mini_miner_total_tx4.IsReadyToCalculate());\n+        const auto tx4_bump_fee = mini_miner_total_tx4.CalculateTotalBumpFees(very_high_feerate);\n+        BOOST_CHECK(!mini_miner_total_tx4.IsReadyToCalculate());\n+        BOOST_CHECK(tx4_bump_fee.has_value());\n+        BOOST_CHECK_EQUAL(tx4_bump_fee.value(),\n+            very_high_feerate.GetFee(tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[2] + tx_vsizes[3]) - (low_fee + med_fee + high_fee + high_fee));\n+        // Total fees: if spending both tx7 and tx8, don't double-count fees.\n+        node::MiniMiner mini_miner_tx7_tx8(pool, {COutPoint{tx7->GetHash(), 0}, COutPoint{tx8->GetHash(), 0}});\n+        BOOST_CHECK(mini_miner_tx7_tx8.IsReadyToCalculate());\n+        const auto tx7_tx8_bumpfee = mini_miner_tx7_tx8.CalculateTotalBumpFees(very_high_feerate);\n+        BOOST_CHECK(!mini_miner_tx7_tx8.IsReadyToCalculate());\n+        BOOST_CHECK(tx7_tx8_bumpfee.has_value());\n+        BOOST_CHECK_EQUAL(tx7_tx8_bumpfee.value(),\n+            very_high_feerate.GetFee(tx_vsizes[4] + tx_vsizes[5] + tx_vsizes[6] + tx_vsizes[7]) - (high_fee + low_fee + med_fee + high_fee));\n+    }\n+    // Feerate just below tx5: tx7 and tx8 have different bump fees.\n+    {\n+        const auto just_below_tx5 = CFeeRate(tx5_feerate.GetFeePerK() - 5);\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(just_below_tx5);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        const auto tx7_bumpfee = bump_fees.find(COutPoint{tx7->GetHash(), 0});\n+        BOOST_CHECK(tx7_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx7_bumpfee->second, just_below_tx5.GetFee(tx_vsizes[5] + tx_vsizes[6]) - (low_fee + med_fee));\n+        const auto tx8_bumpfee = bump_fees.find(COutPoint{tx8->GetHash(), 0});\n+        BOOST_CHECK(tx8_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx8_bumpfee->second, just_below_tx5.GetFee(tx_vsizes[5] + tx_vsizes[7]) - (low_fee + high_fee));\n+        // Total fees: if spending both tx7 and tx8, don't double-count fees.\n+        node::MiniMiner mini_miner_tx7_tx8(pool, {COutPoint{tx7->GetHash(), 0}, COutPoint{tx8->GetHash(), 0}});\n+        BOOST_CHECK(mini_miner_tx7_tx8.IsReadyToCalculate());\n+        const auto tx7_tx8_bumpfee = mini_miner_tx7_tx8.CalculateTotalBumpFees(just_below_tx5);\n+        BOOST_CHECK(!mini_miner_tx7_tx8.IsReadyToCalculate());\n+        BOOST_CHECK(tx7_tx8_bumpfee.has_value());\n+        BOOST_CHECK_EQUAL(tx7_tx8_bumpfee.value(), just_below_tx5.GetFee(tx_vsizes[5] + tx_vsizes[6]) - (low_fee + med_fee));\n+    }\n+    // Feerate between tx7 and tx8's ancestor feerates: don't need to bump tx6 because tx8 already does.\n+    {\n+        const auto just_above_tx7 = CFeeRate(med_fee + 10, tx_vsizes[6]);\n+        BOOST_CHECK(just_above_tx7 <= CFeeRate(low_fee + high_fee, tx_vsizes[5] + tx_vsizes[7]));\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(just_above_tx7);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        const auto tx7_bumpfee = bump_fees.find(COutPoint{tx7->GetHash(), 0});\n+        BOOST_CHECK(tx7_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx7_bumpfee->second, just_above_tx7.GetFee(tx_vsizes[6]) - (med_fee));\n+        const auto tx8_bumpfee = bump_fees.find(COutPoint{tx8->GetHash(), 0});\n+        BOOST_CHECK(tx8_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx8_bumpfee->second, 0);\n+    }\n+}\n+BOOST_FIXTURE_TEST_CASE(calculate_cluster, TestChain100Setup)\n+{\n+    FastRandomContext det_rand{true};",
      "path": "src/test/miniminer_tests.cpp",
      "position": null,
      "original_position": 412,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "in_reply_to_id": 1148418379,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks, removed",
      "created_at": "2023-03-27T19:54:21Z",
      "updated_at": "2023-03-27T21:37:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149727812",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149727812"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 412,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149728848",
      "pull_request_review_id": 1359286170,
      "id": 1149728848,
      "node_id": "PRRC_kwDOABII585Eh3hQ",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<CTxMemPool::txiter> all_entries;\n+    std::map<uint256, int64_t> tx_vsizes;\n+    std::map<uint256, CAmount> tx_modified_fees;\n+    std::map<uint256, CFeeRate> tx_feerates;\n+    for (const auto& tx : all_transactions) {\n+        const auto entry = pool.GetIter(tx->GetHash()).value();\n+        all_entries.push_back(entry);\n+        tx_vsizes.emplace(tx->GetHash(), entry->GetTxSize());\n+        tx_modified_fees.emplace(tx->GetHash(), entry->GetModifiedFee());\n+        tx_feerates.emplace(tx->GetHash(), CFeeRate(entry->GetModifiedFee(), entry->GetTxSize()));\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        // Check tx1 bumpfee: no other bumper.\n+        const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+        auto it1_unspent = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(it1_unspent != bump_fees.end());\n+        if (target_feerate <= tx1_feerate) {\n+            BOOST_CHECK_EQUAL(it1_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(it1_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+        }\n+        // Check tx3 bumpfee: assisted by tx4.\n+        const auto tx3_feerate = CFeeRate(\n+            tx_modified_fees.find(tx3->GetHash())->second + tx_modified_fees.find(tx4->GetHash())->second,\n+            tx_vsizes.find(tx3->GetHash())->second + tx_vsizes.find(tx4->GetHash())->second);\n+        auto it3_unspent = bump_fees.find(COutPoint{tx3->GetHash(), 1});\n+        BOOST_CHECK(it3_unspent != bump_fees.end());\n+        if (target_feerate <= tx3_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it3_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+            BOOST_CHECK_EQUAL(it3_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+        }\n+        // Check tx5 bumpfee: assisted by tx6. Specifically, tx6's modified fees.\n+        const auto tx5_feerate = CFeeRate(\n+            tx_modified_fees.find(tx5->GetHash())->second + tx_modified_fees.find(tx6->GetHash())->second,\n+            tx_vsizes.find(tx5->GetHash())->second + tx_vsizes.find(tx6->GetHash())->second);\n+        auto it5_unspent = bump_fees.find(COutPoint{tx5->GetHash(), 1});\n+        BOOST_CHECK(it5_unspent != bump_fees.end());\n+        if (target_feerate <= tx5_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it5_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+            BOOST_CHECK_EQUAL(it5_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx5->GetHash())->second) - tx_modified_fees.find(tx5->GetHash())->second);\n+        }\n+    }\n+    // Spent outpoints should usually not be requested as they would not be\n+    // considered available. However, when they are explicitly requested, we\n+    // can calculate their bumpfee to facilitate RBF-replacements\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner_all_spent(pool, all_spent_outpoints);\n+        BOOST_CHECK(mini_miner_all_spent.IsReadyToCalculate());\n+        auto bump_fees_all_spent = mini_miner_all_spent.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_spent.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_spent.size(), all_spent_outpoints.size());\n+        node::MiniMiner mini_miner_all_parents(pool, all_parent_outputs);\n+        BOOST_CHECK(mini_miner_all_parents.IsReadyToCalculate());\n+        auto bump_fees_all_parents = mini_miner_all_parents.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_parents.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_parents.size(), all_parent_outputs.size());\n+        for (auto& bump_fees : {bump_fees_all_parents, bump_fees_all_spent}) {\n+            // For all_parents case, both outputs from the parent should have the same bump fee,\n+            // even though only one of them is in a to-be-replaced transaction.\n+            BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+            // Check tx1 bumpfee: no other bumper.\n+            const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+            auto it1_spent = bump_fees.find(COutPoint{tx1->GetHash(), 0});\n+            BOOST_CHECK(it1_spent != bump_fees.end());\n+            if (target_feerate <= tx1_feerate) {\n+                BOOST_CHECK_EQUAL(it1_spent->second, 0);\n+            } else {\n+                // Difference is fee to bump tx1 from current to target feerate.\n+                BOOST_CHECK_EQUAL(it1_spent->second,\n+                    target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+            }\n+            // Check tx3 bumpfee: no other bumper, because tx4 is to-be-replaced.\n+            const auto tx3_feerate_unbumped = tx_feerates.find(tx3->GetHash())->second;\n+            auto it3_spent = bump_fees.find(COutPoint{tx3->GetHash(), 0});\n+            BOOST_CHECK(it3_spent != bump_fees.end());\n+            if (target_feerate <= tx3_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it3_spent->second, 0);\n+            } else {\n+                // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+                BOOST_CHECK_EQUAL(it3_spent->second,\n+                    target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+            }\n+            // Check tx5 bumpfee: no other bumper, because tx6 is to-be-replaced.\n+            const auto tx5_feerate_unbumped = tx_feerates.find(tx5->GetHash())->second;\n+            auto it5_spent = bump_fees.find(COutPoint{tx5->GetHash(), 0});\n+            BOOST_CHECK(it5_spent != bump_fees.end());\n+            if (target_feerate <= tx5_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it5_spent->second, 0);\n+            } else {\n+                // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+                BOOST_CHECK_EQUAL(it5_spent->second,\n+                    target_feerate.GetFee(tx_vsizes.find(tx5->GetHash())->second) - tx_modified_fees.find(tx5->GetHash())->second);\n+            }\n+        }\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_overlap, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount med_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create 3 parents of different feerates, and 1 child spending from all 3.\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx2));\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx1->GetHash(), 0}, COutPoint{tx2->GetHash(), 0}, COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create 1 grandparent and 1 parent, then 2 children.\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    const auto tx7 = make_tx({COutPoint{tx6->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx6->GetHash(), 1}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<int64_t> tx_vsizes;\n+    tx_vsizes.reserve(all_transactions.size());\n+    for (const auto& tx : all_transactions) tx_vsizes.push_back(GetVirtualTransactionSize(*tx));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx4->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 2},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 2},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    const auto tx3_feerate = CFeeRate(high_fee, tx_vsizes[2]);\n+    const auto tx4_feerate = CFeeRate(high_fee, tx_vsizes[3]);\n+    // tx4's feerate is lower than tx3's. same fee, different weight.\n+    BOOST_CHECK(tx3_feerate > tx4_feerate);\n+    const auto tx4_anc_feerate = CFeeRate(low_fee + med_fee + high_fee, tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[3]);\n+    const auto tx5_feerate = CFeeRate(high_fee, tx_vsizes[4]);\n+    const auto tx7_anc_feerate = CFeeRate(low_fee + med_fee, tx_vsizes[5] + tx_vsizes[6]);\n+    const auto tx8_anc_feerate = CFeeRate(low_fee + high_fee, tx_vsizes[5] + tx_vsizes[7]);\n+    BOOST_CHECK(tx5_feerate > tx7_anc_feerate);\n+    BOOST_CHECK(tx5_feerate > tx8_anc_feerate);\n+\n+    // Extremely high feerate: everybody's bumpfee is from their full ancestor set.\n+    {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        const CFeeRate very_high_feerate(COIN);\n+        BOOST_CHECK(tx4_anc_feerate < very_high_feerate);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(very_high_feerate);\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        const auto tx1_bumpfee = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(tx1_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx1_bumpfee->second, very_high_feerate.GetFee(tx_vsizes[0]) - low_fee);\n+        const auto tx4_bumpfee = bump_fees.find(COutPoint{tx4->GetHash(), 0});\n+        BOOST_CHECK(tx4_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx4_bumpfee->second,\n+            very_high_feerate.GetFee(tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[2] + tx_vsizes[3]) - (low_fee + med_fee + high_fee + high_fee));\n+        const auto tx7_bumpfee = bump_fees.find(COutPoint{tx7->GetHash(), 0});\n+        BOOST_CHECK(tx7_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx7_bumpfee->second,\n+            very_high_feerate.GetFee(tx_vsizes[4] + tx_vsizes[5] + tx_vsizes[6]) - (high_fee + low_fee + med_fee));\n+        const auto tx8_bumpfee = bump_fees.find(COutPoint{tx8->GetHash(), 0});\n+        BOOST_CHECK(tx8_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx8_bumpfee->second,\n+            very_high_feerate.GetFee(tx_vsizes[4] + tx_vsizes[5] + tx_vsizes[7]) - (high_fee + low_fee + high_fee));\n+        // Total fees: if spending multiple outputs from tx4 don't double-count fees.\n+        node::MiniMiner mini_miner_total_tx4(pool, {COutPoint{tx4->GetHash(), 0}, COutPoint{tx4->GetHash(), 1}});\n+        BOOST_CHECK(mini_miner_total_tx4.IsReadyToCalculate());\n+        const auto tx4_bump_fee = mini_miner_total_tx4.CalculateTotalBumpFees(very_high_feerate);\n+        BOOST_CHECK(!mini_miner_total_tx4.IsReadyToCalculate());\n+        BOOST_CHECK(tx4_bump_fee.has_value());\n+        BOOST_CHECK_EQUAL(tx4_bump_fee.value(),\n+            very_high_feerate.GetFee(tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[2] + tx_vsizes[3]) - (low_fee + med_fee + high_fee + high_fee));\n+        // Total fees: if spending both tx7 and tx8, don't double-count fees.\n+        node::MiniMiner mini_miner_tx7_tx8(pool, {COutPoint{tx7->GetHash(), 0}, COutPoint{tx8->GetHash(), 0}});\n+        BOOST_CHECK(mini_miner_tx7_tx8.IsReadyToCalculate());\n+        const auto tx7_tx8_bumpfee = mini_miner_tx7_tx8.CalculateTotalBumpFees(very_high_feerate);\n+        BOOST_CHECK(!mini_miner_tx7_tx8.IsReadyToCalculate());\n+        BOOST_CHECK(tx7_tx8_bumpfee.has_value());\n+        BOOST_CHECK_EQUAL(tx7_tx8_bumpfee.value(),\n+            very_high_feerate.GetFee(tx_vsizes[4] + tx_vsizes[5] + tx_vsizes[6] + tx_vsizes[7]) - (high_fee + low_fee + med_fee + high_fee));\n+    }\n+    // Feerate just below tx5: tx7 and tx8 have different bump fees.\n+    {\n+        const auto just_below_tx5 = CFeeRate(tx5_feerate.GetFeePerK() - 5);\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(just_below_tx5);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        const auto tx7_bumpfee = bump_fees.find(COutPoint{tx7->GetHash(), 0});\n+        BOOST_CHECK(tx7_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx7_bumpfee->second, just_below_tx5.GetFee(tx_vsizes[5] + tx_vsizes[6]) - (low_fee + med_fee));\n+        const auto tx8_bumpfee = bump_fees.find(COutPoint{tx8->GetHash(), 0});\n+        BOOST_CHECK(tx8_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx8_bumpfee->second, just_below_tx5.GetFee(tx_vsizes[5] + tx_vsizes[7]) - (low_fee + high_fee));\n+        // Total fees: if spending both tx7 and tx8, don't double-count fees.\n+        node::MiniMiner mini_miner_tx7_tx8(pool, {COutPoint{tx7->GetHash(), 0}, COutPoint{tx8->GetHash(), 0}});\n+        BOOST_CHECK(mini_miner_tx7_tx8.IsReadyToCalculate());\n+        const auto tx7_tx8_bumpfee = mini_miner_tx7_tx8.CalculateTotalBumpFees(just_below_tx5);\n+        BOOST_CHECK(!mini_miner_tx7_tx8.IsReadyToCalculate());\n+        BOOST_CHECK(tx7_tx8_bumpfee.has_value());\n+        BOOST_CHECK_EQUAL(tx7_tx8_bumpfee.value(), just_below_tx5.GetFee(tx_vsizes[5] + tx_vsizes[6]) - (low_fee + med_fee));\n+    }\n+    // Feerate between tx7 and tx8's ancestor feerates: don't need to bump tx6 because tx8 already does.\n+    {\n+        const auto just_above_tx7 = CFeeRate(med_fee + 10, tx_vsizes[6]);\n+        BOOST_CHECK(just_above_tx7 <= CFeeRate(low_fee + high_fee, tx_vsizes[5] + tx_vsizes[7]));\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(just_above_tx7);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        const auto tx7_bumpfee = bump_fees.find(COutPoint{tx7->GetHash(), 0});\n+        BOOST_CHECK(tx7_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx7_bumpfee->second, just_above_tx7.GetFee(tx_vsizes[6]) - (med_fee));\n+        const auto tx8_bumpfee = bump_fees.find(COutPoint{tx8->GetHash(), 0});\n+        BOOST_CHECK(tx8_bumpfee != bump_fees.end());\n+        BOOST_CHECK_EQUAL(tx8_bumpfee->second, 0);\n+    }\n+}\n+BOOST_FIXTURE_TEST_CASE(calculate_cluster, TestChain100Setup)\n+{\n+    FastRandomContext det_rand{true};\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+\n+    // Add chain of size 500\n+    TestMemPoolEntryHelper entry;\n+    std::vector<uint256> chain_txids;\n+    auto& lasttx = m_coinbase_txns[0];\n+    for (auto i{0}; i < 500; ++i) {\n+        const auto tx = make_tx({COutPoint{lasttx->GetHash(), 0}}, /*num_outputs=*/1);\n+        pool.addUnchecked(entry.Fee(CENT).FromTx(tx));\n+        chain_txids.push_back(tx->GetHash());\n+        lasttx = tx;\n+    }\n+    const auto cluster_500tx = pool.GatherClusters({lasttx->GetHash()});\n+    CTxMemPool::setEntries cluster_500tx_set{cluster_500tx.begin(), cluster_500tx.end()};\n+    BOOST_CHECK_EQUAL(cluster_500tx.size(), cluster_500tx_set.size());\n+    const auto vec_iters_500 = pool.GetIterVec(chain_txids);\n+    for (const auto& iter : vec_iters_500) BOOST_CHECK(cluster_500tx_set.count(iter));\n+\n+    // GatherClusters stops at 500 transactions.\n+    const auto tx_501 = make_tx({COutPoint{lasttx->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(CENT).FromTx(tx_501));\n+    const auto cluster_501 = pool.GatherClusters({tx_501->GetHash()});\n+    BOOST_CHECK_EQUAL(cluster_501.size(), 0);\n+\n+    // Zig Zag cluster:\n+    // txp0     txp1     txp2    ...  txp48  txp49\n+    //    \\    /    \\   /   \\            \\   /\n+    //     txc0     txc1    txc2  ...    txc48\n+    // Note that each transaction's ancestor size is 2 or 3, and each descendant size is 2 or 3.",
      "path": "src/test/miniminer_tests.cpp",
      "position": null,
      "original_position": 442,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "in_reply_to_id": 1148418808,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks, you are most correct!",
      "created_at": "2023-03-27T19:55:30Z",
      "updated_at": "2023-03-27T21:37:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149728848",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149728848"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 442,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149730720",
      "pull_request_review_id": 1359286170,
      "id": 1149730720,
      "node_id": "PRRC_kwDOABII585Eh3-g",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<CTxMemPool::txiter> all_entries;\n+    std::map<uint256, int64_t> tx_vsizes;\n+    std::map<uint256, CAmount> tx_modified_fees;\n+    std::map<uint256, CFeeRate> tx_feerates;\n+    for (const auto& tx : all_transactions) {\n+        const auto entry = pool.GetIter(tx->GetHash()).value();\n+        all_entries.push_back(entry);\n+        tx_vsizes.emplace(tx->GetHash(), entry->GetTxSize());\n+        tx_modified_fees.emplace(tx->GetHash(), entry->GetModifiedFee());\n+        tx_feerates.emplace(tx->GetHash(), CFeeRate(entry->GetModifiedFee(), entry->GetTxSize()));\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        // Check tx1 bumpfee: no other bumper.\n+        const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+        auto it1_unspent = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(it1_unspent != bump_fees.end());\n+        if (target_feerate <= tx1_feerate) {\n+            BOOST_CHECK_EQUAL(it1_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(it1_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+        }\n+        // Check tx3 bumpfee: assisted by tx4.\n+        const auto tx3_feerate = CFeeRate(\n+            tx_modified_fees.find(tx3->GetHash())->second + tx_modified_fees.find(tx4->GetHash())->second,\n+            tx_vsizes.find(tx3->GetHash())->second + tx_vsizes.find(tx4->GetHash())->second);\n+        auto it3_unspent = bump_fees.find(COutPoint{tx3->GetHash(), 1});\n+        BOOST_CHECK(it3_unspent != bump_fees.end());\n+        if (target_feerate <= tx3_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it3_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+            BOOST_CHECK_EQUAL(it3_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+        }\n+        // Check tx5 bumpfee: assisted by tx6. Specifically, tx6's modified fees.\n+        const auto tx5_feerate = CFeeRate(\n+            tx_modified_fees.find(tx5->GetHash())->second + tx_modified_fees.find(tx6->GetHash())->second,\n+            tx_vsizes.find(tx5->GetHash())->second + tx_vsizes.find(tx6->GetHash())->second);\n+        auto it5_unspent = bump_fees.find(COutPoint{tx5->GetHash(), 1});\n+        BOOST_CHECK(it5_unspent != bump_fees.end());\n+        if (target_feerate <= tx5_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it5_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+            BOOST_CHECK_EQUAL(it5_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx5->GetHash())->second) - tx_modified_fees.find(tx5->GetHash())->second);",
      "path": "src/test/miniminer_tests.cpp",
      "position": null,
      "original_position": 209,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "in_reply_to_id": 1147030012,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks for catching that. I amended the above fee and tested that this else-branch now is executed.",
      "created_at": "2023-03-27T19:57:40Z",
      "updated_at": "2023-03-27T21:37:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149730720",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149730720"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 207,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 217,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149731460",
      "pull_request_review_id": 1359286170,
      "id": 1149731460,
      "node_id": "PRRC_kwDOABII585Eh4KE",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);",
      "path": "src/test/miniminer_tests.cpp",
      "position": null,
      "original_position": 89,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "in_reply_to_id": 1147032833,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks, I’ve reduced the fee used here and verified that the else branch mentioned below now gets traversed",
      "created_at": "2023-03-27T19:58:31Z",
      "updated_at": "2023-03-27T21:37:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149731460",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149731460"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 87,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 89,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149731957",
      "pull_request_review_id": 1359286170,
      "id": 1149731957,
      "node_id": "PRRC_kwDOABII585Eh4R1",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<CTxMemPool::txiter> all_entries;\n+    std::map<uint256, int64_t> tx_vsizes;\n+    std::map<uint256, CAmount> tx_modified_fees;\n+    std::map<uint256, CFeeRate> tx_feerates;\n+    for (const auto& tx : all_transactions) {\n+        const auto entry = pool.GetIter(tx->GetHash()).value();\n+        all_entries.push_back(entry);",
      "path": "src/test/miniminer_tests.cpp",
      "position": null,
      "original_position": 136,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "in_reply_to_id": 1146945075,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I’ve removed `all_entries`. Thanks for catching that",
      "created_at": "2023-03-27T19:59:07Z",
      "updated_at": "2023-03-27T21:37:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149731957",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149731957"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 130,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 136,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149782804",
      "pull_request_review_id": 1359286170,
      "id": 1149782804,
      "node_id": "PRRC_kwDOABII585EiEsU",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), COIN);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<CTxMemPool::txiter> all_entries;\n+    std::map<uint256, int64_t> tx_vsizes;\n+    std::map<uint256, CAmount> tx_modified_fees;\n+    std::map<uint256, CFeeRate> tx_feerates;\n+    for (const auto& tx : all_transactions) {\n+        const auto entry = pool.GetIter(tx->GetHash()).value();\n+        all_entries.push_back(entry);\n+        tx_vsizes.emplace(tx->GetHash(), entry->GetTxSize());\n+        tx_modified_fees.emplace(tx->GetHash(), entry->GetModifiedFee());\n+        tx_feerates.emplace(tx->GetHash(), CFeeRate(entry->GetModifiedFee(), entry->GetTxSize()));\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+        // Check tx1 bumpfee: no other bumper.\n+        const auto tx1_feerate = tx_feerates.find(tx1->GetHash())->second;\n+        auto it1_unspent = bump_fees.find(COutPoint{tx1->GetHash(), 1});\n+        BOOST_CHECK(it1_unspent != bump_fees.end());\n+        if (target_feerate <= tx1_feerate) {\n+            BOOST_CHECK_EQUAL(it1_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(it1_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx1->GetHash())->second) - tx_modified_fees.find(tx1->GetHash())->second);\n+        }\n+        // Check tx3 bumpfee: assisted by tx4.\n+        const auto tx3_feerate = CFeeRate(\n+            tx_modified_fees.find(tx3->GetHash())->second + tx_modified_fees.find(tx4->GetHash())->second,\n+            tx_vsizes.find(tx3->GetHash())->second + tx_vsizes.find(tx4->GetHash())->second);\n+        auto it3_unspent = bump_fees.find(COutPoint{tx3->GetHash(), 1});\n+        BOOST_CHECK(it3_unspent != bump_fees.end());\n+        if (target_feerate <= tx3_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(it3_unspent->second, 0);\n+        } else {\n+            // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+            BOOST_CHECK_EQUAL(it3_unspent->second,\n+                target_feerate.GetFee(tx_vsizes.find(tx3->GetHash())->second) - tx_modified_fees.find(tx3->GetHash())->second);\n+        }\n+        // Check tx5 bumpfee: assisted by tx6. Specifically, tx6's modified fees.\n+        const auto tx5_feerate = CFeeRate(\n+            tx_modified_fees.find(tx5->GetHash())->second + tx_modified_fees.find(tx6->GetHash())->second,\n+            tx_vsizes.find(tx5->GetHash())->second + tx_vsizes.find(tx6->GetHash())->second);\n+        auto it5_unspent = bump_fees.find(COutPoint{tx5->GetHash(), 1});\n+        BOOST_CHECK(it5_unspent != bump_fees.end());\n+        if (target_feerate <= tx5_feerate) {",
      "path": "src/test/miniminer_tests.cpp",
      "position": null,
      "original_position": 203,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "in_reply_to_id": 1146944495,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I’ve renamed the variable and better explained what’s going on here.",
      "created_at": "2023-03-27T20:56:44Z",
      "updated_at": "2023-03-27T21:37:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149782804",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149782804"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 197,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 216,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149783183",
      "pull_request_review_id": 1359286170,
      "id": 1149783183,
      "node_id": "PRRC_kwDOABII585EiEyP",
      "diff_hunk": "@@ -0,0 +1,467 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;",
      "path": "src/test/miniminer_tests.cpp",
      "position": null,
      "original_position": 28,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "5bcc04c5c01f599cf2bd888cd2590795dd58ffdb",
      "in_reply_to_id": 1147037874,
      "user": {
        "login": "Xekyo",
        "id": 4060799,
        "node_id": "MDQ6VXNlcjQwNjA3OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4060799?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Xekyo",
        "html_url": "https://github.com/Xekyo",
        "followers_url": "https://api.github.com/users/Xekyo/followers",
        "following_url": "https://api.github.com/users/Xekyo/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Xekyo/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Xekyo/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Xekyo/subscriptions",
        "organizations_url": "https://api.github.com/users/Xekyo/orgs",
        "repos_url": "https://api.github.com/users/Xekyo/repos",
        "events_url": "https://api.github.com/users/Xekyo/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Xekyo/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Thanks, I’ve removed the unnecessary definitions here",
      "created_at": "2023-03-27T20:57:08Z",
      "updated_at": "2023-03-27T21:37:59Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1149783183",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1149783183"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": 25,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 28,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151002690",
      "pull_request_review_id": 1361682595,
      "id": 1151002690,
      "node_id": "PRRC_kwDOABII585EmuhC",
      "diff_hunk": "@@ -1140,3 +1153,30 @@ std::string RemovalReasonToString(const MemPoolRemovalReason& r) noexcept\n     }\n     assert(false);\n }\n+\n+std::vector<CTxMemPool::txiter> CTxMemPool::GatherClusters(const std::vector<uint256>& txids) const\n+{\n+    AssertLockHeld(cs);\n+    std::vector<txiter> clustered_txs{GetIterVec(txids)};\n+    // Use epoch: visiting an entry means we have added it to the clustered_txs vector. It does not\n+    // necessarily mean the entry has been processed.\n+    WITH_FRESH_EPOCH(m_epoch);\n+    for (const auto& it : clustered_txs) {\n+        visited(it);\n+    }",
      "path": "src/txmempool.cpp",
      "position": 50,
      "original_position": 50,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "fa8432aeeca39641da6e9bbb9fbf1c52ec5efa72",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Just a note to other reviews who also think this looks weird: `it` is a `const` reference being passed to `visited()` so you'd think `it` (or what it points to) can't be modified, so seems like `visited()` must have no effect. Yet we're ignoring its return value. The answer is that `visited()` does modify `it->m_epoch_marker` but that member is `mutable`. To me, it seems like this shouldn't be marked mutable because it does change the state of `*it` in a way that affects behavior, not just caching or locking (the usual use cases for `mutable`). Anyway, nothing wrong with the PR, just wanted to mention it in case others were confused as well.",
      "created_at": "2023-03-28T18:21:39Z",
      "updated_at": "2023-03-29T05:17:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1151002690",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151002690"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": 1164,
      "original_start_line": 1164,
      "start_side": "RIGHT",
      "line": 1166,
      "original_line": 1166,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151062167",
      "pull_request_review_id": 1361682595,
      "id": 1151062167,
      "node_id": "PRRC_kwDOABII585Em9CX",
      "diff_hunk": "@@ -0,0 +1,121 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_MINI_MINER_H\n+#define BITCOIN_NODE_MINI_MINER_H\n+\n+#include <txmempool.h>\n+\n+#include <memory>\n+#include <optional>\n+#include <stdint.h>\n+\n+namespace node {\n+\n+// Container for tracking updates to ancestor feerate as we include ancestors in the \"block\"\n+class MiniMinerMempoolEntry\n+{\n+    const CAmount fee_individual;\n+    const CTransactionRef tx;\n+    const int64_t vsize_individual;\n+\n+// This class must be constructed while holding mempool.cs. After construction, the object's\n+// methods can be called without holding that lock.\n+public:\n+    CAmount fee_with_ancestors;\n+    int64_t vsize_with_ancestors;\n+    explicit MiniMinerMempoolEntry(CTxMemPool::txiter entry) :\n+        fee_individual{entry->GetModifiedFee()},\n+        tx{entry->GetSharedTx()},\n+        vsize_individual(entry->GetTxSize()),\n+        fee_with_ancestors{entry->GetModFeesWithAncestors()},\n+        vsize_with_ancestors(entry->GetSizeWithAncestors())\n+    { }\n+\n+    CAmount GetModifiedFee() const { return fee_individual; }\n+    CAmount GetModFeesWithAncestors() const { return fee_with_ancestors; }\n+    int64_t GetTxSize() const { return vsize_individual; }\n+    int64_t GetSizeWithAncestors() const { return vsize_with_ancestors; }\n+    const CTransaction& GetTx() const LIFETIMEBOUND { return *tx; }\n+};\n+\n+// Comparator needed for std::set<MockEntryMap::iterator>\n+struct IteratorComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const\n+    {\n+        return &(*a) < &(*b);\n+    }\n+};\n+\n+/** A minimal version of BlockAssembler. Allows us to run the mining algorithm on a subset of\n+ * mempool transactions, ignoring consensus rules, to calculate mining scores. */\n+class MiniMiner\n+{\n+    // When true, a caller may use CalculateBumpFees(). Becomes false if we failed to retrieve\n+    // mempool entries (i.e. cluster size too large) or bump fees have already been calculated.\n+    bool m_ready_to_calculate{true};",
      "path": "src/node/mini_miner.h",
      "position": 59,
      "original_position": 59,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "fa8432aeeca39641da6e9bbb9fbf1c52ec5efa72",
      "in_reply_to_id": null,
      "user": {
        "login": "LarryRuane",
        "id": 8321330,
        "node_id": "MDQ6VXNlcjgzMjEzMzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8321330?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/LarryRuane",
        "html_url": "https://github.com/LarryRuane",
        "followers_url": "https://api.github.com/users/LarryRuane/followers",
        "following_url": "https://api.github.com/users/LarryRuane/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/LarryRuane/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/LarryRuane/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/LarryRuane/subscriptions",
        "organizations_url": "https://api.github.com/users/LarryRuane/orgs",
        "repos_url": "https://api.github.com/users/LarryRuane/repos",
        "events_url": "https://api.github.com/users/LarryRuane/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/LarryRuane/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This comment is for a possible follow-up PR, not suggesting any change here, just wanted to document this thought.\r\n\r\nAs an alternative to this flag, it might be more natural to use \"chained methods\" so you could write something like:\r\n```\r\nstd::map<COutPoint, CAmount> node::MiniMiner(pool, outpoints)\r\n        .BuildMockTemplate(target_feerate)\r\n        .CalculateBumpFees();\r\n```\r\n(This technique is used [here](https://github.com/bitcoin/bitcoin/blob/fdd363ebd917e5916742587608d59023ced513e1/src/blockfilter.cpp#L29) for example, and is common in more modern languages like Rust).\r\n\r\n`BuildMockTemplate()` would `return *this` instead of `void`.\r\n\r\nOf course, `CalculateBumpFees()` and `CalculateTotalBumpFees()` would not call `BuildMockTemplate()` as they currently do. We'd also need `BuildMockTemplate()` to save the feerate in the object for either of the calculate functions to us; we don't want the caller to have to specify the same value twice. The feerate should probably be accessible using a getter.\r\n\r\nA nice property of this approach is that for testing, the results of each \"stage\" could be instantiated into variables, and inspection methods or `SanityCheck()` could be called on them.\r\n\r\nIt should then be possible to make the two calculate methods `const`, which is intuitive -- calculating from an object shouldn't need to mutate it.\r\n\r\nOne other more subtle thing we'd want to do is handle the case where `BuildMockTemplate()` is called more than once -- it would be nice to allow that even if initially only for testing. That is, the caller might do something like:\r\n```\r\nnode::MiniMiner miner(pool, outpoints);\r\nminer.BuildMockTemplate(feerate1);\r\nminer.BuildMockTemplate(feerate2);\r\nresults = miner.CalculateBumpFees();\r\n```\r\nThe effect you'd expect is for the bump fees to be based on `feerate2`. But the first call to `BuildMockTemplate()` would modify the object in such a way that, if nothing special is done, would mess up the second call to `BuildMockTemplate()`.\r\n\r\nI think the best way to deal with this is that when `BuildMockTemplate()` begins, it checks if there's already a feerate set in the object (maybe `m_feerate` is type `std::optional<CFeeRate>`). If so, it resets of the object's state to as it was after the constructor ran. (It shouldn't need to actually re-run the constructor code; that may be a possible design but seems less elegant.)\r\n\r\nOne last thing, what would this do? (Note, `BuildMockTemplate()` isn't called)\r\n```\r\nresults = node::MiniMiner(pool, outpoints).CalculateBumpFees();\r\n```\r\nI think what would be natural here is that all the bump fees would be zero, as if the target feerate is zero. In other words, the \"default\" target feerate is zero; `BuildMockTemplate()` simply modifies the feerate from zero.\r\n\r\nZero bump fees is also what can happen if we hit the cluster-too-large limit. We wouldn't bump any fees, but that's no worse than today. (I think this is what happens with the PR?)",
      "created_at": "2023-03-28T19:22:50Z",
      "updated_at": "2023-03-29T05:17:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1151062167",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151062167"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 59,
      "original_line": 59,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1153139259",
      "pull_request_review_id": 1364933315,
      "id": 1153139259,
      "node_id": "PRRC_kwDOABII585Eu4I7",
      "diff_hunk": "@@ -0,0 +1,365 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+            continue;\n+        }\n+\n+        // UXTO is created by transaction in mempool, add to map.\n+        // Note: This will either create a missing entry or add the outpoint to an existing entry\n+        m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool. We\n+            // assume that the caller wants to replace this transaction and its descendants. It\n+            // would be unusual for the transaction to have descendants as the wallet won’t normally\n+            // attempt to replace transactions with descendants. If the outpoint is from a mempool\n+            // transaction, we still need to calculate its ancestors bump fees (added to\n+            // m_requested_outpoints_by_txid below), but after removing the to-be-replaced entries.\n+            //\n+            // Note that the descendants of a transaction include the transaction itself. Also note,\n+            // that this is only calculating bump fees. RBF fee rules should be handled separately.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;",
      "path": "src/node/mini_miner.cpp",
      "position": 61,
      "original_position": 61,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "fa8432aeeca39641da6e9bbb9fbf1c52ec5efa72",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://cirrus-ci.com/task/4526522288046080:\r\n```\r\n/tmp/cirrus-ci-build/ci/scratch/build/bitcoin-x86_64-pc-linux-gnu/src/node/mini_miner.cpp:63:9: error: 'push_back' is called inside a loop; consider pre-allocating the container capacity before the loop [performance-inefficient-vector-operation,-warnings-as-errors]\r\n        txids_needed.push_back(txid);\r\n```\r\nseems like the tidy job wants you to add this:\r\n```suggestion\r\n    std::vector<uint256> txids_needed;\r\n    txids_needed.reserve(m_requested_outpoints_by_txid.size());\r\n```",
      "created_at": "2023-03-30T11:46:26Z",
      "updated_at": "2023-03-30T11:47:11Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1153139259",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1153139259"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 61,
      "original_line": 61,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1188846506",
      "pull_request_review_id": 1419015473,
      "id": 1188846506,
      "node_id": "PRRC_kwDOABII585G3Fuq",
      "diff_hunk": "@@ -0,0 +1,366 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>",
      "path": "src/node/mini_miner.cpp",
      "position": 12,
      "original_position": 12,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "59afcc83548ea67a863dac7b75d000bc8f6a7023",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: unused includes\r\n```suggestion\r\n#include <util/check.h>\r\n```",
      "created_at": "2023-05-09T16:20:43Z",
      "updated_at": "2023-05-09T17:41:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1188846506",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1188846506"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": 10,
      "original_start_line": 10,
      "start_side": "RIGHT",
      "line": 12,
      "original_line": 12,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1188865405",
      "pull_request_review_id": 1419015473,
      "id": 1188865405,
      "node_id": "PRRC_kwDOABII585G3KV9",
      "diff_hunk": "@@ -0,0 +1,366 @@\n+// Copyright (c) 2023 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/mini_miner.h>\n+\n+#include <consensus/amount.h>\n+#include <policy/feerate.h>\n+#include <primitives/transaction.h>\n+#include <timedata.h>\n+#include <util/check.h>\n+#include <util/moneystr.h>\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <utility>\n+\n+namespace node {\n+\n+MiniMiner::MiniMiner(const CTxMemPool& mempool, const std::vector<COutPoint>& outpoints)\n+{\n+    LOCK(mempool.cs);\n+    // Find which outpoints to calculate bump fees for.\n+    // Anything that's spent by the mempool is to-be-replaced\n+    // Anything otherwise unavailable just has a bump fee of 0\n+    for (const auto& outpoint : outpoints) {\n+        if (!mempool.exists(GenTxid::Txid(outpoint.hash))) {\n+            // This UTXO is either confirmed or not yet submitted to mempool.\n+            // If it's confirmed, no bump fee is required.\n+            // If it's not yet submitted, we have no information, so return 0.\n+            m_bump_fees.emplace(outpoint, 0);\n+            continue;\n+        }\n+\n+        // UXTO is created by transaction in mempool, add to map.\n+        // Note: This will either create a missing entry or add the outpoint to an existing entry\n+        m_requested_outpoints_by_txid[outpoint.hash].push_back(outpoint);\n+\n+        if (const auto ptx{mempool.GetConflictTx(outpoint)}) {\n+            // This outpoint is already being spent by another transaction in the mempool. We\n+            // assume that the caller wants to replace this transaction and its descendants. It\n+            // would be unusual for the transaction to have descendants as the wallet won’t normally\n+            // attempt to replace transactions with descendants. If the outpoint is from a mempool\n+            // transaction, we still need to calculate its ancestors bump fees (added to\n+            // m_requested_outpoints_by_txid below), but after removing the to-be-replaced entries.\n+            //\n+            // Note that the descendants of a transaction include the transaction itself. Also note,\n+            // that this is only calculating bump fees. RBF fee rules should be handled separately.\n+            CTxMemPool::setEntries descendants;\n+            mempool.CalculateDescendants(mempool.GetIter(ptx->GetHash()).value(), descendants);\n+            for (const auto& desc_txiter : descendants) {\n+                m_to_be_replaced.insert(desc_txiter->GetTx().GetHash());\n+            }\n+        }\n+    }\n+\n+    // No unconfirmed UTXOs, so nothing mempool-related needs to be calculated.\n+    if (m_requested_outpoints_by_txid.empty()) return;\n+\n+    // Calculate the cluster and construct the entry map.\n+    std::vector<uint256> txids_needed;\n+    txids_needed.reserve(m_requested_outpoints_by_txid.size());\n+    for (const auto& [txid, _]: m_requested_outpoints_by_txid) {\n+        txids_needed.push_back(txid);\n+    }\n+    const auto cluster = mempool.GatherClusters(txids_needed);\n+    if (cluster.empty()) {\n+        // An empty cluster means that at least one of the transactions is missing from the mempool\n+        // (should not be possible given processing above) or DoS limit was hit.\n+        m_ready_to_calculate = false;\n+        return;\n+    }\n+\n+    // Add every entry to m_entries_by_txid and m_entries, except the ones that will be replaced.\n+    for (const auto& txiter : cluster) {\n+        if (!m_to_be_replaced.count(txiter->GetTx().GetHash())) {\n+            auto [mapiter, success] = m_entries_by_txid.emplace(txiter->GetTx().GetHash(), MiniMinerMempoolEntry(txiter));\n+            m_entries.push_back(mapiter);\n+        } else {\n+            auto outpoints_it = m_requested_outpoints_by_txid.find(txiter->GetTx().GetHash());\n+            if (outpoints_it != m_requested_outpoints_by_txid.end()) {\n+                // This UTXO is the output of a to-be-replaced transaction. Bump fee is 0; spending\n+                // this UTXO is impossible as it will no longer exist after the replacement.\n+                for (const auto& outpoint : outpoints_it->second) {\n+                    m_bump_fees.emplace(outpoint, 0);\n+                }\n+                m_requested_outpoints_by_txid.erase(outpoints_it);\n+            }\n+        }\n+    }\n+\n+    // Build the m_descendant_set_by_txid cache.\n+    for (const auto& txiter : cluster) {\n+        const auto& txid = txiter->GetTx().GetHash();\n+        // Cache descendants for future use. Unlike the real mempool, a descendant MiniMinerMempoolEntry\n+        // will not exist without its ancestor MiniMinerMempoolEntry, so these sets won't be invalidated.\n+        std::vector<MockEntryMap::iterator> cached_descendants;\n+        const bool remove{m_to_be_replaced.count(txid) > 0};\n+        CTxMemPool::setEntries descendants;\n+        mempool.CalculateDescendants(txiter, descendants);\n+        Assume(descendants.count(txiter) > 0);\n+        for (const auto& desc_txiter : descendants) {\n+            const auto txid_desc = desc_txiter->GetTx().GetHash();\n+            const bool remove_desc{m_to_be_replaced.count(txid_desc) > 0};\n+            auto desc_it{m_entries_by_txid.find(txid_desc)};\n+            Assume((desc_it == m_entries_by_txid.end()) == remove_desc);\n+            if (remove) Assume(remove_desc);\n+            // It's possible that remove=false but remove_desc=true.\n+            if (!remove && !remove_desc) {\n+                cached_descendants.push_back(desc_it);\n+            }\n+        }\n+        if (remove) {\n+            Assume(cached_descendants.empty());\n+        } else {\n+            m_descendant_set_by_txid.emplace(txid, cached_descendants);\n+        }\n+    }\n+\n+    // Release the mempool lock; we now have all the information we need for a subset of the entries\n+    // we care about. We will solely operate on the MiniMinerMempoolEntry map from now on.\n+    Assume(m_in_block.empty());\n+    Assume(m_requested_outpoints_by_txid.size() <= outpoints.size());\n+    SanityCheck();\n+}\n+\n+// Compare by min(ancestor feerate, individual feerate), then iterator\n+//\n+// Under the ancestor-based mining approach, high-feerate children can pay for parents, but high-feerate\n+// parents do not incentive inclusion of their children. Therefore the mining algorithm only considers\n+// transactions for inclusion on basis of the minimum of their own feerate or their ancestor feerate.\n+struct AncestorFeerateComparator\n+{\n+    template<typename I>\n+    bool operator()(const I& a, const I& b) const {\n+        auto min_feerate = [](const MiniMinerMempoolEntry& e) -> CFeeRate {\n+            const CAmount ancestor_fee{e.GetModFeesWithAncestors()};\n+            const int64_t ancestor_size{e.GetSizeWithAncestors()};\n+            const CAmount tx_fee{e.GetModifiedFee()};\n+            const int64_t tx_size{e.GetTxSize()};\n+            // Comparing ancestor feerate with individual feerate:\n+            //     ancestor_fee / ancestor_size <= tx_fee / tx_size\n+            // Avoid division and possible loss of precision by\n+            // multiplying both sides by the sizes:\n+            return ancestor_fee * tx_size < tx_fee * ancestor_size ?\n+                       CFeeRate(ancestor_fee, ancestor_size) :\n+                       CFeeRate(tx_fee, tx_size);\n+        };\n+        CFeeRate a_feerate{min_feerate(a->second)};\n+        CFeeRate b_feerate{min_feerate(b->second)};\n+        if (a_feerate != b_feerate) {\n+            return a_feerate > b_feerate;\n+        }\n+        // Use txid as tiebreaker for stable sorting\n+        return a->first < b->first;\n+    }\n+};\n+\n+void MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator>& ancestors)\n+{\n+    Assume(ancestors.size() >= 1);\n+    // \"Mine\" all transactions in this ancestor set.\n+    for (auto& anc : ancestors) {\n+        Assume(m_in_block.count(anc->first) == 0);\n+        m_in_block.insert(anc->first);\n+        m_total_fees += anc->second.GetModifiedFee();\n+        m_total_vsize += anc->second.GetTxSize();\n+        auto it = m_descendant_set_by_txid.find(anc->first);\n+        // Each entry’s descendant set includes itself\n+        Assume(it != m_descendant_set_by_txid.end());\n+        for (auto& descendant : it->second) {\n+            // If these fail, we must be double-deducting.\n+            Assume(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n+            Assume(descendant->second.vsize_with_ancestors >= anc->second.GetTxSize());",
      "path": "src/node/mini_miner.cpp",
      "position": 174,
      "original_position": 174,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "59afcc83548ea67a863dac7b75d000bc8f6a7023",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: seems odd to sometimes access `MiniMinerMempoolEntry` entrie's ancestor-set information via method (`.GetModFeesWithAncestors(...)`), and sometimes directly by member variable (`.vsize_with_ancestors`). Would suggest to be consistent here and either move the `{fee,vsize}_with_ancestors` fields to the `private:` section (i.e. the getter methods have to be always used) or remove the methods completely and hence always use field access.",
      "created_at": "2023-05-09T16:37:45Z",
      "updated_at": "2023-05-09T17:41:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1188865405",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1188865405"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": 173,
      "original_start_line": 173,
      "start_side": "RIGHT",
      "line": 174,
      "original_line": 174,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1188884884",
      "pull_request_review_id": 1419015473,
      "id": 1188884884,
      "node_id": "PRRC_kwDOABII585G3PGU",
      "diff_hunk": "@@ -0,0 +1,477 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+        if (fee == 0) continue;\n+        auto outpoint_ = outpoint; // structured bindings can't be captured in C++17, so we need to use a variable\n+        const bool found = std::any_of(transactions.cbegin(), transactions.cend(), [&](const auto& tx) {\n+            return outpoint_.hash == tx->GetHash() && outpoint_.n < tx->vout.size();\n+        });\n+        if (!found) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+template <typename Key, typename Value>\n+Value Find(const std::map<Key, Value>& map, const Key& key)\n+{\n+    auto it = map.find(key);\n+    BOOST_CHECK_MESSAGE(it != map.end(), strprintf(\"Cannot find %s\", key.ToString()));\n+    return it->second;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), CENT/100);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    struct TxDimensions {\n+        size_t vsize; CAmount mod_fee; CFeeRate feerate;\n+    };\n+    std::map<uint256, TxDimensions> tx_dims;\n+    for (const auto& tx : all_transactions) {\n+        const auto it = pool.GetIter(tx->GetHash()).value();\n+        tx_dims.emplace(tx->GetHash(), TxDimensions{it->GetTxSize(), it->GetModifiedFee(),\n+                                              CFeeRate(it->GetModifiedFee(), it->GetTxSize())});\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(5*CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+\n+        // Check tx1 bumpfee: no other bumper.\n+        const TxDimensions& tx1_dimensions = tx_dims.find(tx1->GetHash())->second;\n+        CAmount bumpfee1 = Find(bump_fees, COutPoint{tx1->GetHash(), 1});\n+        if (target_feerate <= tx1_dimensions.feerate) {\n+            BOOST_CHECK_EQUAL(bumpfee1, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(bumpfee1, target_feerate.GetFee(tx1_dimensions.vsize) - tx1_dimensions.mod_fee);\n+        }\n+\n+        // Check tx3 bumpfee: assisted by tx4.\n+        const TxDimensions& tx3_dimensions = tx_dims.find(tx3->GetHash())->second;\n+        const TxDimensions& tx4_dimensions = tx_dims.find(tx4->GetHash())->second;\n+        const CFeeRate tx3_feerate = CFeeRate(tx3_dimensions.mod_fee + tx4_dimensions.mod_fee, tx3_dimensions.vsize + tx4_dimensions.vsize);\n+        CAmount bumpfee3 = Find(bump_fees, COutPoint{tx3->GetHash(), 1});\n+        if (target_feerate <= tx3_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(bumpfee3, 0);\n+        } else {\n+            // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+            BOOST_CHECK_EQUAL(bumpfee3, target_feerate.GetFee(tx3_dimensions.vsize) - tx3_dimensions.mod_fee);\n+        }\n+\n+        // If tx6’s modified fees are sufficient for tx5 and tx6 to be picked\n+        // into the block, our prospective new transaction would not need to\n+        // bump tx5 when using tx5’s second output. If however even tx6’s\n+        // modified fee (which essentially indicates \"effective feerate\") is\n+        // not sufficient to bump tx5, using the second output of tx5 would\n+        // require our transaction to bump tx5 from scratch since we evaluate\n+        // transaction packages per ancestor sets and do not consider multiple\n+        // children’s fees.\n+        const TxDimensions& tx5_dimensions = tx_dims.find(tx5->GetHash())->second;\n+        const TxDimensions& tx6_dimensions = tx_dims.find(tx6->GetHash())->second;\n+        const CFeeRate tx5_feerate = CFeeRate(tx5_dimensions.mod_fee + tx6_dimensions.mod_fee, tx5_dimensions.vsize + tx6_dimensions.vsize);\n+        CAmount bumpfee5 = Find(bump_fees, COutPoint{tx5->GetHash(), 1});\n+        if (target_feerate <= tx5_feerate) {\n+            // As long as target feerate is below tx6's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(bumpfee5, 0);\n+        } else {\n+            // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+            BOOST_CHECK_EQUAL(bumpfee5, target_feerate.GetFee(tx5_dimensions.vsize) - tx5_dimensions.mod_fee);\n+        }\n+    }\n+    // Spent outpoints should usually not be requested as they would not be\n+    // considered available. However, when they are explicitly requested, we\n+    // can calculate their bumpfee to facilitate RBF-replacements\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner_all_spent(pool, all_spent_outpoints);\n+        BOOST_CHECK(mini_miner_all_spent.IsReadyToCalculate());\n+        auto bump_fees_all_spent = mini_miner_all_spent.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_spent.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_spent.size(), all_spent_outpoints.size());\n+        node::MiniMiner mini_miner_all_parents(pool, all_parent_outputs);\n+        BOOST_CHECK(mini_miner_all_parents.IsReadyToCalculate());\n+        auto bump_fees_all_parents = mini_miner_all_parents.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_parents.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_parents.size(), all_parent_outputs.size());\n+        for (auto& bump_fees : {bump_fees_all_parents, bump_fees_all_spent}) {\n+            // For all_parents case, both outputs from the parent should have the same bump fee,\n+            // even though only one of them is in a to-be-replaced transaction.\n+            BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+\n+            // Check tx1 bumpfee: no other bumper.\n+            const TxDimensions& tx1_dimensions = tx_dims.find(tx1->GetHash())->second;\n+            CAmount it1_spent = Find(bump_fees, COutPoint{tx1->GetHash(), 0});\n+            if (target_feerate <= tx1_dimensions.feerate) {\n+                BOOST_CHECK_EQUAL(it1_spent, 0);\n+            } else {\n+                // Difference is fee to bump tx1 from current to target feerate.\n+                BOOST_CHECK_EQUAL(it1_spent, target_feerate.GetFee(tx1_dimensions.vsize) - tx1_dimensions.mod_fee);\n+            }\n+\n+            // Check tx3 bumpfee: no other bumper, because tx4 is to-be-replaced.\n+            const TxDimensions& tx3_dimensions = tx_dims.find(tx3->GetHash())->second;\n+            const CFeeRate tx3_feerate_unbumped = tx3_dimensions.feerate;\n+            auto it3_spent = Find(bump_fees, COutPoint{tx3->GetHash(), 0});\n+            if (target_feerate <= tx3_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it3_spent, 0);\n+            } else {\n+                // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+                BOOST_CHECK_EQUAL(it3_spent, target_feerate.GetFee(tx3_dimensions.vsize) - tx3_dimensions.mod_fee);\n+            }\n+\n+            // Check tx5 bumpfee: no other bumper, because tx6 is to-be-replaced.\n+            const TxDimensions& tx5_dimensions = tx_dims.find(tx5->GetHash())->second;\n+            const CFeeRate tx5_feerate_unbumped = tx5_dimensions.feerate;\n+            auto it5_spent = Find(bump_fees, COutPoint{tx5->GetHash(), 0});\n+            if (target_feerate <= tx5_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it5_spent, 0);\n+            } else {\n+                // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+                BOOST_CHECK_EQUAL(it5_spent, target_feerate.GetFee(tx5_dimensions.vsize) - tx5_dimensions.mod_fee);\n+            }\n+        }\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_overlap, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount med_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create 3 parents of different feerates, and 1 child spending from all 3.\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx2));\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx1->GetHash(), 0}, COutPoint{tx2->GetHash(), 0}, COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create 1 grandparent and 1 parent, then 2 children.\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    const auto tx7 = make_tx({COutPoint{tx6->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx6->GetHash(), 1}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<int64_t> tx_vsizes;\n+    tx_vsizes.reserve(all_transactions.size());\n+    for (const auto& tx : all_transactions) tx_vsizes.push_back(GetVirtualTransactionSize(*tx));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx4->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 2},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 2},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    const auto tx3_feerate = CFeeRate(high_fee, tx_vsizes[2]);\n+    const auto tx4_feerate = CFeeRate(high_fee, tx_vsizes[3]);\n+    // tx4's feerate is lower than tx3's. same fee, different weight.\n+    BOOST_CHECK(tx3_feerate > tx4_feerate);\n+    const auto tx4_anc_feerate = CFeeRate(low_fee + med_fee + high_fee, tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[3]);\n+    const auto tx5_feerate = CFeeRate(high_fee, tx_vsizes[4]);\n+    const auto tx7_anc_feerate = CFeeRate(low_fee + med_fee, tx_vsizes[5] + tx_vsizes[6]);\n+    const auto tx8_anc_feerate = CFeeRate(low_fee + high_fee, tx_vsizes[5] + tx_vsizes[7]);",
      "path": "src/test/miniminer_tests.cpp",
      "position": 334,
      "original_position": 334,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "3f3f2d59ea2946a7b7cc8cb0222fb602d62645d0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit, follow-up material:\r\nI think the `{tx5,tx7,tx8}_anc_feerate`s are all off here as they forget to account for their own tx's vsize/fee. Probably it would even make sense to check against the fee-rate calculated with the \"real\" values gathered from CTxMemPool with some checks like this:\r\n```diff\r\n-    const auto tx4_anc_feerate = CFeeRate(low_fee + med_fee + high_fee, tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[3]);\r\n+    const auto tx4_anc_feerate = CFeeRate(low_fee + med_fee + high_fee + high_fee, tx_vsizes[0] + tx_vsizes[1] + tx_vsizes[2] + tx_vsizes[3]);\r\n+    const auto tx4_iter = pool.GetIter(tx4->GetHash());\r\n+    BOOST_CHECK(tx4_anc_feerate == CFeeRate(tx4_iter.value()->GetModFeesWithAncestors(), tx4_iter.value()->GetSizeWithAncestors()));\r\n\r\n```",
      "created_at": "2023-05-09T16:53:53Z",
      "updated_at": "2023-05-09T17:41:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1188884884",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1188884884"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": 331,
      "original_start_line": 331,
      "start_side": "RIGHT",
      "line": 334,
      "original_line": 334,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1188935619",
      "pull_request_review_id": 1419015473,
      "id": 1188935619,
      "node_id": "PRRC_kwDOABII585G3bfD",
      "diff_hunk": "@@ -0,0 +1,477 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <node/mini_miner.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+#include <test/util/txmempool.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(miniminer_tests, TestingSetup)\n+\n+static inline CTransactionRef make_tx(const std::vector<COutPoint>& inputs, size_t num_outputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(num_outputs);\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout = inputs[i];\n+    }\n+    for (size_t i = 0; i < num_outputs; ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        // The actual input and output values of these transactions don't really\n+        // matter, since all accounting will use the entries' cached fees.\n+        tx.vout[i].nValue = COIN;\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+static inline bool sanity_check(const std::vector<CTransactionRef>& transactions,\n+                                const std::map<COutPoint, CAmount>& bumpfees)\n+{\n+    // No negative bumpfees.\n+    for (const auto& [outpoint, fee] : bumpfees) {\n+        if (fee < 0) return false;\n+        if (fee == 0) continue;\n+        auto outpoint_ = outpoint; // structured bindings can't be captured in C++17, so we need to use a variable\n+        const bool found = std::any_of(transactions.cbegin(), transactions.cend(), [&](const auto& tx) {\n+            return outpoint_.hash == tx->GetHash() && outpoint_.n < tx->vout.size();\n+        });\n+        if (!found) return false;\n+    }\n+    for (const auto& tx : transactions) {\n+        // If tx has multiple outputs, they must all have the same bumpfee (if they exist).\n+        if (tx->vout.size() > 1) {\n+            std::set<CAmount> distinct_bumpfees;\n+            for (size_t i{0}; i < tx->vout.size(); ++i) {\n+                const auto bumpfee = bumpfees.find(COutPoint{tx->GetHash(), static_cast<uint32_t>(i)});\n+                if (bumpfee != bumpfees.end()) distinct_bumpfees.insert(bumpfee->second);\n+            }\n+            if (distinct_bumpfees.size() > 1) return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+template <typename Key, typename Value>\n+Value Find(const std::map<Key, Value>& map, const Key& key)\n+{\n+    auto it = map.find(key);\n+    BOOST_CHECK_MESSAGE(it != map.end(), strprintf(\"Cannot find %s\", key.ToString()));\n+    return it->second;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_1p1c, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount normal_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{tx1->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have low fees\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), CENT/100);\n+\n+    // Create a high-feerate parent tx7, low-feerate child tx8\n+    const auto tx7 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx7->GetHash(), 0}}, /*num_outputs=*/1);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx8));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    std::vector<COutPoint> all_spent_outpoints({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_spent_outpoints) BOOST_CHECK(pool.GetConflictTx(outpoint) != nullptr);\n+\n+    std::vector<COutPoint> all_parent_outputs({\n+        COutPoint{tx1->GetHash(), 0},\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 0},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx5->GetHash(), 0},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx7->GetHash(), 1}\n+    });\n+\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    struct TxDimensions {\n+        size_t vsize; CAmount mod_fee; CFeeRate feerate;\n+    };\n+    std::map<uint256, TxDimensions> tx_dims;\n+    for (const auto& tx : all_transactions) {\n+        const auto it = pool.GetIter(tx->GetHash()).value();\n+        tx_dims.emplace(tx->GetHash(), TxDimensions{it->GetTxSize(), it->GetModifiedFee(),\n+                                              CFeeRate(it->GetModifiedFee(), it->GetTxSize())});\n+    }\n+\n+    const std::vector<CFeeRate> various_normal_feerates({CFeeRate(0), CFeeRate(500), CFeeRate(999),\n+                                                         CFeeRate(1000), CFeeRate(2000), CFeeRate(2500),\n+                                                         CFeeRate(3333), CFeeRate(7800), CFeeRate(11199),\n+                                                         CFeeRate(23330), CFeeRate(50000), CFeeRate(5*CENT)});\n+\n+    // All nonexistent entries have a bumpfee of zero, regardless of feerate\n+    std::vector<COutPoint> nonexistent_outpoints({ COutPoint{GetRandHash(), 0}, COutPoint{GetRandHash(), 3} });\n+    for (const auto& outpoint : nonexistent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+    for (const auto& feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, nonexistent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK(bump_fees.size() == nonexistent_outpoints.size());\n+        for (const auto& outpoint: nonexistent_outpoints) {\n+            auto it = bump_fees.find(outpoint);\n+            BOOST_CHECK(it != bump_fees.end());\n+            BOOST_CHECK_EQUAL(it->second, 0);\n+        }\n+    }\n+\n+    // Gather bump fees for all available UTXOs.\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner(pool, all_unspent_outpoints);\n+        BOOST_CHECK(mini_miner.IsReadyToCalculate());\n+        auto bump_fees = mini_miner.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner.IsReadyToCalculate());\n+        BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+        BOOST_CHECK_EQUAL(bump_fees.size(), all_unspent_outpoints.size());\n+\n+        // Check tx1 bumpfee: no other bumper.\n+        const TxDimensions& tx1_dimensions = tx_dims.find(tx1->GetHash())->second;\n+        CAmount bumpfee1 = Find(bump_fees, COutPoint{tx1->GetHash(), 1});\n+        if (target_feerate <= tx1_dimensions.feerate) {\n+            BOOST_CHECK_EQUAL(bumpfee1, 0);\n+        } else {\n+            // Difference is fee to bump tx1 from current to target feerate.\n+            BOOST_CHECK_EQUAL(bumpfee1, target_feerate.GetFee(tx1_dimensions.vsize) - tx1_dimensions.mod_fee);\n+        }\n+\n+        // Check tx3 bumpfee: assisted by tx4.\n+        const TxDimensions& tx3_dimensions = tx_dims.find(tx3->GetHash())->second;\n+        const TxDimensions& tx4_dimensions = tx_dims.find(tx4->GetHash())->second;\n+        const CFeeRate tx3_feerate = CFeeRate(tx3_dimensions.mod_fee + tx4_dimensions.mod_fee, tx3_dimensions.vsize + tx4_dimensions.vsize);\n+        CAmount bumpfee3 = Find(bump_fees, COutPoint{tx3->GetHash(), 1});\n+        if (target_feerate <= tx3_feerate) {\n+            // As long as target feerate is below tx4's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(bumpfee3, 0);\n+        } else {\n+            // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+            BOOST_CHECK_EQUAL(bumpfee3, target_feerate.GetFee(tx3_dimensions.vsize) - tx3_dimensions.mod_fee);\n+        }\n+\n+        // If tx6’s modified fees are sufficient for tx5 and tx6 to be picked\n+        // into the block, our prospective new transaction would not need to\n+        // bump tx5 when using tx5’s second output. If however even tx6’s\n+        // modified fee (which essentially indicates \"effective feerate\") is\n+        // not sufficient to bump tx5, using the second output of tx5 would\n+        // require our transaction to bump tx5 from scratch since we evaluate\n+        // transaction packages per ancestor sets and do not consider multiple\n+        // children’s fees.\n+        const TxDimensions& tx5_dimensions = tx_dims.find(tx5->GetHash())->second;\n+        const TxDimensions& tx6_dimensions = tx_dims.find(tx6->GetHash())->second;\n+        const CFeeRate tx5_feerate = CFeeRate(tx5_dimensions.mod_fee + tx6_dimensions.mod_fee, tx5_dimensions.vsize + tx6_dimensions.vsize);\n+        CAmount bumpfee5 = Find(bump_fees, COutPoint{tx5->GetHash(), 1});\n+        if (target_feerate <= tx5_feerate) {\n+            // As long as target feerate is below tx6's ancestor feerate, there is no bump fee.\n+            BOOST_CHECK_EQUAL(bumpfee5, 0);\n+        } else {\n+            // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+            BOOST_CHECK_EQUAL(bumpfee5, target_feerate.GetFee(tx5_dimensions.vsize) - tx5_dimensions.mod_fee);\n+        }\n+    }\n+    // Spent outpoints should usually not be requested as they would not be\n+    // considered available. However, when they are explicitly requested, we\n+    // can calculate their bumpfee to facilitate RBF-replacements\n+    for (const auto& target_feerate : various_normal_feerates) {\n+        node::MiniMiner mini_miner_all_spent(pool, all_spent_outpoints);\n+        BOOST_CHECK(mini_miner_all_spent.IsReadyToCalculate());\n+        auto bump_fees_all_spent = mini_miner_all_spent.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_spent.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_spent.size(), all_spent_outpoints.size());\n+        node::MiniMiner mini_miner_all_parents(pool, all_parent_outputs);\n+        BOOST_CHECK(mini_miner_all_parents.IsReadyToCalculate());\n+        auto bump_fees_all_parents = mini_miner_all_parents.CalculateBumpFees(target_feerate);\n+        BOOST_CHECK(!mini_miner_all_parents.IsReadyToCalculate());\n+        BOOST_CHECK_EQUAL(bump_fees_all_parents.size(), all_parent_outputs.size());\n+        for (auto& bump_fees : {bump_fees_all_parents, bump_fees_all_spent}) {\n+            // For all_parents case, both outputs from the parent should have the same bump fee,\n+            // even though only one of them is in a to-be-replaced transaction.\n+            BOOST_CHECK(sanity_check(all_transactions, bump_fees));\n+\n+            // Check tx1 bumpfee: no other bumper.\n+            const TxDimensions& tx1_dimensions = tx_dims.find(tx1->GetHash())->second;\n+            CAmount it1_spent = Find(bump_fees, COutPoint{tx1->GetHash(), 0});\n+            if (target_feerate <= tx1_dimensions.feerate) {\n+                BOOST_CHECK_EQUAL(it1_spent, 0);\n+            } else {\n+                // Difference is fee to bump tx1 from current to target feerate.\n+                BOOST_CHECK_EQUAL(it1_spent, target_feerate.GetFee(tx1_dimensions.vsize) - tx1_dimensions.mod_fee);\n+            }\n+\n+            // Check tx3 bumpfee: no other bumper, because tx4 is to-be-replaced.\n+            const TxDimensions& tx3_dimensions = tx_dims.find(tx3->GetHash())->second;\n+            const CFeeRate tx3_feerate_unbumped = tx3_dimensions.feerate;\n+            auto it3_spent = Find(bump_fees, COutPoint{tx3->GetHash(), 0});\n+            if (target_feerate <= tx3_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it3_spent, 0);\n+            } else {\n+                // Difference is fee to bump tx3 from current to target feerate, without tx4.\n+                BOOST_CHECK_EQUAL(it3_spent, target_feerate.GetFee(tx3_dimensions.vsize) - tx3_dimensions.mod_fee);\n+            }\n+\n+            // Check tx5 bumpfee: no other bumper, because tx6 is to-be-replaced.\n+            const TxDimensions& tx5_dimensions = tx_dims.find(tx5->GetHash())->second;\n+            const CFeeRate tx5_feerate_unbumped = tx5_dimensions.feerate;\n+            auto it5_spent = Find(bump_fees, COutPoint{tx5->GetHash(), 0});\n+            if (target_feerate <= tx5_feerate_unbumped) {\n+                BOOST_CHECK_EQUAL(it5_spent, 0);\n+            } else {\n+                // Difference is fee to bump tx5 from current to target feerate, without tx6.\n+                BOOST_CHECK_EQUAL(it5_spent, target_feerate.GetFee(tx5_dimensions.vsize) - tx5_dimensions.mod_fee);\n+            }\n+        }\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(miniminer_overlap, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(::cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{CENT/2000};\n+    const CAmount med_fee{CENT/200};\n+    const CAmount high_fee{CENT/10};\n+\n+    // Create 3 parents of different feerates, and 1 child spending from all 3.\n+    const auto tx1 = make_tx({COutPoint{m_coinbase_txns[0]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx1));\n+    const auto tx2 = make_tx({COutPoint{m_coinbase_txns[1]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx2));\n+    const auto tx3 = make_tx({COutPoint{m_coinbase_txns[2]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx3));\n+    const auto tx4 = make_tx({COutPoint{tx1->GetHash(), 0}, COutPoint{tx2->GetHash(), 0}, COutPoint{tx3->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create 1 grandparent and 1 parent, then 2 children.\n+    const auto tx5 = make_tx({COutPoint{m_coinbase_txns[3]->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx5));\n+    const auto tx6 = make_tx({COutPoint{tx5->GetHash(), 0}}, /*num_outputs=*/3);\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    const auto tx7 = make_tx({COutPoint{tx6->GetHash(), 0}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(med_fee).FromTx(tx7));\n+    const auto tx8 = make_tx({COutPoint{tx6->GetHash(), 1}}, /*num_outputs=*/2);\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    std::vector<CTransactionRef> all_transactions{tx1, tx2, tx3, tx4, tx5, tx6, tx7, tx8};\n+    std::vector<int64_t> tx_vsizes;\n+    tx_vsizes.reserve(all_transactions.size());\n+    for (const auto& tx : all_transactions) tx_vsizes.push_back(GetVirtualTransactionSize(*tx));\n+\n+    std::vector<COutPoint> all_unspent_outpoints({\n+        COutPoint{tx1->GetHash(), 1},\n+        COutPoint{tx2->GetHash(), 1},\n+        COutPoint{tx3->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 0},\n+        COutPoint{tx4->GetHash(), 1},\n+        COutPoint{tx4->GetHash(), 2},\n+        COutPoint{tx5->GetHash(), 1},\n+        COutPoint{tx6->GetHash(), 2},\n+        COutPoint{tx7->GetHash(), 0},\n+        COutPoint{tx8->GetHash(), 0}\n+    });\n+    for (const auto& outpoint : all_unspent_outpoints) BOOST_CHECK(!pool.isSpent(outpoint));\n+\n+    const auto tx3_feerate = CFeeRate(high_fee, tx_vsizes[2]);",
      "path": "src/test/miniminer_tests.cpp",
      "position": 327,
      "original_position": 327,
      "commit_id": "6b605b91c1faf2c7f7cc0c9d39b4fcfd66dc2965",
      "original_commit_id": "3f3f2d59ea2946a7b7cc8cb0222fb602d62645d0",
      "in_reply_to_id": null,
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "For better readability and maintainability, would be nice to start naming the txs with index zero, to avoid the off-by-one relation (`txN <-> tx_vsizes[N-1]`).",
      "created_at": "2023-05-09T17:40:57Z",
      "updated_at": "2023-05-09T17:41:41Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/27021#discussion_r1188935619",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1188935619"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/27021"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 327,
      "original_line": 327,
      "side": "RIGHT"
    }
  ]
}