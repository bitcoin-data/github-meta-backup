{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097",
    "id": 931390789,
    "node_id": "PR_kwDOABII5843g-VF",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/25097",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/25097.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/25097.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25097",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25097/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/eeefec343592c6de85048e3b055ba49755cfb072",
    "number": 25097,
    "state": "closed",
    "locked": false,
    "maintainer_can_modify": false,
    "title": "test: Unit tests for taproot/tapscript coverage in `interpreter.cpp`",
    "user": {
      "login": "david-bakin",
      "id": 4162948,
      "node_id": "MDQ6VXNlcjQxNjI5NDg=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/david-bakin",
      "html_url": "https://github.com/david-bakin",
      "followers_url": "https://api.github.com/users/david-bakin/followers",
      "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
      "organizations_url": "https://api.github.com/users/david-bakin/orgs",
      "repos_url": "https://api.github.com/users/david-bakin/repos",
      "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/david-bakin/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "[Unit tests are not complete to resolve #23279 - _yet_.  But those additional tests - see this space for future developments! - will not change the code presented here.]\r\n\r\nThis PR provides unit tests for Taproot functionality in `script/interpreter.cpp`, #23279.\r\n\r\nGoal is to show correctness vs specifications in BIPs 341/342, and to improve code coverage in Taproot functionality there.\r\n\r\nIntent is to unit test completely without changing `interpreter.cpp` itself to provide visibility into static functions/private methods.  Thus some of the tests must be \"indirect\", testing the unit-under-test by probing a visible caller.  This makes those specific tests somewhat fragile as they depend on code paths in the caller, which may change in the future.  However, such tests are written so they will fail if the unit-under-test isn't actually called.  This is noted in the code of those specific tests.\r\n\r\nNo changes to Bitcoin Core are made - just unit tests added.  The Boost Test framework file `boost/test/execution_monitor.hpp` was added to the lint whitelist - this is acceptable because it is a documented public header of the Boost Test framework, which is already part of the project.\r\n\r\n- [x] `EvalChecksigTapscript`\r\n- [x] `HandleMissingData`\r\n- [x] `SignatureHashSchnorr` - now with full _path_ coverage\r\n- [x] `GenericTransactionSignatureChecker<T>::VerifySchnorrSignature`\r\n- [x] `GenericTransactionSignatureChecker<T>::CheckSchnorrSignature`\r\n- [x] `ComputeTaprootMerkleRoot`\r\n- [ ] `SigVersion::TAPSCRIPT` code paths in `ExecuteWitnessScript`\r\n- [x] Taproot code paths in `VerifyWitnessProgram`\r\n- [ ] Tapscript code paths in `VerifyWitnessProgram`\r\n\r\n**TODO:** Full Tapscript (BIP-342) unit tests yet to be completed.\r\n**TODO:** Does anything need to be done with `libconsensus`? Please advise!\r\n\r\n2 commits:\r\n\r\n1. Add new utility functions to `src/test/util` that are not only used in these tests but may also be useful for future unit tests.  Also, refactor some existing utility functions from current tests (mainly, `script_tests.cpp`) into `src/test/util` so they can be more widely used too.  All of these new test utility functions have unit tests themselves, in `src/test/test_utils_tests.cpp`.\r\n1. All the tests for Taproot/Tapscript functionality requested by #23279 in a new file `src/test/script_tapscript_tests.cpp`.  Code coverage runs show 100% coverage of lines and near 100% coverage of branches.\r\n\r\n**DEATH TRAP AHEAD!:** These unit tests include \"death tests\" (name comes from Googletest framework): Tests that check that an `assert` actually fails.  These are handled with a Boost `execution_monitor` (mentioned above) _but_ the asserts _still issue messages_ even when correctly trapped by the Boost Test framework.  You'll see the following in the logs:\r\n\r\n```\r\ngitpod /workspace/bitcoin/src/test (23279-taproot-unit-tests) $ ./test_bitcoin \r\nRunning 527 test cases...\r\ntest_bitcoin: script/interpreter.cpp:1495: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `false' failed.\r\ntest_bitcoin: script/interpreter.cpp:1497: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `in_pos < tx_to.vin.size()' failed.\r\ntest_bitcoin: script/interpreter.cpp:1528: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `execdata.m_annex_init' failed.\r\ntest_bitcoin: script/interpreter.cpp:1556: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `execdata.m_tapleaf_hash_init' failed.\r\ntest_bitcoin: script/interpreter.cpp:1559: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `execdata.m_codeseparator_pos_init' failed.\r\ntest_bitcoin: script/interpreter.cpp:1469: bool HandleMissingData(MissingDataBehavior): Assertion `!\"Missing data\"' failed.\r\ntest_bitcoin: script/interpreter.cpp:1474: bool HandleMissingData(MissingDataBehavior): Assertion `!\"Unknown MissingDataBehavior value\"' failed.\r\n\r\n*** No errors detected\r\ngitpod /workspace/bitcoin/src/test (23279-taproot-unit-tests) $ \r\n```\r\n\r\nThese specific `Assertion ... failed` messages are _expected_.  The tests triggering them properly _pass_ iff the `assert` (and no other) is _triggered_.\r\n\r\n-----\r\n\r\nCoverage results 2022-06-05 showing Taproot coverage (Tapscript tests not yet complete) when _only running_ `script_tapscript_tests.cpp`:\r\n\r\n|  |   |\r\n|--:|:--|\r\n|`EvalChecksigTapscript`|<img alt=\"EvalChecksigTapscript\" align=\"left\" width=\"550\" src=\"https://user-images.githubusercontent.com/4162948/172067379-4815fd13-1eca-4fdc-afb3-ab321f644ca6.png\">|\r\n|`HandleMissingData`|<img alt=\"HandleMissingData coverage\" align=\"left\" width=\"550\" src=\"https://user-images.githubusercontent.com/4162948/172066800-7ad85065-448c-4300-8f5f-bbdaeb5bc885.png\">|\r\n|`SignatureHashSchnorr`|<img alt=\"SignatureHashSchnorr coverage\" align=\"left\" width=\"550\" src=\"https://user-images.githubusercontent.com/4162948/172067034-c8d65908-bf41-4420-8a5d-5c023f85824a.png\">|\r\n|`GenericTransaction-`<br>`SignatureChecker<T>::`<br>`CheckSchnorrSignature`|<img alt=\"CheckSchnorrSignature\" align=\"left\" width=\"550\" src=\"https://user-images.githubusercontent.com/4162948/172067232-b58ea75a-9df7-4f02-b291-c1adda4792e8.png\">|\r\n|`ComputeTaprootMerkleRoot`|<img alt=\"ComputeTaprootMerkleRoot\" align=\"left\" width=\"550\" src=\"https://user-images.githubusercontent.com/4162948/172067270-d15ac048-6001-4a8f-b0a7-f62b76cf584b.png\">|\r\n|`VerifyWitnessProgram`<br>(Taproot only)|<img alt=\"VerifyWitnessProgram\" align=\"left\" width=\"550\" src=\"https://user-images.githubusercontent.com/4162948/172067308-c23ccaaa-dbee-43ea-b2df-cbee9ba375ed.png\">|\r\n\r\n",
    "labels": [
      {
        "id": 62963516,
        "node_id": "MDU6TGFiZWw2Mjk2MzUxNg==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Tests",
        "name": "Tests",
        "color": "d4c5f9",
        "default": false
      },
      {
        "id": 955867938,
        "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
        "name": "Needs rebase",
        "description": "",
        "color": "cccccc",
        "default": false
      }
    ],
    "created_at": "2022-05-09T16:17:57Z",
    "updated_at": "2022-11-10T21:27:41Z",
    "closed_at": "2022-11-10T17:16:20Z",
    "mergeable": false,
    "mergeable_state": "dirty",
    "merge_commit_sha": "fafe89db9945081cda6950e25c23ac062c5bf010",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": false,
    "head": {
      "label": "david-bakin:23279-taproot-unit-tests",
      "ref": "23279-taproot-unit-tests",
      "sha": "eeefec343592c6de85048e3b055ba49755cfb072",
      "user": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 488700653,
        "node_id": "R_kgDOHSD67Q",
        "name": "bitcoin",
        "full_name": "david-bakin/bitcoin",
        "owner": {
          "login": "david-bakin",
          "id": 4162948,
          "node_id": "MDQ6VXNlcjQxNjI5NDg=",
          "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/david-bakin",
          "html_url": "https://github.com/david-bakin",
          "followers_url": "https://api.github.com/users/david-bakin/followers",
          "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
          "organizations_url": "https://api.github.com/users/david-bakin/orgs",
          "repos_url": "https://api.github.com/users/david-bakin/repos",
          "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/david-bakin/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/david-bakin/bitcoin",
        "description": "Working copy of: Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/david-bakin/bitcoin",
        "archive_url": "https://api.github.com/repos/david-bakin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/david-bakin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/david-bakin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/david-bakin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/david-bakin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/david-bakin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/david-bakin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/david-bakin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/david-bakin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/david-bakin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/david-bakin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/david-bakin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/david-bakin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/david-bakin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/david-bakin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/david-bakin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/david-bakin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/david-bakin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/david-bakin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/david-bakin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/david-bakin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/david-bakin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/david-bakin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/david-bakin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/david-bakin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/david-bakin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/david-bakin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/david-bakin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/david-bakin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:david-bakin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/david-bakin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/david-bakin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/david-bakin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/david-bakin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/david-bakin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/david-bakin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/david-bakin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/david-bakin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/david-bakin/bitcoin/hooks",
        "svn_url": "https://github.com/david-bakin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 1,
        "stargazers_count": 1,
        "watchers_count": 1,
        "size": 209507,
        "default_branch": "master",
        "open_issues_count": 0,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2022-08-14T02:04:40Z",
        "created_at": "2022-05-04T18:24:34Z",
        "updated_at": "2022-05-15T09:30:41Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "29d540b7ada890dd588c4825d40c27c5e6f20061",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 34324,
        "stargazers_count": 69818,
        "watchers_count": 69818,
        "size": 233879,
        "default_branch": "master",
        "open_issues_count": 627,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-06-07T05:35:10Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2023-06-07T06:49:43Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 2727,
    "deletions": 182,
    "changed_files": 13,
    "commits": 2,
    "review_comments": 16,
    "comments": 19
  },
  "events": [
    {
      "event": "labeled",
      "id": 6574560995,
      "node_id": "LE_lADOABII585JT61QzwAAAAGH39bj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6574560995",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-09T16:18:52Z",
      "label": {
        "name": "Tests",
        "color": "d4c5f9"
      }
    },
    {
      "event": "commented",
      "id": 1121866886,
      "node_id": "IC_kwDOABII585C3lSG",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1121866886",
      "actor": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-10T03:52:23Z",
      "updated_at": "2022-05-10T03:52:23Z",
      "author_association": "CONTRIBUTOR",
      "body": "(`Win64 native [msvc]` failed above in functional test `feature_index_prune.py` - this test has been reported recently as flaky, see #25031.)",
      "user": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1121866886",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25097"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6600947589,
      "node_id": "HRFPE_lADOABII585JT61QzwAAAAGJcneF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6600947589",
      "actor": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-12T19:38:02Z"
    },
    {
      "event": "renamed",
      "id": 6610645950,
      "node_id": "RTE_lADOABII585JT61QzwAAAAGKBnO-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6610645950",
      "actor": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-14T22:47:27Z",
      "rename": {
        "from": "Unit tests for taproot/tapscript coverage in `interpreter.cpp`",
        "to": "test: Unit tests for taproot/tapscript coverage in `interpreter.cpp`"
      }
    },
    {
      "event": "renamed",
      "id": 6610646420,
      "node_id": "RTE_lADOABII585JT61QzwAAAAGKBnWU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6610646420",
      "actor": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-14T22:48:16Z",
      "rename": {
        "from": "test: Unit tests for taproot/tapscript coverage in `interpreter.cpp`",
        "to": "test: [WIP] Unit tests for taproot/tapscript coverage in `interpreter.cpp`"
      }
    },
    {
      "event": "renamed",
      "id": 6610646688,
      "node_id": "RTE_lADOABII585JT61QzwAAAAGKBnag",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6610646688",
      "actor": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-14T22:48:42Z",
      "rename": {
        "from": "test: [WIP] Unit tests for taproot/tapscript coverage in `interpreter.cpp`",
        "to": "[WIP] test: Unit tests for taproot/tapscript coverage in `interpreter.cpp`"
      }
    },
    {
      "event": "commented",
      "id": 1129634277,
      "node_id": "IC_kwDOABII585DVNnl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1129634277",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-18T06:47:06Z",
      "updated_at": "2022-05-18T06:47:06Z",
      "author_association": "MEMBER",
      "body": "Squashed and rebased this branch to master and seeing this when running the tests:\r\n```\r\n$  ./src/test/test_bitcoin -t script_tapscript_tests\r\nRunning 12 test cases...\r\ntest_bitcoin: script/interpreter.cpp:1495: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `false' failed.\r\ntest_bitcoin: script/interpreter.cpp:1497: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `in_pos < tx_to.vin.size()' failed.\r\ntest_bitcoin: script/interpreter.cpp:1528: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `execdata.m_annex_init' failed.\r\ntest_bitcoin: script/interpreter.cpp:1556: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `execdata.m_tapleaf_hash_init' failed.\r\ntest_bitcoin: script/interpreter.cpp:1559: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `execdata.m_codeseparator_pos_init' failed.\r\ntest_bitcoin: script/interpreter.cpp:1469: bool HandleMissingData(MissingDataBehavior): Assertion `!\"Missing data\"' failed.\r\ntest_bitcoin: script/interpreter.cpp:1474: bool HandleMissingData(MissingDataBehavior): Assertion `!\"Unknown MissingDataBehavior value\"' failed.\r\n```\r\n",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1129634277",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25097"
    },
    {
      "event": "commented",
      "id": 1129636628,
      "node_id": "IC_kwDOABII585DVOMU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1129636628",
      "actor": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-18T06:50:23Z",
      "updated_at": "2022-05-18T07:02:34Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Squashed and rebased this branch to master and seeing this when running the tests:\r\n> \r\n> ```\r\n> $  ./src/test/test_bitcoin -t script_tapscript_tests\r\n> Running 12 test cases...\r\n> test_bitcoin: script/interpreter.cpp:1495: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `false' failed.\r\n\r\n\r\nYes - that's actually expected.  Those are death tests - testing asserts.  The Boost Test framework will print that the assertion failed but then it is properly caught with an `ExecutionMonitor` so the test actually succeeds.\r\n\r\n**[Following paragraph was initially wrong but now is correct:]**\r\nThe reason for these tests is that I wanted to get 100% coverage.  This routine implements the Schnorr signature hash - which is specified in a BIP and of course is part of the consensus - and it is a very complicated routine - it takes several structs as inputs and those structs can have \"optional\" fields (but not `std::optional`) - which may or may not be initialized.  I thought it was important to make sure that the logic errors in callers actually caused the asserts to happen.  Plus, it makes it easier to look at the coverage report and say, yep, everything in here is tested.\r\n\r\nDo you have any suggestions on how I can improve the documentation or the test to avoid confusion such as this?  Perhaps I could use `BOOST_TEST_MESSAGE` to emit a message: \"These following assertions are _expected_\"??\r\n\r\n(There's a big comment explaining this in the code [@1366](https://github.com/bitcoin/bitcoin/pull/25097/files#diff-21483d0e032747850208f21325b29cde89e9c1f55f83a7a166a388cc5c27115aR1366) but of course people will just see the logs first ...)\r\n\r\nP.S. _Thank you_ for checking this PR out!  Very encouraging for me...",
      "user": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1129636628",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25097"
    },
    {
      "event": "mentioned",
      "id": 6629645587,
      "node_id": "MEE_lADOABII585JT61QzwAAAAGLKF0T",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6629645587",
      "actor": {
        "login": "1366",
        "id": 1255189,
        "node_id": "MDQ6VXNlcjEyNTUxODk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1255189?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/1366",
        "html_url": "https://github.com/1366",
        "followers_url": "https://api.github.com/users/1366/followers",
        "following_url": "https://api.github.com/users/1366/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/1366/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/1366/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/1366/subscriptions",
        "organizations_url": "https://api.github.com/users/1366/orgs",
        "repos_url": "https://api.github.com/users/1366/repos",
        "events_url": "https://api.github.com/users/1366/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/1366/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-18T06:51:45Z"
    },
    {
      "event": "subscribed",
      "id": 6629645591,
      "node_id": "SE_lADOABII585JT61QzwAAAAGLKF0X",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6629645591",
      "actor": {
        "login": "1366",
        "id": 1255189,
        "node_id": "MDQ6VXNlcjEyNTUxODk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1255189?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/1366",
        "html_url": "https://github.com/1366",
        "followers_url": "https://api.github.com/users/1366/followers",
        "following_url": "https://api.github.com/users/1366/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/1366/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/1366/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/1366/subscriptions",
        "organizations_url": "https://api.github.com/users/1366/orgs",
        "repos_url": "https://api.github.com/users/1366/repos",
        "events_url": "https://api.github.com/users/1366/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/1366/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-18T06:51:45Z"
    },
    {
      "event": "commented",
      "id": 1129647169,
      "node_id": "IC_kwDOABII585DVQxB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1129647169",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-18T07:04:22Z",
      "updated_at": "2022-05-18T07:04:22Z",
      "author_association": "MEMBER",
      "body": "Oh ok, I hadn't looked at the code yet (the fixup and merge commits really need to be squashed to encourage people to look at it) but indeed there is a large comment. Agree, logging a message to explain would be helpful.",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1129647169",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25097"
    },
    {
      "event": "commented",
      "id": 1129648074,
      "node_id": "IC_kwDOABII585DVQ_K",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1129648074",
      "actor": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-18T07:05:28Z",
      "updated_at": "2022-05-18T07:19:52Z",
      "author_association": "CONTRIBUTOR",
      "body": "I will squash now (actually, in the morning ...) - I was waiting until I finished the last couple of tasks but no problem doing it now.  Thanks for the tip.\r\n\r\nAlso, unfortunately, `BOOST_TEST_MESSAGE` messages aren't displayed unless you set a `log_level`, like `--log_level=message` - so most people still won't see it ...",
      "user": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1129648074",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25097"
    },
    {
      "event": "commented",
      "id": 1129682494,
      "node_id": "IC_kwDOABII585DVZY-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1129682494",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-18T07:45:46Z",
      "updated_at": "2022-05-18T08:38:35Z",
      "author_association": "MEMBER",
      "body": "I tend to run individual tests with `-l test_suite` or `-l all` if anything unusual occurs when running it without a log level.\r\n\r\n In any case, the unit test runner invoked with `make check` runs it fine locally for me and it looks like you solved your CI issue.\r\n\r\nEdit: nit fixups signaled by `test/lint/lint-spelling.py`\r\n```\r\n$ test/lint/lint-spelling.py\r\nsrc/test/script_tapscript_tests.cpp:650: tranaction ==> transaction\r\nsrc/test/script_tapscript_tests.cpp:1048: suceeds ==> succeeds\r\n```\r\n\r\nEdit 2: I did see this error with `make check`, unsure if it was with your latest push:\r\n```\r\nRunning tests: from test/script_tapscript_tests.cpp\r\ncat: test/script_tapscript_tests.cpp: No such file or directory\r\nMissing an argument value for the parameter run_test in the argument \r\n\r\n  run_test\r\n    Filters which tests to execute.\r\n    --run_test=<test unit filter>\r\n    -t <test unit filter>\r\n\r\n\r\n  Use\r\n      test_bitcoin --help\r\n  or  test_bitcoin --help=<parameter name>\r\n  for detailed help on Boost.Test parameters.\r\nmake[3]: *** [Makefile:20940: test/script_tapscript_tests.cpp.test] Error 1\r\nmake[3]: *** Waiting for unfinished jobs....\r\n```\r\n",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1129682494",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25097"
    },
    {
      "event": "reviewed",
      "id": 976500374,
      "node_id": "PRR_kwDOABII5846NDaW",
      "url": null,
      "actor": null,
      "commit_id": "a5808ce2f05040f740dad313e503624de2e8db93",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#pullrequestreview-976500374",
      "submitted_at": "2022-05-18T07:46:30Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
    },
    {
      "event": "reviewed",
      "id": 977185276,
      "node_id": "PRR_kwDOABII5846Pqn8",
      "url": null,
      "actor": null,
      "commit_id": "a5808ce2f05040f740dad313e503624de2e8db93",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Concept ACK\r\n\r\nNice job so far! These tests are well formulated. I like how declarative and readable they are. I'll review more of the substance once this exits draft state.",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#pullrequestreview-977185276",
      "submitted_at": "2022-05-18T16:38:48Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
    },
    {
      "event": "commented",
      "id": 1132163610,
      "node_id": "IC_kwDOABII585De3Ia",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1132163610",
      "actor": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-19T20:16:03Z",
      "updated_at": "2022-05-19T20:16:03Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Edit: nit fixups signaled by `test/lint/lint-spelling.py`\r\n\r\nFixed, and I'll run `lint-spelling` on my own from now on.\r\n\r\n> Edit 2: I did see this error with `make check`, unsure if it was with your latest push:\r\n> \r\n> ```\r\n> Running tests: from test/script_tapscript_tests.cpp\r\n> cat: test/script_tapscript_tests.cpp: No such file or directory\r\n> Missing an argument value for the parameter run_test in the argument \r\n> \r\n>   run_test\r\n> ...\r\n> ```\r\n\r\nI do not see this when running `make check` or when running `test_bitcoin` either with or without `--run_test=script_tapscript_tests`.  Relevant section of my terminal spew when running `make check` locally:\r\n\r\n```\r\n...\r\nRunning tests: script_tapscript_tests from test/script_tapscript_tests.cpp\r\nexport TEST_LOGFILE=/workspace/bitcoin/src/$( echo test/script_tapscript_tests.cpp | grep -E -o \"(wallet/test/.*\\.cpp|test/.*\\.cpp)\" | /usr/bin/sed -e s/\\.cpp/.log/ ) && \\\r\ntest/test_bitcoin --catch_system_errors=no -l test_suite -t \"$( cat test/script_tapscript_tests.cpp | grep -E \"(BOOST_FIXTURE_TEST_SUITE\\\\(|BOOST_AUTO_TEST_SUITE\\\\()\" | cut -d '(' -f 2 | cut -d ',' -f 1 | cut -d ')' -f 1 )\" -- DEBUG_LOG_OUT > \"$TEST_LOGFILE\" 2>&1 || (cat \"$TEST_LOGFILE\" && false)\r\nRunning tests: script_tests from test/script_tests.cpp\r\n...\r\n```\r\nAnd the CI checks all pass too.  Not sure how to proceed on this report.",
      "user": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1132163610",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25097"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6654477495,
      "node_id": "HRFPE_lADOABII585JT61QzwAAAAGMo0S3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6654477495",
      "actor": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-21T04:29:57Z"
    },
    {
      "event": "commented",
      "id": 1133529339,
      "node_id": "IC_kwDOABII585DkEj7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1133529339",
      "actor": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-21T04:31:27Z",
      "updated_at": "2022-05-21T04:33:20Z",
      "author_association": "CONTRIBUTOR",
      "body": "Squashed now as requested.  Still 2 tests left to write: They're tough ones as both are for `static` free functions well hidden by an accessible public free function, and no easy hooks like polymorphic classes to mock/fake to get in there with.\r\n\r\nHowever, all general-purpose \"test only\" internal helpers - data structures, functions for visibility, etc. - are now in `src/test/util` headers, with tests for them in `src/test/test_util_tests.cpp`.",
      "user": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1133529339",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25097"
    },
    {
      "event": "commented",
      "id": 1135947784,
      "node_id": "IC_kwDOABII585DtTAI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1135947784",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-24T13:48:39Z",
      "updated_at": "2022-07-21T21:49:09Z",
      "author_association": "MEMBER",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#25648](https://github.com/bitcoin/bitcoin/pull/25648) (refactor: Remove all policy globals by MarcoFalke)\n* [#25325](https://github.com/bitcoin/bitcoin/pull/25325) (Add pool based memory resource by martinus)\n* [#22954](https://github.com/bitcoin/bitcoin/pull/22954) ([TESTS] Allow tx_invalid.json tests to include flag rules for if_unset: [A,B,C] then_unset: [D] by JeremyRubin)\n* [#22876](https://github.com/bitcoin/bitcoin/pull/22876) ([TESTS] Update Transaction Tests to permit setting a flag as always on and disabling the exhaustive failure test by JeremyRubin)\n* [#22793](https://github.com/bitcoin/bitcoin/pull/22793) (Simplify BaseSignatureChecker virtual functions and GenericTransactionSignatureChecker constructors by achow101)\n* [#22338](https://github.com/bitcoin/bitcoin/pull/22338) ([Refactor]: Rename Script methods that only work on PreTapScript scripts by sanket1729)\n* [#20100](https://github.com/bitcoin/bitcoin/pull/20100) (Script: split policy/error consensus codes for CLEANSTACK, MINIMALIF by sanket1729)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1135947784",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25097"
    },
    {
      "event": "commented",
      "id": 1136260199,
      "node_id": "IC_kwDOABII585DufRn",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1136260199",
      "actor": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-24T17:50:26Z",
      "updated_at": "2022-05-24T17:50:26Z",
      "author_association": "CONTRIBUTOR",
      "body": "DrahtBot said:\r\n> ### Conflicts\r\n> Reviewers, this pull request conflicts with the following ones:\r\n> \r\n> * [#25152](https://github.com/bitcoin/bitcoin/pull/25152) (refactor: Split util/system into exception, shell, and fs-specific files by Empact)\r\n\r\nReferenced PR is a refactoring PR.  I tried it out in my branch.  Only merge conflict here is to `src/Makefile.test.include` (and it's not a \"real\" conflict: just two lines changed, one in each PR, which happen to be adjacent (due to the alphabet)) which will be easily merged whichever PR lands first.\r\n\r\n",
      "user": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1136260199",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25097"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6672223442,
      "node_id": "HRFPE_lADOABII585JT61QzwAAAAGNsgzS",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6672223442",
      "actor": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-05-24T20:42:00Z"
    },
    {
      "event": "referenced",
      "id": 6685306376,
      "node_id": "REFE_lADOABII585JT61QzwAAAAGOea4I",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6685306376",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "cacbdbaa95317b45cf2100702bca92410fb43b9a",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cacbdbaa95317b45cf2100702bca92410fb43b9a",
      "created_at": "2022-05-26T12:34:38Z"
    },
    {
      "event": "referenced",
      "id": 6697616888,
      "node_id": "REFE_lADOABII585JT61QzwAAAAGPNYX4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6697616888",
      "actor": {
        "login": "sidhujag",
        "id": 6238042,
        "node_id": "MDQ6VXNlcjYyMzgwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6238042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sidhujag",
        "html_url": "https://github.com/sidhujag",
        "followers_url": "https://api.github.com/users/sidhujag/followers",
        "following_url": "https://api.github.com/users/sidhujag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sidhujag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sidhujag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sidhujag/subscriptions",
        "organizations_url": "https://api.github.com/users/sidhujag/orgs",
        "repos_url": "https://api.github.com/users/sidhujag/repos",
        "events_url": "https://api.github.com/users/sidhujag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sidhujag/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "85b89f342629712facb99e81667c6627d8d140a4",
      "commit_url": "https://api.github.com/repos/syscoin/syscoin/commits/85b89f342629712facb99e81667c6627d8d140a4",
      "created_at": "2022-05-28T22:51:04Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDEyYWUzMzcwOGVlMTk3OGUyYTIxNTk1NGU0MWU2Y2NmNGYwYTI1ZmQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/12ae33708ee1978e2a215954e41e6ccf4f0a25fd",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/12ae33708ee1978e2a215954e41e6ccf4f0a25fd",
      "tree": {
        "sha": "bc2596873d254052b71d8400e7c44c81a64a5ccc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bc2596873d254052b71d8400e7c44c81a64a5ccc"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/695ca641a4e3ae065121815a968c769198aa73de",
          "sha": "695ca641a4e3ae065121815a968c769198aa73de",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/695ca641a4e3ae065121815a968c769198aa73de"
        }
      ],
      "message": "Add new test utility methods; break out some existing ones\n\n- Add new test utility methods for use in various unit tests.\n- Refactor some existing methods out of tests where they're currently\n  embedded into the test util area.\n- Ensure that the conversions of string name to/from ScriptError_t have\n  all the defined enum values.\n- And provide unit tests for the whole shebang.",
      "committer": {
        "name": "David Bakin",
        "email": "david@bakins-bits.com",
        "date": "2022-06-05T01:33:14Z"
      },
      "author": {
        "name": "David Bakin",
        "email": "david@bakins-bits.com",
        "date": "2022-06-05T01:32:12Z"
      },
      "sha": "12ae33708ee1978e2a215954e41e6ccf4f0a25fd"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGVlZWZlYzM0MzU5MmM2ZGU4NTA0OGUzYjA1NWJhNDk3NTVjZmIwNzI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/eeefec343592c6de85048e3b055ba49755cfb072",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/eeefec343592c6de85048e3b055ba49755cfb072",
      "tree": {
        "sha": "b567daaaf357a8081fa59e4aeeda492d28c76623",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b567daaaf357a8081fa59e4aeeda492d28c76623"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/12ae33708ee1978e2a215954e41e6ccf4f0a25fd",
          "sha": "12ae33708ee1978e2a215954e41e6ccf4f0a25fd",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/12ae33708ee1978e2a215954e41e6ccf4f0a25fd"
        }
      ],
      "message": "Unit tests for Tap{root,script} of `interpreter.cpp`, #23279\n\nThis commit provides unit tests for Taproot functionality in\n`script/interpreter.cpp`, #23279.\n\nGoal is to show correctness vs specifications in BIPs 341/342, and to\nimprove code coverage in Taproot functionality there.\n\nIntent is to unit test completely without changing `interpreter.cpp`\nitself to provide visibility into static functions/private methods.\nThus some of the tests must be \"indirect\", testing the unit-under-test\nby probing a visible caller. This makes those specific somewhat fragile\nas they depend on code paths in the caller, which may change in the\nfuture.  However, such tests are written so they will fail if the\nunit-under-test isn't actually called. This is noted in the code of\nthose specific tests.\n\nNo changes to Bitcoin Core are made - just unit tests added. The\nBoost Test framework file `boost/test/execution_monitor.hpp` was\nadded to the lint whitelist - this is acceptable because it is a\ndocumented public header of the Boost Test framework, which is\nalready part of the project.\n\n- [x] `EvalChecksigTapscript`\n- [x] `HandleMissingData`\n- [x] `SignatureHashSchnorr` - now with full _path_ coverage\n- [x] `GenericTransactionSignatureChecker<T>::VerifySchnorrSignature`\n- [x] `GenericTransactionSignatureChecker<T>::CheckSchnorrSignature`\n- [x] `ComputeTaprootMerkleRoot`\n- [ ] `SigVersion::TAPSCRIPT` code paths in `ExecuteWitnessScript`\n- [x] Taproot code paths in `VerifyWitnessProgram`\n- [ ] Tapscript code paths in `VerifyWitnessProgram`\n\n**TODO:** Full Tapscript (BIP-342) unit tests yet to be completed.\n**TODO:** Does anything need to be done with `libconsensus`? Please advise!\n\n**N.B.:** These unit tests include \"death tests\" (name comes from\nGoogletest framework): Tests that check that an `assert` actually\nfails.  These are handled with a Boost `execution_monitor`\n(mentioned above) but the asserts _still issue messages_ even when\nby correctly trapped by the Boost Test framework.  You'll see the following:\n\n```\ngitpod /workspace/bitcoin/src/test (23279-taproot-unit-tests) $ ./test_bitcoin\nRunning 527 test cases...\ntest_bitcoin: script/interpreter.cpp:1495: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `false' failed.\ntest_bitcoin: script/interpreter.cpp:1497: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `in_pos < tx_to.vin.size()' failed.\ntest_bitcoin: script/interpreter.cpp:1528: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `execdata.m_annex_init' failed.\ntest_bitcoin: script/interpreter.cpp:1556: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `execdata.m_tapleaf_hash_init' failed.\ntest_bitcoin: script/interpreter.cpp:1559: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `execdata.m_codeseparator_pos_init' failed.\ntest_bitcoin: script/interpreter.cpp:1469: bool HandleMissingData(MissingDataBehavior): Assertion `!\"Missing data\"' failed.\ntest_bitcoin: script/interpreter.cpp:1474: bool HandleMissingData(MissingDataBehavior): Assertion `!\"Unknown MissingDataBehavior value\"' failed.\n\n*** No errors detected\ngitpod /workspace/bitcoin/src/test (23279-taproot-unit-tests) $\n```\n\nThese specific `Assertion ... failed` messages are _expected_.  The\ntests triggering them properly _pass_ iff the `assert` (and no other)\nis _triggered_.",
      "committer": {
        "name": "David Bakin",
        "email": "david@bakins-bits.com",
        "date": "2022-06-05T05:03:58Z"
      },
      "author": {
        "name": "David Bakin",
        "email": "david@bakins-bits.com",
        "date": "2022-06-05T02:51:38Z"
      },
      "sha": "eeefec343592c6de85048e3b055ba49755cfb072"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 6744129272,
      "node_id": "HRFPE_lADOABII585JT61QzwAAAAGR-z74",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6744129272",
      "actor": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-05T16:29:59Z"
    },
    {
      "event": "renamed",
      "id": 6744207105,
      "node_id": "RTE_lADOABII585JT61QzwAAAAGR_G8B",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6744207105",
      "actor": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-05T17:48:18Z",
      "rename": {
        "from": "[WIP] test: Unit tests for taproot/tapscript coverage in `interpreter.cpp`",
        "to": "test: Unit tests for taproot/tapscript coverage in `interpreter.cpp`"
      }
    },
    {
      "event": "ready_for_review",
      "id": 6744207388,
      "node_id": "RFRE_lADOABII585JT61QzwAAAAGR_HAc",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6744207388",
      "actor": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-05T17:48:34Z"
    },
    {
      "event": "commented",
      "id": 1147041689,
      "node_id": "IC_kwDOABII585EXneZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1147041689",
      "actor": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-06-06T04:50:22Z",
      "updated_at": "2022-06-06T04:53:40Z",
      "author_association": "CONTRIBUTOR",
      "body": "DrahtBot said:\r\n> ### Conflicts\r\n> Reviewers, this pull request conflicts with the following ones:\r\n> \r\n> * [#22793](https://github.com/bitcoin/bitcoin/pull/22793) (Simplify BaseSignatureChecker virtual functions and GenericTransactionSignatureChecker constructors by achow101)\r\n\r\nReferenced PR updates `BaseSignatureChecker` and `GenericSignatureChecker` which are used in these tests, and also various the internals of some routines in `interpreter.cpp` including `CheckSchnorrSignature`.\r\n\r\nMost of the resulting conflicts are easy to resolve; the tricky one was the update to `CheckSchnorrSignature` which changed its behavior in such a way that one of these tests became invalid.\r\n- This was exactly the case I was referring to in the PR header comment when I said:\r\n  \r\n  > This makes those specific tests somewhat fragile as they depend on code paths in the caller, which may change in the future. However, such tests are written so they will fail if the unit-under-test isn't actually called. This is noted in the code of those specific tests.\r\n\r\n  And naturally it was immediately hit! But it was also easily fixable.\r\n\r\nSo in fact I am ready to update this PR if #22793 lands first.  And also, _except_ for that, I can update this code _now_ so that there won't be any conflict if #22793 lands later.\r\n\r\n(I am of the opinion that there are routines in `interpreter.cpp` which are defined there `static` which needn't be.  They could just be file-scoped.  And thus these unit tests could call them _directly_ (by providing the prototype) and test them _directly_ rather than having to go indirectly through `CheckSchnorrSignature`, and so on.  But I didn't want to change `interpreter.cpp` to add unit tests after-the-fact.  I thought it would make it easier to get approvals for _this_ PR if I didn't make changes _there_.)",
      "user": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1147041689",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25097"
    },
    {
      "event": "reviewed",
      "id": 1033377314,
      "node_id": "PRR_kwDOABII5849mBYi",
      "url": null,
      "actor": null,
      "commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#pullrequestreview-1033377314",
      "submitted_at": "2022-07-08T20:58:11Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
    },
    {
      "event": "reviewed",
      "id": 1033389106,
      "node_id": "PRR_kwDOABII5849mEQy",
      "url": null,
      "actor": null,
      "commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Partial review done\r\n\r\nCode is high quality so far (if not a little complex), and I really like the look of these tests. Will finish review early next week, probably Monday. \r\n\r\n---\r\n\r\n\r\n- [x] 12ae33708e Add new test utility methods; break out some existing ones\r\n\r\nA lot of this code is fairly elaborate in terms of use of C++ templating\r\nfeatures - for example, all the machinations necessary to get `Hex()` to work -\r\nwhich I think I'd be hesitant to include in non-test code. But since these are\r\ntests, the complexity/convenience trade-off seems okay.\r\n\r\n- [ ] eeefec3435 Unit tests for Tap{root,script} of `interpreter.cpp`, #23279",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#pullrequestreview-1033389106",
      "submitted_at": "2022-07-08T21:37:17Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
    },
    {
      "event": "commented",
      "id": 1180497110,
      "node_id": "IC_kwDOABII585GXPTW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1180497110",
      "actor": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-07-11T14:41:11Z",
      "updated_at": "2022-07-11T14:41:11Z",
      "author_association": "CONTRIBUTOR",
      "body": "> Partial review done\r\n\r\nAddressing these comments now.\r\n\r\n> \r\n> Code is high quality so far (if not a little complex), and I really like the look of these tests. Will finish review early next week, probably Monday.\r\n\r\nThank you, and looking forward to more comments!\r\n\r\nIs it preferred (i.e., do you prefer) squashing _during_ a review or should I fix things in an additional commit on top of this one while you're in progress and squash it later?",
      "user": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1180497110",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25097"
    },
    {
      "event": "commented",
      "id": 1181773388,
      "node_id": "IC_kwDOABII585GcG5M",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1181773388",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-07-12T13:39:11Z",
      "updated_at": "2022-07-12T13:39:11Z",
      "author_association": "MEMBER",
      "body": "> Is it preferred (i.e., do you prefer) squashing during a review or should I fix things in an additional commit on top of this one while you're in progress and squash it later?\r\n\r\nTypically squashes are done immediately because if you squash at some point later, all reviewers will have to re-review to ensure that the code hasn't actually changed unexpectedly during the squash.",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1181773388",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25097"
    },
    {
      "event": "reviewed",
      "id": 1036328057,
      "node_id": "PRR_kwDOABII5849xRx5",
      "url": null,
      "actor": null,
      "commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "approach ACK eeefec343592c6de85048e3b055ba49755cfb072 ([`jamesob/ackr/25097.1.david-bakin.test_unit_tests_for_tapr`](https://github.com/jamesob/bitcoin/tree/ackr/25097.1.david-bakin.test_unit_tests_for_tapr))\r\n\r\nWow, thanks for this contribution @david-bakin. These are some really\r\nfine-grained tests for various Taproot related parts of the script interpreter.\r\nThe code here is very readable and seems nicely extensible. Clearly a\r\nlot of work went into this.\r\n\r\nFor many parts of the codebase, this sort of testing would be overkill IMO\r\nbecause it is so tightly coupled to the tested code. But in the case of script\r\ninterpretation - debatably the heart of bitcoin validation - I think it's\r\nworthwhile to have painstakingly involved tests at the cost of slight\r\nmaintenance burden if the underlying code happens to change somehow. Maybe\r\nsomeone more experienced than me w.r.t. changing the script interpreter can\r\nweigh in here and confirm my intuition.\r\n\r\nAll of my comments are pretty minor. I'd say it might be wortwhile to break\r\nout the `Parse*()` `optional` changes in the second commit either into their own\r\ncommit, or as I mentioned in a previous review, fold it into the first.",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#pullrequestreview-1036328057",
      "submitted_at": "2022-07-12T20:25:07Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
    },
    {
      "event": "commented",
      "id": 1203703815,
      "node_id": "IC_kwDOABII585HvxAH",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1203703815",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-08-03T09:24:15Z",
      "updated_at": "2022-08-03T09:24:15Z",
      "author_association": "MEMBER",
      "body": "<!--cf906140f33d8803c4a75a2196329ecb-->\n🐙 This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1203703815",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25097"
    },
    {
      "event": "labeled",
      "id": 7116900041,
      "node_id": "LE_lADOABII585JT61QzwAAAAGoM0bJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7116900041",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-08-03T09:24:15Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 1276634618,
      "node_id": "IC_kwDOABII585MF-X6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1276634618",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-12T19:20:22Z",
      "updated_at": "2022-10-12T19:20:22Z",
      "author_association": "MEMBER",
      "body": "Are you still working on this?",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1276634618",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25097"
    },
    {
      "event": "commented",
      "id": 1276671362,
      "node_id": "IC_kwDOABII585MGHWC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1276671362",
      "actor": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-12T20:00:58Z",
      "updated_at": "2022-10-12T20:00:58Z",
      "author_association": "CONTRIBUTOR",
      "body": "yes sorry - i will update by tomorrow!\n\n\nOn Wed, Oct 12, 2022 at 12:21 PM Andrew Chow ***@***.***>\nwrote:\n\n> Are you still working on this?\n>\n> —\n> Reply to this email directly, view it on GitHub\n> <https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1276634618>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AA7YLBE6IOKK4MJDCZ47JYDWC4FUPANCNFSM5VOZLXLQ>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> ***@***.***>\n>\n",
      "user": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1276671362",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25097"
    },
    {
      "event": "commented",
      "id": 1310624464,
      "node_id": "IC_kwDOABII585OHorQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1310624464",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-10T17:16:20Z",
      "updated_at": "2022-11-10T17:16:20Z",
      "author_association": "MEMBER",
      "body": "> yes sorry - i will update by tomorrow!\r\n\r\nIt's been several weeks since this comment with no additional updates, so I'm going to close this for now. If you do get around to working on this, please leave a comment so that it can be reopened.",
      "user": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1310624464",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25097"
    },
    {
      "event": "closed",
      "id": 7785440801,
      "node_id": "CE_lADOABII585JT61QzwAAAAHQDGYh",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7785440801",
      "actor": {
        "login": "achow101",
        "id": 3782274,
        "node_id": "MDQ6VXNlcjM3ODIyNzQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3782274?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/achow101",
        "html_url": "https://github.com/achow101",
        "followers_url": "https://api.github.com/users/achow101/followers",
        "following_url": "https://api.github.com/users/achow101/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/achow101/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/achow101/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/achow101/subscriptions",
        "organizations_url": "https://api.github.com/users/achow101/orgs",
        "repos_url": "https://api.github.com/users/achow101/repos",
        "events_url": "https://api.github.com/users/achow101/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/achow101/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-10T17:16:20Z"
    },
    {
      "event": "commented",
      "id": 1310840025,
      "node_id": "IC_kwDOABII585OIdTZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1310840025",
      "actor": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-10T20:12:09Z",
      "updated_at": "2022-11-10T20:12:09Z",
      "author_association": "MEMBER",
      "body": "Sad to see this closed as it contains some novel unittest coverage. Please feel free to reopen with updates @david-bakin. Hopefully others will step in to review as well.",
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1310840025",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25097"
    },
    {
      "event": "mentioned",
      "id": 7786717573,
      "node_id": "MEE_lADOABII585JT61QzwAAAAHQH-GF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7786717573",
      "actor": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-10T20:12:09Z"
    },
    {
      "event": "subscribed",
      "id": 7786717578,
      "node_id": "SE_lADOABII585JT61QzwAAAAHQH-GK",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7786717578",
      "actor": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-10T20:12:09Z"
    },
    {
      "event": "commented",
      "id": 1310912439,
      "node_id": "IC_kwDOABII585OIu-3",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1310912439",
      "actor": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-10T21:27:40Z",
      "updated_at": "2022-11-10T21:27:40Z",
      "author_association": "CONTRIBUTOR",
      "body": "Soon! Tied up temporarily\n\nOn Thu, Nov 10, 2022, 12:12 jamesob ***@***.***> wrote:\n\n> Sad to see this closed as it contains some novel unittest coverage. Please\n> feel free to reopen with updates @david-bakin\n> <https://github.com/david-bakin>. Hopefully others will step in to review\n> as well.\n>\n> —\n> Reply to this email directly, view it on GitHub\n> <https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1310840025>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AA7YLBHXF2WHJN3HJ2HN4E3WHVJKNANCNFSM5VOZLXLQ>\n> .\n> You are receiving this because you were mentioned.Message ID:\n> ***@***.***>\n>\n",
      "user": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1310912439",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/25097"
    },
    {
      "event": "mentioned",
      "id": 7787191240,
      "node_id": "MEE_lADOABII585JT61QzwAAAAHQJxvI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7787191240",
      "actor": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-10T21:27:40Z"
    },
    {
      "event": "subscribed",
      "id": 7787191251,
      "node_id": "SE_lADOABII585JT61QzwAAAAHQJxvT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7787191251",
      "actor": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-10T21:27:41Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/875574299",
      "pull_request_review_id": 976500374,
      "id": 875574299,
      "node_id": "PRRC_kwDOABII5840MDQb",
      "diff_hunk": "@@ -0,0 +1,1546 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <script/script_error.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/transaction_utils.h>\n+#include <util/strencodings.h>\n+#include <univalue.h>\n+\n+#include <boost/test/execution_monitor.hpp>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <array>\n+#include <charconv>\n+#include <cstddef>\n+#include <stdexcept>\n+#include <iomanip>\n+#include <iterator>\n+#include <limits>\n+#include <ostream>\n+#include <set>\n+#include <string_view>\n+#include <string>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+using namespace std::literals::string_literals;\n+using namespace std::literals::string_view_literals;\n+\n+namespace {\n+\n+typedef std::vector<unsigned char> valtype;\n+\n+/**\n+ * Value/Name pair used in data-driven tests\n+ */\n+template <typename T>\n+struct vn_pair\n+{\n+    vn_pair(T v, std::string_view n) : value(v), name(n) {}\n+\n+    const T value;\n+    const std::string_view name;\n+};\n+\n+/**\n+ * Sequence of value/name pairs used in data-driven tests\n+ */\n+template <typename T>\n+using vn_sequence = std::vector<vn_pair<T>>;\n+\n+/**\n+ * Invokes undefined behavior.  See `std::unreachable` in C++23.\n+ */\n+[[noreturn]] inline void declare_unreachable()\n+{\n+#ifdef _MSC_VER\n+    __assume(false);\n+#else\n+    // Assume all other compilers than MSVC implement this GCC builtin.\n+    __builtin_unreachable();\n+#endif\n+}\n+\n+/**\n+ * Outputs to stream as hex\n+ */\n+template <typename US>\n+struct hex\n+{\n+    hex(US v) : value(v) {}\n+    const US value;\n+\n+    friend std::ostream& operator<<(std::ostream& os, hex hx)\n+    {\n+        auto flags = os.flags();\n+        os << std::setw(2*sizeof(US)) << std::setfill('0') << std::showbase\n+           << std::hex << +hx.value;\n+        os.flags(flags);\n+        return os;\n+    }\n+};\n+\n+/**\n+ * Representation changer to fill an integral type with a known pattern.\n+ *\n+ * Pattern is successive byte values given a starting point.  Endianness doesn't\n+ * matter.\n+ */\n+union FillWithPattern {\n+    uint256 u256{0};\n+    uint64_t u64raw[sizeof(uint256)/sizeof(uint64_t)];\n+    uint32_t u32[sizeof(uint256)/sizeof(uint32_t)];\n+    int32_t i32[sizeof(uint256)/sizeof(int32_t)];\n+    uint8_t u8[sizeof(uint256)];\n+\n+    constexpr FillWithPattern(uint8_t start)\n+    {\n+        for (auto it = std::begin(u8); it != std::end(u8); ++it) {\n+            *it = start++;\n+        }\n+    }\n+\n+    uint64_t u64() const {\n+        // It is desirable to force high bit off\n+        return u64raw[0] & static_cast<uint64_t>(std::numeric_limits<int64_t>::max());\n+    }\n+};\n+\n+} // anon namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(script_tapscript_tests, BasicTestingSetup)\n+\n+/**\n+ * Testing EvalScript OP_CHECKSIGADD branch and EvalChecksigTapscript, both in\n+ * interpreter.cpp, against the BIP342 \"Rules for signature opcodes\".\n+ */\n+BOOST_AUTO_TEST_CASE(eval_checksigadd_basic_checks)\n+{\n+    const valtype SIG_64BYTES(64, 0);  // N.B.: Must be () not {}!\n+    const valtype SIG_65BYTES(65, 0);\n+    const valtype SIG_EMPTY{};\n+\n+    const valtype PUBKEY_32BYTES(32, 0);\n+    const valtype PUBKEY_15BYTES(15, 0);\n+    const valtype PUBKEY_EMPTY{};\n+\n+    constexpr int64_t TEST_NUM = 10;\n+\n+    constexpr int64_t START_VALIDATION_WEIGHT{ 90 };\n+    constexpr int64_t BIP342_SIGOPS_LIMIT{ 50 };\n+    constexpr int64_t END_VALIDATION_WEIGHT{ START_VALIDATION_WEIGHT - BIP342_SIGOPS_LIMIT };\n+\n+    /**\n+     * For these tests don't need _real_ signature/pubkey validation.  That is\n+     * tested elsewhere.  So we just _mock_ the signature checker and force it\n+     * to answer valid/invalid as we wish.\n+     */\n+\n+    struct SignatureCheckerMock : public BaseSignatureChecker\n+    {\n+        //! Whether this mock always validates, or always fails, the signature/pubkey check.\n+        enum class VALIDATION { ALWAYS_SUCCEEDS, ALWAYS_FAILS };\n+        VALIDATION m_kind = VALIDATION::ALWAYS_FAILS;\n+\n+        //! True _iff_ CheckSchnorrSignature was actually called\n+        mutable bool m_was_called = false;\n+\n+        SignatureCheckerMock() {}\n+\n+        bool CheckSchnorrSignature(Span<const unsigned char> sig,\n+                                    Span<const unsigned char> pubkey,\n+                                    SigVersion sigversion,\n+                                    ScriptExecutionData& execdata,\n+                                    ScriptError* serror = nullptr) const override\n+        {\n+            m_was_called = true;\n+            switch (m_kind) {\n+            case VALIDATION::ALWAYS_SUCCEEDS:\n+                *serror = SCRIPT_ERR_OK;\n+                return true;\n+            case VALIDATION::ALWAYS_FAILS:\n+                *serror = SCRIPT_ERR_SCHNORR_SIG;\n+                return false;\n+            }\n+            declare_unreachable();\n+        }\n+    };\n+\n+    /**\n+     * A fluent API for running these tests.\n+     *\n+     * (Easiest way to understand this class is to look at the actual tests\n+     * that follow in this function.)\n+     */\n+    struct Context\n+    {\n+        explicit Context(std::string_view descr) : testDescription(descr) {\n+            execdata.m_validation_weight_left_init = true;\n+            execdata.m_validation_weight_left = START_VALIDATION_WEIGHT;\n+        }\n+\n+        std::string testDescription;\n+        SigVersion sigVersion = SigVersion::TAPSCRIPT;\n+        uint32_t flags = 0;\n+        CScript script;\n+        ScriptError err = SCRIPT_ERR_OK;\n+        std::vector<valtype> stack;\n+        ScriptExecutionData execdata;\n+        SignatureCheckerMock sigchecker;\n+        int64_t callerLine = 0;\n+        bool result = false;\n+\n+        Context& SetVersion(SigVersion v)\n+        {\n+            sigVersion = v;\n+            return *this;\n+        }\n+\n+        Context& SetChecker(SignatureCheckerMock::VALIDATION kind)\n+        {\n+            sigchecker.m_kind = kind;\n+            return *this;\n+        }\n+\n+        Context& SetRemainingWeight(int64_t w)\n+        {\n+            execdata.m_validation_weight_left = w;\n+            return *this;\n+        }\n+\n+        Context& AddFlags(uint32_t f)\n+        {\n+            flags |= f;\n+            return *this;\n+        }\n+\n+        CScript& SetScript()\n+        {\n+            return script;\n+        }\n+\n+        Context& DoTest(int64_t line)\n+        {\n+            callerLine = line;\n+            result = EvalScript(stack, script,\n+                                SCRIPT_VERIFY_TAPROOT | flags,\n+                                sigchecker,\n+                                sigVersion,\n+                                execdata,\n+                                &err);\n+            return *this;\n+        }\n+\n+        Context& CheckCallSucceeded()\n+        {\n+            BOOST_CHECK_MESSAGE(result,\n+                               Descr()\n+                               << \": EvalScript succeeded, as expected\");\n+            BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK,\n+                                Descr()\n+                                << \": Error code expected OK, actual was \"\n+                                << ScriptErrorString(err));\n+            return *this;\n+        }\n+\n+        Context& CheckCallFailed(ScriptError expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!result,\n+                               Descr()\n+                               << \": EvalScript failed, as expected\");\n+            BOOST_CHECK_MESSAGE(err == expected,\n+                                Descr()\n+                                << \": Error code expected \" << ScriptErrorString(expected)\n+                                << \", actual was \" << ScriptErrorString(err));\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(sigchecker.m_was_called,\n+                               Descr()\n+                               << \": CheckSchnorrSignature was called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasNotValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(!sigchecker.m_was_called,\n+                               Descr()\n+                               << \": CheckSchnorrSignature was not called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckRemainingValidationWeight(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(execdata.m_validation_weight_left == expected,\n+                                Descr()\n+                                << \": Remaining validation weight expected \"\n+                                << expected << \", actual was \"\n+                                << execdata.m_validation_weight_left);\n+            return *this;\n+        }\n+\n+        Context& CheckStackDepth(std::size_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(stack.size() == expected,\n+                                Descr()\n+                                << \": Stack depth expected \" << expected\n+                                << \", actual was \" << stack.size());\n+            return *this;\n+        }\n+\n+        Context& CheckTOS(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!stack.empty(),\n+                                Descr()\n+                                << \": Stack expected at least one item, actually was empty\");\n+            const int64_t actual = CScriptNum(stack.at(0), false).GetInt64();\n+            BOOST_CHECK_MESSAGE(expected == actual,\n+                                Descr()\n+                                << \": Top-of-stack expected \" << expected\n+                                << \", actual was \" << actual);\n+            return *this;\n+        }\n+\n+    private:\n+        std::string Descr() {\n+            std::array<char, 24> sline{0};\n+            std::string_view svline(\"\");\n+            // (This seems rather elaborate to avoid locale issues with `std::to_string`. One\n+            // can't help but think the C++ committee could have provided a nicer wrapper for it.)\n+            if (auto [ptr,ec] = std::to_chars(sline.data(), sline.data() + sline.size(),\n+                                            callerLine);\n+                ec == std::errc())\n+            {\n+                svline = std::string_view(sline.data(), ptr - sline.data());\n+            }\n+\n+            std::string descr;\n+            descr.reserve(testDescription.size() + 20);\n+            descr += testDescription;\n+            descr += \" (@\";\n+            descr += svline;\n+            descr += \")\";\n+            return descr;\n+        }\n+    };\n+\n+    {\n+        Context ctx(\"SigVersion must not be BASE\");\n+        ctx.SetVersion(SigVersion::BASE).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"SigVersion must not be WITNESS_V0\");\n+        ctx.SetVersion(SigVersion::WITNESS_V0).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Minimum stack height 3 for OP_CHECKSIGADD\");\n+        ctx.SetScript()\n+            << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_INVALID_STACK_OPERATION)\n+            .CheckStackDepth(2);\n+    }\n+\n+    {\n+        Context ctx(\"`n` (2nd arg) size > 4 must fail\");\n+        // This is probably meant to be a check on the _encoding_ - that it is\n+        // minimal, but it can also be a check on the _value_.  BIP342 doesn't\n+        // say which.  Could be both...\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(10000000000LL) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            // (IMO this is an _unsatisfactory_ error code to return for a required\n+            // BIP342 check, but see the `catch` clause in `EvalScript`)\n+            .CheckCallFailed(SCRIPT_ERR_UNKNOWN_ERROR)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Insufficient validation weight remaining\");\n+        ctx.SetRemainingWeight(BIP342_SIGOPS_LIMIT-1)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + 32byte pubkey skips validation\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + non32byte pubkey skips validation\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey ('unknown pubkey type') _with_ discourage flag fails\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .AddFlags(SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .CheckSignatureWasNotValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation failure forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_FAILS)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_SCHNORR_SIG)\n+            .CheckSignatureWasValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation success forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasValidated()\n+            .CheckRemainingValidationWeight(END_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM+1);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey + empty sig with validation success forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_failure_cases)\n+{\n+    // As defined by BIP-341 Signature Validation Rules\n+    // Here we pick an acceptable SigVersion\n+    const SigVersion sigversion = SigVersion::TAPROOT;\n+\n+    CMutableTransaction tx_to_m;\n+    tx_to_m.vin.push_back(CTxIn());\n+    const uint32_t in_pos{0};\n+\n+    PrecomputedTransactionData cache;\n+    cache.m_bip341_taproot_ready = true;\n+    cache.m_spent_outputs_ready = true;\n+\n+    ScriptExecutionData execdata;\n+    execdata.m_annex_init = true;\n+    execdata.m_annex_present = false;\n+    execdata.m_annex_hash = uint256::ZERO;\n+    execdata.m_tapleaf_hash_init = false;\n+    execdata.m_codeseparator_pos_init = true;\n+\n+    uint256 hash_out{0};\n+\n+    {\n+        // Check all invalid hash_type codes rejected\n+        const std::set<uint8_t> allowable_hash_types{ 0x00, 0x01, 0x02, 0x03, 0x81, 0x82, 0x83 };\n+        for (unsigned ht = 0; ht <= 255; ht++) {\n+            const uint8_t hash_type = static_cast<uint8_t>(ht);\n+            if (allowable_hash_types.find(hash_type) != allowable_hash_types.end()) continue;\n+\n+            BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m, in_pos,\n+                                                      hash_type, sigversion, cache,\n+                                                      MissingDataBehavior::FAIL),\n+                                \"hash_type = \" << hex(hash_type) << \" expected to fail\");\n+        }\n+    }\n+\n+    {\n+        // Check that if hash_type == SIGHASH_SINGLE then missing a \"corresponding\n+        // output\" fails.\n+        CMutableTransaction tx_to_m;\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+\n+        uint8_t in_pos = 1;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(1) > #tx_to==0 is expected to fail\");\n+\n+        tx_to_m.vout.push_back(CTxOut());\n+        in_pos = 2;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(2) > #tx_to==1 is expected to fail\");\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_all_success_paths)\n+{\n+    // Our approach here will be to follow BIP-341's signature algorithm (with\n+    // the BIP-342 extension) doing two things at once:\n+    //   1) We'll set up the input arguments to `SignatureHashSchnorr` function\n+    //      being tested, _and_\n+    //   2) we'll _compute the hash of those fields ourselves_ exaxctly as\n+    //      it is described in BIP-341 and BIP-342.\n+    // Then we can compare the two.  We'll do this in a data-driven way for each\n+    // of the different scenarios that the algorithm supports.\n+    //\n+    // In this way this test achieves 100% _path_ coverage of `SignatureHashSchnorr`\n+    // (not just 100% _branch_ coverage).\n+    // - Sadly, this isn't shown in the `lcov` reports.  There are still a few\n+    //   red `-` marks left.  This is because:\n+    //   1. `lcov` wasn't designed to handle death tests.\n+    //   2. ??? Some other unknown reasons, possibly due to the instrumentation,\n+    //      possibly due to `lcov` limitations.  You can see by the test output\n+    //      (`-log_level=all`) or within a debugger that in fact _all_ branches\n+    //      are taken when executing all the tests in this file.\n+\n+    // Here we define, and then generate, all combinations of the alternatives\n+    // for the parameters that vary the signature combination algorithm\n+\n+    const vn_sequence<SigVersion> SigVersion_alternatives{\n+        {SigVersion::TAPROOT, \"TAPROOT\"sv},\n+        {SigVersion::TAPSCRIPT, \"TAPSCRIPT\"sv}\n+    };\n+\n+    const vn_sequence<uint32_t> hash_type_output_alternatives{\n+        {SIGHASH_DEFAULT, \"SIGHASH_DEFAULT\"sv},\n+        {SIGHASH_ALL, \"SIGHASH_ALL\"sv},\n+        {SIGHASH_NONE, \"SIGHASH_NONE\"sv},\n+        {SIGHASH_SINGLE, \"SIGHASH_SINGLE\"sv}\n+    };\n+\n+    const vn_sequence<uint32_t> hash_type_input_alternatives{\n+        {0, \"N/A\"sv},\n+        {SIGHASH_ANYONECANPAY, \"SIGHASH_ANYONECANPAY\"sv}\n+    };\n+\n+    const vn_sequence<uint8_t> annex_alternatives{\n+        {0, \"no annex\"sv},\n+        {1, \"annex present\"sv}\n+    };\n+\n+    const vn_sequence<bool> output_hash_alternatives{\n+        {false, \"output hash missing\"sv},\n+        {true, \"output hash provided\"sv}\n+    };\n+\n+    {\n+        const int nAlternatives = SigVersion_alternatives.size()\n+                                  * hash_type_output_alternatives.size()\n+                                  * hash_type_input_alternatives.size()\n+                                  * annex_alternatives.size()\n+                                  * output_hash_alternatives.size()\n+                                  - 8 /* exclude SIGHASH_DEFAULT w/ SISHASH_ANYONECANPAY */;\n+\n+        BOOST_TEST_MESSAGE(\"Running \" << nAlternatives << \"scenarios\");",
      "path": "src/test/script_tapscript_tests.cpp",
      "position": null,
      "original_position": 602,
      "commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "original_commit_id": "a5808ce2f05040f740dad313e503624de2e8db93",
      "in_reply_to_id": null,
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Noticed this in the test output.\r\n```suggestion\r\n        BOOST_TEST_MESSAGE(\"Running \" << nAlternatives << \" scenarios\");\r\n```",
      "created_at": "2022-05-18T07:46:30Z",
      "updated_at": "2022-05-18T07:46:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r875574299",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/875574299"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 602,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/876048956",
      "pull_request_review_id": 977185276,
      "id": 876048956,
      "node_id": "PRRC_kwDOABII5840N3I8",
      "diff_hunk": "@@ -0,0 +1,1546 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <script/script_error.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/transaction_utils.h>\n+#include <util/strencodings.h>\n+#include <univalue.h>\n+\n+#include <boost/test/execution_monitor.hpp>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <array>\n+#include <charconv>\n+#include <cstddef>\n+#include <stdexcept>\n+#include <iomanip>\n+#include <iterator>\n+#include <limits>\n+#include <ostream>\n+#include <set>\n+#include <string_view>\n+#include <string>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+using namespace std::literals::string_literals;\n+using namespace std::literals::string_view_literals;\n+\n+namespace {\n+\n+typedef std::vector<unsigned char> valtype;\n+\n+/**\n+ * Value/Name pair used in data-driven tests\n+ */\n+template <typename T>\n+struct vn_pair\n+{\n+    vn_pair(T v, std::string_view n) : value(v), name(n) {}\n+\n+    const T value;\n+    const std::string_view name;\n+};\n+\n+/**\n+ * Sequence of value/name pairs used in data-driven tests\n+ */\n+template <typename T>\n+using vn_sequence = std::vector<vn_pair<T>>;\n+\n+/**\n+ * Invokes undefined behavior.  See `std::unreachable` in C++23.\n+ */\n+[[noreturn]] inline void declare_unreachable()\n+{\n+#ifdef _MSC_VER\n+    __assume(false);\n+#else\n+    // Assume all other compilers than MSVC implement this GCC builtin.\n+    __builtin_unreachable();\n+#endif\n+}\n+\n+/**\n+ * Outputs to stream as hex\n+ */\n+template <typename US>\n+struct hex\n+{\n+    hex(US v) : value(v) {}\n+    const US value;\n+\n+    friend std::ostream& operator<<(std::ostream& os, hex hx)\n+    {\n+        auto flags = os.flags();\n+        os << std::setw(2*sizeof(US)) << std::setfill('0') << std::showbase\n+           << std::hex << +hx.value;\n+        os.flags(flags);\n+        return os;\n+    }\n+};\n+\n+/**\n+ * Representation changer to fill an integral type with a known pattern.\n+ *\n+ * Pattern is successive byte values given a starting point.  Endianness doesn't\n+ * matter.\n+ */\n+union FillWithPattern {\n+    uint256 u256{0};\n+    uint64_t u64raw[sizeof(uint256)/sizeof(uint64_t)];\n+    uint32_t u32[sizeof(uint256)/sizeof(uint32_t)];\n+    int32_t i32[sizeof(uint256)/sizeof(int32_t)];\n+    uint8_t u8[sizeof(uint256)];\n+\n+    constexpr FillWithPattern(uint8_t start)\n+    {\n+        for (auto it = std::begin(u8); it != std::end(u8); ++it) {\n+            *it = start++;\n+        }\n+    }\n+\n+    uint64_t u64() const {\n+        // It is desirable to force high bit off\n+        return u64raw[0] & static_cast<uint64_t>(std::numeric_limits<int64_t>::max());\n+    }\n+};\n+\n+} // anon namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(script_tapscript_tests, BasicTestingSetup)\n+\n+/**\n+ * Testing EvalScript OP_CHECKSIGADD branch and EvalChecksigTapscript, both in\n+ * interpreter.cpp, against the BIP342 \"Rules for signature opcodes\".\n+ */\n+BOOST_AUTO_TEST_CASE(eval_checksigadd_basic_checks)\n+{\n+    const valtype SIG_64BYTES(64, 0);  // N.B.: Must be () not {}!\n+    const valtype SIG_65BYTES(65, 0);\n+    const valtype SIG_EMPTY{};\n+\n+    const valtype PUBKEY_32BYTES(32, 0);\n+    const valtype PUBKEY_15BYTES(15, 0);\n+    const valtype PUBKEY_EMPTY{};\n+\n+    constexpr int64_t TEST_NUM = 10;\n+\n+    constexpr int64_t START_VALIDATION_WEIGHT{ 90 };\n+    constexpr int64_t BIP342_SIGOPS_LIMIT{ 50 };\n+    constexpr int64_t END_VALIDATION_WEIGHT{ START_VALIDATION_WEIGHT - BIP342_SIGOPS_LIMIT };\n+\n+    /**\n+     * For these tests don't need _real_ signature/pubkey validation.  That is\n+     * tested elsewhere.  So we just _mock_ the signature checker and force it\n+     * to answer valid/invalid as we wish.\n+     */\n+\n+    struct SignatureCheckerMock : public BaseSignatureChecker\n+    {\n+        //! Whether this mock always validates, or always fails, the signature/pubkey check.\n+        enum class VALIDATION { ALWAYS_SUCCEEDS, ALWAYS_FAILS };\n+        VALIDATION m_kind = VALIDATION::ALWAYS_FAILS;\n+\n+        //! True _iff_ CheckSchnorrSignature was actually called\n+        mutable bool m_was_called = false;\n+\n+        SignatureCheckerMock() {}\n+\n+        bool CheckSchnorrSignature(Span<const unsigned char> sig,\n+                                    Span<const unsigned char> pubkey,\n+                                    SigVersion sigversion,\n+                                    ScriptExecutionData& execdata,\n+                                    ScriptError* serror = nullptr) const override",
      "path": "src/test/script_tapscript_tests.cpp",
      "position": null,
      "original_position": 163,
      "commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "original_commit_id": "a5808ce2f05040f740dad313e503624de2e8db93",
      "in_reply_to_id": null,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "At some point (maybe before this exits draft state) you might want to run clang format on this whole file.",
      "created_at": "2022-05-18T15:33:38Z",
      "updated_at": "2022-05-18T16:38:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r876048956",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/876048956"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 163,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/876110013",
      "pull_request_review_id": 977185276,
      "id": 876110013,
      "node_id": "PRRC_kwDOABII5840OGC9",
      "diff_hunk": "@@ -0,0 +1,1546 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <script/script_error.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/transaction_utils.h>\n+#include <util/strencodings.h>\n+#include <univalue.h>\n+\n+#include <boost/test/execution_monitor.hpp>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <array>\n+#include <charconv>\n+#include <cstddef>\n+#include <stdexcept>\n+#include <iomanip>\n+#include <iterator>\n+#include <limits>\n+#include <ostream>\n+#include <set>\n+#include <string_view>\n+#include <string>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+using namespace std::literals::string_literals;\n+using namespace std::literals::string_view_literals;\n+\n+namespace {\n+\n+typedef std::vector<unsigned char> valtype;\n+\n+/**\n+ * Value/Name pair used in data-driven tests\n+ */\n+template <typename T>\n+struct vn_pair\n+{\n+    vn_pair(T v, std::string_view n) : value(v), name(n) {}\n+\n+    const T value;\n+    const std::string_view name;\n+};\n+\n+/**\n+ * Sequence of value/name pairs used in data-driven tests\n+ */\n+template <typename T>\n+using vn_sequence = std::vector<vn_pair<T>>;\n+\n+/**\n+ * Invokes undefined behavior.  See `std::unreachable` in C++23.\n+ */\n+[[noreturn]] inline void declare_unreachable()\n+{\n+#ifdef _MSC_VER\n+    __assume(false);\n+#else\n+    // Assume all other compilers than MSVC implement this GCC builtin.\n+    __builtin_unreachable();\n+#endif\n+}\n+\n+/**\n+ * Outputs to stream as hex\n+ */\n+template <typename US>\n+struct hex\n+{\n+    hex(US v) : value(v) {}\n+    const US value;\n+\n+    friend std::ostream& operator<<(std::ostream& os, hex hx)\n+    {\n+        auto flags = os.flags();\n+        os << std::setw(2*sizeof(US)) << std::setfill('0') << std::showbase\n+           << std::hex << +hx.value;\n+        os.flags(flags);\n+        return os;\n+    }\n+};\n+\n+/**\n+ * Representation changer to fill an integral type with a known pattern.\n+ *\n+ * Pattern is successive byte values given a starting point.  Endianness doesn't\n+ * matter.\n+ */\n+union FillWithPattern {\n+    uint256 u256{0};\n+    uint64_t u64raw[sizeof(uint256)/sizeof(uint64_t)];\n+    uint32_t u32[sizeof(uint256)/sizeof(uint32_t)];\n+    int32_t i32[sizeof(uint256)/sizeof(int32_t)];\n+    uint8_t u8[sizeof(uint256)];\n+\n+    constexpr FillWithPattern(uint8_t start)\n+    {\n+        for (auto it = std::begin(u8); it != std::end(u8); ++it) {\n+            *it = start++;\n+        }\n+    }\n+\n+    uint64_t u64() const {\n+        // It is desirable to force high bit off\n+        return u64raw[0] & static_cast<uint64_t>(std::numeric_limits<int64_t>::max());\n+    }\n+};\n+\n+} // anon namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(script_tapscript_tests, BasicTestingSetup)\n+\n+/**\n+ * Testing EvalScript OP_CHECKSIGADD branch and EvalChecksigTapscript, both in\n+ * interpreter.cpp, against the BIP342 \"Rules for signature opcodes\".\n+ */\n+BOOST_AUTO_TEST_CASE(eval_checksigadd_basic_checks)\n+{\n+    const valtype SIG_64BYTES(64, 0);  // N.B.: Must be () not {}!\n+    const valtype SIG_65BYTES(65, 0);\n+    const valtype SIG_EMPTY{};\n+\n+    const valtype PUBKEY_32BYTES(32, 0);\n+    const valtype PUBKEY_15BYTES(15, 0);\n+    const valtype PUBKEY_EMPTY{};\n+\n+    constexpr int64_t TEST_NUM = 10;\n+\n+    constexpr int64_t START_VALIDATION_WEIGHT{ 90 };\n+    constexpr int64_t BIP342_SIGOPS_LIMIT{ 50 };\n+    constexpr int64_t END_VALIDATION_WEIGHT{ START_VALIDATION_WEIGHT - BIP342_SIGOPS_LIMIT };\n+\n+    /**\n+     * For these tests don't need _real_ signature/pubkey validation.  That is\n+     * tested elsewhere.  So we just _mock_ the signature checker and force it\n+     * to answer valid/invalid as we wish.\n+     */\n+\n+    struct SignatureCheckerMock : public BaseSignatureChecker\n+    {\n+        //! Whether this mock always validates, or always fails, the signature/pubkey check.\n+        enum class VALIDATION { ALWAYS_SUCCEEDS, ALWAYS_FAILS };\n+        VALIDATION m_kind = VALIDATION::ALWAYS_FAILS;\n+\n+        //! True _iff_ CheckSchnorrSignature was actually called\n+        mutable bool m_was_called = false;\n+\n+        SignatureCheckerMock() {}\n+\n+        bool CheckSchnorrSignature(Span<const unsigned char> sig,\n+                                    Span<const unsigned char> pubkey,\n+                                    SigVersion sigversion,\n+                                    ScriptExecutionData& execdata,\n+                                    ScriptError* serror = nullptr) const override\n+        {\n+            m_was_called = true;\n+            switch (m_kind) {\n+            case VALIDATION::ALWAYS_SUCCEEDS:\n+                *serror = SCRIPT_ERR_OK;\n+                return true;\n+            case VALIDATION::ALWAYS_FAILS:\n+                *serror = SCRIPT_ERR_SCHNORR_SIG;\n+                return false;\n+            }\n+            declare_unreachable();\n+        }\n+    };\n+\n+    /**\n+     * A fluent API for running these tests.\n+     *\n+     * (Easiest way to understand this class is to look at the actual tests\n+     * that follow in this function.)\n+     */\n+    struct Context\n+    {\n+        explicit Context(std::string_view descr) : testDescription(descr) {\n+            execdata.m_validation_weight_left_init = true;\n+            execdata.m_validation_weight_left = START_VALIDATION_WEIGHT;\n+        }\n+\n+        std::string testDescription;\n+        SigVersion sigVersion = SigVersion::TAPSCRIPT;\n+        uint32_t flags = 0;\n+        CScript script;\n+        ScriptError err = SCRIPT_ERR_OK;\n+        std::vector<valtype> stack;\n+        ScriptExecutionData execdata;\n+        SignatureCheckerMock sigchecker;\n+        int64_t callerLine = 0;\n+        bool result = false;\n+\n+        Context& SetVersion(SigVersion v)\n+        {\n+            sigVersion = v;\n+            return *this;\n+        }\n+\n+        Context& SetChecker(SignatureCheckerMock::VALIDATION kind)\n+        {\n+            sigchecker.m_kind = kind;\n+            return *this;\n+        }\n+\n+        Context& SetRemainingWeight(int64_t w)\n+        {\n+            execdata.m_validation_weight_left = w;\n+            return *this;\n+        }\n+\n+        Context& AddFlags(uint32_t f)\n+        {\n+            flags |= f;\n+            return *this;\n+        }\n+\n+        CScript& SetScript()\n+        {\n+            return script;\n+        }\n+\n+        Context& DoTest(int64_t line)\n+        {\n+            callerLine = line;\n+            result = EvalScript(stack, script,\n+                                SCRIPT_VERIFY_TAPROOT | flags,\n+                                sigchecker,\n+                                sigVersion,\n+                                execdata,\n+                                &err);\n+            return *this;\n+        }\n+\n+        Context& CheckCallSucceeded()\n+        {\n+            BOOST_CHECK_MESSAGE(result,\n+                               Descr()\n+                               << \": EvalScript succeeded, as expected\");\n+            BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK,\n+                                Descr()\n+                                << \": Error code expected OK, actual was \"\n+                                << ScriptErrorString(err));\n+            return *this;\n+        }\n+\n+        Context& CheckCallFailed(ScriptError expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!result,\n+                               Descr()\n+                               << \": EvalScript failed, as expected\");\n+            BOOST_CHECK_MESSAGE(err == expected,\n+                                Descr()\n+                                << \": Error code expected \" << ScriptErrorString(expected)\n+                                << \", actual was \" << ScriptErrorString(err));\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(sigchecker.m_was_called,\n+                               Descr()\n+                               << \": CheckSchnorrSignature was called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasNotValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(!sigchecker.m_was_called,\n+                               Descr()\n+                               << \": CheckSchnorrSignature was not called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckRemainingValidationWeight(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(execdata.m_validation_weight_left == expected,\n+                                Descr()\n+                                << \": Remaining validation weight expected \"\n+                                << expected << \", actual was \"\n+                                << execdata.m_validation_weight_left);\n+            return *this;\n+        }\n+\n+        Context& CheckStackDepth(std::size_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(stack.size() == expected,\n+                                Descr()\n+                                << \": Stack depth expected \" << expected\n+                                << \", actual was \" << stack.size());\n+            return *this;\n+        }\n+\n+        Context& CheckTOS(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!stack.empty(),\n+                                Descr()\n+                                << \": Stack expected at least one item, actually was empty\");\n+            const int64_t actual = CScriptNum(stack.at(0), false).GetInt64();\n+            BOOST_CHECK_MESSAGE(expected == actual,\n+                                Descr()\n+                                << \": Top-of-stack expected \" << expected\n+                                << \", actual was \" << actual);\n+            return *this;\n+        }\n+\n+    private:\n+        std::string Descr() {\n+            std::array<char, 24> sline{0};\n+            std::string_view svline(\"\");\n+            // (This seems rather elaborate to avoid locale issues with `std::to_string`. One\n+            // can't help but think the C++ committee could have provided a nicer wrapper for it.)\n+            if (auto [ptr,ec] = std::to_chars(sline.data(), sline.data() + sline.size(),\n+                                            callerLine);\n+                ec == std::errc())\n+            {\n+                svline = std::string_view(sline.data(), ptr - sline.data());\n+            }\n+\n+            std::string descr;\n+            descr.reserve(testDescription.size() + 20);\n+            descr += testDescription;\n+            descr += \" (@\";\n+            descr += svline;\n+            descr += \")\";\n+            return descr;\n+        }\n+    };\n+\n+    {\n+        Context ctx(\"SigVersion must not be BASE\");\n+        ctx.SetVersion(SigVersion::BASE).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"SigVersion must not be WITNESS_V0\");\n+        ctx.SetVersion(SigVersion::WITNESS_V0).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Minimum stack height 3 for OP_CHECKSIGADD\");\n+        ctx.SetScript()\n+            << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_INVALID_STACK_OPERATION)\n+            .CheckStackDepth(2);\n+    }\n+\n+    {\n+        Context ctx(\"`n` (2nd arg) size > 4 must fail\");\n+        // This is probably meant to be a check on the _encoding_ - that it is\n+        // minimal, but it can also be a check on the _value_.  BIP342 doesn't\n+        // say which.  Could be both...\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(10000000000LL) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            // (IMO this is an _unsatisfactory_ error code to return for a required\n+            // BIP342 check, but see the `catch` clause in `EvalScript`)\n+            .CheckCallFailed(SCRIPT_ERR_UNKNOWN_ERROR)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Insufficient validation weight remaining\");\n+        ctx.SetRemainingWeight(BIP342_SIGOPS_LIMIT-1)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + 32byte pubkey skips validation\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + non32byte pubkey skips validation\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey ('unknown pubkey type') _with_ discourage flag fails\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .AddFlags(SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .CheckSignatureWasNotValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation failure forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_FAILS)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_SCHNORR_SIG)\n+            .CheckSignatureWasValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation success forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasValidated()\n+            .CheckRemainingValidationWeight(END_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM+1);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey + empty sig with validation success forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_failure_cases)\n+{\n+    // As defined by BIP-341 Signature Validation Rules\n+    // Here we pick an acceptable SigVersion\n+    const SigVersion sigversion = SigVersion::TAPROOT;\n+\n+    CMutableTransaction tx_to_m;\n+    tx_to_m.vin.push_back(CTxIn());\n+    const uint32_t in_pos{0};\n+\n+    PrecomputedTransactionData cache;\n+    cache.m_bip341_taproot_ready = true;\n+    cache.m_spent_outputs_ready = true;\n+\n+    ScriptExecutionData execdata;\n+    execdata.m_annex_init = true;\n+    execdata.m_annex_present = false;\n+    execdata.m_annex_hash = uint256::ZERO;\n+    execdata.m_tapleaf_hash_init = false;\n+    execdata.m_codeseparator_pos_init = true;\n+\n+    uint256 hash_out{0};\n+\n+    {\n+        // Check all invalid hash_type codes rejected\n+        const std::set<uint8_t> allowable_hash_types{ 0x00, 0x01, 0x02, 0x03, 0x81, 0x82, 0x83 };\n+        for (unsigned ht = 0; ht <= 255; ht++) {\n+            const uint8_t hash_type = static_cast<uint8_t>(ht);\n+            if (allowable_hash_types.find(hash_type) != allowable_hash_types.end()) continue;\n+\n+            BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m, in_pos,\n+                                                      hash_type, sigversion, cache,\n+                                                      MissingDataBehavior::FAIL),\n+                                \"hash_type = \" << hex(hash_type) << \" expected to fail\");\n+        }\n+    }\n+\n+    {\n+        // Check that if hash_type == SIGHASH_SINGLE then missing a \"corresponding\n+        // output\" fails.\n+        CMutableTransaction tx_to_m;\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+\n+        uint8_t in_pos = 1;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(1) > #tx_to==0 is expected to fail\");\n+\n+        tx_to_m.vout.push_back(CTxOut());\n+        in_pos = 2;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(2) > #tx_to==1 is expected to fail\");\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_all_success_paths)\n+{\n+    // Our approach here will be to follow BIP-341's signature algorithm (with\n+    // the BIP-342 extension) doing two things at once:\n+    //   1) We'll set up the input arguments to `SignatureHashSchnorr` function\n+    //      being tested, _and_\n+    //   2) we'll _compute the hash of those fields ourselves_ exaxctly as\n+    //      it is described in BIP-341 and BIP-342.\n+    // Then we can compare the two.  We'll do this in a data-driven way for each\n+    // of the different scenarios that the algorithm supports.\n+    //\n+    // In this way this test achieves 100% _path_ coverage of `SignatureHashSchnorr`\n+    // (not just 100% _branch_ coverage).\n+    // - Sadly, this isn't shown in the `lcov` reports.  There are still a few\n+    //   red `-` marks left.  This is because:\n+    //   1. `lcov` wasn't designed to handle death tests.\n+    //   2. ??? Some other unknown reasons, possibly due to the instrumentation,\n+    //      possibly due to `lcov` limitations.  You can see by the test output\n+    //      (`-log_level=all`) or within a debugger that in fact _all_ branches\n+    //      are taken when executing all the tests in this file.\n+\n+    // Here we define, and then generate, all combinations of the alternatives\n+    // for the parameters that vary the signature combination algorithm\n+\n+    const vn_sequence<SigVersion> SigVersion_alternatives{\n+        {SigVersion::TAPROOT, \"TAPROOT\"sv},\n+        {SigVersion::TAPSCRIPT, \"TAPSCRIPT\"sv}\n+    };\n+\n+    const vn_sequence<uint32_t> hash_type_output_alternatives{\n+        {SIGHASH_DEFAULT, \"SIGHASH_DEFAULT\"sv},\n+        {SIGHASH_ALL, \"SIGHASH_ALL\"sv},\n+        {SIGHASH_NONE, \"SIGHASH_NONE\"sv},\n+        {SIGHASH_SINGLE, \"SIGHASH_SINGLE\"sv}\n+    };\n+\n+    const vn_sequence<uint32_t> hash_type_input_alternatives{\n+        {0, \"N/A\"sv},\n+        {SIGHASH_ANYONECANPAY, \"SIGHASH_ANYONECANPAY\"sv}\n+    };\n+\n+    const vn_sequence<uint8_t> annex_alternatives{\n+        {0, \"no annex\"sv},\n+        {1, \"annex present\"sv}\n+    };\n+\n+    const vn_sequence<bool> output_hash_alternatives{\n+        {false, \"output hash missing\"sv},\n+        {true, \"output hash provided\"sv}\n+    };\n+\n+    {\n+        const int nAlternatives = SigVersion_alternatives.size()\n+                                  * hash_type_output_alternatives.size()\n+                                  * hash_type_input_alternatives.size()\n+                                  * annex_alternatives.size()\n+                                  * output_hash_alternatives.size()\n+                                  - 8 /* exclude SIGHASH_DEFAULT w/ SISHASH_ANYONECANPAY */;\n+\n+        BOOST_TEST_MESSAGE(\"Running \" << nAlternatives << \"scenarios\");\n+    }\n+\n+    for (const auto& sigversion_alternative : SigVersion_alternatives)\n+    for (const auto& hash_type_output_alternative : hash_type_output_alternatives)\n+    for (const auto& hash_type_input_alternative : hash_type_input_alternatives)\n+    for (const auto& annex_alternative : annex_alternatives)\n+    for (const auto& output_hash_alternative : output_hash_alternatives)\n+    {\n+        // Exclude the invalid combination of SIGHASH_DEFAULT with SIGHASH_ANYONECANPAY\n+        if (hash_type_output_alternative.value == SIGHASH_DEFAULT\n+            && hash_type_input_alternative.value == SIGHASH_ANYONECANPAY) continue;\n+\n+        // We're going to want to know which scenario it is if a check actually\n+        // fails ...\n+        std::string scenario_description;\n+        {\n+            std::ostringstream oss;\n+            oss << sigversion_alternative.name << \", \"\n+                << hash_type_output_alternative.name << \", \"\n+                << hash_type_input_alternative.name << \", \"\n+                << annex_alternative.name << \", \"\n+                << output_hash_alternative.name;\n+            scenario_description = oss.str();\n+        }\n+        BOOST_TEST_MESSAGE(\"Scenario: \" << scenario_description);\n+\n+        // Set up the scenario we're running now - these 4 variables define the scenario\n+        const SigVersion sigversion{sigversion_alternative.value};\n+        const uint8_t hash_type{static_cast<uint8_t>(hash_type_output_alternative.value\n+                                                   | hash_type_input_alternative.value)};\n+        const uint8_t annex_present{annex_alternative.value};\n+        const bool have_output_hash{output_hash_alternative.value};\n+\n+        // Compute some helper values that depend on scenario\n+        const uint8_t ext_flag{sigversion == SigVersion::TAPSCRIPT};\n+        const uint8_t hash_input_type{static_cast<uint8_t>(hash_type & SIGHASH_INPUT_MASK)};\n+        const uint8_t hash_output_type{static_cast<uint8_t>((hash_type == SIGHASH_DEFAULT)\n+                                                             ? SIGHASH_ALL\n+                                                             : (hash_type & SIGHASH_OUTPUT_MASK))};\n+        const uint8_t spend_type = (ext_flag * 2) + annex_present;\n+\n+        // Fixed values (by algorithm)\n+        const uint8_t epoch{0x00};\n+        const uint8_t key_version{0};\n+\n+        // Mocked values fixed for purposes of this unit test.  This is a long\n+        // list of crufty things but that's because `SignatureHashSchnorr`, the\n+        // function begin tested, takes as arguments not just the tranaction\n+        // being signed (plus control data) but also some _precomputed values_\n+        // in two different structs: `PrecomputedTransactionData`, and\n+        // `ScriptExecutionData`.  On the one hand this is nice because a lot\n+        // of complexity of the signature algorithm doesn't have to be duplicated\n+        // here in this test: we can just use mocked values.  On the other hand,\n+        // there's a lot of icky setup to do to get all the values in the right\n+        // places both for our \"by the book\" implementation and to be set up to\n+        // call `SignatureHashSchnorr`.\n+        //\n+        // Try to make things simpler by at least using the same names for the\n+        // setup variables as for the fields in the parameter structs.\n+\n+        const uint32_t in_pos{1};\n+        const int32_t tx_version{FillWithPattern(0x01).i32[0]};\n+        const uint32_t tx_lock_time{FillWithPattern(0x05).u32[0]};\n+        const uint256 prevouts_single_hash{FillWithPattern(0x10).u256};\n+        const uint256 spent_amounts_single_hash{FillWithPattern(0x18).u256};\n+        const uint256 spent_scripts_single_hash{FillWithPattern(0x20).u256};\n+        const uint256 sequences_single_hash{FillWithPattern(0x28).u256};\n+        const uint256 outputs_single_hash{FillWithPattern(0x30).u256};\n+        const uint256 output_hash{FillWithPattern(0x40).u256};\n+        const uint256 annex_hash{FillWithPattern(0x48).u256};\n+        const uint256 tapleaf_hash{FillWithPattern(0x50).u256};\n+        const uint32_t codeseparator_pos{FillWithPattern(0x58).u32[0]};\n+        const COutPoint tx_input_at_pos_prevout{FillWithPattern(0x60).u256,\n+                                                FillWithPattern(0x68).u32[0]};\n+        const uint32_t tx_input_at_pos_nsequence{FillWithPattern(0x70).u32[0]};\n+        CTxOut spent_output_at_pos;\n+        spent_output_at_pos.nValue = FillWithPattern(0x80).u64();\n+        spent_output_at_pos.scriptPubKey /*random script, not even valid*/\n+            << OP_DUP << OP_HASH160 << OP_EQUALVERIFY << OP_CHECKSIG;\n+        CTxOut tx_output_at_pos;\n+        tx_output_at_pos.nValue = FillWithPattern(0x90).u64();\n+        tx_output_at_pos.scriptPubKey /*random script, not even valid*/\n+            << OP_CHECKSIG << OP_EQUALVERIFY << OP_HASH160 << OP_DUP;\n+\n+        // Now set up the arguments that are going to be passed to\n+        // `SignatureHashSchnorr`\n+\n+        CMutableTransaction tx_to;\n+        tx_to.nVersion = tx_version;\n+        tx_to.nLockTime = tx_lock_time;\n+        for (uint32_t i = 0; i < in_pos+2; i++) {\n+            tx_to.vin.push_back(CTxIn());\n+            tx_to.vout.push_back(CTxOut());\n+        }\n+        tx_to.vin[in_pos].prevout = tx_input_at_pos_prevout;\n+        tx_to.vin[in_pos].nSequence = tx_input_at_pos_nsequence;\n+        tx_to.vout[in_pos] = tx_output_at_pos;\n+\n+        PrecomputedTransactionData cache;\n+        cache.m_bip341_taproot_ready = true;\n+        cache.m_prevouts_single_hash = prevouts_single_hash;\n+        cache.m_spent_amounts_single_hash = spent_amounts_single_hash;\n+        cache.m_spent_scripts_single_hash = spent_scripts_single_hash;\n+        cache.m_sequences_single_hash = sequences_single_hash;\n+        cache.m_spent_outputs_ready = true;\n+        for (uint32_t i = 0; i < in_pos+2; i++) {\n+            cache.m_spent_outputs.push_back(CTxOut());\n+        }\n+        cache.m_spent_outputs[in_pos] = spent_output_at_pos;\n+        cache.m_outputs_single_hash = outputs_single_hash;\n+\n+        ScriptExecutionData execdata;\n+        execdata.m_annex_init = true;\n+        execdata.m_annex_present = !!annex_present;\n+        execdata.m_annex_hash = annex_hash;\n+        execdata.m_output_hash.reset();\n+        if (have_output_hash) {\n+            execdata.m_output_hash = output_hash;\n+        }\n+        if (sigversion == SigVersion::TAPSCRIPT) {\n+            execdata.m_tapleaf_hash_init = true;\n+            execdata.m_tapleaf_hash = tapleaf_hash;\n+            execdata.m_codeseparator_pos_init = true;\n+            execdata.m_codeseparator_pos = codeseparator_pos;\n+        }\n+\n+        // Now here is where we take all that data - _not_ the arguments to\n+        // `SignatureHashSchnorr` but all the scenario parameters, the helpers,\n+        // the values fixed by the algorithm, and our mocked values, and actually\n+        // follow the BIP-341/BIP-342 signature calculation algorithm right from\n+        // the specs ...\n+\n+        // Start with a tagged hasher with the correct tag\n+        CHashWriter hasher = TaggedHash(\"TapSighash\");\n+\n+        // First byte to hash is always the \"epoch\", 0x00 (BIP-341, footnote 20)\n+        hasher << epoch;\n+\n+        // Next: hash_type (1 byte)\n+        hasher << hash_type;\n+\n+        // Next: transaction version (4 bytes)\n+        hasher << tx_version;\n+\n+        // Next: transaction lock time (4 bytes)\n+        hasher << tx_lock_time;\n+\n+        // Next if _not_ SIGHASH_ANYONECANPAY:\n+        // a) SHA256 of the serialization of all input outpoints (32 bytes)\n+        // b) SHA256 of the serialization of all spent output amounts (32 bytes)\n+        // c) SHA256 of the serialization of all spent outputs' _scriptPubKeys_\n+        //    serialized as script (32 bytes)\n+        // d) SHA256 of the serialization of all input `nSequence` (32 bytes)\n+        if (hash_input_type != SIGHASH_ANYONECANPAY) {\n+            hasher << prevouts_single_hash;\n+            hasher << spent_amounts_single_hash;\n+            hasher << spent_scripts_single_hash;\n+            hasher << sequences_single_hash;\n+        }\n+\n+        // Next if _not_ SIGHASH_NONE _and not_ SIGHASH_SINGLE:\n+        // SHA256 of the serialization of all outputs in CTxOut format (32 bytes)\n+        if (hash_output_type != SIGHASH_NONE && hash_output_type != SIGHASH_SINGLE) {\n+            hasher << outputs_single_hash;\n+        }\n+\n+        // Now, data about input/prevout being spent\n+\n+        // The \"spend_type\" (1 byte) which is a function of ext_flag (above) and\n+        // whether there is an annex present (here: no)\n+        hasher << spend_type;\n+\n+        // Here, if we are _not_ SIGHASH_ANYONECANPAY, we just add the index of\n+        // the input in the transaction input vector (4 bytes). There must be a\n+        // input transaction at this index but _in this scenario_ it doesn't have\n+        // to have any data (it is never inspected).  Same for output transactions.\n+        //\n+        // On the other hand, if we _are_ SIGHASH_ANYONECANPAY, then we add the\n+        // `COutPoint` of this input (36 bytes), the value of the previous\n+        // output spent by this input (8 bytes), the `ScriptPubKey` of the\n+        // previous output spent by this input (35 bytes), and the `nSequence`\n+        // of this input.  These values are all precomputed and made available\n+        // to `SignatureHashSchnorr` in the `PrecomputedTransactionData` struct.\n+        if (hash_input_type == SIGHASH_ANYONECANPAY) {\n+            hasher << tx_input_at_pos_prevout;\n+            hasher << spent_output_at_pos.nValue;\n+            hasher << spent_output_at_pos.scriptPubKey;\n+            hasher << tx_input_at_pos_nsequence;\n+        } else {\n+            hasher << in_pos;\n+        }\n+\n+        // Now, if there is an \"annex\", add its hash (32 byte).  This is\n+        // precomputed and we don't actually have to have an actual annex to\n+        // pass in to `SignatureHashSchnorr`, nor do we have to hash it.\n+        if (annex_present) {\n+            hasher << annex_hash;\n+        }\n+\n+        // Here, iff the hash type is `SIGHASH_SINGLE`, add the hash of the\n+        // corresponding transaction output (32 bytes).  The wrinkle here is that\n+        // (for some reason) _sometimes_ this hash is precomputed, and _sometimes_\n+        // it is _not_.  So `SignatureHashSchnorr` will either use it if it is\n+        // provided or compute it from the corresponding output itself. (For our\n+        // purposes in this test the output need not be valid - it just must be\n+        // present.)\n+        if (hash_output_type == SIGHASH_SINGLE) {\n+            if (!have_output_hash) {\n+                CHashWriter hasher2(SER_GETHASH, 0);\n+                hasher2 << tx_output_at_pos;\n+                hasher << hasher2.GetSHA256();\n+            } else {\n+                hasher << output_hash;\n+            }\n+        }\n+\n+        // This is the TAPSCRIPT extension from BIP-342.  If the version is\n+        // TAPSCRIPT then add the tapleaf hash (32 bytes), the key_version (1\n+        // byte, fixed value of 0x00), and the \"opcode position of the last\n+        // executed OP_CODESEPARATOR before the currently executed signature\n+        // opcode\" (4 bytes).  The tapleaf hash and the code separator position\n+        // are both precomputed values.\n+        if (sigversion == SigVersion::TAPSCRIPT) {\n+            hasher << tapleaf_hash;\n+            hasher << key_version;\n+            hasher << codeseparator_pos;\n+        }\n+\n+        // That's all that goes into the hasher for this signature\n+        const uint256 expected_hash_out = hasher.GetSHA256();\n+\n+        // Now finally we test the actual implemented algorithm under test:\n+        uint256 actual_hash_out{0};\n+        BOOST_TEST(SignatureHashSchnorr(actual_hash_out,\n+                                        execdata, tx_to, in_pos,\n+                                        hash_type, sigversion, cache,\n+                                        MissingDataBehavior::FAIL),\n+                   \"Scenario: \" << scenario_description);\n+        BOOST_TEST(expected_hash_out == actual_hash_out,\n+                   \"Scenario: \" << scenario_description\n+                   << \" - expected \" << expected_hash_out.ToString()\n+                   << \" == actual \" << actual_hash_out.ToString());\n+    }\n+}\n+\n+namespace {\n+\n+// Valid Schnoor (pubkey, msg, signature) tuples (copied from `key_tests.cpp`)\n+\n+struct SchnorrTriplet\n+{\n+    SchnorrTriplet(std::string pubkey, std::string sighash, std::string sig)\n+                : pubkey(ParseHex(pubkey))\n+                , sighash(uint256(ParseHex(sighash)))\n+                , sig(ParseHex(sig)) {}\n+    valtype pubkey;\n+    uint256 sighash;\n+    valtype sig;\n+};\n+\n+static const std::vector<SchnorrTriplet> SCHNORR_TRIPLETS = {\n+    {\"F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9\", \"0000000000000000000000000000000000000000000000000000000000000000\", \"E907831F80848D1069A5371B402410364BDF1C5F8307B0084C55F1CE2DCA821525F66A4A85EA8B71E482A74F382D2CE5EBEEE8FDB2172F477DF4900D310536C0\"},\n+    {\"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659\", \"243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89\", \"6896BD60EEAE296DB48A229FF71DFE071BDE413E6D43F917DC8DCF8C78DE33418906D11AC976ABCCB20B091292BFF4EA897EFCB639EA871CFA95F6DE339E4B0A\"},\n+    {\"DD308AFEC5777E13121FA72B9CC1B7CC0139715309B086C960E18FD969774EB8\", \"7E2D58D8B3BCDF1ABADEC7829054F90DDA9805AAB56C77333024B9D0A508B75C\", \"5831AAEED7B44BB74E5EAB94BA9D4294C49BCF2A60728D8B4C200F50DD313C1BAB745879A5AD954A72C45A91C3A51D3C7ADEA98D82F8481E0E1E03674A6F3FB7\"},\n+    {\"25D1DFF95105F5253C4022F628A996AD3A0D95FBF21D468A1B33F8C160D8F517\", \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", \"7EB0509757E246F19449885651611CB965ECC1A187DD51B64FDA1EDC9637D5EC97582B9CB13DB3933705B32BA982AF5AF25FD78881EBB32771FC5922EFC66EA3\"},\n+    {\"D69C3509BB99E412E68B0FE8544E72837DFA30746D8BE2AA65975F29D22DC7B9\", \"4DF3C3F68FCC83B27E9D42C90431A72499F17875C81A599B566C9889B9696703\", \"00000000000000000000003B78CE563F89A0ED9414F5AA28AD0D96D6795F9C6376AFB1548AF603B3EB45C9F8207DEE1060CB71C04E80F593060B07D28308D7F4\"},\n+};\n+\n+}\n+\n+BOOST_AUTO_TEST_CASE(internal_test_validate_schnorr_testdata)\n+{\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(XOnlyPubKey(triplet.pubkey).VerifySchnorr(triplet.sighash, triplet.sig));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(verify_schnorr_signature)\n+{\n+    // Defeat, for test purposes, the protected access of\n+    // `GenericTransactionSignatureChecker::VerifySchnorrSignature`\n+    struct UnprotectedTransactionSignatureChecker : public MutableTransactionSignatureChecker\n+    {\n+        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;\n+        using MutableTransactionSignatureChecker::VerifySchnorrSignature;\n+    };\n+    UnprotectedTransactionSignatureChecker sut{nullptr, 0, {}, {}};\n+\n+    // Positive tests: triplets which verify\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(sut.VerifySchnorrSignature(triplet.sig,\n+                                              XOnlyPubKey{triplet.pubkey},\n+                                              triplet.sighash));\n+    }\n+\n+    // Negative tests: triplets which fail to verify (get these failing triplets\n+    // by modifying a valid triplet, one field at a time)\n+    auto diddle_front_byte = [](auto v) { v[0]++; return v; };\n+    auto& triplet = SCHNORR_TRIPLETS[0];\n+    BOOST_TEST(!sut.VerifySchnorrSignature(diddle_front_byte(triplet.sig),\n+                                           XOnlyPubKey{triplet.pubkey},\n+                                           triplet.sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.sig,\n+                                           XOnlyPubKey{diddle_front_byte(triplet.pubkey)},\n+                                           triplet.sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.sig,\n+                                           XOnlyPubKey{triplet.pubkey},\n+                                           uint256::ONE));\n+}\n+\n+BOOST_AUTO_TEST_CASE(check_schnorr_signature)\n+{\n+    // Provide, for test purposes, a subclass of `GenericTransactionsSignatureChecker`\n+    // that mocks `VerifySchnorrSignature` so we can more easily test\n+    // `CheckSchnorrSignature` without going to the trouble of having a valid\n+    // transaction (which is unnecessary for this _unit_ test.)\n+    struct MockVerifyingTransactionSignatureChecker : public MutableTransactionSignatureChecker\n+    {\n+\n+        uint256 expected_sighash = [](){\n+            uint256 h{};\n+            // This is the known sighash of the Tx and input data we set up (precomputed)\n+            h.SetHex(\"f614d8ae6dcc49e2ca2ef1c03f93c7326189e5575d446e825e5a2700fb1cb83c\");\n+            return h;\n+        }();\n+\n+        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;\n+\n+        enum class if_as_expected_return { False, True };\n+        if_as_expected_return iae{ if_as_expected_return::True };\n+        void SetExpectation(if_as_expected_return iaer) { iae = iaer; }\n+\n+        bool VerifySchnorrSignature(Span<const unsigned char> sig,\n+                                    const XOnlyPubKey& pubkey,\n+                                    const uint256& sighash) const override\n+        {\n+            // Following line used only to determine the known canned `expected_sighash` above:\n+            // BOOST_TEST_MESSAGE(\"MockVerifySchnorrSignature: sighash == \" << sighash.ToString());\n+\n+            bool as_expected = sighash == expected_sighash;\n+            if (iae == if_as_expected_return::True)\n+                return as_expected;\n+            else\n+                return !as_expected;\n+        };\n+    };\n+\n+    const auto triplet = SCHNORR_TRIPLETS[0];\n+    const CMutableTransaction txToIn{};\n+    ScriptExecutionData execdata{};\n+\n+    {\n+        // Signature must be 64 or 65 bytes long\n+        for (size_t i = 0; i <= 99; i++) {\n+            valtype testsig(i, i);\n+            if (testsig.size() == 64 || testsig.size() == 65) continue;\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_SIZE);\n+        }\n+    }\n+\n+    {\n+        // Iff signature is 65 bytes long last byte must **NOT** be SIGHASH_DEFAULT (0x00) per BIP-342\n+        {\n+            // Negative test: last byte _is_ SIGHASH_DEFAULT\n+            valtype testsig(65, 65);\n+            testsig.back() = SIGHASH_DEFAULT;\n+\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);\n+        }\n+        {\n+            // Negative tests: last byte is _not_ SIGHASH_DEFAULT, but we early exit _without changing\n+            // serror_ because we don't provide a txDataIn (🡄 this requires knowledge of how\n+            // `CheckSchnorrSignature` is written).\n+            for (size_t i = 1; i <= 255; i++) {\n+                valtype testsig(65, i);\n+\n+                MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+                ScriptError serror{SCRIPT_ERR_OK};\n+                BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+                BOOST_TEST(serror == SCRIPT_ERR_OK);\n+            }\n+        }\n+    }\n+\n+    {\n+        // Now check that, given the parameters, if `SignatureHashSchnorr fails there's an error exit.\n+        // Otherwise, if it succeeds, it proceeds to call `VerifySchnorrSignature` and depending on\n+        // _that_ result `SignatureHashSchnorr` either succeeds or fails.\n+        //\n+        // We do this using the mocked `VerifySchnorrSignature` so we only need to pass parameters\n+        // that work with `SignatureHashSchnorr`, they don't _also_ have to validate with\n+        // `VerifySchnorrSignature`.\n+\n+        const uint32_t in_pos{0};\n+        CMutableTransaction txToIn{};\n+        txToIn.nVersion = 0;\n+        txToIn.nLockTime = 0;\n+        txToIn.vin.push_back(CTxIn());\n+        txToIn.vin[in_pos].prevout = COutPoint(uint256::ZERO, 0);\n+        txToIn.vin[in_pos].nSequence = 0;\n+        txToIn.vout.push_back(CTxOut());\n+\n+        PrecomputedTransactionData txDataIn{};\n+        txDataIn.m_bip341_taproot_ready = true;\n+        txDataIn.m_prevouts_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_amounts_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_scripts_single_hash = uint256::ZERO;\n+        txDataIn.m_sequences_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_outputs_ready = true;\n+        txDataIn.m_spent_outputs.push_back(CTxOut());\n+        txDataIn.m_spent_outputs[in_pos].nValue = 0;\n+        txDataIn.m_spent_outputs[in_pos].scriptPubKey << OP_DUP << OP_CHECKSIG;\n+        txDataIn.m_outputs_single_hash = uint256::ZERO;\n+\n+        ScriptExecutionData execdata{};\n+        execdata.m_annex_init = true;\n+        execdata.m_annex_present = true;\n+        execdata.m_annex_hash = uint256::ZERO;\n+        execdata.m_output_hash.reset();\n+\n+        {\n+            // Confirm that we can force `SignatureHashSchnorr` to fail (via an early exit)\n+            PrecomputedTransactionData txDataIn{};\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(triplet.sig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);\n+        }\n+        {\n+            // Now `SignatureHashSchnorr` will return true but we'll fail `VerifySchnorrSignature`\n+            // and show it returns the correct error.\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            sut.SetExpectation(MockVerifyingTransactionSignatureChecker::if_as_expected_return::False);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(triplet.sig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG);\n+        }\n+        {\n+            // Finally, same as previous, except we'll force `VerifySchnorrSignature` to succeed and\n+            // show now that `CheckSchnorrSignature` finally suceeds.\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            sut.SetExpectation(MockVerifyingTransactionSignatureChecker::if_as_expected_return::True);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(sut.CheckSchnorrSignature(triplet.sig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_OK);\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+    std::optional<valtype> from_hex(std::string_view sv) {\n+        static const auto hexits = \"0123456789abcdefABCDEF\"sv;\n+\n+        constexpr auto is_hexit = [](char c) {\n+            return std::string::npos != hexits.find(c);\n+        };\n+\n+        // validate\n+        if (sv.size() % 2 != 0) return {};\n+        if (!std::all_of(sv.begin(), sv.end(), is_hexit)) return {};\n+\n+        constexpr auto from_hexit = [](char c) -> unsigned char {\n+            auto d = hexits.find(c);\n+            return d < 16 ? d : d - 6;\n+        };\n+\n+        valtype r; r.reserve(sv.size() / 2);\n+        for (size_t i = 0; i < sv.size(); i+=2) {\n+            r.push_back(from_hexit(sv[i])<<4 | from_hexit(sv[i+1]));\n+        }\n+        return r;\n+    }\n+\n+    valtype operator \"\" _hex(const char* s, size_t len) {\n+        auto v = from_hex({s, len});\n+        if (v) return v.value();\n+        throw std::invalid_argument(\"invalid hex literal\");\n+    }\n+\n+    // (not checked: That `C` is a container (supporting `std::begin()` and `std::end()`)\n+    // whose elements are `unsigned char`) (note `uint256` doesn't have a `value_type` member)\n+    template <typename C>\n+    std::string to_hex(C container) {\n+        constexpr auto to_hexit = [](unsigned char c) -> char {\n+            return \"0123456789ABCDEF\"[c];\n+        };\n+\n+        std::string r; r.reserve(container.size() * 2);\n+        for (unsigned char c : container) {\n+            r.push_back(to_hexit(c>>4 & 0x0F));\n+            r.push_back(to_hexit(c & 0x0F));\n+        }\n+        return r;\n+    }\n+\n+    // An attempt to get close to the notation of BIP-340:\n+    //   `||` concatenates byte vectors\n+    //   `[j]` indexes a single element\n+    //   `[i:j]` can't be represented in C++ - there is no `:` operator, so instead\n+    //       I substitute `[{i,j}]` - which is the subrange `[i,j)`.\n+    //\n+    // For convenience, constructing from a string and comparing (equality) against\n+    // a string are available.\n+    struct bytevector : public std::vector<unsigned char>\n+    {\n+        using std::vector<unsigned char>::vector;\n+        explicit bytevector(std::string_view sv) {\n+            resize(sv.size());\n+            std::copy(sv.begin(), sv.end(), begin());\n+        }\n+\n+        explicit bytevector(uint256 u) {\n+            resize(u.size());\n+            std::copy(u.begin(), u.end(), begin());\n+        }\n+\n+        /**\n+         * Return half-open subrange from byte vector: `[i:j)`\n+         */\n+        bytevector subrange(size_t i, size_t j) const {\n+            assert(i <= j && j <= size());\n+            bytevector r(j-i, 0);\n+            std::copy(begin()+i, begin()+j, r.begin());\n+            return r;\n+        }\n+\n+        using std::vector<unsigned char>::operator[];\n+        bytevector operator[](std::tuple<size_t, size_t> range) const {\n+            auto [i, j] = range;\n+            return subrange(i, j);\n+        }\n+\n+        void concat(const bytevector& bv) {\n+            size_t this_size{size()};\n+            resize(size() + bv.size());\n+            std::copy(bv.begin(), bv.end(), begin() + this_size);\n+        }\n+\n+        std::string to_string() const {\n+            return std::string(begin(), end());\n+        }\n+    };\n+\n+    bytevector operator \"\"_bv(const char* s, size_t len) {\n+        return bytevector(std::string_view(s, len));\n+    }\n+\n+    bool operator==(const bytevector& lhs, std::string_view rhs) {\n+        return lhs.to_string() == rhs;\n+    }\n+\n+    bool operator==(std::string_view lhs, const bytevector& rhs) {\n+        return lhs == rhs.to_string();\n+    }\n+\n+    bool operator<(const bytevector& lhs, const bytevector& rhs) {\n+        return std::lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());\n+    }\n+\n+    bytevector operator||(const bytevector& lhs, const bytevector& rhs)\n+    {\n+        bytevector r(lhs);\n+        r = lhs;\n+        r.concat(rhs);\n+        return r;\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(internal_test_validate_hex_to_bytes_and_back_helpers)\n+{\n+    // Hex digits have correct value\n+    std::pair<char, unsigned char> hexit_map[] {\n+                {'0',  0}, {'1',  1}, {'2',  2}, {'3',  3}, {'4',  4},\n+                {'5',  5}, {'6',  6}, {'7',  7}, {'8',  8}, {'9',  9},\n+                {'a', 10}, {'b', 11}, {'c', 12}, {'d', 13}, {'e', 14}, {'f', 15},\n+                {'A', 10}, {'B', 11}, {'C', 12}, {'D', 13}, {'E', 14}, {'F', 15},\n+    };\n+\n+    for (const auto& [c, d] : hexit_map) {\n+        BOOST_TEST(from_hex(std::string(2, c)).value() == valtype(1, d*16 + d));\n+    };\n+    // Non-hex digits fail to convert\n+    for (int d = 0; d < 255; d++) {\n+        char dig = static_cast<char>(d);\n+        static const auto hex_digits = \"0123456789abcdefABCDEF\"sv;\n+        if (std::none_of(hex_digits.begin(), hex_digits.end(), [dig](char c) { return c == dig; })) {\n+            BOOST_TEST((!from_hex(std::string{1, dig} + dig)));\n+        }\n+    }\n+\n+    // hex strings to byte vector\n+    BOOST_TEST(\"0A\"_hex == valtype(1, 0x0a));",
      "path": "src/test/script_tapscript_tests.cpp",
      "position": null,
      "original_position": 1201,
      "commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "original_commit_id": "a5808ce2f05040f740dad313e503624de2e8db93",
      "in_reply_to_id": null,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Wow, TIL about user-defined literals in C++11.\r\n\r\nSo these are cool, but is the \"xx\"_hex stuff actually used in taproot-specific tests anywhere here? I can't find any usages, which would make that facility (and these tests) unnecessary if I'm reading right.",
      "created_at": "2022-05-18T16:33:32Z",
      "updated_at": "2022-05-18T16:38:48Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r876110013",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/876110013"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1201,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/877503897",
      "pull_request_review_id": 979210647,
      "id": 877503897,
      "node_id": "PRRC_kwDOABII5840TaWZ",
      "diff_hunk": "@@ -0,0 +1,1546 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <script/script_error.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/transaction_utils.h>\n+#include <util/strencodings.h>\n+#include <univalue.h>\n+\n+#include <boost/test/execution_monitor.hpp>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <array>\n+#include <charconv>\n+#include <cstddef>\n+#include <stdexcept>\n+#include <iomanip>\n+#include <iterator>\n+#include <limits>\n+#include <ostream>\n+#include <set>\n+#include <string_view>\n+#include <string>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+using namespace std::literals::string_literals;\n+using namespace std::literals::string_view_literals;\n+\n+namespace {\n+\n+typedef std::vector<unsigned char> valtype;\n+\n+/**\n+ * Value/Name pair used in data-driven tests\n+ */\n+template <typename T>\n+struct vn_pair\n+{\n+    vn_pair(T v, std::string_view n) : value(v), name(n) {}\n+\n+    const T value;\n+    const std::string_view name;\n+};\n+\n+/**\n+ * Sequence of value/name pairs used in data-driven tests\n+ */\n+template <typename T>\n+using vn_sequence = std::vector<vn_pair<T>>;\n+\n+/**\n+ * Invokes undefined behavior.  See `std::unreachable` in C++23.\n+ */\n+[[noreturn]] inline void declare_unreachable()\n+{\n+#ifdef _MSC_VER\n+    __assume(false);\n+#else\n+    // Assume all other compilers than MSVC implement this GCC builtin.\n+    __builtin_unreachable();\n+#endif\n+}\n+\n+/**\n+ * Outputs to stream as hex\n+ */\n+template <typename US>\n+struct hex\n+{\n+    hex(US v) : value(v) {}\n+    const US value;\n+\n+    friend std::ostream& operator<<(std::ostream& os, hex hx)\n+    {\n+        auto flags = os.flags();\n+        os << std::setw(2*sizeof(US)) << std::setfill('0') << std::showbase\n+           << std::hex << +hx.value;\n+        os.flags(flags);\n+        return os;\n+    }\n+};\n+\n+/**\n+ * Representation changer to fill an integral type with a known pattern.\n+ *\n+ * Pattern is successive byte values given a starting point.  Endianness doesn't\n+ * matter.\n+ */\n+union FillWithPattern {\n+    uint256 u256{0};\n+    uint64_t u64raw[sizeof(uint256)/sizeof(uint64_t)];\n+    uint32_t u32[sizeof(uint256)/sizeof(uint32_t)];\n+    int32_t i32[sizeof(uint256)/sizeof(int32_t)];\n+    uint8_t u8[sizeof(uint256)];\n+\n+    constexpr FillWithPattern(uint8_t start)\n+    {\n+        for (auto it = std::begin(u8); it != std::end(u8); ++it) {\n+            *it = start++;\n+        }\n+    }\n+\n+    uint64_t u64() const {\n+        // It is desirable to force high bit off\n+        return u64raw[0] & static_cast<uint64_t>(std::numeric_limits<int64_t>::max());\n+    }\n+};\n+\n+} // anon namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(script_tapscript_tests, BasicTestingSetup)\n+\n+/**\n+ * Testing EvalScript OP_CHECKSIGADD branch and EvalChecksigTapscript, both in\n+ * interpreter.cpp, against the BIP342 \"Rules for signature opcodes\".\n+ */\n+BOOST_AUTO_TEST_CASE(eval_checksigadd_basic_checks)\n+{\n+    const valtype SIG_64BYTES(64, 0);  // N.B.: Must be () not {}!\n+    const valtype SIG_65BYTES(65, 0);\n+    const valtype SIG_EMPTY{};\n+\n+    const valtype PUBKEY_32BYTES(32, 0);\n+    const valtype PUBKEY_15BYTES(15, 0);\n+    const valtype PUBKEY_EMPTY{};\n+\n+    constexpr int64_t TEST_NUM = 10;\n+\n+    constexpr int64_t START_VALIDATION_WEIGHT{ 90 };\n+    constexpr int64_t BIP342_SIGOPS_LIMIT{ 50 };\n+    constexpr int64_t END_VALIDATION_WEIGHT{ START_VALIDATION_WEIGHT - BIP342_SIGOPS_LIMIT };\n+\n+    /**\n+     * For these tests don't need _real_ signature/pubkey validation.  That is\n+     * tested elsewhere.  So we just _mock_ the signature checker and force it\n+     * to answer valid/invalid as we wish.\n+     */\n+\n+    struct SignatureCheckerMock : public BaseSignatureChecker\n+    {\n+        //! Whether this mock always validates, or always fails, the signature/pubkey check.\n+        enum class VALIDATION { ALWAYS_SUCCEEDS, ALWAYS_FAILS };\n+        VALIDATION m_kind = VALIDATION::ALWAYS_FAILS;\n+\n+        //! True _iff_ CheckSchnorrSignature was actually called\n+        mutable bool m_was_called = false;\n+\n+        SignatureCheckerMock() {}\n+\n+        bool CheckSchnorrSignature(Span<const unsigned char> sig,\n+                                    Span<const unsigned char> pubkey,\n+                                    SigVersion sigversion,\n+                                    ScriptExecutionData& execdata,\n+                                    ScriptError* serror = nullptr) const override\n+        {\n+            m_was_called = true;\n+            switch (m_kind) {\n+            case VALIDATION::ALWAYS_SUCCEEDS:\n+                *serror = SCRIPT_ERR_OK;\n+                return true;\n+            case VALIDATION::ALWAYS_FAILS:\n+                *serror = SCRIPT_ERR_SCHNORR_SIG;\n+                return false;\n+            }\n+            declare_unreachable();\n+        }\n+    };\n+\n+    /**\n+     * A fluent API for running these tests.\n+     *\n+     * (Easiest way to understand this class is to look at the actual tests\n+     * that follow in this function.)\n+     */\n+    struct Context\n+    {\n+        explicit Context(std::string_view descr) : testDescription(descr) {\n+            execdata.m_validation_weight_left_init = true;\n+            execdata.m_validation_weight_left = START_VALIDATION_WEIGHT;\n+        }\n+\n+        std::string testDescription;\n+        SigVersion sigVersion = SigVersion::TAPSCRIPT;\n+        uint32_t flags = 0;\n+        CScript script;\n+        ScriptError err = SCRIPT_ERR_OK;\n+        std::vector<valtype> stack;\n+        ScriptExecutionData execdata;\n+        SignatureCheckerMock sigchecker;\n+        int64_t callerLine = 0;\n+        bool result = false;\n+\n+        Context& SetVersion(SigVersion v)\n+        {\n+            sigVersion = v;\n+            return *this;\n+        }\n+\n+        Context& SetChecker(SignatureCheckerMock::VALIDATION kind)\n+        {\n+            sigchecker.m_kind = kind;\n+            return *this;\n+        }\n+\n+        Context& SetRemainingWeight(int64_t w)\n+        {\n+            execdata.m_validation_weight_left = w;\n+            return *this;\n+        }\n+\n+        Context& AddFlags(uint32_t f)\n+        {\n+            flags |= f;\n+            return *this;\n+        }\n+\n+        CScript& SetScript()\n+        {\n+            return script;\n+        }\n+\n+        Context& DoTest(int64_t line)\n+        {\n+            callerLine = line;\n+            result = EvalScript(stack, script,\n+                                SCRIPT_VERIFY_TAPROOT | flags,\n+                                sigchecker,\n+                                sigVersion,\n+                                execdata,\n+                                &err);\n+            return *this;\n+        }\n+\n+        Context& CheckCallSucceeded()\n+        {\n+            BOOST_CHECK_MESSAGE(result,\n+                               Descr()\n+                               << \": EvalScript succeeded, as expected\");\n+            BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK,\n+                                Descr()\n+                                << \": Error code expected OK, actual was \"\n+                                << ScriptErrorString(err));\n+            return *this;\n+        }\n+\n+        Context& CheckCallFailed(ScriptError expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!result,\n+                               Descr()\n+                               << \": EvalScript failed, as expected\");\n+            BOOST_CHECK_MESSAGE(err == expected,\n+                                Descr()\n+                                << \": Error code expected \" << ScriptErrorString(expected)\n+                                << \", actual was \" << ScriptErrorString(err));\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(sigchecker.m_was_called,\n+                               Descr()\n+                               << \": CheckSchnorrSignature was called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasNotValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(!sigchecker.m_was_called,\n+                               Descr()\n+                               << \": CheckSchnorrSignature was not called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckRemainingValidationWeight(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(execdata.m_validation_weight_left == expected,\n+                                Descr()\n+                                << \": Remaining validation weight expected \"\n+                                << expected << \", actual was \"\n+                                << execdata.m_validation_weight_left);\n+            return *this;\n+        }\n+\n+        Context& CheckStackDepth(std::size_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(stack.size() == expected,\n+                                Descr()\n+                                << \": Stack depth expected \" << expected\n+                                << \", actual was \" << stack.size());\n+            return *this;\n+        }\n+\n+        Context& CheckTOS(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!stack.empty(),\n+                                Descr()\n+                                << \": Stack expected at least one item, actually was empty\");\n+            const int64_t actual = CScriptNum(stack.at(0), false).GetInt64();\n+            BOOST_CHECK_MESSAGE(expected == actual,\n+                                Descr()\n+                                << \": Top-of-stack expected \" << expected\n+                                << \", actual was \" << actual);\n+            return *this;\n+        }\n+\n+    private:\n+        std::string Descr() {\n+            std::array<char, 24> sline{0};\n+            std::string_view svline(\"\");\n+            // (This seems rather elaborate to avoid locale issues with `std::to_string`. One\n+            // can't help but think the C++ committee could have provided a nicer wrapper for it.)\n+            if (auto [ptr,ec] = std::to_chars(sline.data(), sline.data() + sline.size(),\n+                                            callerLine);\n+                ec == std::errc())\n+            {\n+                svline = std::string_view(sline.data(), ptr - sline.data());\n+            }\n+\n+            std::string descr;\n+            descr.reserve(testDescription.size() + 20);\n+            descr += testDescription;\n+            descr += \" (@\";\n+            descr += svline;\n+            descr += \")\";\n+            return descr;\n+        }\n+    };\n+\n+    {\n+        Context ctx(\"SigVersion must not be BASE\");\n+        ctx.SetVersion(SigVersion::BASE).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"SigVersion must not be WITNESS_V0\");\n+        ctx.SetVersion(SigVersion::WITNESS_V0).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Minimum stack height 3 for OP_CHECKSIGADD\");\n+        ctx.SetScript()\n+            << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_INVALID_STACK_OPERATION)\n+            .CheckStackDepth(2);\n+    }\n+\n+    {\n+        Context ctx(\"`n` (2nd arg) size > 4 must fail\");\n+        // This is probably meant to be a check on the _encoding_ - that it is\n+        // minimal, but it can also be a check on the _value_.  BIP342 doesn't\n+        // say which.  Could be both...\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(10000000000LL) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            // (IMO this is an _unsatisfactory_ error code to return for a required\n+            // BIP342 check, but see the `catch` clause in `EvalScript`)\n+            .CheckCallFailed(SCRIPT_ERR_UNKNOWN_ERROR)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Insufficient validation weight remaining\");\n+        ctx.SetRemainingWeight(BIP342_SIGOPS_LIMIT-1)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + 32byte pubkey skips validation\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + non32byte pubkey skips validation\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey ('unknown pubkey type') _with_ discourage flag fails\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .AddFlags(SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .CheckSignatureWasNotValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation failure forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_FAILS)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_SCHNORR_SIG)\n+            .CheckSignatureWasValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation success forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasValidated()\n+            .CheckRemainingValidationWeight(END_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM+1);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey + empty sig with validation success forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_failure_cases)\n+{\n+    // As defined by BIP-341 Signature Validation Rules\n+    // Here we pick an acceptable SigVersion\n+    const SigVersion sigversion = SigVersion::TAPROOT;\n+\n+    CMutableTransaction tx_to_m;\n+    tx_to_m.vin.push_back(CTxIn());\n+    const uint32_t in_pos{0};\n+\n+    PrecomputedTransactionData cache;\n+    cache.m_bip341_taproot_ready = true;\n+    cache.m_spent_outputs_ready = true;\n+\n+    ScriptExecutionData execdata;\n+    execdata.m_annex_init = true;\n+    execdata.m_annex_present = false;\n+    execdata.m_annex_hash = uint256::ZERO;\n+    execdata.m_tapleaf_hash_init = false;\n+    execdata.m_codeseparator_pos_init = true;\n+\n+    uint256 hash_out{0};\n+\n+    {\n+        // Check all invalid hash_type codes rejected\n+        const std::set<uint8_t> allowable_hash_types{ 0x00, 0x01, 0x02, 0x03, 0x81, 0x82, 0x83 };\n+        for (unsigned ht = 0; ht <= 255; ht++) {\n+            const uint8_t hash_type = static_cast<uint8_t>(ht);\n+            if (allowable_hash_types.find(hash_type) != allowable_hash_types.end()) continue;\n+\n+            BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m, in_pos,\n+                                                      hash_type, sigversion, cache,\n+                                                      MissingDataBehavior::FAIL),\n+                                \"hash_type = \" << hex(hash_type) << \" expected to fail\");\n+        }\n+    }\n+\n+    {\n+        // Check that if hash_type == SIGHASH_SINGLE then missing a \"corresponding\n+        // output\" fails.\n+        CMutableTransaction tx_to_m;\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+\n+        uint8_t in_pos = 1;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(1) > #tx_to==0 is expected to fail\");\n+\n+        tx_to_m.vout.push_back(CTxOut());\n+        in_pos = 2;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(2) > #tx_to==1 is expected to fail\");\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_all_success_paths)\n+{\n+    // Our approach here will be to follow BIP-341's signature algorithm (with\n+    // the BIP-342 extension) doing two things at once:\n+    //   1) We'll set up the input arguments to `SignatureHashSchnorr` function\n+    //      being tested, _and_\n+    //   2) we'll _compute the hash of those fields ourselves_ exaxctly as\n+    //      it is described in BIP-341 and BIP-342.\n+    // Then we can compare the two.  We'll do this in a data-driven way for each\n+    // of the different scenarios that the algorithm supports.\n+    //\n+    // In this way this test achieves 100% _path_ coverage of `SignatureHashSchnorr`\n+    // (not just 100% _branch_ coverage).\n+    // - Sadly, this isn't shown in the `lcov` reports.  There are still a few\n+    //   red `-` marks left.  This is because:\n+    //   1. `lcov` wasn't designed to handle death tests.\n+    //   2. ??? Some other unknown reasons, possibly due to the instrumentation,\n+    //      possibly due to `lcov` limitations.  You can see by the test output\n+    //      (`-log_level=all`) or within a debugger that in fact _all_ branches\n+    //      are taken when executing all the tests in this file.\n+\n+    // Here we define, and then generate, all combinations of the alternatives\n+    // for the parameters that vary the signature combination algorithm\n+\n+    const vn_sequence<SigVersion> SigVersion_alternatives{\n+        {SigVersion::TAPROOT, \"TAPROOT\"sv},\n+        {SigVersion::TAPSCRIPT, \"TAPSCRIPT\"sv}\n+    };\n+\n+    const vn_sequence<uint32_t> hash_type_output_alternatives{\n+        {SIGHASH_DEFAULT, \"SIGHASH_DEFAULT\"sv},\n+        {SIGHASH_ALL, \"SIGHASH_ALL\"sv},\n+        {SIGHASH_NONE, \"SIGHASH_NONE\"sv},\n+        {SIGHASH_SINGLE, \"SIGHASH_SINGLE\"sv}\n+    };\n+\n+    const vn_sequence<uint32_t> hash_type_input_alternatives{\n+        {0, \"N/A\"sv},\n+        {SIGHASH_ANYONECANPAY, \"SIGHASH_ANYONECANPAY\"sv}\n+    };\n+\n+    const vn_sequence<uint8_t> annex_alternatives{\n+        {0, \"no annex\"sv},\n+        {1, \"annex present\"sv}\n+    };\n+\n+    const vn_sequence<bool> output_hash_alternatives{\n+        {false, \"output hash missing\"sv},\n+        {true, \"output hash provided\"sv}\n+    };\n+\n+    {\n+        const int nAlternatives = SigVersion_alternatives.size()\n+                                  * hash_type_output_alternatives.size()\n+                                  * hash_type_input_alternatives.size()\n+                                  * annex_alternatives.size()\n+                                  * output_hash_alternatives.size()\n+                                  - 8 /* exclude SIGHASH_DEFAULT w/ SISHASH_ANYONECANPAY */;\n+\n+        BOOST_TEST_MESSAGE(\"Running \" << nAlternatives << \"scenarios\");",
      "path": "src/test/script_tapscript_tests.cpp",
      "position": null,
      "original_position": 602,
      "commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "original_commit_id": "a5808ce2f05040f740dad313e503624de2e8db93",
      "in_reply_to_id": 875574299,
      "user": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Fixed.",
      "created_at": "2022-05-19T20:16:57Z",
      "updated_at": "2022-05-19T20:16:57Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r877503897",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/877503897"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 602,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/877504162",
      "pull_request_review_id": 979210986,
      "id": 877504162,
      "node_id": "PRRC_kwDOABII5840Taai",
      "diff_hunk": "@@ -0,0 +1,1546 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <script/script_error.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/transaction_utils.h>\n+#include <util/strencodings.h>\n+#include <univalue.h>\n+\n+#include <boost/test/execution_monitor.hpp>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <array>\n+#include <charconv>\n+#include <cstddef>\n+#include <stdexcept>\n+#include <iomanip>\n+#include <iterator>\n+#include <limits>\n+#include <ostream>\n+#include <set>\n+#include <string_view>\n+#include <string>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+using namespace std::literals::string_literals;\n+using namespace std::literals::string_view_literals;\n+\n+namespace {\n+\n+typedef std::vector<unsigned char> valtype;\n+\n+/**\n+ * Value/Name pair used in data-driven tests\n+ */\n+template <typename T>\n+struct vn_pair\n+{\n+    vn_pair(T v, std::string_view n) : value(v), name(n) {}\n+\n+    const T value;\n+    const std::string_view name;\n+};\n+\n+/**\n+ * Sequence of value/name pairs used in data-driven tests\n+ */\n+template <typename T>\n+using vn_sequence = std::vector<vn_pair<T>>;\n+\n+/**\n+ * Invokes undefined behavior.  See `std::unreachable` in C++23.\n+ */\n+[[noreturn]] inline void declare_unreachable()\n+{\n+#ifdef _MSC_VER\n+    __assume(false);\n+#else\n+    // Assume all other compilers than MSVC implement this GCC builtin.\n+    __builtin_unreachable();\n+#endif\n+}\n+\n+/**\n+ * Outputs to stream as hex\n+ */\n+template <typename US>\n+struct hex\n+{\n+    hex(US v) : value(v) {}\n+    const US value;\n+\n+    friend std::ostream& operator<<(std::ostream& os, hex hx)\n+    {\n+        auto flags = os.flags();\n+        os << std::setw(2*sizeof(US)) << std::setfill('0') << std::showbase\n+           << std::hex << +hx.value;\n+        os.flags(flags);\n+        return os;\n+    }\n+};\n+\n+/**\n+ * Representation changer to fill an integral type with a known pattern.\n+ *\n+ * Pattern is successive byte values given a starting point.  Endianness doesn't\n+ * matter.\n+ */\n+union FillWithPattern {\n+    uint256 u256{0};\n+    uint64_t u64raw[sizeof(uint256)/sizeof(uint64_t)];\n+    uint32_t u32[sizeof(uint256)/sizeof(uint32_t)];\n+    int32_t i32[sizeof(uint256)/sizeof(int32_t)];\n+    uint8_t u8[sizeof(uint256)];\n+\n+    constexpr FillWithPattern(uint8_t start)\n+    {\n+        for (auto it = std::begin(u8); it != std::end(u8); ++it) {\n+            *it = start++;\n+        }\n+    }\n+\n+    uint64_t u64() const {\n+        // It is desirable to force high bit off\n+        return u64raw[0] & static_cast<uint64_t>(std::numeric_limits<int64_t>::max());\n+    }\n+};\n+\n+} // anon namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(script_tapscript_tests, BasicTestingSetup)\n+\n+/**\n+ * Testing EvalScript OP_CHECKSIGADD branch and EvalChecksigTapscript, both in\n+ * interpreter.cpp, against the BIP342 \"Rules for signature opcodes\".\n+ */\n+BOOST_AUTO_TEST_CASE(eval_checksigadd_basic_checks)\n+{\n+    const valtype SIG_64BYTES(64, 0);  // N.B.: Must be () not {}!\n+    const valtype SIG_65BYTES(65, 0);\n+    const valtype SIG_EMPTY{};\n+\n+    const valtype PUBKEY_32BYTES(32, 0);\n+    const valtype PUBKEY_15BYTES(15, 0);\n+    const valtype PUBKEY_EMPTY{};\n+\n+    constexpr int64_t TEST_NUM = 10;\n+\n+    constexpr int64_t START_VALIDATION_WEIGHT{ 90 };\n+    constexpr int64_t BIP342_SIGOPS_LIMIT{ 50 };\n+    constexpr int64_t END_VALIDATION_WEIGHT{ START_VALIDATION_WEIGHT - BIP342_SIGOPS_LIMIT };\n+\n+    /**\n+     * For these tests don't need _real_ signature/pubkey validation.  That is\n+     * tested elsewhere.  So we just _mock_ the signature checker and force it\n+     * to answer valid/invalid as we wish.\n+     */\n+\n+    struct SignatureCheckerMock : public BaseSignatureChecker\n+    {\n+        //! Whether this mock always validates, or always fails, the signature/pubkey check.\n+        enum class VALIDATION { ALWAYS_SUCCEEDS, ALWAYS_FAILS };\n+        VALIDATION m_kind = VALIDATION::ALWAYS_FAILS;\n+\n+        //! True _iff_ CheckSchnorrSignature was actually called\n+        mutable bool m_was_called = false;\n+\n+        SignatureCheckerMock() {}\n+\n+        bool CheckSchnorrSignature(Span<const unsigned char> sig,\n+                                    Span<const unsigned char> pubkey,\n+                                    SigVersion sigversion,\n+                                    ScriptExecutionData& execdata,\n+                                    ScriptError* serror = nullptr) const override",
      "path": "src/test/script_tapscript_tests.cpp",
      "position": null,
      "original_position": 163,
      "commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "original_commit_id": "a5808ce2f05040f740dad313e503624de2e8db93",
      "in_reply_to_id": 876048956,
      "user": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "OK!",
      "created_at": "2022-05-19T20:17:15Z",
      "updated_at": "2022-05-19T20:17:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r877504162",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/877504162"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 163,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/877505159",
      "pull_request_review_id": 979212648,
      "id": 877505159,
      "node_id": "PRRC_kwDOABII5840TaqH",
      "diff_hunk": "@@ -0,0 +1,1546 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <script/script_error.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/transaction_utils.h>\n+#include <util/strencodings.h>\n+#include <univalue.h>\n+\n+#include <boost/test/execution_monitor.hpp>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <array>\n+#include <charconv>\n+#include <cstddef>\n+#include <stdexcept>\n+#include <iomanip>\n+#include <iterator>\n+#include <limits>\n+#include <ostream>\n+#include <set>\n+#include <string_view>\n+#include <string>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+using namespace std::literals::string_literals;\n+using namespace std::literals::string_view_literals;\n+\n+namespace {\n+\n+typedef std::vector<unsigned char> valtype;\n+\n+/**\n+ * Value/Name pair used in data-driven tests\n+ */\n+template <typename T>\n+struct vn_pair\n+{\n+    vn_pair(T v, std::string_view n) : value(v), name(n) {}\n+\n+    const T value;\n+    const std::string_view name;\n+};\n+\n+/**\n+ * Sequence of value/name pairs used in data-driven tests\n+ */\n+template <typename T>\n+using vn_sequence = std::vector<vn_pair<T>>;\n+\n+/**\n+ * Invokes undefined behavior.  See `std::unreachable` in C++23.\n+ */\n+[[noreturn]] inline void declare_unreachable()\n+{\n+#ifdef _MSC_VER\n+    __assume(false);\n+#else\n+    // Assume all other compilers than MSVC implement this GCC builtin.\n+    __builtin_unreachable();\n+#endif\n+}\n+\n+/**\n+ * Outputs to stream as hex\n+ */\n+template <typename US>\n+struct hex\n+{\n+    hex(US v) : value(v) {}\n+    const US value;\n+\n+    friend std::ostream& operator<<(std::ostream& os, hex hx)\n+    {\n+        auto flags = os.flags();\n+        os << std::setw(2*sizeof(US)) << std::setfill('0') << std::showbase\n+           << std::hex << +hx.value;\n+        os.flags(flags);\n+        return os;\n+    }\n+};\n+\n+/**\n+ * Representation changer to fill an integral type with a known pattern.\n+ *\n+ * Pattern is successive byte values given a starting point.  Endianness doesn't\n+ * matter.\n+ */\n+union FillWithPattern {\n+    uint256 u256{0};\n+    uint64_t u64raw[sizeof(uint256)/sizeof(uint64_t)];\n+    uint32_t u32[sizeof(uint256)/sizeof(uint32_t)];\n+    int32_t i32[sizeof(uint256)/sizeof(int32_t)];\n+    uint8_t u8[sizeof(uint256)];\n+\n+    constexpr FillWithPattern(uint8_t start)\n+    {\n+        for (auto it = std::begin(u8); it != std::end(u8); ++it) {\n+            *it = start++;\n+        }\n+    }\n+\n+    uint64_t u64() const {\n+        // It is desirable to force high bit off\n+        return u64raw[0] & static_cast<uint64_t>(std::numeric_limits<int64_t>::max());\n+    }\n+};\n+\n+} // anon namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(script_tapscript_tests, BasicTestingSetup)\n+\n+/**\n+ * Testing EvalScript OP_CHECKSIGADD branch and EvalChecksigTapscript, both in\n+ * interpreter.cpp, against the BIP342 \"Rules for signature opcodes\".\n+ */\n+BOOST_AUTO_TEST_CASE(eval_checksigadd_basic_checks)\n+{\n+    const valtype SIG_64BYTES(64, 0);  // N.B.: Must be () not {}!\n+    const valtype SIG_65BYTES(65, 0);\n+    const valtype SIG_EMPTY{};\n+\n+    const valtype PUBKEY_32BYTES(32, 0);\n+    const valtype PUBKEY_15BYTES(15, 0);\n+    const valtype PUBKEY_EMPTY{};\n+\n+    constexpr int64_t TEST_NUM = 10;\n+\n+    constexpr int64_t START_VALIDATION_WEIGHT{ 90 };\n+    constexpr int64_t BIP342_SIGOPS_LIMIT{ 50 };\n+    constexpr int64_t END_VALIDATION_WEIGHT{ START_VALIDATION_WEIGHT - BIP342_SIGOPS_LIMIT };\n+\n+    /**\n+     * For these tests don't need _real_ signature/pubkey validation.  That is\n+     * tested elsewhere.  So we just _mock_ the signature checker and force it\n+     * to answer valid/invalid as we wish.\n+     */\n+\n+    struct SignatureCheckerMock : public BaseSignatureChecker\n+    {\n+        //! Whether this mock always validates, or always fails, the signature/pubkey check.\n+        enum class VALIDATION { ALWAYS_SUCCEEDS, ALWAYS_FAILS };\n+        VALIDATION m_kind = VALIDATION::ALWAYS_FAILS;\n+\n+        //! True _iff_ CheckSchnorrSignature was actually called\n+        mutable bool m_was_called = false;\n+\n+        SignatureCheckerMock() {}\n+\n+        bool CheckSchnorrSignature(Span<const unsigned char> sig,\n+                                    Span<const unsigned char> pubkey,\n+                                    SigVersion sigversion,\n+                                    ScriptExecutionData& execdata,\n+                                    ScriptError* serror = nullptr) const override\n+        {\n+            m_was_called = true;\n+            switch (m_kind) {\n+            case VALIDATION::ALWAYS_SUCCEEDS:\n+                *serror = SCRIPT_ERR_OK;\n+                return true;\n+            case VALIDATION::ALWAYS_FAILS:\n+                *serror = SCRIPT_ERR_SCHNORR_SIG;\n+                return false;\n+            }\n+            declare_unreachable();\n+        }\n+    };\n+\n+    /**\n+     * A fluent API for running these tests.\n+     *\n+     * (Easiest way to understand this class is to look at the actual tests\n+     * that follow in this function.)\n+     */\n+    struct Context\n+    {\n+        explicit Context(std::string_view descr) : testDescription(descr) {\n+            execdata.m_validation_weight_left_init = true;\n+            execdata.m_validation_weight_left = START_VALIDATION_WEIGHT;\n+        }\n+\n+        std::string testDescription;\n+        SigVersion sigVersion = SigVersion::TAPSCRIPT;\n+        uint32_t flags = 0;\n+        CScript script;\n+        ScriptError err = SCRIPT_ERR_OK;\n+        std::vector<valtype> stack;\n+        ScriptExecutionData execdata;\n+        SignatureCheckerMock sigchecker;\n+        int64_t callerLine = 0;\n+        bool result = false;\n+\n+        Context& SetVersion(SigVersion v)\n+        {\n+            sigVersion = v;\n+            return *this;\n+        }\n+\n+        Context& SetChecker(SignatureCheckerMock::VALIDATION kind)\n+        {\n+            sigchecker.m_kind = kind;\n+            return *this;\n+        }\n+\n+        Context& SetRemainingWeight(int64_t w)\n+        {\n+            execdata.m_validation_weight_left = w;\n+            return *this;\n+        }\n+\n+        Context& AddFlags(uint32_t f)\n+        {\n+            flags |= f;\n+            return *this;\n+        }\n+\n+        CScript& SetScript()\n+        {\n+            return script;\n+        }\n+\n+        Context& DoTest(int64_t line)\n+        {\n+            callerLine = line;\n+            result = EvalScript(stack, script,\n+                                SCRIPT_VERIFY_TAPROOT | flags,\n+                                sigchecker,\n+                                sigVersion,\n+                                execdata,\n+                                &err);\n+            return *this;\n+        }\n+\n+        Context& CheckCallSucceeded()\n+        {\n+            BOOST_CHECK_MESSAGE(result,\n+                               Descr()\n+                               << \": EvalScript succeeded, as expected\");\n+            BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK,\n+                                Descr()\n+                                << \": Error code expected OK, actual was \"\n+                                << ScriptErrorString(err));\n+            return *this;\n+        }\n+\n+        Context& CheckCallFailed(ScriptError expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!result,\n+                               Descr()\n+                               << \": EvalScript failed, as expected\");\n+            BOOST_CHECK_MESSAGE(err == expected,\n+                                Descr()\n+                                << \": Error code expected \" << ScriptErrorString(expected)\n+                                << \", actual was \" << ScriptErrorString(err));\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(sigchecker.m_was_called,\n+                               Descr()\n+                               << \": CheckSchnorrSignature was called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasNotValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(!sigchecker.m_was_called,\n+                               Descr()\n+                               << \": CheckSchnorrSignature was not called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckRemainingValidationWeight(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(execdata.m_validation_weight_left == expected,\n+                                Descr()\n+                                << \": Remaining validation weight expected \"\n+                                << expected << \", actual was \"\n+                                << execdata.m_validation_weight_left);\n+            return *this;\n+        }\n+\n+        Context& CheckStackDepth(std::size_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(stack.size() == expected,\n+                                Descr()\n+                                << \": Stack depth expected \" << expected\n+                                << \", actual was \" << stack.size());\n+            return *this;\n+        }\n+\n+        Context& CheckTOS(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!stack.empty(),\n+                                Descr()\n+                                << \": Stack expected at least one item, actually was empty\");\n+            const int64_t actual = CScriptNum(stack.at(0), false).GetInt64();\n+            BOOST_CHECK_MESSAGE(expected == actual,\n+                                Descr()\n+                                << \": Top-of-stack expected \" << expected\n+                                << \", actual was \" << actual);\n+            return *this;\n+        }\n+\n+    private:\n+        std::string Descr() {\n+            std::array<char, 24> sline{0};\n+            std::string_view svline(\"\");\n+            // (This seems rather elaborate to avoid locale issues with `std::to_string`. One\n+            // can't help but think the C++ committee could have provided a nicer wrapper for it.)\n+            if (auto [ptr,ec] = std::to_chars(sline.data(), sline.data() + sline.size(),\n+                                            callerLine);\n+                ec == std::errc())\n+            {\n+                svline = std::string_view(sline.data(), ptr - sline.data());\n+            }\n+\n+            std::string descr;\n+            descr.reserve(testDescription.size() + 20);\n+            descr += testDescription;\n+            descr += \" (@\";\n+            descr += svline;\n+            descr += \")\";\n+            return descr;\n+        }\n+    };\n+\n+    {\n+        Context ctx(\"SigVersion must not be BASE\");\n+        ctx.SetVersion(SigVersion::BASE).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"SigVersion must not be WITNESS_V0\");\n+        ctx.SetVersion(SigVersion::WITNESS_V0).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Minimum stack height 3 for OP_CHECKSIGADD\");\n+        ctx.SetScript()\n+            << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_INVALID_STACK_OPERATION)\n+            .CheckStackDepth(2);\n+    }\n+\n+    {\n+        Context ctx(\"`n` (2nd arg) size > 4 must fail\");\n+        // This is probably meant to be a check on the _encoding_ - that it is\n+        // minimal, but it can also be a check on the _value_.  BIP342 doesn't\n+        // say which.  Could be both...\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(10000000000LL) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            // (IMO this is an _unsatisfactory_ error code to return for a required\n+            // BIP342 check, but see the `catch` clause in `EvalScript`)\n+            .CheckCallFailed(SCRIPT_ERR_UNKNOWN_ERROR)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Insufficient validation weight remaining\");\n+        ctx.SetRemainingWeight(BIP342_SIGOPS_LIMIT-1)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + 32byte pubkey skips validation\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + non32byte pubkey skips validation\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey ('unknown pubkey type') _with_ discourage flag fails\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .AddFlags(SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .CheckSignatureWasNotValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation failure forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_FAILS)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_SCHNORR_SIG)\n+            .CheckSignatureWasValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation success forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasValidated()\n+            .CheckRemainingValidationWeight(END_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM+1);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey + empty sig with validation success forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_failure_cases)\n+{\n+    // As defined by BIP-341 Signature Validation Rules\n+    // Here we pick an acceptable SigVersion\n+    const SigVersion sigversion = SigVersion::TAPROOT;\n+\n+    CMutableTransaction tx_to_m;\n+    tx_to_m.vin.push_back(CTxIn());\n+    const uint32_t in_pos{0};\n+\n+    PrecomputedTransactionData cache;\n+    cache.m_bip341_taproot_ready = true;\n+    cache.m_spent_outputs_ready = true;\n+\n+    ScriptExecutionData execdata;\n+    execdata.m_annex_init = true;\n+    execdata.m_annex_present = false;\n+    execdata.m_annex_hash = uint256::ZERO;\n+    execdata.m_tapleaf_hash_init = false;\n+    execdata.m_codeseparator_pos_init = true;\n+\n+    uint256 hash_out{0};\n+\n+    {\n+        // Check all invalid hash_type codes rejected\n+        const std::set<uint8_t> allowable_hash_types{ 0x00, 0x01, 0x02, 0x03, 0x81, 0x82, 0x83 };\n+        for (unsigned ht = 0; ht <= 255; ht++) {\n+            const uint8_t hash_type = static_cast<uint8_t>(ht);\n+            if (allowable_hash_types.find(hash_type) != allowable_hash_types.end()) continue;\n+\n+            BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m, in_pos,\n+                                                      hash_type, sigversion, cache,\n+                                                      MissingDataBehavior::FAIL),\n+                                \"hash_type = \" << hex(hash_type) << \" expected to fail\");\n+        }\n+    }\n+\n+    {\n+        // Check that if hash_type == SIGHASH_SINGLE then missing a \"corresponding\n+        // output\" fails.\n+        CMutableTransaction tx_to_m;\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+\n+        uint8_t in_pos = 1;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(1) > #tx_to==0 is expected to fail\");\n+\n+        tx_to_m.vout.push_back(CTxOut());\n+        in_pos = 2;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(2) > #tx_to==1 is expected to fail\");\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_all_success_paths)\n+{\n+    // Our approach here will be to follow BIP-341's signature algorithm (with\n+    // the BIP-342 extension) doing two things at once:\n+    //   1) We'll set up the input arguments to `SignatureHashSchnorr` function\n+    //      being tested, _and_\n+    //   2) we'll _compute the hash of those fields ourselves_ exaxctly as\n+    //      it is described in BIP-341 and BIP-342.\n+    // Then we can compare the two.  We'll do this in a data-driven way for each\n+    // of the different scenarios that the algorithm supports.\n+    //\n+    // In this way this test achieves 100% _path_ coverage of `SignatureHashSchnorr`\n+    // (not just 100% _branch_ coverage).\n+    // - Sadly, this isn't shown in the `lcov` reports.  There are still a few\n+    //   red `-` marks left.  This is because:\n+    //   1. `lcov` wasn't designed to handle death tests.\n+    //   2. ??? Some other unknown reasons, possibly due to the instrumentation,\n+    //      possibly due to `lcov` limitations.  You can see by the test output\n+    //      (`-log_level=all`) or within a debugger that in fact _all_ branches\n+    //      are taken when executing all the tests in this file.\n+\n+    // Here we define, and then generate, all combinations of the alternatives\n+    // for the parameters that vary the signature combination algorithm\n+\n+    const vn_sequence<SigVersion> SigVersion_alternatives{\n+        {SigVersion::TAPROOT, \"TAPROOT\"sv},\n+        {SigVersion::TAPSCRIPT, \"TAPSCRIPT\"sv}\n+    };\n+\n+    const vn_sequence<uint32_t> hash_type_output_alternatives{\n+        {SIGHASH_DEFAULT, \"SIGHASH_DEFAULT\"sv},\n+        {SIGHASH_ALL, \"SIGHASH_ALL\"sv},\n+        {SIGHASH_NONE, \"SIGHASH_NONE\"sv},\n+        {SIGHASH_SINGLE, \"SIGHASH_SINGLE\"sv}\n+    };\n+\n+    const vn_sequence<uint32_t> hash_type_input_alternatives{\n+        {0, \"N/A\"sv},\n+        {SIGHASH_ANYONECANPAY, \"SIGHASH_ANYONECANPAY\"sv}\n+    };\n+\n+    const vn_sequence<uint8_t> annex_alternatives{\n+        {0, \"no annex\"sv},\n+        {1, \"annex present\"sv}\n+    };\n+\n+    const vn_sequence<bool> output_hash_alternatives{\n+        {false, \"output hash missing\"sv},\n+        {true, \"output hash provided\"sv}\n+    };\n+\n+    {\n+        const int nAlternatives = SigVersion_alternatives.size()\n+                                  * hash_type_output_alternatives.size()\n+                                  * hash_type_input_alternatives.size()\n+                                  * annex_alternatives.size()\n+                                  * output_hash_alternatives.size()\n+                                  - 8 /* exclude SIGHASH_DEFAULT w/ SISHASH_ANYONECANPAY */;\n+\n+        BOOST_TEST_MESSAGE(\"Running \" << nAlternatives << \"scenarios\");\n+    }\n+\n+    for (const auto& sigversion_alternative : SigVersion_alternatives)\n+    for (const auto& hash_type_output_alternative : hash_type_output_alternatives)\n+    for (const auto& hash_type_input_alternative : hash_type_input_alternatives)\n+    for (const auto& annex_alternative : annex_alternatives)\n+    for (const auto& output_hash_alternative : output_hash_alternatives)\n+    {\n+        // Exclude the invalid combination of SIGHASH_DEFAULT with SIGHASH_ANYONECANPAY\n+        if (hash_type_output_alternative.value == SIGHASH_DEFAULT\n+            && hash_type_input_alternative.value == SIGHASH_ANYONECANPAY) continue;\n+\n+        // We're going to want to know which scenario it is if a check actually\n+        // fails ...\n+        std::string scenario_description;\n+        {\n+            std::ostringstream oss;\n+            oss << sigversion_alternative.name << \", \"\n+                << hash_type_output_alternative.name << \", \"\n+                << hash_type_input_alternative.name << \", \"\n+                << annex_alternative.name << \", \"\n+                << output_hash_alternative.name;\n+            scenario_description = oss.str();\n+        }\n+        BOOST_TEST_MESSAGE(\"Scenario: \" << scenario_description);\n+\n+        // Set up the scenario we're running now - these 4 variables define the scenario\n+        const SigVersion sigversion{sigversion_alternative.value};\n+        const uint8_t hash_type{static_cast<uint8_t>(hash_type_output_alternative.value\n+                                                   | hash_type_input_alternative.value)};\n+        const uint8_t annex_present{annex_alternative.value};\n+        const bool have_output_hash{output_hash_alternative.value};\n+\n+        // Compute some helper values that depend on scenario\n+        const uint8_t ext_flag{sigversion == SigVersion::TAPSCRIPT};\n+        const uint8_t hash_input_type{static_cast<uint8_t>(hash_type & SIGHASH_INPUT_MASK)};\n+        const uint8_t hash_output_type{static_cast<uint8_t>((hash_type == SIGHASH_DEFAULT)\n+                                                             ? SIGHASH_ALL\n+                                                             : (hash_type & SIGHASH_OUTPUT_MASK))};\n+        const uint8_t spend_type = (ext_flag * 2) + annex_present;\n+\n+        // Fixed values (by algorithm)\n+        const uint8_t epoch{0x00};\n+        const uint8_t key_version{0};\n+\n+        // Mocked values fixed for purposes of this unit test.  This is a long\n+        // list of crufty things but that's because `SignatureHashSchnorr`, the\n+        // function begin tested, takes as arguments not just the tranaction\n+        // being signed (plus control data) but also some _precomputed values_\n+        // in two different structs: `PrecomputedTransactionData`, and\n+        // `ScriptExecutionData`.  On the one hand this is nice because a lot\n+        // of complexity of the signature algorithm doesn't have to be duplicated\n+        // here in this test: we can just use mocked values.  On the other hand,\n+        // there's a lot of icky setup to do to get all the values in the right\n+        // places both for our \"by the book\" implementation and to be set up to\n+        // call `SignatureHashSchnorr`.\n+        //\n+        // Try to make things simpler by at least using the same names for the\n+        // setup variables as for the fields in the parameter structs.\n+\n+        const uint32_t in_pos{1};\n+        const int32_t tx_version{FillWithPattern(0x01).i32[0]};\n+        const uint32_t tx_lock_time{FillWithPattern(0x05).u32[0]};\n+        const uint256 prevouts_single_hash{FillWithPattern(0x10).u256};\n+        const uint256 spent_amounts_single_hash{FillWithPattern(0x18).u256};\n+        const uint256 spent_scripts_single_hash{FillWithPattern(0x20).u256};\n+        const uint256 sequences_single_hash{FillWithPattern(0x28).u256};\n+        const uint256 outputs_single_hash{FillWithPattern(0x30).u256};\n+        const uint256 output_hash{FillWithPattern(0x40).u256};\n+        const uint256 annex_hash{FillWithPattern(0x48).u256};\n+        const uint256 tapleaf_hash{FillWithPattern(0x50).u256};\n+        const uint32_t codeseparator_pos{FillWithPattern(0x58).u32[0]};\n+        const COutPoint tx_input_at_pos_prevout{FillWithPattern(0x60).u256,\n+                                                FillWithPattern(0x68).u32[0]};\n+        const uint32_t tx_input_at_pos_nsequence{FillWithPattern(0x70).u32[0]};\n+        CTxOut spent_output_at_pos;\n+        spent_output_at_pos.nValue = FillWithPattern(0x80).u64();\n+        spent_output_at_pos.scriptPubKey /*random script, not even valid*/\n+            << OP_DUP << OP_HASH160 << OP_EQUALVERIFY << OP_CHECKSIG;\n+        CTxOut tx_output_at_pos;\n+        tx_output_at_pos.nValue = FillWithPattern(0x90).u64();\n+        tx_output_at_pos.scriptPubKey /*random script, not even valid*/\n+            << OP_CHECKSIG << OP_EQUALVERIFY << OP_HASH160 << OP_DUP;\n+\n+        // Now set up the arguments that are going to be passed to\n+        // `SignatureHashSchnorr`\n+\n+        CMutableTransaction tx_to;\n+        tx_to.nVersion = tx_version;\n+        tx_to.nLockTime = tx_lock_time;\n+        for (uint32_t i = 0; i < in_pos+2; i++) {\n+            tx_to.vin.push_back(CTxIn());\n+            tx_to.vout.push_back(CTxOut());\n+        }\n+        tx_to.vin[in_pos].prevout = tx_input_at_pos_prevout;\n+        tx_to.vin[in_pos].nSequence = tx_input_at_pos_nsequence;\n+        tx_to.vout[in_pos] = tx_output_at_pos;\n+\n+        PrecomputedTransactionData cache;\n+        cache.m_bip341_taproot_ready = true;\n+        cache.m_prevouts_single_hash = prevouts_single_hash;\n+        cache.m_spent_amounts_single_hash = spent_amounts_single_hash;\n+        cache.m_spent_scripts_single_hash = spent_scripts_single_hash;\n+        cache.m_sequences_single_hash = sequences_single_hash;\n+        cache.m_spent_outputs_ready = true;\n+        for (uint32_t i = 0; i < in_pos+2; i++) {\n+            cache.m_spent_outputs.push_back(CTxOut());\n+        }\n+        cache.m_spent_outputs[in_pos] = spent_output_at_pos;\n+        cache.m_outputs_single_hash = outputs_single_hash;\n+\n+        ScriptExecutionData execdata;\n+        execdata.m_annex_init = true;\n+        execdata.m_annex_present = !!annex_present;\n+        execdata.m_annex_hash = annex_hash;\n+        execdata.m_output_hash.reset();\n+        if (have_output_hash) {\n+            execdata.m_output_hash = output_hash;\n+        }\n+        if (sigversion == SigVersion::TAPSCRIPT) {\n+            execdata.m_tapleaf_hash_init = true;\n+            execdata.m_tapleaf_hash = tapleaf_hash;\n+            execdata.m_codeseparator_pos_init = true;\n+            execdata.m_codeseparator_pos = codeseparator_pos;\n+        }\n+\n+        // Now here is where we take all that data - _not_ the arguments to\n+        // `SignatureHashSchnorr` but all the scenario parameters, the helpers,\n+        // the values fixed by the algorithm, and our mocked values, and actually\n+        // follow the BIP-341/BIP-342 signature calculation algorithm right from\n+        // the specs ...\n+\n+        // Start with a tagged hasher with the correct tag\n+        CHashWriter hasher = TaggedHash(\"TapSighash\");\n+\n+        // First byte to hash is always the \"epoch\", 0x00 (BIP-341, footnote 20)\n+        hasher << epoch;\n+\n+        // Next: hash_type (1 byte)\n+        hasher << hash_type;\n+\n+        // Next: transaction version (4 bytes)\n+        hasher << tx_version;\n+\n+        // Next: transaction lock time (4 bytes)\n+        hasher << tx_lock_time;\n+\n+        // Next if _not_ SIGHASH_ANYONECANPAY:\n+        // a) SHA256 of the serialization of all input outpoints (32 bytes)\n+        // b) SHA256 of the serialization of all spent output amounts (32 bytes)\n+        // c) SHA256 of the serialization of all spent outputs' _scriptPubKeys_\n+        //    serialized as script (32 bytes)\n+        // d) SHA256 of the serialization of all input `nSequence` (32 bytes)\n+        if (hash_input_type != SIGHASH_ANYONECANPAY) {\n+            hasher << prevouts_single_hash;\n+            hasher << spent_amounts_single_hash;\n+            hasher << spent_scripts_single_hash;\n+            hasher << sequences_single_hash;\n+        }\n+\n+        // Next if _not_ SIGHASH_NONE _and not_ SIGHASH_SINGLE:\n+        // SHA256 of the serialization of all outputs in CTxOut format (32 bytes)\n+        if (hash_output_type != SIGHASH_NONE && hash_output_type != SIGHASH_SINGLE) {\n+            hasher << outputs_single_hash;\n+        }\n+\n+        // Now, data about input/prevout being spent\n+\n+        // The \"spend_type\" (1 byte) which is a function of ext_flag (above) and\n+        // whether there is an annex present (here: no)\n+        hasher << spend_type;\n+\n+        // Here, if we are _not_ SIGHASH_ANYONECANPAY, we just add the index of\n+        // the input in the transaction input vector (4 bytes). There must be a\n+        // input transaction at this index but _in this scenario_ it doesn't have\n+        // to have any data (it is never inspected).  Same for output transactions.\n+        //\n+        // On the other hand, if we _are_ SIGHASH_ANYONECANPAY, then we add the\n+        // `COutPoint` of this input (36 bytes), the value of the previous\n+        // output spent by this input (8 bytes), the `ScriptPubKey` of the\n+        // previous output spent by this input (35 bytes), and the `nSequence`\n+        // of this input.  These values are all precomputed and made available\n+        // to `SignatureHashSchnorr` in the `PrecomputedTransactionData` struct.\n+        if (hash_input_type == SIGHASH_ANYONECANPAY) {\n+            hasher << tx_input_at_pos_prevout;\n+            hasher << spent_output_at_pos.nValue;\n+            hasher << spent_output_at_pos.scriptPubKey;\n+            hasher << tx_input_at_pos_nsequence;\n+        } else {\n+            hasher << in_pos;\n+        }\n+\n+        // Now, if there is an \"annex\", add its hash (32 byte).  This is\n+        // precomputed and we don't actually have to have an actual annex to\n+        // pass in to `SignatureHashSchnorr`, nor do we have to hash it.\n+        if (annex_present) {\n+            hasher << annex_hash;\n+        }\n+\n+        // Here, iff the hash type is `SIGHASH_SINGLE`, add the hash of the\n+        // corresponding transaction output (32 bytes).  The wrinkle here is that\n+        // (for some reason) _sometimes_ this hash is precomputed, and _sometimes_\n+        // it is _not_.  So `SignatureHashSchnorr` will either use it if it is\n+        // provided or compute it from the corresponding output itself. (For our\n+        // purposes in this test the output need not be valid - it just must be\n+        // present.)\n+        if (hash_output_type == SIGHASH_SINGLE) {\n+            if (!have_output_hash) {\n+                CHashWriter hasher2(SER_GETHASH, 0);\n+                hasher2 << tx_output_at_pos;\n+                hasher << hasher2.GetSHA256();\n+            } else {\n+                hasher << output_hash;\n+            }\n+        }\n+\n+        // This is the TAPSCRIPT extension from BIP-342.  If the version is\n+        // TAPSCRIPT then add the tapleaf hash (32 bytes), the key_version (1\n+        // byte, fixed value of 0x00), and the \"opcode position of the last\n+        // executed OP_CODESEPARATOR before the currently executed signature\n+        // opcode\" (4 bytes).  The tapleaf hash and the code separator position\n+        // are both precomputed values.\n+        if (sigversion == SigVersion::TAPSCRIPT) {\n+            hasher << tapleaf_hash;\n+            hasher << key_version;\n+            hasher << codeseparator_pos;\n+        }\n+\n+        // That's all that goes into the hasher for this signature\n+        const uint256 expected_hash_out = hasher.GetSHA256();\n+\n+        // Now finally we test the actual implemented algorithm under test:\n+        uint256 actual_hash_out{0};\n+        BOOST_TEST(SignatureHashSchnorr(actual_hash_out,\n+                                        execdata, tx_to, in_pos,\n+                                        hash_type, sigversion, cache,\n+                                        MissingDataBehavior::FAIL),\n+                   \"Scenario: \" << scenario_description);\n+        BOOST_TEST(expected_hash_out == actual_hash_out,\n+                   \"Scenario: \" << scenario_description\n+                   << \" - expected \" << expected_hash_out.ToString()\n+                   << \" == actual \" << actual_hash_out.ToString());\n+    }\n+}\n+\n+namespace {\n+\n+// Valid Schnoor (pubkey, msg, signature) tuples (copied from `key_tests.cpp`)\n+\n+struct SchnorrTriplet\n+{\n+    SchnorrTriplet(std::string pubkey, std::string sighash, std::string sig)\n+                : pubkey(ParseHex(pubkey))\n+                , sighash(uint256(ParseHex(sighash)))\n+                , sig(ParseHex(sig)) {}\n+    valtype pubkey;\n+    uint256 sighash;\n+    valtype sig;\n+};\n+\n+static const std::vector<SchnorrTriplet> SCHNORR_TRIPLETS = {\n+    {\"F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9\", \"0000000000000000000000000000000000000000000000000000000000000000\", \"E907831F80848D1069A5371B402410364BDF1C5F8307B0084C55F1CE2DCA821525F66A4A85EA8B71E482A74F382D2CE5EBEEE8FDB2172F477DF4900D310536C0\"},\n+    {\"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659\", \"243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89\", \"6896BD60EEAE296DB48A229FF71DFE071BDE413E6D43F917DC8DCF8C78DE33418906D11AC976ABCCB20B091292BFF4EA897EFCB639EA871CFA95F6DE339E4B0A\"},\n+    {\"DD308AFEC5777E13121FA72B9CC1B7CC0139715309B086C960E18FD969774EB8\", \"7E2D58D8B3BCDF1ABADEC7829054F90DDA9805AAB56C77333024B9D0A508B75C\", \"5831AAEED7B44BB74E5EAB94BA9D4294C49BCF2A60728D8B4C200F50DD313C1BAB745879A5AD954A72C45A91C3A51D3C7ADEA98D82F8481E0E1E03674A6F3FB7\"},\n+    {\"25D1DFF95105F5253C4022F628A996AD3A0D95FBF21D468A1B33F8C160D8F517\", \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", \"7EB0509757E246F19449885651611CB965ECC1A187DD51B64FDA1EDC9637D5EC97582B9CB13DB3933705B32BA982AF5AF25FD78881EBB32771FC5922EFC66EA3\"},\n+    {\"D69C3509BB99E412E68B0FE8544E72837DFA30746D8BE2AA65975F29D22DC7B9\", \"4DF3C3F68FCC83B27E9D42C90431A72499F17875C81A599B566C9889B9696703\", \"00000000000000000000003B78CE563F89A0ED9414F5AA28AD0D96D6795F9C6376AFB1548AF603B3EB45C9F8207DEE1060CB71C04E80F593060B07D28308D7F4\"},\n+};\n+\n+}\n+\n+BOOST_AUTO_TEST_CASE(internal_test_validate_schnorr_testdata)\n+{\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(XOnlyPubKey(triplet.pubkey).VerifySchnorr(triplet.sighash, triplet.sig));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(verify_schnorr_signature)\n+{\n+    // Defeat, for test purposes, the protected access of\n+    // `GenericTransactionSignatureChecker::VerifySchnorrSignature`\n+    struct UnprotectedTransactionSignatureChecker : public MutableTransactionSignatureChecker\n+    {\n+        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;\n+        using MutableTransactionSignatureChecker::VerifySchnorrSignature;\n+    };\n+    UnprotectedTransactionSignatureChecker sut{nullptr, 0, {}, {}};\n+\n+    // Positive tests: triplets which verify\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(sut.VerifySchnorrSignature(triplet.sig,\n+                                              XOnlyPubKey{triplet.pubkey},\n+                                              triplet.sighash));\n+    }\n+\n+    // Negative tests: triplets which fail to verify (get these failing triplets\n+    // by modifying a valid triplet, one field at a time)\n+    auto diddle_front_byte = [](auto v) { v[0]++; return v; };\n+    auto& triplet = SCHNORR_TRIPLETS[0];\n+    BOOST_TEST(!sut.VerifySchnorrSignature(diddle_front_byte(triplet.sig),\n+                                           XOnlyPubKey{triplet.pubkey},\n+                                           triplet.sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.sig,\n+                                           XOnlyPubKey{diddle_front_byte(triplet.pubkey)},\n+                                           triplet.sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.sig,\n+                                           XOnlyPubKey{triplet.pubkey},\n+                                           uint256::ONE));\n+}\n+\n+BOOST_AUTO_TEST_CASE(check_schnorr_signature)\n+{\n+    // Provide, for test purposes, a subclass of `GenericTransactionsSignatureChecker`\n+    // that mocks `VerifySchnorrSignature` so we can more easily test\n+    // `CheckSchnorrSignature` without going to the trouble of having a valid\n+    // transaction (which is unnecessary for this _unit_ test.)\n+    struct MockVerifyingTransactionSignatureChecker : public MutableTransactionSignatureChecker\n+    {\n+\n+        uint256 expected_sighash = [](){\n+            uint256 h{};\n+            // This is the known sighash of the Tx and input data we set up (precomputed)\n+            h.SetHex(\"f614d8ae6dcc49e2ca2ef1c03f93c7326189e5575d446e825e5a2700fb1cb83c\");\n+            return h;\n+        }();\n+\n+        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;\n+\n+        enum class if_as_expected_return { False, True };\n+        if_as_expected_return iae{ if_as_expected_return::True };\n+        void SetExpectation(if_as_expected_return iaer) { iae = iaer; }\n+\n+        bool VerifySchnorrSignature(Span<const unsigned char> sig,\n+                                    const XOnlyPubKey& pubkey,\n+                                    const uint256& sighash) const override\n+        {\n+            // Following line used only to determine the known canned `expected_sighash` above:\n+            // BOOST_TEST_MESSAGE(\"MockVerifySchnorrSignature: sighash == \" << sighash.ToString());\n+\n+            bool as_expected = sighash == expected_sighash;\n+            if (iae == if_as_expected_return::True)\n+                return as_expected;\n+            else\n+                return !as_expected;\n+        };\n+    };\n+\n+    const auto triplet = SCHNORR_TRIPLETS[0];\n+    const CMutableTransaction txToIn{};\n+    ScriptExecutionData execdata{};\n+\n+    {\n+        // Signature must be 64 or 65 bytes long\n+        for (size_t i = 0; i <= 99; i++) {\n+            valtype testsig(i, i);\n+            if (testsig.size() == 64 || testsig.size() == 65) continue;\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_SIZE);\n+        }\n+    }\n+\n+    {\n+        // Iff signature is 65 bytes long last byte must **NOT** be SIGHASH_DEFAULT (0x00) per BIP-342\n+        {\n+            // Negative test: last byte _is_ SIGHASH_DEFAULT\n+            valtype testsig(65, 65);\n+            testsig.back() = SIGHASH_DEFAULT;\n+\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);\n+        }\n+        {\n+            // Negative tests: last byte is _not_ SIGHASH_DEFAULT, but we early exit _without changing\n+            // serror_ because we don't provide a txDataIn (🡄 this requires knowledge of how\n+            // `CheckSchnorrSignature` is written).\n+            for (size_t i = 1; i <= 255; i++) {\n+                valtype testsig(65, i);\n+\n+                MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+                ScriptError serror{SCRIPT_ERR_OK};\n+                BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+                BOOST_TEST(serror == SCRIPT_ERR_OK);\n+            }\n+        }\n+    }\n+\n+    {\n+        // Now check that, given the parameters, if `SignatureHashSchnorr fails there's an error exit.\n+        // Otherwise, if it succeeds, it proceeds to call `VerifySchnorrSignature` and depending on\n+        // _that_ result `SignatureHashSchnorr` either succeeds or fails.\n+        //\n+        // We do this using the mocked `VerifySchnorrSignature` so we only need to pass parameters\n+        // that work with `SignatureHashSchnorr`, they don't _also_ have to validate with\n+        // `VerifySchnorrSignature`.\n+\n+        const uint32_t in_pos{0};\n+        CMutableTransaction txToIn{};\n+        txToIn.nVersion = 0;\n+        txToIn.nLockTime = 0;\n+        txToIn.vin.push_back(CTxIn());\n+        txToIn.vin[in_pos].prevout = COutPoint(uint256::ZERO, 0);\n+        txToIn.vin[in_pos].nSequence = 0;\n+        txToIn.vout.push_back(CTxOut());\n+\n+        PrecomputedTransactionData txDataIn{};\n+        txDataIn.m_bip341_taproot_ready = true;\n+        txDataIn.m_prevouts_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_amounts_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_scripts_single_hash = uint256::ZERO;\n+        txDataIn.m_sequences_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_outputs_ready = true;\n+        txDataIn.m_spent_outputs.push_back(CTxOut());\n+        txDataIn.m_spent_outputs[in_pos].nValue = 0;\n+        txDataIn.m_spent_outputs[in_pos].scriptPubKey << OP_DUP << OP_CHECKSIG;\n+        txDataIn.m_outputs_single_hash = uint256::ZERO;\n+\n+        ScriptExecutionData execdata{};\n+        execdata.m_annex_init = true;\n+        execdata.m_annex_present = true;\n+        execdata.m_annex_hash = uint256::ZERO;\n+        execdata.m_output_hash.reset();\n+\n+        {\n+            // Confirm that we can force `SignatureHashSchnorr` to fail (via an early exit)\n+            PrecomputedTransactionData txDataIn{};\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(triplet.sig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);\n+        }\n+        {\n+            // Now `SignatureHashSchnorr` will return true but we'll fail `VerifySchnorrSignature`\n+            // and show it returns the correct error.\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            sut.SetExpectation(MockVerifyingTransactionSignatureChecker::if_as_expected_return::False);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(triplet.sig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG);\n+        }\n+        {\n+            // Finally, same as previous, except we'll force `VerifySchnorrSignature` to succeed and\n+            // show now that `CheckSchnorrSignature` finally suceeds.\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            sut.SetExpectation(MockVerifyingTransactionSignatureChecker::if_as_expected_return::True);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(sut.CheckSchnorrSignature(triplet.sig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_OK);\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+    std::optional<valtype> from_hex(std::string_view sv) {\n+        static const auto hexits = \"0123456789abcdefABCDEF\"sv;\n+\n+        constexpr auto is_hexit = [](char c) {\n+            return std::string::npos != hexits.find(c);\n+        };\n+\n+        // validate\n+        if (sv.size() % 2 != 0) return {};\n+        if (!std::all_of(sv.begin(), sv.end(), is_hexit)) return {};\n+\n+        constexpr auto from_hexit = [](char c) -> unsigned char {\n+            auto d = hexits.find(c);\n+            return d < 16 ? d : d - 6;\n+        };\n+\n+        valtype r; r.reserve(sv.size() / 2);\n+        for (size_t i = 0; i < sv.size(); i+=2) {\n+            r.push_back(from_hexit(sv[i])<<4 | from_hexit(sv[i+1]));\n+        }\n+        return r;\n+    }\n+\n+    valtype operator \"\" _hex(const char* s, size_t len) {\n+        auto v = from_hex({s, len});\n+        if (v) return v.value();\n+        throw std::invalid_argument(\"invalid hex literal\");\n+    }\n+\n+    // (not checked: That `C` is a container (supporting `std::begin()` and `std::end()`)\n+    // whose elements are `unsigned char`) (note `uint256` doesn't have a `value_type` member)\n+    template <typename C>\n+    std::string to_hex(C container) {\n+        constexpr auto to_hexit = [](unsigned char c) -> char {\n+            return \"0123456789ABCDEF\"[c];\n+        };\n+\n+        std::string r; r.reserve(container.size() * 2);\n+        for (unsigned char c : container) {\n+            r.push_back(to_hexit(c>>4 & 0x0F));\n+            r.push_back(to_hexit(c & 0x0F));\n+        }\n+        return r;\n+    }\n+\n+    // An attempt to get close to the notation of BIP-340:\n+    //   `||` concatenates byte vectors\n+    //   `[j]` indexes a single element\n+    //   `[i:j]` can't be represented in C++ - there is no `:` operator, so instead\n+    //       I substitute `[{i,j}]` - which is the subrange `[i,j)`.\n+    //\n+    // For convenience, constructing from a string and comparing (equality) against\n+    // a string are available.\n+    struct bytevector : public std::vector<unsigned char>\n+    {\n+        using std::vector<unsigned char>::vector;\n+        explicit bytevector(std::string_view sv) {\n+            resize(sv.size());\n+            std::copy(sv.begin(), sv.end(), begin());\n+        }\n+\n+        explicit bytevector(uint256 u) {\n+            resize(u.size());\n+            std::copy(u.begin(), u.end(), begin());\n+        }\n+\n+        /**\n+         * Return half-open subrange from byte vector: `[i:j)`\n+         */\n+        bytevector subrange(size_t i, size_t j) const {\n+            assert(i <= j && j <= size());\n+            bytevector r(j-i, 0);\n+            std::copy(begin()+i, begin()+j, r.begin());\n+            return r;\n+        }\n+\n+        using std::vector<unsigned char>::operator[];\n+        bytevector operator[](std::tuple<size_t, size_t> range) const {\n+            auto [i, j] = range;\n+            return subrange(i, j);\n+        }\n+\n+        void concat(const bytevector& bv) {\n+            size_t this_size{size()};\n+            resize(size() + bv.size());\n+            std::copy(bv.begin(), bv.end(), begin() + this_size);\n+        }\n+\n+        std::string to_string() const {\n+            return std::string(begin(), end());\n+        }\n+    };\n+\n+    bytevector operator \"\"_bv(const char* s, size_t len) {\n+        return bytevector(std::string_view(s, len));\n+    }\n+\n+    bool operator==(const bytevector& lhs, std::string_view rhs) {\n+        return lhs.to_string() == rhs;\n+    }\n+\n+    bool operator==(std::string_view lhs, const bytevector& rhs) {\n+        return lhs == rhs.to_string();\n+    }\n+\n+    bool operator<(const bytevector& lhs, const bytevector& rhs) {\n+        return std::lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());\n+    }\n+\n+    bytevector operator||(const bytevector& lhs, const bytevector& rhs)\n+    {\n+        bytevector r(lhs);\n+        r = lhs;\n+        r.concat(rhs);\n+        return r;\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(internal_test_validate_hex_to_bytes_and_back_helpers)\n+{\n+    // Hex digits have correct value\n+    std::pair<char, unsigned char> hexit_map[] {\n+                {'0',  0}, {'1',  1}, {'2',  2}, {'3',  3}, {'4',  4},\n+                {'5',  5}, {'6',  6}, {'7',  7}, {'8',  8}, {'9',  9},\n+                {'a', 10}, {'b', 11}, {'c', 12}, {'d', 13}, {'e', 14}, {'f', 15},\n+                {'A', 10}, {'B', 11}, {'C', 12}, {'D', 13}, {'E', 14}, {'F', 15},\n+    };\n+\n+    for (const auto& [c, d] : hexit_map) {\n+        BOOST_TEST(from_hex(std::string(2, c)).value() == valtype(1, d*16 + d));\n+    };\n+    // Non-hex digits fail to convert\n+    for (int d = 0; d < 255; d++) {\n+        char dig = static_cast<char>(d);\n+        static const auto hex_digits = \"0123456789abcdefABCDEF\"sv;\n+        if (std::none_of(hex_digits.begin(), hex_digits.end(), [dig](char c) { return c == dig; })) {\n+            BOOST_TEST((!from_hex(std::string{1, dig} + dig)));\n+        }\n+    }\n+\n+    // hex strings to byte vector\n+    BOOST_TEST(\"0A\"_hex == valtype(1, 0x0a));",
      "path": "src/test/script_tapscript_tests.cpp",
      "position": null,
      "original_position": 1201,
      "commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "original_commit_id": "a5808ce2f05040f740dad313e503624de2e8db93",
      "in_reply_to_id": 876110013,
      "user": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I'm going to move all of these helpers off into homes in `src/test/util` where they can be used to make unit tests easier to write/read/maintain.  But reduce the set of them at the same time - there's some redundancy, as you've noticed.  (In a subsequent push to this PR.)",
      "created_at": "2022-05-19T20:18:34Z",
      "updated_at": "2022-05-19T20:18:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r877505159",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/877505159"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1201,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/878645117",
      "pull_request_review_id": 980786990,
      "id": 878645117,
      "node_id": "PRRC_kwDOABII5840Xw99",
      "diff_hunk": "@@ -0,0 +1,1546 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <script/script_error.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/transaction_utils.h>\n+#include <util/strencodings.h>\n+#include <univalue.h>\n+\n+#include <boost/test/execution_monitor.hpp>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <array>\n+#include <charconv>\n+#include <cstddef>\n+#include <stdexcept>\n+#include <iomanip>\n+#include <iterator>\n+#include <limits>\n+#include <ostream>\n+#include <set>\n+#include <string_view>\n+#include <string>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+using namespace std::literals::string_literals;\n+using namespace std::literals::string_view_literals;\n+\n+namespace {\n+\n+typedef std::vector<unsigned char> valtype;\n+\n+/**\n+ * Value/Name pair used in data-driven tests\n+ */\n+template <typename T>\n+struct vn_pair\n+{\n+    vn_pair(T v, std::string_view n) : value(v), name(n) {}\n+\n+    const T value;\n+    const std::string_view name;\n+};\n+\n+/**\n+ * Sequence of value/name pairs used in data-driven tests\n+ */\n+template <typename T>\n+using vn_sequence = std::vector<vn_pair<T>>;\n+\n+/**\n+ * Invokes undefined behavior.  See `std::unreachable` in C++23.\n+ */\n+[[noreturn]] inline void declare_unreachable()\n+{\n+#ifdef _MSC_VER\n+    __assume(false);\n+#else\n+    // Assume all other compilers than MSVC implement this GCC builtin.\n+    __builtin_unreachable();\n+#endif\n+}\n+\n+/**\n+ * Outputs to stream as hex\n+ */\n+template <typename US>\n+struct hex\n+{\n+    hex(US v) : value(v) {}\n+    const US value;\n+\n+    friend std::ostream& operator<<(std::ostream& os, hex hx)\n+    {\n+        auto flags = os.flags();\n+        os << std::setw(2*sizeof(US)) << std::setfill('0') << std::showbase\n+           << std::hex << +hx.value;\n+        os.flags(flags);\n+        return os;\n+    }\n+};\n+\n+/**\n+ * Representation changer to fill an integral type with a known pattern.\n+ *\n+ * Pattern is successive byte values given a starting point.  Endianness doesn't\n+ * matter.\n+ */\n+union FillWithPattern {\n+    uint256 u256{0};\n+    uint64_t u64raw[sizeof(uint256)/sizeof(uint64_t)];\n+    uint32_t u32[sizeof(uint256)/sizeof(uint32_t)];\n+    int32_t i32[sizeof(uint256)/sizeof(int32_t)];\n+    uint8_t u8[sizeof(uint256)];\n+\n+    constexpr FillWithPattern(uint8_t start)\n+    {\n+        for (auto it = std::begin(u8); it != std::end(u8); ++it) {\n+            *it = start++;\n+        }\n+    }\n+\n+    uint64_t u64() const {\n+        // It is desirable to force high bit off\n+        return u64raw[0] & static_cast<uint64_t>(std::numeric_limits<int64_t>::max());\n+    }\n+};\n+\n+} // anon namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(script_tapscript_tests, BasicTestingSetup)\n+\n+/**\n+ * Testing EvalScript OP_CHECKSIGADD branch and EvalChecksigTapscript, both in\n+ * interpreter.cpp, against the BIP342 \"Rules for signature opcodes\".\n+ */\n+BOOST_AUTO_TEST_CASE(eval_checksigadd_basic_checks)\n+{\n+    const valtype SIG_64BYTES(64, 0);  // N.B.: Must be () not {}!\n+    const valtype SIG_65BYTES(65, 0);\n+    const valtype SIG_EMPTY{};\n+\n+    const valtype PUBKEY_32BYTES(32, 0);\n+    const valtype PUBKEY_15BYTES(15, 0);\n+    const valtype PUBKEY_EMPTY{};\n+\n+    constexpr int64_t TEST_NUM = 10;\n+\n+    constexpr int64_t START_VALIDATION_WEIGHT{ 90 };\n+    constexpr int64_t BIP342_SIGOPS_LIMIT{ 50 };\n+    constexpr int64_t END_VALIDATION_WEIGHT{ START_VALIDATION_WEIGHT - BIP342_SIGOPS_LIMIT };\n+\n+    /**\n+     * For these tests don't need _real_ signature/pubkey validation.  That is\n+     * tested elsewhere.  So we just _mock_ the signature checker and force it\n+     * to answer valid/invalid as we wish.\n+     */\n+\n+    struct SignatureCheckerMock : public BaseSignatureChecker\n+    {\n+        //! Whether this mock always validates, or always fails, the signature/pubkey check.\n+        enum class VALIDATION { ALWAYS_SUCCEEDS, ALWAYS_FAILS };\n+        VALIDATION m_kind = VALIDATION::ALWAYS_FAILS;\n+\n+        //! True _iff_ CheckSchnorrSignature was actually called\n+        mutable bool m_was_called = false;\n+\n+        SignatureCheckerMock() {}\n+\n+        bool CheckSchnorrSignature(Span<const unsigned char> sig,\n+                                    Span<const unsigned char> pubkey,\n+                                    SigVersion sigversion,\n+                                    ScriptExecutionData& execdata,\n+                                    ScriptError* serror = nullptr) const override\n+        {\n+            m_was_called = true;\n+            switch (m_kind) {\n+            case VALIDATION::ALWAYS_SUCCEEDS:\n+                *serror = SCRIPT_ERR_OK;\n+                return true;\n+            case VALIDATION::ALWAYS_FAILS:\n+                *serror = SCRIPT_ERR_SCHNORR_SIG;\n+                return false;\n+            }\n+            declare_unreachable();\n+        }\n+    };\n+\n+    /**\n+     * A fluent API for running these tests.\n+     *\n+     * (Easiest way to understand this class is to look at the actual tests\n+     * that follow in this function.)\n+     */\n+    struct Context\n+    {\n+        explicit Context(std::string_view descr) : testDescription(descr) {\n+            execdata.m_validation_weight_left_init = true;\n+            execdata.m_validation_weight_left = START_VALIDATION_WEIGHT;\n+        }\n+\n+        std::string testDescription;\n+        SigVersion sigVersion = SigVersion::TAPSCRIPT;\n+        uint32_t flags = 0;\n+        CScript script;\n+        ScriptError err = SCRIPT_ERR_OK;\n+        std::vector<valtype> stack;\n+        ScriptExecutionData execdata;\n+        SignatureCheckerMock sigchecker;\n+        int64_t callerLine = 0;\n+        bool result = false;\n+\n+        Context& SetVersion(SigVersion v)\n+        {\n+            sigVersion = v;\n+            return *this;\n+        }\n+\n+        Context& SetChecker(SignatureCheckerMock::VALIDATION kind)\n+        {\n+            sigchecker.m_kind = kind;\n+            return *this;\n+        }\n+\n+        Context& SetRemainingWeight(int64_t w)\n+        {\n+            execdata.m_validation_weight_left = w;\n+            return *this;\n+        }\n+\n+        Context& AddFlags(uint32_t f)\n+        {\n+            flags |= f;\n+            return *this;\n+        }\n+\n+        CScript& SetScript()\n+        {\n+            return script;\n+        }\n+\n+        Context& DoTest(int64_t line)\n+        {\n+            callerLine = line;\n+            result = EvalScript(stack, script,\n+                                SCRIPT_VERIFY_TAPROOT | flags,\n+                                sigchecker,\n+                                sigVersion,\n+                                execdata,\n+                                &err);\n+            return *this;\n+        }\n+\n+        Context& CheckCallSucceeded()\n+        {\n+            BOOST_CHECK_MESSAGE(result,\n+                               Descr()\n+                               << \": EvalScript succeeded, as expected\");\n+            BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK,\n+                                Descr()\n+                                << \": Error code expected OK, actual was \"\n+                                << ScriptErrorString(err));\n+            return *this;\n+        }\n+\n+        Context& CheckCallFailed(ScriptError expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!result,\n+                               Descr()\n+                               << \": EvalScript failed, as expected\");\n+            BOOST_CHECK_MESSAGE(err == expected,\n+                                Descr()\n+                                << \": Error code expected \" << ScriptErrorString(expected)\n+                                << \", actual was \" << ScriptErrorString(err));\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(sigchecker.m_was_called,\n+                               Descr()\n+                               << \": CheckSchnorrSignature was called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasNotValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(!sigchecker.m_was_called,\n+                               Descr()\n+                               << \": CheckSchnorrSignature was not called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckRemainingValidationWeight(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(execdata.m_validation_weight_left == expected,\n+                                Descr()\n+                                << \": Remaining validation weight expected \"\n+                                << expected << \", actual was \"\n+                                << execdata.m_validation_weight_left);\n+            return *this;\n+        }\n+\n+        Context& CheckStackDepth(std::size_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(stack.size() == expected,\n+                                Descr()\n+                                << \": Stack depth expected \" << expected\n+                                << \", actual was \" << stack.size());\n+            return *this;\n+        }\n+\n+        Context& CheckTOS(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!stack.empty(),\n+                                Descr()\n+                                << \": Stack expected at least one item, actually was empty\");\n+            const int64_t actual = CScriptNum(stack.at(0), false).GetInt64();\n+            BOOST_CHECK_MESSAGE(expected == actual,\n+                                Descr()\n+                                << \": Top-of-stack expected \" << expected\n+                                << \", actual was \" << actual);\n+            return *this;\n+        }\n+\n+    private:\n+        std::string Descr() {\n+            std::array<char, 24> sline{0};\n+            std::string_view svline(\"\");\n+            // (This seems rather elaborate to avoid locale issues with `std::to_string`. One\n+            // can't help but think the C++ committee could have provided a nicer wrapper for it.)\n+            if (auto [ptr,ec] = std::to_chars(sline.data(), sline.data() + sline.size(),\n+                                            callerLine);\n+                ec == std::errc())\n+            {\n+                svline = std::string_view(sline.data(), ptr - sline.data());\n+            }\n+\n+            std::string descr;\n+            descr.reserve(testDescription.size() + 20);\n+            descr += testDescription;\n+            descr += \" (@\";\n+            descr += svline;\n+            descr += \")\";\n+            return descr;\n+        }\n+    };\n+\n+    {\n+        Context ctx(\"SigVersion must not be BASE\");\n+        ctx.SetVersion(SigVersion::BASE).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"SigVersion must not be WITNESS_V0\");\n+        ctx.SetVersion(SigVersion::WITNESS_V0).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Minimum stack height 3 for OP_CHECKSIGADD\");\n+        ctx.SetScript()\n+            << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_INVALID_STACK_OPERATION)\n+            .CheckStackDepth(2);\n+    }\n+\n+    {\n+        Context ctx(\"`n` (2nd arg) size > 4 must fail\");\n+        // This is probably meant to be a check on the _encoding_ - that it is\n+        // minimal, but it can also be a check on the _value_.  BIP342 doesn't\n+        // say which.  Could be both...\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(10000000000LL) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            // (IMO this is an _unsatisfactory_ error code to return for a required\n+            // BIP342 check, but see the `catch` clause in `EvalScript`)\n+            .CheckCallFailed(SCRIPT_ERR_UNKNOWN_ERROR)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Insufficient validation weight remaining\");\n+        ctx.SetRemainingWeight(BIP342_SIGOPS_LIMIT-1)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + 32byte pubkey skips validation\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + non32byte pubkey skips validation\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey ('unknown pubkey type') _with_ discourage flag fails\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .AddFlags(SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .CheckSignatureWasNotValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation failure forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_FAILS)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_SCHNORR_SIG)\n+            .CheckSignatureWasValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation success forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasValidated()\n+            .CheckRemainingValidationWeight(END_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM+1);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey + empty sig with validation success forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_failure_cases)\n+{\n+    // As defined by BIP-341 Signature Validation Rules\n+    // Here we pick an acceptable SigVersion\n+    const SigVersion sigversion = SigVersion::TAPROOT;\n+\n+    CMutableTransaction tx_to_m;\n+    tx_to_m.vin.push_back(CTxIn());\n+    const uint32_t in_pos{0};\n+\n+    PrecomputedTransactionData cache;\n+    cache.m_bip341_taproot_ready = true;\n+    cache.m_spent_outputs_ready = true;\n+\n+    ScriptExecutionData execdata;\n+    execdata.m_annex_init = true;\n+    execdata.m_annex_present = false;\n+    execdata.m_annex_hash = uint256::ZERO;\n+    execdata.m_tapleaf_hash_init = false;\n+    execdata.m_codeseparator_pos_init = true;\n+\n+    uint256 hash_out{0};\n+\n+    {\n+        // Check all invalid hash_type codes rejected\n+        const std::set<uint8_t> allowable_hash_types{ 0x00, 0x01, 0x02, 0x03, 0x81, 0x82, 0x83 };\n+        for (unsigned ht = 0; ht <= 255; ht++) {\n+            const uint8_t hash_type = static_cast<uint8_t>(ht);\n+            if (allowable_hash_types.find(hash_type) != allowable_hash_types.end()) continue;\n+\n+            BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m, in_pos,\n+                                                      hash_type, sigversion, cache,\n+                                                      MissingDataBehavior::FAIL),\n+                                \"hash_type = \" << hex(hash_type) << \" expected to fail\");\n+        }\n+    }\n+\n+    {\n+        // Check that if hash_type == SIGHASH_SINGLE then missing a \"corresponding\n+        // output\" fails.\n+        CMutableTransaction tx_to_m;\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+\n+        uint8_t in_pos = 1;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(1) > #tx_to==0 is expected to fail\");\n+\n+        tx_to_m.vout.push_back(CTxOut());\n+        in_pos = 2;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(2) > #tx_to==1 is expected to fail\");\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_all_success_paths)\n+{\n+    // Our approach here will be to follow BIP-341's signature algorithm (with\n+    // the BIP-342 extension) doing two things at once:\n+    //   1) We'll set up the input arguments to `SignatureHashSchnorr` function\n+    //      being tested, _and_\n+    //   2) we'll _compute the hash of those fields ourselves_ exaxctly as\n+    //      it is described in BIP-341 and BIP-342.\n+    // Then we can compare the two.  We'll do this in a data-driven way for each\n+    // of the different scenarios that the algorithm supports.\n+    //\n+    // In this way this test achieves 100% _path_ coverage of `SignatureHashSchnorr`\n+    // (not just 100% _branch_ coverage).\n+    // - Sadly, this isn't shown in the `lcov` reports.  There are still a few\n+    //   red `-` marks left.  This is because:\n+    //   1. `lcov` wasn't designed to handle death tests.\n+    //   2. ??? Some other unknown reasons, possibly due to the instrumentation,\n+    //      possibly due to `lcov` limitations.  You can see by the test output\n+    //      (`-log_level=all`) or within a debugger that in fact _all_ branches\n+    //      are taken when executing all the tests in this file.\n+\n+    // Here we define, and then generate, all combinations of the alternatives\n+    // for the parameters that vary the signature combination algorithm\n+\n+    const vn_sequence<SigVersion> SigVersion_alternatives{\n+        {SigVersion::TAPROOT, \"TAPROOT\"sv},\n+        {SigVersion::TAPSCRIPT, \"TAPSCRIPT\"sv}\n+    };\n+\n+    const vn_sequence<uint32_t> hash_type_output_alternatives{\n+        {SIGHASH_DEFAULT, \"SIGHASH_DEFAULT\"sv},\n+        {SIGHASH_ALL, \"SIGHASH_ALL\"sv},\n+        {SIGHASH_NONE, \"SIGHASH_NONE\"sv},\n+        {SIGHASH_SINGLE, \"SIGHASH_SINGLE\"sv}\n+    };\n+\n+    const vn_sequence<uint32_t> hash_type_input_alternatives{\n+        {0, \"N/A\"sv},\n+        {SIGHASH_ANYONECANPAY, \"SIGHASH_ANYONECANPAY\"sv}\n+    };\n+\n+    const vn_sequence<uint8_t> annex_alternatives{\n+        {0, \"no annex\"sv},\n+        {1, \"annex present\"sv}\n+    };\n+\n+    const vn_sequence<bool> output_hash_alternatives{\n+        {false, \"output hash missing\"sv},\n+        {true, \"output hash provided\"sv}\n+    };\n+\n+    {\n+        const int nAlternatives = SigVersion_alternatives.size()\n+                                  * hash_type_output_alternatives.size()\n+                                  * hash_type_input_alternatives.size()\n+                                  * annex_alternatives.size()\n+                                  * output_hash_alternatives.size()\n+                                  - 8 /* exclude SIGHASH_DEFAULT w/ SISHASH_ANYONECANPAY */;\n+\n+        BOOST_TEST_MESSAGE(\"Running \" << nAlternatives << \"scenarios\");\n+    }\n+\n+    for (const auto& sigversion_alternative : SigVersion_alternatives)\n+    for (const auto& hash_type_output_alternative : hash_type_output_alternatives)\n+    for (const auto& hash_type_input_alternative : hash_type_input_alternatives)\n+    for (const auto& annex_alternative : annex_alternatives)\n+    for (const auto& output_hash_alternative : output_hash_alternatives)\n+    {\n+        // Exclude the invalid combination of SIGHASH_DEFAULT with SIGHASH_ANYONECANPAY\n+        if (hash_type_output_alternative.value == SIGHASH_DEFAULT\n+            && hash_type_input_alternative.value == SIGHASH_ANYONECANPAY) continue;\n+\n+        // We're going to want to know which scenario it is if a check actually\n+        // fails ...\n+        std::string scenario_description;\n+        {\n+            std::ostringstream oss;\n+            oss << sigversion_alternative.name << \", \"\n+                << hash_type_output_alternative.name << \", \"\n+                << hash_type_input_alternative.name << \", \"\n+                << annex_alternative.name << \", \"\n+                << output_hash_alternative.name;\n+            scenario_description = oss.str();\n+        }\n+        BOOST_TEST_MESSAGE(\"Scenario: \" << scenario_description);\n+\n+        // Set up the scenario we're running now - these 4 variables define the scenario\n+        const SigVersion sigversion{sigversion_alternative.value};\n+        const uint8_t hash_type{static_cast<uint8_t>(hash_type_output_alternative.value\n+                                                   | hash_type_input_alternative.value)};\n+        const uint8_t annex_present{annex_alternative.value};\n+        const bool have_output_hash{output_hash_alternative.value};\n+\n+        // Compute some helper values that depend on scenario\n+        const uint8_t ext_flag{sigversion == SigVersion::TAPSCRIPT};\n+        const uint8_t hash_input_type{static_cast<uint8_t>(hash_type & SIGHASH_INPUT_MASK)};\n+        const uint8_t hash_output_type{static_cast<uint8_t>((hash_type == SIGHASH_DEFAULT)\n+                                                             ? SIGHASH_ALL\n+                                                             : (hash_type & SIGHASH_OUTPUT_MASK))};\n+        const uint8_t spend_type = (ext_flag * 2) + annex_present;\n+\n+        // Fixed values (by algorithm)\n+        const uint8_t epoch{0x00};\n+        const uint8_t key_version{0};\n+\n+        // Mocked values fixed for purposes of this unit test.  This is a long\n+        // list of crufty things but that's because `SignatureHashSchnorr`, the\n+        // function begin tested, takes as arguments not just the tranaction\n+        // being signed (plus control data) but also some _precomputed values_\n+        // in two different structs: `PrecomputedTransactionData`, and\n+        // `ScriptExecutionData`.  On the one hand this is nice because a lot\n+        // of complexity of the signature algorithm doesn't have to be duplicated\n+        // here in this test: we can just use mocked values.  On the other hand,\n+        // there's a lot of icky setup to do to get all the values in the right\n+        // places both for our \"by the book\" implementation and to be set up to\n+        // call `SignatureHashSchnorr`.\n+        //\n+        // Try to make things simpler by at least using the same names for the\n+        // setup variables as for the fields in the parameter structs.\n+\n+        const uint32_t in_pos{1};\n+        const int32_t tx_version{FillWithPattern(0x01).i32[0]};\n+        const uint32_t tx_lock_time{FillWithPattern(0x05).u32[0]};\n+        const uint256 prevouts_single_hash{FillWithPattern(0x10).u256};\n+        const uint256 spent_amounts_single_hash{FillWithPattern(0x18).u256};\n+        const uint256 spent_scripts_single_hash{FillWithPattern(0x20).u256};\n+        const uint256 sequences_single_hash{FillWithPattern(0x28).u256};\n+        const uint256 outputs_single_hash{FillWithPattern(0x30).u256};\n+        const uint256 output_hash{FillWithPattern(0x40).u256};\n+        const uint256 annex_hash{FillWithPattern(0x48).u256};\n+        const uint256 tapleaf_hash{FillWithPattern(0x50).u256};\n+        const uint32_t codeseparator_pos{FillWithPattern(0x58).u32[0]};\n+        const COutPoint tx_input_at_pos_prevout{FillWithPattern(0x60).u256,\n+                                                FillWithPattern(0x68).u32[0]};\n+        const uint32_t tx_input_at_pos_nsequence{FillWithPattern(0x70).u32[0]};\n+        CTxOut spent_output_at_pos;\n+        spent_output_at_pos.nValue = FillWithPattern(0x80).u64();\n+        spent_output_at_pos.scriptPubKey /*random script, not even valid*/\n+            << OP_DUP << OP_HASH160 << OP_EQUALVERIFY << OP_CHECKSIG;\n+        CTxOut tx_output_at_pos;\n+        tx_output_at_pos.nValue = FillWithPattern(0x90).u64();\n+        tx_output_at_pos.scriptPubKey /*random script, not even valid*/\n+            << OP_CHECKSIG << OP_EQUALVERIFY << OP_HASH160 << OP_DUP;\n+\n+        // Now set up the arguments that are going to be passed to\n+        // `SignatureHashSchnorr`\n+\n+        CMutableTransaction tx_to;\n+        tx_to.nVersion = tx_version;\n+        tx_to.nLockTime = tx_lock_time;\n+        for (uint32_t i = 0; i < in_pos+2; i++) {\n+            tx_to.vin.push_back(CTxIn());\n+            tx_to.vout.push_back(CTxOut());\n+        }\n+        tx_to.vin[in_pos].prevout = tx_input_at_pos_prevout;\n+        tx_to.vin[in_pos].nSequence = tx_input_at_pos_nsequence;\n+        tx_to.vout[in_pos] = tx_output_at_pos;\n+\n+        PrecomputedTransactionData cache;\n+        cache.m_bip341_taproot_ready = true;\n+        cache.m_prevouts_single_hash = prevouts_single_hash;\n+        cache.m_spent_amounts_single_hash = spent_amounts_single_hash;\n+        cache.m_spent_scripts_single_hash = spent_scripts_single_hash;\n+        cache.m_sequences_single_hash = sequences_single_hash;\n+        cache.m_spent_outputs_ready = true;\n+        for (uint32_t i = 0; i < in_pos+2; i++) {\n+            cache.m_spent_outputs.push_back(CTxOut());\n+        }\n+        cache.m_spent_outputs[in_pos] = spent_output_at_pos;\n+        cache.m_outputs_single_hash = outputs_single_hash;\n+\n+        ScriptExecutionData execdata;\n+        execdata.m_annex_init = true;\n+        execdata.m_annex_present = !!annex_present;\n+        execdata.m_annex_hash = annex_hash;\n+        execdata.m_output_hash.reset();\n+        if (have_output_hash) {\n+            execdata.m_output_hash = output_hash;\n+        }\n+        if (sigversion == SigVersion::TAPSCRIPT) {\n+            execdata.m_tapleaf_hash_init = true;\n+            execdata.m_tapleaf_hash = tapleaf_hash;\n+            execdata.m_codeseparator_pos_init = true;\n+            execdata.m_codeseparator_pos = codeseparator_pos;\n+        }\n+\n+        // Now here is where we take all that data - _not_ the arguments to\n+        // `SignatureHashSchnorr` but all the scenario parameters, the helpers,\n+        // the values fixed by the algorithm, and our mocked values, and actually\n+        // follow the BIP-341/BIP-342 signature calculation algorithm right from\n+        // the specs ...\n+\n+        // Start with a tagged hasher with the correct tag\n+        CHashWriter hasher = TaggedHash(\"TapSighash\");\n+\n+        // First byte to hash is always the \"epoch\", 0x00 (BIP-341, footnote 20)\n+        hasher << epoch;\n+\n+        // Next: hash_type (1 byte)\n+        hasher << hash_type;\n+\n+        // Next: transaction version (4 bytes)\n+        hasher << tx_version;\n+\n+        // Next: transaction lock time (4 bytes)\n+        hasher << tx_lock_time;\n+\n+        // Next if _not_ SIGHASH_ANYONECANPAY:\n+        // a) SHA256 of the serialization of all input outpoints (32 bytes)\n+        // b) SHA256 of the serialization of all spent output amounts (32 bytes)\n+        // c) SHA256 of the serialization of all spent outputs' _scriptPubKeys_\n+        //    serialized as script (32 bytes)\n+        // d) SHA256 of the serialization of all input `nSequence` (32 bytes)\n+        if (hash_input_type != SIGHASH_ANYONECANPAY) {\n+            hasher << prevouts_single_hash;\n+            hasher << spent_amounts_single_hash;\n+            hasher << spent_scripts_single_hash;\n+            hasher << sequences_single_hash;\n+        }\n+\n+        // Next if _not_ SIGHASH_NONE _and not_ SIGHASH_SINGLE:\n+        // SHA256 of the serialization of all outputs in CTxOut format (32 bytes)\n+        if (hash_output_type != SIGHASH_NONE && hash_output_type != SIGHASH_SINGLE) {\n+            hasher << outputs_single_hash;\n+        }\n+\n+        // Now, data about input/prevout being spent\n+\n+        // The \"spend_type\" (1 byte) which is a function of ext_flag (above) and\n+        // whether there is an annex present (here: no)\n+        hasher << spend_type;\n+\n+        // Here, if we are _not_ SIGHASH_ANYONECANPAY, we just add the index of\n+        // the input in the transaction input vector (4 bytes). There must be a\n+        // input transaction at this index but _in this scenario_ it doesn't have\n+        // to have any data (it is never inspected).  Same for output transactions.\n+        //\n+        // On the other hand, if we _are_ SIGHASH_ANYONECANPAY, then we add the\n+        // `COutPoint` of this input (36 bytes), the value of the previous\n+        // output spent by this input (8 bytes), the `ScriptPubKey` of the\n+        // previous output spent by this input (35 bytes), and the `nSequence`\n+        // of this input.  These values are all precomputed and made available\n+        // to `SignatureHashSchnorr` in the `PrecomputedTransactionData` struct.\n+        if (hash_input_type == SIGHASH_ANYONECANPAY) {\n+            hasher << tx_input_at_pos_prevout;\n+            hasher << spent_output_at_pos.nValue;\n+            hasher << spent_output_at_pos.scriptPubKey;\n+            hasher << tx_input_at_pos_nsequence;\n+        } else {\n+            hasher << in_pos;\n+        }\n+\n+        // Now, if there is an \"annex\", add its hash (32 byte).  This is\n+        // precomputed and we don't actually have to have an actual annex to\n+        // pass in to `SignatureHashSchnorr`, nor do we have to hash it.\n+        if (annex_present) {\n+            hasher << annex_hash;\n+        }\n+\n+        // Here, iff the hash type is `SIGHASH_SINGLE`, add the hash of the\n+        // corresponding transaction output (32 bytes).  The wrinkle here is that\n+        // (for some reason) _sometimes_ this hash is precomputed, and _sometimes_\n+        // it is _not_.  So `SignatureHashSchnorr` will either use it if it is\n+        // provided or compute it from the corresponding output itself. (For our\n+        // purposes in this test the output need not be valid - it just must be\n+        // present.)\n+        if (hash_output_type == SIGHASH_SINGLE) {\n+            if (!have_output_hash) {\n+                CHashWriter hasher2(SER_GETHASH, 0);\n+                hasher2 << tx_output_at_pos;\n+                hasher << hasher2.GetSHA256();\n+            } else {\n+                hasher << output_hash;\n+            }\n+        }\n+\n+        // This is the TAPSCRIPT extension from BIP-342.  If the version is\n+        // TAPSCRIPT then add the tapleaf hash (32 bytes), the key_version (1\n+        // byte, fixed value of 0x00), and the \"opcode position of the last\n+        // executed OP_CODESEPARATOR before the currently executed signature\n+        // opcode\" (4 bytes).  The tapleaf hash and the code separator position\n+        // are both precomputed values.\n+        if (sigversion == SigVersion::TAPSCRIPT) {\n+            hasher << tapleaf_hash;\n+            hasher << key_version;\n+            hasher << codeseparator_pos;\n+        }\n+\n+        // That's all that goes into the hasher for this signature\n+        const uint256 expected_hash_out = hasher.GetSHA256();\n+\n+        // Now finally we test the actual implemented algorithm under test:\n+        uint256 actual_hash_out{0};\n+        BOOST_TEST(SignatureHashSchnorr(actual_hash_out,\n+                                        execdata, tx_to, in_pos,\n+                                        hash_type, sigversion, cache,\n+                                        MissingDataBehavior::FAIL),\n+                   \"Scenario: \" << scenario_description);\n+        BOOST_TEST(expected_hash_out == actual_hash_out,\n+                   \"Scenario: \" << scenario_description\n+                   << \" - expected \" << expected_hash_out.ToString()\n+                   << \" == actual \" << actual_hash_out.ToString());\n+    }\n+}\n+\n+namespace {\n+\n+// Valid Schnoor (pubkey, msg, signature) tuples (copied from `key_tests.cpp`)\n+\n+struct SchnorrTriplet\n+{\n+    SchnorrTriplet(std::string pubkey, std::string sighash, std::string sig)\n+                : pubkey(ParseHex(pubkey))\n+                , sighash(uint256(ParseHex(sighash)))\n+                , sig(ParseHex(sig)) {}\n+    valtype pubkey;\n+    uint256 sighash;\n+    valtype sig;\n+};\n+\n+static const std::vector<SchnorrTriplet> SCHNORR_TRIPLETS = {\n+    {\"F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9\", \"0000000000000000000000000000000000000000000000000000000000000000\", \"E907831F80848D1069A5371B402410364BDF1C5F8307B0084C55F1CE2DCA821525F66A4A85EA8B71E482A74F382D2CE5EBEEE8FDB2172F477DF4900D310536C0\"},\n+    {\"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659\", \"243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89\", \"6896BD60EEAE296DB48A229FF71DFE071BDE413E6D43F917DC8DCF8C78DE33418906D11AC976ABCCB20B091292BFF4EA897EFCB639EA871CFA95F6DE339E4B0A\"},\n+    {\"DD308AFEC5777E13121FA72B9CC1B7CC0139715309B086C960E18FD969774EB8\", \"7E2D58D8B3BCDF1ABADEC7829054F90DDA9805AAB56C77333024B9D0A508B75C\", \"5831AAEED7B44BB74E5EAB94BA9D4294C49BCF2A60728D8B4C200F50DD313C1BAB745879A5AD954A72C45A91C3A51D3C7ADEA98D82F8481E0E1E03674A6F3FB7\"},\n+    {\"25D1DFF95105F5253C4022F628A996AD3A0D95FBF21D468A1B33F8C160D8F517\", \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", \"7EB0509757E246F19449885651611CB965ECC1A187DD51B64FDA1EDC9637D5EC97582B9CB13DB3933705B32BA982AF5AF25FD78881EBB32771FC5922EFC66EA3\"},\n+    {\"D69C3509BB99E412E68B0FE8544E72837DFA30746D8BE2AA65975F29D22DC7B9\", \"4DF3C3F68FCC83B27E9D42C90431A72499F17875C81A599B566C9889B9696703\", \"00000000000000000000003B78CE563F89A0ED9414F5AA28AD0D96D6795F9C6376AFB1548AF603B3EB45C9F8207DEE1060CB71C04E80F593060B07D28308D7F4\"},\n+};\n+\n+}\n+\n+BOOST_AUTO_TEST_CASE(internal_test_validate_schnorr_testdata)\n+{\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(XOnlyPubKey(triplet.pubkey).VerifySchnorr(triplet.sighash, triplet.sig));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(verify_schnorr_signature)\n+{\n+    // Defeat, for test purposes, the protected access of\n+    // `GenericTransactionSignatureChecker::VerifySchnorrSignature`\n+    struct UnprotectedTransactionSignatureChecker : public MutableTransactionSignatureChecker\n+    {\n+        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;\n+        using MutableTransactionSignatureChecker::VerifySchnorrSignature;\n+    };\n+    UnprotectedTransactionSignatureChecker sut{nullptr, 0, {}, {}};\n+\n+    // Positive tests: triplets which verify\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(sut.VerifySchnorrSignature(triplet.sig,\n+                                              XOnlyPubKey{triplet.pubkey},\n+                                              triplet.sighash));\n+    }\n+\n+    // Negative tests: triplets which fail to verify (get these failing triplets\n+    // by modifying a valid triplet, one field at a time)\n+    auto diddle_front_byte = [](auto v) { v[0]++; return v; };\n+    auto& triplet = SCHNORR_TRIPLETS[0];\n+    BOOST_TEST(!sut.VerifySchnorrSignature(diddle_front_byte(triplet.sig),\n+                                           XOnlyPubKey{triplet.pubkey},\n+                                           triplet.sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.sig,\n+                                           XOnlyPubKey{diddle_front_byte(triplet.pubkey)},\n+                                           triplet.sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.sig,\n+                                           XOnlyPubKey{triplet.pubkey},\n+                                           uint256::ONE));\n+}\n+\n+BOOST_AUTO_TEST_CASE(check_schnorr_signature)\n+{\n+    // Provide, for test purposes, a subclass of `GenericTransactionsSignatureChecker`\n+    // that mocks `VerifySchnorrSignature` so we can more easily test\n+    // `CheckSchnorrSignature` without going to the trouble of having a valid\n+    // transaction (which is unnecessary for this _unit_ test.)\n+    struct MockVerifyingTransactionSignatureChecker : public MutableTransactionSignatureChecker\n+    {\n+\n+        uint256 expected_sighash = [](){\n+            uint256 h{};\n+            // This is the known sighash of the Tx and input data we set up (precomputed)\n+            h.SetHex(\"f614d8ae6dcc49e2ca2ef1c03f93c7326189e5575d446e825e5a2700fb1cb83c\");\n+            return h;\n+        }();\n+\n+        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;\n+\n+        enum class if_as_expected_return { False, True };\n+        if_as_expected_return iae{ if_as_expected_return::True };\n+        void SetExpectation(if_as_expected_return iaer) { iae = iaer; }\n+\n+        bool VerifySchnorrSignature(Span<const unsigned char> sig,\n+                                    const XOnlyPubKey& pubkey,\n+                                    const uint256& sighash) const override\n+        {\n+            // Following line used only to determine the known canned `expected_sighash` above:\n+            // BOOST_TEST_MESSAGE(\"MockVerifySchnorrSignature: sighash == \" << sighash.ToString());\n+\n+            bool as_expected = sighash == expected_sighash;\n+            if (iae == if_as_expected_return::True)\n+                return as_expected;\n+            else\n+                return !as_expected;\n+        };\n+    };\n+\n+    const auto triplet = SCHNORR_TRIPLETS[0];\n+    const CMutableTransaction txToIn{};\n+    ScriptExecutionData execdata{};\n+\n+    {\n+        // Signature must be 64 or 65 bytes long\n+        for (size_t i = 0; i <= 99; i++) {\n+            valtype testsig(i, i);\n+            if (testsig.size() == 64 || testsig.size() == 65) continue;\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_SIZE);\n+        }\n+    }\n+\n+    {\n+        // Iff signature is 65 bytes long last byte must **NOT** be SIGHASH_DEFAULT (0x00) per BIP-342\n+        {\n+            // Negative test: last byte _is_ SIGHASH_DEFAULT\n+            valtype testsig(65, 65);\n+            testsig.back() = SIGHASH_DEFAULT;\n+\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);\n+        }\n+        {\n+            // Negative tests: last byte is _not_ SIGHASH_DEFAULT, but we early exit _without changing\n+            // serror_ because we don't provide a txDataIn (🡄 this requires knowledge of how\n+            // `CheckSchnorrSignature` is written).\n+            for (size_t i = 1; i <= 255; i++) {\n+                valtype testsig(65, i);\n+\n+                MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+                ScriptError serror{SCRIPT_ERR_OK};\n+                BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+                BOOST_TEST(serror == SCRIPT_ERR_OK);\n+            }\n+        }\n+    }\n+\n+    {\n+        // Now check that, given the parameters, if `SignatureHashSchnorr fails there's an error exit.\n+        // Otherwise, if it succeeds, it proceeds to call `VerifySchnorrSignature` and depending on\n+        // _that_ result `SignatureHashSchnorr` either succeeds or fails.\n+        //\n+        // We do this using the mocked `VerifySchnorrSignature` so we only need to pass parameters\n+        // that work with `SignatureHashSchnorr`, they don't _also_ have to validate with\n+        // `VerifySchnorrSignature`.\n+\n+        const uint32_t in_pos{0};\n+        CMutableTransaction txToIn{};\n+        txToIn.nVersion = 0;\n+        txToIn.nLockTime = 0;\n+        txToIn.vin.push_back(CTxIn());\n+        txToIn.vin[in_pos].prevout = COutPoint(uint256::ZERO, 0);\n+        txToIn.vin[in_pos].nSequence = 0;\n+        txToIn.vout.push_back(CTxOut());\n+\n+        PrecomputedTransactionData txDataIn{};\n+        txDataIn.m_bip341_taproot_ready = true;\n+        txDataIn.m_prevouts_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_amounts_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_scripts_single_hash = uint256::ZERO;\n+        txDataIn.m_sequences_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_outputs_ready = true;\n+        txDataIn.m_spent_outputs.push_back(CTxOut());\n+        txDataIn.m_spent_outputs[in_pos].nValue = 0;\n+        txDataIn.m_spent_outputs[in_pos].scriptPubKey << OP_DUP << OP_CHECKSIG;\n+        txDataIn.m_outputs_single_hash = uint256::ZERO;\n+\n+        ScriptExecutionData execdata{};\n+        execdata.m_annex_init = true;\n+        execdata.m_annex_present = true;\n+        execdata.m_annex_hash = uint256::ZERO;\n+        execdata.m_output_hash.reset();\n+\n+        {\n+            // Confirm that we can force `SignatureHashSchnorr` to fail (via an early exit)\n+            PrecomputedTransactionData txDataIn{};\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(triplet.sig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);\n+        }\n+        {\n+            // Now `SignatureHashSchnorr` will return true but we'll fail `VerifySchnorrSignature`\n+            // and show it returns the correct error.\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            sut.SetExpectation(MockVerifyingTransactionSignatureChecker::if_as_expected_return::False);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(triplet.sig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG);\n+        }\n+        {\n+            // Finally, same as previous, except we'll force `VerifySchnorrSignature` to succeed and\n+            // show now that `CheckSchnorrSignature` finally suceeds.\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            sut.SetExpectation(MockVerifyingTransactionSignatureChecker::if_as_expected_return::True);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(sut.CheckSchnorrSignature(triplet.sig, triplet.pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_OK);\n+        }\n+    }\n+}\n+\n+namespace {\n+\n+    std::optional<valtype> from_hex(std::string_view sv) {\n+        static const auto hexits = \"0123456789abcdefABCDEF\"sv;\n+\n+        constexpr auto is_hexit = [](char c) {\n+            return std::string::npos != hexits.find(c);\n+        };\n+\n+        // validate\n+        if (sv.size() % 2 != 0) return {};\n+        if (!std::all_of(sv.begin(), sv.end(), is_hexit)) return {};\n+\n+        constexpr auto from_hexit = [](char c) -> unsigned char {\n+            auto d = hexits.find(c);\n+            return d < 16 ? d : d - 6;\n+        };\n+\n+        valtype r; r.reserve(sv.size() / 2);\n+        for (size_t i = 0; i < sv.size(); i+=2) {\n+            r.push_back(from_hexit(sv[i])<<4 | from_hexit(sv[i+1]));\n+        }\n+        return r;\n+    }\n+\n+    valtype operator \"\" _hex(const char* s, size_t len) {\n+        auto v = from_hex({s, len});\n+        if (v) return v.value();\n+        throw std::invalid_argument(\"invalid hex literal\");\n+    }\n+\n+    // (not checked: That `C` is a container (supporting `std::begin()` and `std::end()`)\n+    // whose elements are `unsigned char`) (note `uint256` doesn't have a `value_type` member)\n+    template <typename C>\n+    std::string to_hex(C container) {\n+        constexpr auto to_hexit = [](unsigned char c) -> char {\n+            return \"0123456789ABCDEF\"[c];\n+        };\n+\n+        std::string r; r.reserve(container.size() * 2);\n+        for (unsigned char c : container) {\n+            r.push_back(to_hexit(c>>4 & 0x0F));\n+            r.push_back(to_hexit(c & 0x0F));\n+        }\n+        return r;\n+    }\n+\n+    // An attempt to get close to the notation of BIP-340:\n+    //   `||` concatenates byte vectors\n+    //   `[j]` indexes a single element\n+    //   `[i:j]` can't be represented in C++ - there is no `:` operator, so instead\n+    //       I substitute `[{i,j}]` - which is the subrange `[i,j)`.\n+    //\n+    // For convenience, constructing from a string and comparing (equality) against\n+    // a string are available.\n+    struct bytevector : public std::vector<unsigned char>\n+    {\n+        using std::vector<unsigned char>::vector;\n+        explicit bytevector(std::string_view sv) {\n+            resize(sv.size());\n+            std::copy(sv.begin(), sv.end(), begin());\n+        }\n+\n+        explicit bytevector(uint256 u) {\n+            resize(u.size());\n+            std::copy(u.begin(), u.end(), begin());\n+        }\n+\n+        /**\n+         * Return half-open subrange from byte vector: `[i:j)`\n+         */\n+        bytevector subrange(size_t i, size_t j) const {\n+            assert(i <= j && j <= size());\n+            bytevector r(j-i, 0);\n+            std::copy(begin()+i, begin()+j, r.begin());\n+            return r;\n+        }\n+\n+        using std::vector<unsigned char>::operator[];\n+        bytevector operator[](std::tuple<size_t, size_t> range) const {\n+            auto [i, j] = range;\n+            return subrange(i, j);\n+        }\n+\n+        void concat(const bytevector& bv) {\n+            size_t this_size{size()};\n+            resize(size() + bv.size());\n+            std::copy(bv.begin(), bv.end(), begin() + this_size);\n+        }\n+\n+        std::string to_string() const {\n+            return std::string(begin(), end());\n+        }\n+    };\n+\n+    bytevector operator \"\"_bv(const char* s, size_t len) {\n+        return bytevector(std::string_view(s, len));\n+    }\n+\n+    bool operator==(const bytevector& lhs, std::string_view rhs) {\n+        return lhs.to_string() == rhs;\n+    }\n+\n+    bool operator==(std::string_view lhs, const bytevector& rhs) {\n+        return lhs == rhs.to_string();\n+    }\n+\n+    bool operator<(const bytevector& lhs, const bytevector& rhs) {\n+        return std::lexicographical_compare(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());\n+    }\n+\n+    bytevector operator||(const bytevector& lhs, const bytevector& rhs)\n+    {\n+        bytevector r(lhs);\n+        r = lhs;\n+        r.concat(rhs);\n+        return r;\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(internal_test_validate_hex_to_bytes_and_back_helpers)\n+{\n+    // Hex digits have correct value\n+    std::pair<char, unsigned char> hexit_map[] {\n+                {'0',  0}, {'1',  1}, {'2',  2}, {'3',  3}, {'4',  4},\n+                {'5',  5}, {'6',  6}, {'7',  7}, {'8',  8}, {'9',  9},\n+                {'a', 10}, {'b', 11}, {'c', 12}, {'d', 13}, {'e', 14}, {'f', 15},\n+                {'A', 10}, {'B', 11}, {'C', 12}, {'D', 13}, {'E', 14}, {'F', 15},\n+    };\n+\n+    for (const auto& [c, d] : hexit_map) {\n+        BOOST_TEST(from_hex(std::string(2, c)).value() == valtype(1, d*16 + d));\n+    };\n+    // Non-hex digits fail to convert\n+    for (int d = 0; d < 255; d++) {\n+        char dig = static_cast<char>(d);\n+        static const auto hex_digits = \"0123456789abcdefABCDEF\"sv;\n+        if (std::none_of(hex_digits.begin(), hex_digits.end(), [dig](char c) { return c == dig; })) {\n+            BOOST_TEST((!from_hex(std::string{1, dig} + dig)));\n+        }\n+    }\n+\n+    // hex strings to byte vector\n+    BOOST_TEST(\"0A\"_hex == valtype(1, 0x0a));",
      "path": "src/test/script_tapscript_tests.cpp",
      "position": null,
      "original_position": 1201,
      "commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "original_commit_id": "a5808ce2f05040f740dad313e503624de2e8db93",
      "in_reply_to_id": 876110013,
      "user": {
        "login": "david-bakin",
        "id": 4162948,
        "node_id": "MDQ6VXNlcjQxNjI5NDg=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4162948?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/david-bakin",
        "html_url": "https://github.com/david-bakin",
        "followers_url": "https://api.github.com/users/david-bakin/followers",
        "following_url": "https://api.github.com/users/david-bakin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/david-bakin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/david-bakin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/david-bakin/subscriptions",
        "organizations_url": "https://api.github.com/users/david-bakin/orgs",
        "repos_url": "https://api.github.com/users/david-bakin/repos",
        "events_url": "https://api.github.com/users/david-bakin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/david-bakin/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "And that's done now.",
      "created_at": "2022-05-21T05:00:33Z",
      "updated_at": "2022-05-21T05:00:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r878645117",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/878645117"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 1201,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/917134721",
      "pull_request_review_id": 1033377314,
      "id": 917134721,
      "node_id": "PRRC_kwDOABII5842ql2B",
      "diff_hunk": "@@ -156,23 +153,22 @@ std::string FormatScriptFlags(unsigned int flags)\n         }\n         it++;\n     }\n+    if (ret.empty()) return \"\";\n     return ret.substr(0, ret.size() - 1);\n }\n \n-std::string FormatScriptError(ScriptError_t err, bool issue_boost_error)\n+std::optional<std::string> FormatScriptError(ScriptError_t err)\n {\n     for (const auto& se : script_errors)\n         if (se.err == err)\n             return std::string(se.name);\n-    if (issue_boost_error) BOOST_ERROR(\"Unknown scripterror enumeration value, update script_errors in script_tests.cpp.\");\n-    return \"\";\n+    return {};\n }\n \n-ScriptError_t ParseScriptError(std::string_view name, bool issue_boost_error)\n+std::optional<ScriptError_t> ParseScriptError(std::string_view name)\n {\n     for (const auto& se : script_errors)\n         if (se.name == name)\n             return se.err;\n-    if (issue_boost_error) BOOST_ERROR(\"Unknown scripterror \\\"\" << name << \"\\\" in test description\");",
      "path": "src/test/util/pretty_data.cpp",
      "position": null,
      "original_position": 76,
      "commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "original_commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "in_reply_to_id": null,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin/bitcoin/pull/25097/commits/eeefec343592c6de85048e3b055ba49755cfb072\r\n\r\nYou may want to move these `BOOST_ERROR(...)` changes back to the previous commit (where this file is introduced), since attempting to build the previous commit fails with this error:\r\n```\r\n/usr/bin/ld: /usr/bin/ld: DWARF error: could not find variable specification at offset 7218\r\nlibtest_util.a(libtest_util_a-pretty_data.o): in function `ParseScriptFlags(std::basic_string_view<char, std::char_traits<char> >, bool)':\r\n./src/test/util/pretty_data.cpp:138: undefined reference to `boost::unit_test::unit_test_log_t::set_checkpoint(boost::unit_test::basic_cstring<char const>, unsigned long, boost::unit_test::basic_cstring<char const>)'\r\n/usr/bin/ld: libtest_util.a(libtest_util_a-pretty_data.o): in function `lazy_ostream_impl':\r\n/usr/include/boost/test/utils/lazy_ostream.hpp:74: undefined reference to `boost::unit_test::lazy_ostream::inst'\r\n/usr/bin/ld: libtest_util.a(libtest_util_a-pretty_data.o): in function `ParseScriptFlags(std::basic_string_view<char, std::char_traits<char> >, bool)':\r\n./src/test/util/pretty_data.cpp:138: undefined reference to `boost::test_tools::tt_detail::report_assertion(boost::test_tools::assertion_result const&, boost::unit_test::lazy_ostream const&, boost::unit_test::basic_cstring<char const>, unsigned long, boost::test_tools::tt_detail::tool_level, boost::test_tools::tt_detail::check_type, unsigned long, ...)'\r\n/usr/bin/ld: libtest_util.a(libtest_util_a-pretty_data.o): in function `FormatScriptError[abi:cxx11](ScriptError_t, bool)':\r\n./src/test/util/pretty_data.cpp:167: undefined reference to `boost::unit_test::unit_test_log_t::set_checkpoint(boost::unit_test::basic_cstring<char const>, unsigned long, boost::unit_test::basic_cstring<char const>)'\r\n/usr/bin/ld: libtest_util.a(libtest_util_a-pretty_data.o): in function `lazy_ostream_impl':\r\n/usr/include/boost/test/utils/lazy_ostream.hpp:74: undefined reference to `boost::unit_test::lazy_ostream::inst'\r\n/usr/bin/ld: libtest_util.a(libtest_util_a-pretty_data.o): in function `FormatScriptError[abi:cxx11](ScriptError_t, bool)':\r\n./src/test/util/pretty_data.cpp:167: undefined reference to `boost::test_tools::tt_detail::report_assertion(boost::test_tools::assertion_result const&, boost::unit_test::lazy_ostream const&, boost::unit_test::basic_cstring<char const>, unsigned long, boost::test_tools::tt_detail::tool_level, boost::test_tools::tt_detail::check_type, unsigned long, ...)'\r\n/usr/bin/ld: libtest_util.a(libtest_util_a-pretty_data.o): in function `ParseScriptError(std::basic_string_view<char, std::char_traits<char> >, bool)':\r\n./src/test/util/pretty_data.cpp:176: undefined reference to `boost::unit_test::unit_test_log_t::set_checkpoint(boost::unit_test::basic_cstring<char const>, unsigned long, boost::unit_test::basic_cstring<char const>)'\r\n/usr/bin/ld: libtest_util.a(libtest_util_a-pretty_data.o): in function `lazy_ostream_impl':\r\n/usr/include/boost/test/utils/lazy_ostream.hpp:74: undefined reference to `boost::unit_test::lazy_ostream::inst'\r\n/usr/bin/ld: libtest_util.a(libtest_util_a-pretty_data.o): in function `ParseScriptError(std::basic_string_view<char, std::char_traits<char> >, bool)':\r\n./src/test/util/pretty_data.cpp:176: undefined reference to `boost::test_tools::tt_detail::report_assertion(boost::test_tools::assertion_result const&, boost::unit_test::lazy_ostream const&, boost::unit_test::basic_cstring<char const>, unsigned long, boost::test_tools::tt_detail::tool_level, boost::test_tools::tt_detail::check_type, unsigned long, ...)'\r\n/usr/bin/ld: libtest_util.a(libtest_util_a-pretty_data.o): in function `_GLOBAL__sub_I_pretty_data.cpp':\r\n/usr/include/boost/test/unit_test_log.hpp:227: undefined reference to `boost::unit_test::unit_test_log_t::instance()'\r\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\r\n```",
      "created_at": "2022-07-08T20:58:11Z",
      "updated_at": "2022-07-08T20:58:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r917134721",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/917134721"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 176,
      "side": "LEFT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/917142704",
      "pull_request_review_id": 1033389106,
      "id": 917142704,
      "node_id": "PRRC_kwDOABII5842qnyw",
      "diff_hunk": "@@ -0,0 +1,308 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <span.h>\n+#include <test/util/pretty_data.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/traits.h>\n+#include <test/util/vector.h>\n+#include <uint256.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <iomanip>\n+#include <memory>\n+#include <sstream>\n+#include <string>\n+#include <string_view>\n+#include <type_traits>\n+#include <vector>\n+\n+using namespace std::literals::string_literals;\n+using namespace std::literals::string_view_literals;\n+using namespace test::util::literals;\n+\n+BOOST_FIXTURE_TEST_SUITE(test_util_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(as_string_tests)\n+{\n+    // Some typical values, independent of integral type\n+    BOOST_TEST(as_string(0) == \"0\"s);\n+    BOOST_TEST(as_string(1) == \"1\"s);\n+    BOOST_TEST(as_string(-1) == \"-1\"s);\n+    BOOST_TEST(as_string(12) == \"12\"s);\n+    BOOST_TEST(as_string(123) == \"123\"s);\n+    BOOST_TEST(as_string(1234) == \"1234\"s);\n+\n+    // Now some larger values\n+    BOOST_TEST(as_string(1'000'000'000'000ULL) == \"1000000000000\"s);\n+    BOOST_TEST(as_string(-1'234'567'890'123LL) == \"-1234567890123\"s);\n+}\n+\n+BOOST_AUTO_TEST_CASE(hex_to_stream)\n+{\n+    auto ToStream = [](auto v) {\n+        std::ostringstream oss;\n+        oss << Hex(v);\n+        return oss.str();\n+    };\n+\n+    {\n+        // integral types\n+        BOOST_TEST(ToStream(static_cast<int8_t>(0x75)) == \"0x75\");\n+        BOOST_TEST(ToStream(static_cast<uint8_t>(0x75)) == \"0x75\");\n+        BOOST_TEST(ToStream(0x75) == \"0x00000075\");\n+        BOOST_TEST(ToStream(0x75U) == \"0x00000075\");\n+        BOOST_TEST(ToStream(0x75LL) == \"0x0000000000000075\");\n+        BOOST_TEST(ToStream(0x75ULL) == \"0x0000000000000075\");\n+    }\n+\n+    {\n+        // `uint256` which acts like a container\n+        BOOST_TEST(ToStream(uint256::ZERO) == \"0x0000000000000000000000000000000000000000000000000000000000000000\");\n+        BOOST_TEST(ToStream(uint256::ONE) == \"0x0000000000000000000000000000000000000000000000000000000000000001\");\n+        BOOST_TEST(ToStream(uint256S(\"fedcba9876543210\"s)) == \"0x000000000000000000000000000000000000000000000000fedcba9876543210\");\n+        BOOST_TEST(ToStream(uint256S(\"0123456789abcdef00000000000000000000000000000000fedcba9876543210\")) == \"0x0123456789abcdef00000000000000000000000000000000fedcba9876543210\");\n+    }\n+\n+    {\n+        // `uint160` also acts like a container\n+\n+        // when initialized from a vector it is little-endian; but when written as a hex string it is big-endian\n+        std::vector<unsigned char> v160{0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,\n+                                        0xff, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 0xf7, 0xf6};\n+        BOOST_TEST(ToStream(uint160(v160)) == \"0xf6f7f8f9fafbfcfdfeff0a090807060504030201\");\n+    }\n+\n+    {\n+        // Span of unsigned char\n+        std::vector<unsigned char> v{0x10, 0x11, 0x12, 0x13, 0x14, 0x15};\n+        BOOST_TEST(ToStream(Span(v)) == \"0x101112131415\");\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(string_hex_to_bytes_and_back)\n+{\n+    using valtype = std::vector<unsigned char>;\n+\n+    // hex strings to byte vector\n+    BOOST_TEST(\"0A\"_hex == valtype(1, 0x0a));\n+    BOOST_TEST(\"0a\"_hex == valtype(1, 0x0a));\n+    BOOST_TEST(\"A0\"_hex == valtype(1, 0xa0));\n+    BOOST_TEST(\"a0\"_hex == valtype(1, 0xa0));\n+    BOOST_TEST(\"aA\"_hex == valtype(1, 0xaa));\n+    BOOST_TEST(\"Aa\"_hex == valtype(1, 0xaa));\n+\n+    BOOST_TEST((\"12\"_hex == valtype{0x12}));\n+    BOOST_TEST((\"1234\"_hex == valtype{0x12, 0x34}));\n+    BOOST_TEST((\"123456\"_hex == valtype{0x12, 0x34, 0x56}));\n+\n+    // Invalid hex string literals\n+    BOOST_CHECK_THROW(\"1\"_hex, std::logic_error);\n+    BOOST_CHECK_THROW(\"123\"_hex, std::logic_error);\n+    BOOST_CHECK_THROW(\"1234xyz\"_hex, std::logic_error);\n+\n+    // Binary to hex string\n+    BOOST_TEST(\"12345678abcd\"s == HexStr(\"12345678abcd\"_hex));\n+    BOOST_TEST(std::string(64, '0') == HexStr(uint256::ZERO));\n+    BOOST_TEST((std::string{'0', '1'} + std::string(62, '0') == HexStr(uint256::ONE)));\n+}\n+\n+BOOST_AUTO_TEST_CASE(string_to_bytes)\n+{\n+    using valtype = std::vector<unsigned char>;\n+\n+    BOOST_TEST((\"Aa\"_bv == valtype{'A', 'a'}));\n+    BOOST_TEST((\"ABCD-0123-xyz\"_bv == valtype{'A', 'B', 'C', 'D', '-', '0', '1', '2', '3', '-', 'x', 'y', 'z'}));\n+}\n+\n+BOOST_AUTO_TEST_CASE(HexStr_problem)\n+{\n+    std::vector<unsigned char> a5(1, 0xa5);\n+    auto a5_r = HexStr(Span<unsigned char>(a5));\n+    BOOST_TEST(a5_r == \"a5\"s);\n+}\n+\n+BOOST_AUTO_TEST_CASE(ex_vector_tests)\n+{\n+    using valtype = std::vector<unsigned char>;\n+\n+    using namespace test::util::vector_ops;\n+\n+    {\n+        // Conversion via unary `+`\n+        std::vector<int> v{10, 20, 30};\n+        auto ev = +v;\n+        BOOST_TEST(ev == v);\n+    }\n+\n+    {\n+        // Subrange operation\n+        ex_vector<unsigned char> c1{\"ABCDEFGH\"_bv};\n+\n+        BOOST_TEST((c1[{0, 2}] == \"AB\"_bv));\n+        BOOST_TEST((c1[{1, 4}] == \"BCD\"_bv));\n+        BOOST_TEST((c1[{3, 7}] == \"DEFG\"_bv));\n+        BOOST_TEST((c1[{0, 8}] == c1));\n+    }\n+\n+    {\n+        // Creating ex_vector from a `uint256`.\n+        //\n+        // (w.r.t. these tests note there is an endianness issue - HexStr will print little-endian,\n+        // as a byte array, NOT big-endian like an integer\n+        ex_vector<unsigned char> exv_ZERO = from_base_blob(uint256::ZERO);\n+        BOOST_TEST(HexStr(exv_ZERO) == \"0000000000000000000000000000000000000000000000000000000000000000\");\n+        ex_vector<unsigned char> exv_ONE = from_base_blob(uint256::ONE);\n+        BOOST_TEST(HexStr(exv_ONE) == \"0100000000000000000000000000000000000000000000000000000000000000\");\n+        ex_vector<unsigned char> exv_other = from_base_blob(uint256S(\n+            \"0123456789abcdef00000000000000000000000000000000fedcba9876543210\"));\n+        BOOST_TEST(HexStr(exv_other) == \"1032547698badcfe00000000000000000000000000000000efcdab8967452301\");\n+    }\n+\n+    {\n+        // Concatenating vectors via `operator||` (producing ex_vectors)\n+        valtype c0{};\n+        valtype c1{\"ABCDEFGH\"_bv};\n+        valtype c2{\"1234\"_bv};\n+\n+        BOOST_TEST(((c0 || c0) == c0));\n+        BOOST_TEST(((c0 || c1) == c1));\n+        BOOST_TEST(((c2 || c0) == c2));\n+        BOOST_TEST(((c1 || c2) == \"ABCDEFGH1234\"_bv));\n+        BOOST_TEST(((c2 || c1) == \"1234ABCDEFGH\"_bv));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(pretty_flags)\n+{\n+    // A small assortment\n+    BOOST_TEST(SCRIPT_VERIFY_P2SH == ParseScriptFlags(\"P2SH\"sv, false));\n+    BOOST_TEST(SCRIPT_VERIFY_SIGPUSHONLY == ParseScriptFlags(\"SIGPUSHONLY\"sv, false));\n+    BOOST_TEST(SCRIPT_VERIFY_TAPROOT == ParseScriptFlags(\"TAPROOT\"sv, false));\n+    BOOST_TEST((SCRIPT_VERIFY_MINIMALIF | SCRIPT_VERIFY_WITNESS) == ParseScriptFlags(\"MINIMALIF,WITNESS\"sv, false));\n+    BOOST_TEST((SCRIPT_VERIFY_TAPROOT | SCRIPT_VERIFY_LOW_S | SCRIPT_VERIFY_DERSIG) == ParseScriptFlags(\"TAPROOT,LOW_S,DERSIG\"sv, false));\n+    BOOST_TEST(0 == ParseScriptFlags(\"F00BAR\"sv, false));\n+    BOOST_TEST(0 == ParseScriptFlags(\"witness\"sv, false));        // case-sensitive\n+    BOOST_TEST(0 == ParseScriptFlags(\"P2SH , WITNESS\"sv, false)); // Underlying function \"split\" doesn't trim\n+\n+    BOOST_TEST(\"STRICTENC\"sv == FormatScriptFlags(SCRIPT_VERIFY_STRICTENC));\n+    BOOST_TEST(\"WITNESS_PUBKEYTYPE\"sv == FormatScriptFlags(SCRIPT_VERIFY_WITNESS_PUBKEYTYPE));\n+    BOOST_TEST(\"CONST_SCRIPTCODE,TAPROOT\"sv == FormatScriptFlags(SCRIPT_VERIFY_TAPROOT | SCRIPT_VERIFY_CONST_SCRIPTCODE));\n+    BOOST_TEST(\"CLEANSTACK,NULLDUMMY,NULLFAIL\"sv == FormatScriptFlags(SCRIPT_VERIFY_NULLDUMMY | SCRIPT_VERIFY_CLEANSTACK | SCRIPT_VERIFY_NULLFAIL));\n+    BOOST_TEST(\"\"sv == FormatScriptFlags(0));\n+    BOOST_TEST(\"\"sv == FormatScriptFlags(1U << 30)); // invalid flags just ignored\n+    BOOST_TEST(\"WITNESS\"sv == FormatScriptFlags((1U << 30) | SCRIPT_VERIFY_WITNESS));\n+\n+    // Systematic\n+    auto flag_map = MapFlagNames();\n+    for (auto [name1, value1] : flag_map) {\n+        BOOST_TEST(value1 == ParseScriptFlags(name1));\n+        BOOST_TEST(name1 == FormatScriptFlags(value1));\n+\n+        for (auto [name2, value2] : flag_map) {\n+            if (value1 == value2) continue;\n+            BOOST_TEST((value1 | value2) == ParseScriptFlags(std::string(name1) + \",\" + std::string(name2), false));\n+            BOOST_TEST(std::string(name1 < name2 ? name1 : name2) + \",\" + std::string(name1 < name2 ? name2 : name1) == FormatScriptFlags(value1 | value2));\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(pretty_script_errors)\n+{\n+    // A small assortment\n+    BOOST_TEST(\"OK\"sv == FormatScriptError(SCRIPT_ERR_OK, false));\n+    BOOST_TEST(\"UNKNOWN_ERROR\"sv == FormatScriptError(SCRIPT_ERR_UNKNOWN_ERROR, false));\n+    BOOST_TEST(\"\"sv == FormatScriptError(SCRIPT_ERR_ERROR_COUNT, false));\n+\n+    BOOST_TEST(SCRIPT_ERR_OK == ParseScriptError(\"OK\"sv, false));\n+    BOOST_TEST(SCRIPT_ERR_SCHNORR_SIG_SIZE == ParseScriptError(\"SCHNORR_SIG_SIZE\"sv, false));\n+    BOOST_TEST(SCRIPT_ERR_UNKNOWN_ERROR == ParseScriptError(\"F00Bar\"sv, false));\n+    BOOST_TEST(SCRIPT_ERR_UNKNOWN_ERROR == ParseScriptError(\"Schnorr_Sig\"sv, false)); // case-sensitive\n+    BOOST_TEST(SCRIPT_ERR_UNKNOWN_ERROR == ParseScriptError(\"MINIMALIF \"sv, false));  // doesn't trim arg\n+\n+    // Systematic\n+    for (size_t i = 0; i < SCRIPT_ERR_ERROR_COUNT; ++i) {\n+        const auto name = FormatScriptError(static_cast<ScriptError_t>(i));\n+        BOOST_TEST(!name.empty());\n+        BOOST_TEST(i == ParseScriptError(name));\n+    }\n+}\n+\n+#define EVAL(...) []() -> bool { return __VA_ARGS__; }()\n+\n+BOOST_AUTO_TEST_CASE(is_base_of_trait)",
      "path": "src/test/test_util_tests.cpp",
      "position": 235,
      "original_position": 235,
      "commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "original_commit_id": "12ae33708ee1978e2a215954e41e6ccf4f0a25fd",
      "in_reply_to_id": null,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin/bitcoin/pull/25097/commits/12ae33708ee1978e2a215954e41e6ccf4f0a25fd\r\n\r\nIs there a reason to include this test case? This doesn't look like it's testing any non-std functionality. It also seems like a direct adaptation of the example usage here: https://en.cppreference.com/w/cpp/types/is_base_of",
      "created_at": "2022-07-08T21:15:21Z",
      "updated_at": "2022-07-08T21:37:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r917142704",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/917142704"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 235,
      "original_line": 235,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/919306372",
      "pull_request_review_id": 1036328057,
      "id": 919306372,
      "node_id": "PRRC_kwDOABII5842y4CE",
      "diff_hunk": "@@ -0,0 +1,1711 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+// TODO: Don't know whether Taproot/Tapscript tests should be exercising\n+// `libconsensus` the way the tests in `script_tests` do\n+\n+#include <core_io.h>\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <script/script_error.h>\n+#include <span.h>\n+#include <test/util/boost_test_boosts.h>\n+#include <test/util/pretty_data.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/transaction_utils.h>\n+#include <test/util/vector.h>\n+#include <univalue.h>\n+#include <util/strencodings.h>\n+\n+#include <boost/test/execution_monitor.hpp>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <array>\n+#include <charconv>\n+#include <cstddef>\n+#include <iomanip>\n+#include <iterator>\n+#include <limits>\n+#include <ostream>\n+#include <set>\n+#include <stdexcept>\n+#include <string>\n+#include <string_view>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+using namespace std::literals::string_literals;\n+using namespace std::literals::string_view_literals;\n+using namespace test::util::literals;\n+\n+namespace {\n+\n+typedef std::vector<unsigned char> valtype;\n+\n+/**\n+ * Value/Name pair used in data-driven tests\n+ */\n+template <typename V>\n+struct vn_pair {\n+    vn_pair(V value, std::string_view name) : m_value(value), m_name(name) {}\n+\n+    const V m_value;\n+    const std::string_view m_name;\n+};\n+\n+/**\n+ * Sequence of value/name pairs used in data-driven tests\n+ */\n+template <typename V>\n+using vn_sequence = std::vector<vn_pair<V>>;\n+\n+/**\n+ * Invokes undefined behavior.  See `std::unreachable` in C++23.\n+ */\n+[[noreturn]] inline void declare_unreachable()\n+{\n+#ifdef _MSC_VER\n+    __assume(false);\n+#else\n+    // Assume all other compilers than MSVC implement this GCC builtin.\n+    __builtin_unreachable();\n+#endif\n+}\n+\n+/**\n+ * Representation changer to fill an integral type with a known pattern.\n+ *\n+ * Pattern is successive byte values given a starting point.  Endianness doesn't\n+ * matter.\n+ */\n+union FillWithPattern {\n+    uint256 u256{0};\n+    uint64_t u64raw[sizeof(uint256) / sizeof(uint64_t)];\n+    uint32_t u32[sizeof(uint256) / sizeof(uint32_t)];\n+    int32_t i32[sizeof(uint256) / sizeof(int32_t)];\n+    uint8_t u8[sizeof(uint256)];\n+\n+    constexpr FillWithPattern(uint8_t start)\n+    {\n+        for (auto it = std::begin(u8); it != std::end(u8); ++it) {\n+            *it = start++;\n+        }\n+    }\n+\n+    uint64_t u64() const\n+    {\n+        // It is desirable to force high bit off\n+        return u64raw[0] & static_cast<uint64_t>(std::numeric_limits<int64_t>::max());\n+    }\n+};\n+\n+/**\n+ * The two possible actions for our mock signature checker\n+ */\n+enum class CHECKER_VALIDATION { ALWAYS_SUCCEEDS,\n+                                ALWAYS_FAILS };\n+\n+/**\n+ * For these tests don't need _real_ signature/pubkey validation.  That is\n+ * tested elsewhere.  So we just _mock_ the signature checker and force it\n+ * to answer valid/invalid as we wish.\n+ */\n+class SignatureCheckerMock : public BaseSignatureChecker\n+{\n+    //! What kind of mock checker is this?\n+    CHECKER_VALIDATION m_kind = CHECKER_VALIDATION::ALWAYS_FAILS;\n+\n+    //! True _iff_ CheckSchnorrSignature was actually called\n+    mutable bool m_was_called = false;\n+\n+public:\n+    //! Whether this mock always validates, or always fails, the signature/pubkey check.\n+    explicit SignatureCheckerMock(CHECKER_VALIDATION kind) : m_kind(kind) {}\n+\n+    //! Mocks the actual checking of the validity of the Schnorr signature by always succeeding or always failing\n+    bool CheckSchnorrSignature(Span<const unsigned char> sig,\n+                               Span<const unsigned char> pubkey,\n+                               SigVersion sigversion,\n+                               ScriptExecutionData& execdata,\n+                               ScriptError* serror = nullptr) const override\n+    {\n+        m_was_called = true;\n+        switch (m_kind) {\n+        case CHECKER_VALIDATION::ALWAYS_SUCCEEDS:\n+            if (serror) *serror = SCRIPT_ERR_OK;\n+            return true;\n+\n+        case CHECKER_VALIDATION::ALWAYS_FAILS:\n+            if (serror) *serror = SCRIPT_ERR_SCHNORR_SIG;\n+            return false;\n+        }\n+        declare_unreachable();\n+    }\n+\n+    bool CheckerWasCalled() const\n+    {\n+        return m_was_called;\n+    }\n+};\n+\n+} // namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(script_tapscript_tests, BasicTestingSetup)\n+\n+/**\n+ * Testing EvalScript OP_CHECKSIGADD branch and EvalChecksigTapscript, both in\n+ * interpreter.cpp, against the BIP342 \"Rules for signature opcodes\".\n+ */\n+BOOST_AUTO_TEST_CASE(eval_checksigadd_basic_checks)\n+{\n+    const valtype SIG_64BYTES(64, 0); // N.B.: Must be () not {}!\n+    const valtype SIG_65BYTES(65, 0);\n+    const valtype SIG_EMPTY{};\n+\n+    const valtype PUBKEY_32BYTES(32, 0);\n+    const valtype PUBKEY_15BYTES(15, 0);\n+    const valtype PUBKEY_EMPTY{};\n+\n+    constexpr int64_t TEST_NUM = 10;\n+\n+    constexpr int64_t START_VALIDATION_WEIGHT{90};\n+    constexpr int64_t BIP342_SIGOPS_LIMIT{50};\n+    constexpr int64_t END_VALIDATION_WEIGHT{START_VALIDATION_WEIGHT - BIP342_SIGOPS_LIMIT};\n+\n+    /**\n+     * A fluent API for running these tests.\n+     *\n+     * (Easiest way to understand this class is to look at the actual tests\n+     * that follow in this function.)\n+     */\n+    struct Context {\n+        explicit Context(std::string_view descr) : m_test_description(descr)\n+        {\n+            m_execdata.m_validation_weight_left_init = true;\n+            m_execdata.m_validation_weight_left = START_VALIDATION_WEIGHT;\n+        }\n+\n+        std::string m_test_description;\n+        SigVersion m_sig_version = SigVersion::TAPSCRIPT;\n+        uint32_t m_flags = 0;\n+        CScript m_script;\n+        ScriptError m_err = SCRIPT_ERR_OK;\n+        std::vector<valtype> m_stack;\n+        ScriptExecutionData m_execdata;\n+        CHECKER_VALIDATION m_kind;\n+        bool m_sigchecker_was_called = false;\n+        int64_t m_caller_line = 0;\n+        bool m_result = false;\n+\n+        Context& SetVersion(SigVersion v)\n+        {\n+            m_sig_version = v;\n+            return *this;\n+        }\n+\n+        Context& SetChecker(CHECKER_VALIDATION kind)\n+        {\n+            m_kind = kind;\n+            return *this;\n+        }\n+\n+        Context& SetRemainingWeight(int64_t w)\n+        {\n+            m_execdata.m_validation_weight_left = w;\n+            return *this;\n+        }\n+\n+        Context& AddFlags(uint32_t f)\n+        {\n+            m_flags |= f;\n+            return *this;\n+        }\n+\n+        CScript& SetScript()\n+        {\n+            return m_script;\n+        }\n+\n+        Context& DoTest(int64_t line)\n+        {\n+            SignatureCheckerMock checker_mock(m_kind);\n+            m_caller_line = line;\n+            m_result = EvalScript(m_stack, m_script,\n+                                  SCRIPT_VERIFY_TAPROOT | m_flags,\n+                                  checker_mock,\n+                                  m_sig_version,\n+                                  m_execdata,\n+                                  &m_err);\n+            m_sigchecker_was_called = checker_mock.CheckerWasCalled();\n+            return *this;\n+        }\n+\n+        Context& CheckCallSucceeded()\n+        {\n+            BOOST_CHECK_MESSAGE(m_result,\n+                                Descr()\n+                                    << \": EvalScript succeeded, as expected\");\n+            BOOST_CHECK_MESSAGE(m_err == SCRIPT_ERR_OK,\n+                                Descr()\n+                                    << \": Error code expected OK, actual was \"\n+                                    << ScriptErrorString(m_err));\n+            return *this;\n+        }\n+\n+        Context& CheckCallFailed(ScriptError expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!m_result,\n+                                Descr()\n+                                    << \": EvalScript failed, as expected\");\n+            BOOST_CHECK_MESSAGE(m_err == expected,\n+                                Descr()\n+                                    << \": Error code expected \" << ScriptErrorString(expected)\n+                                    << \", actual was \" << ScriptErrorString(m_err));\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(m_sigchecker_was_called,\n+                                Descr() << \": CheckSchnorrSignature was called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasNotValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(!m_sigchecker_was_called,\n+                                Descr() << \": CheckSchnorrSignature was not called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckRemainingValidationWeight(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(m_execdata.m_validation_weight_left == expected,\n+                                Descr()\n+                                    << \": Remaining validation weight expected \"\n+                                    << expected << \", actual was \"\n+                                    << m_execdata.m_validation_weight_left);\n+            return *this;\n+        }\n+\n+        Context& CheckStackDepth(std::size_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(m_stack.size() == expected,\n+                                Descr()\n+                                    << \": Stack depth expected \" << expected\n+                                    << \", actual was \" << m_stack.size());\n+            return *this;\n+        }\n+\n+        Context& CheckTOS(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!m_stack.empty(),\n+                                Descr()\n+                                    << \": Stack expected at least one item, actually was empty\");\n+            const int64_t actual = CScriptNum(m_stack.at(0), false).GetInt64();\n+            BOOST_CHECK_MESSAGE(expected == actual,\n+                                Descr()\n+                                    << \": Top-of-stack expected \" << expected\n+                                    << \", actual was \" << actual);\n+            return *this;\n+        }\n+\n+    private:\n+        std::string Descr()\n+        {\n+            std::string descr;\n+            descr.reserve(m_test_description.size() + 20);\n+            descr += m_test_description;\n+            descr += \" (@\";\n+            descr += as_string(m_caller_line);\n+            descr += \")\";\n+            return descr;\n+        }\n+    };\n+\n+    {\n+        Context ctx(\"SigVersion must not be BASE\");\n+        ctx.SetVersion(SigVersion::BASE).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"SigVersion must not be WITNESS_V0\");\n+        ctx.SetVersion(SigVersion::WITNESS_V0).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Minimum stack height 3 for OP_CHECKSIGADD\");\n+        ctx.SetScript()\n+            << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_INVALID_STACK_OPERATION)\n+            .CheckStackDepth(2);\n+    }\n+\n+    {\n+        Context ctx(\"`n` (2nd arg) size > 4 must fail\");\n+        // This is probably meant to be a check on the _encoding_ - that it is\n+        // minimal, but it can also be a check on the _value_.  BIP342 doesn't\n+        // say which.  Could be both...\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(10000000000LL) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            // (IMO this is an _unsatisfactory_ error code to return for a required\n+            // BIP342 check, but see the `catch` clause in `EvalScript`)\n+            .CheckCallFailed(SCRIPT_ERR_UNKNOWN_ERROR)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Insufficient validation weight remaining\");\n+        ctx.SetRemainingWeight(BIP342_SIGOPS_LIMIT - 1)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + 32byte pubkey skips validation\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + non32byte pubkey skips validation\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey ('unknown pubkey type') _with_ discourage flag fails\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .AddFlags(SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .CheckSignatureWasNotValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation failure forced\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_FAILS)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_SCHNORR_SIG)\n+            .CheckSignatureWasValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation success forced\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasValidated()\n+            .CheckRemainingValidationWeight(END_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM + 1);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey + empty sig with validation success forced\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_failure_cases)\n+{\n+    // As defined by BIP-341 Signature Validation Rules\n+    // Here we pick an acceptable SigVersion\n+    const SigVersion sigversion = SigVersion::TAPROOT;\n+\n+    CMutableTransaction tx_to_m;\n+    tx_to_m.vin.push_back(CTxIn());\n+    const uint32_t in_pos{0};\n+\n+    PrecomputedTransactionData cache;\n+    cache.m_bip341_taproot_ready = true;\n+    cache.m_spent_outputs_ready = true;\n+\n+    ScriptExecutionData execdata;\n+    execdata.m_annex_init = true;\n+    execdata.m_annex_present = false;\n+    execdata.m_annex_hash = uint256::ZERO;\n+    execdata.m_tapleaf_hash_init = false;\n+    execdata.m_codeseparator_pos_init = true;\n+\n+    uint256 hash_out{0};\n+\n+    {\n+        // Check all invalid hash_type codes rejected\n+        const std::set<uint8_t> allowable_hash_types{0x00, 0x01, 0x02, 0x03, 0x81, 0x82, 0x83};\n+        for (unsigned ht = 0; ht <= 255; ht++) {\n+            const uint8_t hash_type = static_cast<uint8_t>(ht);\n+            if (allowable_hash_types.find(hash_type) != allowable_hash_types.end()) continue;\n+\n+            BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m, in_pos,\n+                                                      hash_type, sigversion, cache,\n+                                                      MissingDataBehavior::FAIL),\n+                                \"hash_type = \" << Hex(hash_type) << \" expected to fail\");\n+        }\n+    }\n+\n+    {\n+        // Check that if hash_type == SIGHASH_SINGLE then missing a \"corresponding\n+        // output\" fails.\n+        CMutableTransaction tx_to_m;\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+\n+        uint8_t in_pos = 1;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(1) > #tx_to==0 is expected to fail\");\n+\n+        tx_to_m.vout.push_back(CTxOut());\n+        in_pos = 2;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(2) > #tx_to==1 is expected to fail\");\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_all_success_paths)\n+{\n+    // Our approach here will be to follow BIP-341's signature algorithm (with\n+    // the BIP-342 extension) doing two things at once:\n+    //   1) We'll set up the input arguments to `SignatureHashSchnorr` function\n+    //      being tested, _and_\n+    //   2) we'll _compute the hash of those fields ourselves_ exaxctly as\n+    //      it is described in BIP-341 and BIP-342.\n+    // Then we can compare the two.  We'll do this in a data-driven way for each\n+    // of the different scenarios that the algorithm supports.\n+    //\n+    // In this way this test achieves 100% _path_ coverage of `SignatureHashSchnorr`\n+    // (not just 100% _branch_ coverage).\n+    // - Sadly, this isn't shown in the `lcov` reports.  There are still a few\n+    //   red `-` marks left.  This is because:\n+    //   1. `lcov` wasn't designed to handle death tests.\n+    //   2. ??? Some other unknown reasons, possibly due to the instrumentation,\n+    //      possibly due to `lcov` limitations.  You can see by the test output\n+    //      (`-log_level=all`) or within a debugger that in fact _all_ branches\n+    //      are taken when executing all the tests in this file.\n+\n+    // Here we define, and then generate, all combinations of the alternatives\n+    // for the parameters that vary the signature combination algorithm\n+\n+    const vn_sequence<SigVersion> SigVersion_alternatives{\n+        {SigVersion::TAPROOT, \"TAPROOT\"sv},\n+        {SigVersion::TAPSCRIPT, \"TAPSCRIPT\"sv}};\n+\n+    const vn_sequence<uint32_t> hash_type_output_alternatives{\n+        {SIGHASH_DEFAULT, \"SIGHASH_DEFAULT\"sv},\n+        {SIGHASH_ALL, \"SIGHASH_ALL\"sv},\n+        {SIGHASH_NONE, \"SIGHASH_NONE\"sv},\n+        {SIGHASH_SINGLE, \"SIGHASH_SINGLE\"sv}};\n+\n+    const vn_sequence<uint32_t> hash_type_input_alternatives{\n+        {0, \"N/A\"sv},\n+        {SIGHASH_ANYONECANPAY, \"SIGHASH_ANYONECANPAY\"sv}};\n+\n+    const vn_sequence<uint8_t> annex_alternatives{\n+        {0, \"no annex\"sv},\n+        {1, \"annex present\"sv}};\n+\n+    const vn_sequence<bool> output_hash_alternatives{\n+        {false, \"output hash missing\"sv},\n+        {true, \"output hash provided\"sv}};\n+\n+    for (const auto& sigversion_alternative : SigVersion_alternatives)\n+        for (const auto& hash_type_output_alternative : hash_type_output_alternatives)\n+            for (const auto& hash_type_input_alternative : hash_type_input_alternatives)\n+                for (const auto& annex_alternative : annex_alternatives)\n+                    for (const auto& output_hash_alternative : output_hash_alternatives) {\n+                        // Exclude the invalid combination of SIGHASH_DEFAULT with SIGHASH_ANYONECANPAY\n+                        if (hash_type_output_alternative.m_value == SIGHASH_DEFAULT && hash_type_input_alternative.m_value == SIGHASH_ANYONECANPAY) continue;\n+\n+                        // We're going to want to know which scenario it is if a check actually\n+                        // fails ...\n+                        std::string scenario_description;\n+                        {\n+                            std::ostringstream oss;\n+                            oss << sigversion_alternative.m_name << \", \"\n+                                << hash_type_output_alternative.m_name << \", \"\n+                                << hash_type_input_alternative.m_name << \", \"\n+                                << annex_alternative.m_name << \", \"\n+                                << output_hash_alternative.m_name;\n+                            scenario_description = oss.str();\n+                        }\n+\n+                        // Set up the scenario we're running now - these 4 variables define the scenario\n+                        const SigVersion sigversion{sigversion_alternative.m_value};\n+                        const uint8_t hash_type{static_cast<uint8_t>(hash_type_output_alternative.m_value | hash_type_input_alternative.m_value)};\n+                        const uint8_t annex_present{annex_alternative.m_value};\n+                        const bool have_output_hash{output_hash_alternative.m_value};\n+\n+                        // Compute some helper values that depend on scenario\n+                        const uint8_t ext_flag{sigversion == SigVersion::TAPSCRIPT};\n+                        const uint8_t hash_input_type{static_cast<uint8_t>(hash_type & SIGHASH_INPUT_MASK)};\n+                        const uint8_t hash_output_type{static_cast<uint8_t>((hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK))};\n+                        const uint8_t spend_type = (ext_flag * 2) + annex_present;\n+\n+                        // Fixed values (by algorithm)\n+                        const uint8_t epoch{0x00};\n+                        const uint8_t key_version{0};\n+\n+                        // Mocked values fixed for purposes of this unit test.  This is a long\n+                        // list of crufty things but that's because `SignatureHashSchnorr`, the\n+                        // function being tested, takes as arguments not just the transaction\n+                        // being signed (plus control data) but also some _precomputed values_\n+                        // in two different structs: `PrecomputedTransactionData`, and\n+                        // `ScriptExecutionData`.  On the one hand this is nice because a lot\n+                        // of complexity of the signature algorithm doesn't have to be duplicated\n+                        // here in this test: we can just use mocked values.  On the other hand,\n+                        // there's a lot of icky setup to do to get all the values in the right\n+                        // places both for our \"by the book\" implementation and to be set up to\n+                        // call `SignatureHashSchnorr`.\n+                        //\n+                        // Try to make things simpler by at least using the same names for the\n+                        // setup variables as for the fields in the parameter structs.\n+\n+                        const uint32_t in_pos{1};\n+                        const int32_t tx_version{FillWithPattern(0x01).i32[0]};\n+                        const uint32_t tx_lock_time{FillWithPattern(0x05).u32[0]};\n+                        const uint256 prevouts_single_hash{FillWithPattern(0x10).u256};\n+                        const uint256 spent_amounts_single_hash{FillWithPattern(0x18).u256};\n+                        const uint256 spent_scripts_single_hash{FillWithPattern(0x20).u256};\n+                        const uint256 sequences_single_hash{FillWithPattern(0x28).u256};\n+                        const uint256 outputs_single_hash{FillWithPattern(0x30).u256};\n+                        const uint256 output_hash{FillWithPattern(0x40).u256};\n+                        const uint256 annex_hash{FillWithPattern(0x48).u256};\n+                        const uint256 tapleaf_hash{FillWithPattern(0x50).u256};\n+                        const uint32_t codeseparator_pos{FillWithPattern(0x58).u32[0]};\n+                        const COutPoint tx_input_at_pos_prevout{FillWithPattern(0x60).u256,\n+                                                                FillWithPattern(0x68).u32[0]};\n+                        const uint32_t tx_input_at_pos_nsequence{FillWithPattern(0x70).u32[0]};\n+                        CTxOut spent_output_at_pos;\n+                        spent_output_at_pos.nValue = FillWithPattern(0x80).u64();\n+                        spent_output_at_pos.scriptPubKey /*random script, not even valid*/\n+                            << OP_DUP << OP_HASH160 << OP_EQUALVERIFY << OP_CHECKSIG;\n+                        CTxOut tx_output_at_pos;\n+                        tx_output_at_pos.nValue = FillWithPattern(0x90).u64();\n+                        tx_output_at_pos.scriptPubKey /*random script, not even valid*/\n+                            << OP_CHECKSIG << OP_EQUALVERIFY << OP_HASH160 << OP_DUP;\n+\n+                        // Now set up the arguments that are going to be passed to\n+                        // `SignatureHashSchnorr`\n+\n+                        CMutableTransaction tx_to;\n+                        tx_to.nVersion = tx_version;\n+                        tx_to.nLockTime = tx_lock_time;\n+                        for (uint32_t i = 0; i < in_pos + 2; i++) {\n+                            tx_to.vin.push_back(CTxIn());\n+                            tx_to.vout.push_back(CTxOut());\n+                        }\n+                        tx_to.vin[in_pos].prevout = tx_input_at_pos_prevout;\n+                        tx_to.vin[in_pos].nSequence = tx_input_at_pos_nsequence;\n+                        tx_to.vout[in_pos] = tx_output_at_pos;\n+\n+                        PrecomputedTransactionData cache;\n+                        cache.m_bip341_taproot_ready = true;\n+                        cache.m_prevouts_single_hash = prevouts_single_hash;\n+                        cache.m_spent_amounts_single_hash = spent_amounts_single_hash;\n+                        cache.m_spent_scripts_single_hash = spent_scripts_single_hash;\n+                        cache.m_sequences_single_hash = sequences_single_hash;\n+                        cache.m_spent_outputs_ready = true;\n+                        for (uint32_t i = 0; i < in_pos + 2; i++) {\n+                            cache.m_spent_outputs.push_back(CTxOut());\n+                        }\n+                        cache.m_spent_outputs[in_pos] = spent_output_at_pos;\n+                        cache.m_outputs_single_hash = outputs_single_hash;\n+\n+                        ScriptExecutionData execdata;\n+                        execdata.m_annex_init = true;\n+                        execdata.m_annex_present = !!annex_present;\n+                        execdata.m_annex_hash = annex_hash;\n+                        execdata.m_output_hash.reset();\n+                        if (have_output_hash) {\n+                            execdata.m_output_hash = output_hash;\n+                        }\n+                        if (sigversion == SigVersion::TAPSCRIPT) {\n+                            execdata.m_tapleaf_hash_init = true;\n+                            execdata.m_tapleaf_hash = tapleaf_hash;\n+                            execdata.m_codeseparator_pos_init = true;\n+                            execdata.m_codeseparator_pos = codeseparator_pos;\n+                        }\n+\n+                        // Now here is where we take all that data - _not_ the arguments to\n+                        // `SignatureHashSchnorr` but all the scenario parameters, the helpers,\n+                        // the values fixed by the algorithm, and our mocked values, and actually\n+                        // follow the BIP-341/BIP-342 signature calculation algorithm right from\n+                        // the spec ...\n+\n+                        // Start with a tagged hasher with the correct tag\n+                        CHashWriter hasher = TaggedHash(\"TapSighash\");\n+\n+                        // First byte to hash is always the \"epoch\", 0x00 (BIP-341, footnote 20)\n+                        hasher << epoch;\n+\n+                        // Next: hash_type (1 byte)\n+                        hasher << hash_type;\n+\n+                        // Next: transaction version (4 bytes)\n+                        hasher << tx_version;\n+\n+                        // Next: transaction lock time (4 bytes)\n+                        hasher << tx_lock_time;\n+\n+                        // Next if _not_ SIGHASH_ANYONECANPAY:\n+                        // a) SHA256 of the serialization of all input outpoints (32 bytes)\n+                        // b) SHA256 of the serialization of all spent output amounts (32 bytes)\n+                        // c) SHA256 of the serialization of all spent outputs' _scriptPubKeys_\n+                        //    serialized as script (32 bytes)\n+                        // d) SHA256 of the serialization of all input `nSequence` (32 bytes)\n+                        if (hash_input_type != SIGHASH_ANYONECANPAY) {\n+                            hasher << prevouts_single_hash;\n+                            hasher << spent_amounts_single_hash;\n+                            hasher << spent_scripts_single_hash;\n+                            hasher << sequences_single_hash;\n+                        }\n+\n+                        // Next if _not_ SIGHASH_NONE _and not_ SIGHASH_SINGLE:\n+                        // SHA256 of the serialization of all outputs in CTxOut format (32 bytes)\n+                        if (hash_output_type != SIGHASH_NONE && hash_output_type != SIGHASH_SINGLE) {\n+                            hasher << outputs_single_hash;\n+                        }\n+\n+                        // Now, data about input/prevout being spent\n+\n+                        // The \"spend_type\" (1 byte) which is a function of ext_flag (above) and\n+                        // whether there is an annex present (here: no)\n+                        hasher << spend_type;\n+\n+                        // Here, if we are _not_ SIGHASH_ANYONECANPAY, we just add the index of\n+                        // the input in the transaction input vector (4 bytes). There must be a\n+                        // input transaction at this index but _in this scenario_ it doesn't have\n+                        // to have any data (it is never inspected).  Same for output transactions.\n+                        //\n+                        // On the other hand, if we _are_ SIGHASH_ANYONECANPAY, then we add the\n+                        // `COutPoint` of this input (36 bytes), the value of the previous\n+                        // output spent by this input (8 bytes), the `ScriptPubKey` of the\n+                        // previous output spent by this input (35 bytes), and the `nSequence`\n+                        // of this input.  These values are all precomputed and made available\n+                        // to `SignatureHashSchnorr` in the `PrecomputedTransactionData` struct.\n+                        if (hash_input_type == SIGHASH_ANYONECANPAY) {\n+                            hasher << tx_input_at_pos_prevout;\n+                            hasher << spent_output_at_pos.nValue;\n+                            hasher << spent_output_at_pos.scriptPubKey;\n+                            hasher << tx_input_at_pos_nsequence;\n+                        } else {\n+                            hasher << in_pos;\n+                        }\n+\n+                        // Now, if there is an \"annex\", add its hash (32 byte).  This is\n+                        // precomputed and we don't actually have to have an actual annex to\n+                        // pass in to `SignatureHashSchnorr`, nor do we have to hash it.\n+                        if (annex_present) {\n+                            hasher << annex_hash;\n+                        }\n+\n+                        // Here, iff the hash type is `SIGHASH_SINGLE`, add the hash of the\n+                        // corresponding transaction output (32 bytes).  The wrinkle here is that\n+                        // (for some reason) _sometimes_ this hash is precomputed, and _sometimes_\n+                        // it is _not_.  So `SignatureHashSchnorr` will either use it if it is\n+                        // provided or compute it from the corresponding output itself. (For our\n+                        // purposes in this test the output need not be valid - it just must be\n+                        // present.)\n+                        if (hash_output_type == SIGHASH_SINGLE) {\n+                            if (!have_output_hash) {\n+                                CHashWriter hasher2(SER_GETHASH, 0);\n+                                hasher2 << tx_output_at_pos;\n+                                hasher << hasher2.GetSHA256();\n+                            } else {\n+                                hasher << output_hash;\n+                            }\n+                        }\n+\n+                        // This is the TAPSCRIPT extension from BIP-342.  If the version is\n+                        // TAPSCRIPT then add the tapleaf hash (32 bytes), the key_version (1\n+                        // byte, fixed value of 0x00), and the \"opcode position of the last\n+                        // executed OP_CODESEPARATOR before the currently executed signature\n+                        // opcode\" (4 bytes).  The tapleaf hash and the code separator position\n+                        // are both precomputed values.\n+                        if (sigversion == SigVersion::TAPSCRIPT) {\n+                            hasher << tapleaf_hash;\n+                            hasher << key_version;\n+                            hasher << codeseparator_pos;\n+                        }\n+\n+                        // That's all that goes into the hasher for this signature\n+                        const uint256 expected_hash_out = hasher.GetSHA256();\n+\n+                        // Now, _finally_, we test the actual implemented algorithm under test:\n+                        uint256 actual_hash_out{0};\n+                        BOOST_TEST(SignatureHashSchnorr(actual_hash_out,\n+                                                        execdata, tx_to, in_pos,\n+                                                        hash_type, sigversion, cache,\n+                                                        MissingDataBehavior::FAIL),\n+                                   \"Scenario: \" << scenario_description);\n+                        BOOST_TEST(expected_hash_out == actual_hash_out,\n+                                   \"Scenario: \" << scenario_description\n+                                                << \" - expected \" << expected_hash_out.ToString()\n+                                                << \" == actual \" << actual_hash_out.ToString());\n+                    }\n+}\n+\n+namespace {\n+\n+// Valid Schnoor (pubkey, msg, signature) tuples (copied from `key_tests.cpp`)\n+\n+struct SchnorrTriplet {\n+    SchnorrTriplet(std::string pubkey, std::string sighash, std::string sig)\n+        : m_pubkey(ParseHex(pubkey)), m_sighash(uint256(ParseHex(sighash))), m_sig(ParseHex(sig)) {}\n+    valtype m_pubkey;\n+    uint256 m_sighash;\n+    valtype m_sig;\n+};\n+\n+static const std::vector<SchnorrTriplet> SCHNORR_TRIPLETS = {\n+    {\"F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9\", \"0000000000000000000000000000000000000000000000000000000000000000\", \"E907831F80848D1069A5371B402410364BDF1C5F8307B0084C55F1CE2DCA821525F66A4A85EA8B71E482A74F382D2CE5EBEEE8FDB2172F477DF4900D310536C0\"},\n+    {\"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659\", \"243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89\", \"6896BD60EEAE296DB48A229FF71DFE071BDE413E6D43F917DC8DCF8C78DE33418906D11AC976ABCCB20B091292BFF4EA897EFCB639EA871CFA95F6DE339E4B0A\"},\n+    {\"DD308AFEC5777E13121FA72B9CC1B7CC0139715309B086C960E18FD969774EB8\", \"7E2D58D8B3BCDF1ABADEC7829054F90DDA9805AAB56C77333024B9D0A508B75C\", \"5831AAEED7B44BB74E5EAB94BA9D4294C49BCF2A60728D8B4C200F50DD313C1BAB745879A5AD954A72C45A91C3A51D3C7ADEA98D82F8481E0E1E03674A6F3FB7\"},\n+    {\"25D1DFF95105F5253C4022F628A996AD3A0D95FBF21D468A1B33F8C160D8F517\", \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", \"7EB0509757E246F19449885651611CB965ECC1A187DD51B64FDA1EDC9637D5EC97582B9CB13DB3933705B32BA982AF5AF25FD78881EBB32771FC5922EFC66EA3\"},\n+    {\"D69C3509BB99E412E68B0FE8544E72837DFA30746D8BE2AA65975F29D22DC7B9\", \"4DF3C3F68FCC83B27E9D42C90431A72499F17875C81A599B566C9889B9696703\", \"00000000000000000000003B78CE563F89A0ED9414F5AA28AD0D96D6795F9C6376AFB1548AF603B3EB45C9F8207DEE1060CB71C04E80F593060B07D28308D7F4\"},\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(internal_test_validate_schnorr_testdata)\n+{\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(XOnlyPubKey(triplet.m_pubkey).VerifySchnorr(triplet.m_sighash, triplet.m_sig));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(verify_schnorr_signature)\n+{\n+    // Defeat, for test purposes, the protected access of\n+    // `GenericTransactionSignatureChecker::VerifySchnorrSignature`\n+    struct UnprotectedTransactionSignatureChecker : public MutableTransactionSignatureChecker {\n+        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;\n+        using MutableTransactionSignatureChecker::VerifySchnorrSignature;\n+    };\n+    UnprotectedTransactionSignatureChecker sut{nullptr, 0, {}, {}};\n+\n+    // Positive tests: triplets which verify\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(sut.VerifySchnorrSignature(triplet.m_sig,\n+                                              XOnlyPubKey{triplet.m_pubkey},\n+                                              triplet.m_sighash));\n+    }\n+\n+    // Negative tests: triplets which fail to verify (get these failing triplets\n+    // by modifying a valid triplet, one field at a time)\n+    auto diddle_front_byte = [](auto v) { v[0]++; return v; };\n+    auto& triplet = SCHNORR_TRIPLETS[0];\n+    BOOST_TEST(!sut.VerifySchnorrSignature(diddle_front_byte(triplet.m_sig),\n+                                           XOnlyPubKey{triplet.m_pubkey},\n+                                           triplet.m_sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.m_sig,\n+                                           XOnlyPubKey{diddle_front_byte(triplet.m_pubkey)},\n+                                           triplet.m_sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.m_sig,\n+                                           XOnlyPubKey{triplet.m_pubkey},\n+                                           uint256::ONE));\n+}\n+\n+BOOST_AUTO_TEST_CASE(check_schnorr_signature)\n+{\n+    // Provide, for test purposes, a subclass of `GenericTransactionsSignatureChecker`\n+    // that mocks `VerifySchnorrSignature` so we can more easily test\n+    // `CheckSchnorrSignature` without going to the trouble of having a valid\n+    // transaction (which is unnecessary for this _unit_ test.)\n+    struct MockVerifyingTransactionSignatureChecker : public MutableTransactionSignatureChecker {\n+        uint256 m_expected_sighash = []() {\n+            uint256 h{};\n+            // This is the known sighash of the Tx and input data we set up (precomputed)\n+            h.SetHex(\"f614d8ae6dcc49e2ca2ef1c03f93c7326189e5575d446e825e5a2700fb1cb83c\");\n+            return h;\n+        }();",
      "path": "src/test/script_tapscript_tests.cpp",
      "position": 893,
      "original_position": 893,
      "commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "original_commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "in_reply_to_id": null,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin/bitcoin/pull/25097/commits/eeefec343592c6de85048e3b055ba49755cfb072\r\n\r\nYou can use `uint256S()` instead of this lambda. (https://github.com/jamesob/bitcoin/blob/eeefec343592c6de85048e3b055ba49755cfb072/src/uint256.h#L139-L144)",
      "created_at": "2022-07-12T18:57:00Z",
      "updated_at": "2022-07-12T20:25:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r919306372",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/919306372"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 893,
      "original_line": 893,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/919308845",
      "pull_request_review_id": 1036328057,
      "id": 919308845,
      "node_id": "PRRC_kwDOABII5842y4ot",
      "diff_hunk": "@@ -0,0 +1,1711 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+// TODO: Don't know whether Taproot/Tapscript tests should be exercising\n+// `libconsensus` the way the tests in `script_tests` do\n+\n+#include <core_io.h>\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <script/script_error.h>\n+#include <span.h>\n+#include <test/util/boost_test_boosts.h>\n+#include <test/util/pretty_data.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/transaction_utils.h>\n+#include <test/util/vector.h>\n+#include <univalue.h>\n+#include <util/strencodings.h>\n+\n+#include <boost/test/execution_monitor.hpp>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <array>\n+#include <charconv>\n+#include <cstddef>\n+#include <iomanip>\n+#include <iterator>\n+#include <limits>\n+#include <ostream>\n+#include <set>\n+#include <stdexcept>\n+#include <string>\n+#include <string_view>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+using namespace std::literals::string_literals;\n+using namespace std::literals::string_view_literals;\n+using namespace test::util::literals;\n+\n+namespace {\n+\n+typedef std::vector<unsigned char> valtype;\n+\n+/**\n+ * Value/Name pair used in data-driven tests\n+ */\n+template <typename V>\n+struct vn_pair {\n+    vn_pair(V value, std::string_view name) : m_value(value), m_name(name) {}\n+\n+    const V m_value;\n+    const std::string_view m_name;\n+};\n+\n+/**\n+ * Sequence of value/name pairs used in data-driven tests\n+ */\n+template <typename V>\n+using vn_sequence = std::vector<vn_pair<V>>;\n+\n+/**\n+ * Invokes undefined behavior.  See `std::unreachable` in C++23.\n+ */\n+[[noreturn]] inline void declare_unreachable()\n+{\n+#ifdef _MSC_VER\n+    __assume(false);\n+#else\n+    // Assume all other compilers than MSVC implement this GCC builtin.\n+    __builtin_unreachable();\n+#endif\n+}\n+\n+/**\n+ * Representation changer to fill an integral type with a known pattern.\n+ *\n+ * Pattern is successive byte values given a starting point.  Endianness doesn't\n+ * matter.\n+ */\n+union FillWithPattern {\n+    uint256 u256{0};\n+    uint64_t u64raw[sizeof(uint256) / sizeof(uint64_t)];\n+    uint32_t u32[sizeof(uint256) / sizeof(uint32_t)];\n+    int32_t i32[sizeof(uint256) / sizeof(int32_t)];\n+    uint8_t u8[sizeof(uint256)];\n+\n+    constexpr FillWithPattern(uint8_t start)\n+    {\n+        for (auto it = std::begin(u8); it != std::end(u8); ++it) {\n+            *it = start++;\n+        }\n+    }\n+\n+    uint64_t u64() const\n+    {\n+        // It is desirable to force high bit off\n+        return u64raw[0] & static_cast<uint64_t>(std::numeric_limits<int64_t>::max());\n+    }\n+};\n+\n+/**\n+ * The two possible actions for our mock signature checker\n+ */\n+enum class CHECKER_VALIDATION { ALWAYS_SUCCEEDS,\n+                                ALWAYS_FAILS };\n+\n+/**\n+ * For these tests don't need _real_ signature/pubkey validation.  That is\n+ * tested elsewhere.  So we just _mock_ the signature checker and force it\n+ * to answer valid/invalid as we wish.\n+ */\n+class SignatureCheckerMock : public BaseSignatureChecker\n+{\n+    //! What kind of mock checker is this?\n+    CHECKER_VALIDATION m_kind = CHECKER_VALIDATION::ALWAYS_FAILS;\n+\n+    //! True _iff_ CheckSchnorrSignature was actually called\n+    mutable bool m_was_called = false;\n+\n+public:\n+    //! Whether this mock always validates, or always fails, the signature/pubkey check.\n+    explicit SignatureCheckerMock(CHECKER_VALIDATION kind) : m_kind(kind) {}\n+\n+    //! Mocks the actual checking of the validity of the Schnorr signature by always succeeding or always failing\n+    bool CheckSchnorrSignature(Span<const unsigned char> sig,\n+                               Span<const unsigned char> pubkey,\n+                               SigVersion sigversion,\n+                               ScriptExecutionData& execdata,\n+                               ScriptError* serror = nullptr) const override\n+    {\n+        m_was_called = true;\n+        switch (m_kind) {\n+        case CHECKER_VALIDATION::ALWAYS_SUCCEEDS:\n+            if (serror) *serror = SCRIPT_ERR_OK;\n+            return true;\n+\n+        case CHECKER_VALIDATION::ALWAYS_FAILS:\n+            if (serror) *serror = SCRIPT_ERR_SCHNORR_SIG;\n+            return false;\n+        }\n+        declare_unreachable();\n+    }\n+\n+    bool CheckerWasCalled() const\n+    {\n+        return m_was_called;\n+    }\n+};\n+\n+} // namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(script_tapscript_tests, BasicTestingSetup)\n+\n+/**\n+ * Testing EvalScript OP_CHECKSIGADD branch and EvalChecksigTapscript, both in\n+ * interpreter.cpp, against the BIP342 \"Rules for signature opcodes\".\n+ */\n+BOOST_AUTO_TEST_CASE(eval_checksigadd_basic_checks)\n+{\n+    const valtype SIG_64BYTES(64, 0); // N.B.: Must be () not {}!\n+    const valtype SIG_65BYTES(65, 0);\n+    const valtype SIG_EMPTY{};\n+\n+    const valtype PUBKEY_32BYTES(32, 0);\n+    const valtype PUBKEY_15BYTES(15, 0);\n+    const valtype PUBKEY_EMPTY{};\n+\n+    constexpr int64_t TEST_NUM = 10;\n+\n+    constexpr int64_t START_VALIDATION_WEIGHT{90};\n+    constexpr int64_t BIP342_SIGOPS_LIMIT{50};\n+    constexpr int64_t END_VALIDATION_WEIGHT{START_VALIDATION_WEIGHT - BIP342_SIGOPS_LIMIT};\n+\n+    /**\n+     * A fluent API for running these tests.\n+     *\n+     * (Easiest way to understand this class is to look at the actual tests\n+     * that follow in this function.)\n+     */\n+    struct Context {\n+        explicit Context(std::string_view descr) : m_test_description(descr)\n+        {\n+            m_execdata.m_validation_weight_left_init = true;\n+            m_execdata.m_validation_weight_left = START_VALIDATION_WEIGHT;\n+        }\n+\n+        std::string m_test_description;\n+        SigVersion m_sig_version = SigVersion::TAPSCRIPT;\n+        uint32_t m_flags = 0;\n+        CScript m_script;\n+        ScriptError m_err = SCRIPT_ERR_OK;\n+        std::vector<valtype> m_stack;\n+        ScriptExecutionData m_execdata;\n+        CHECKER_VALIDATION m_kind;\n+        bool m_sigchecker_was_called = false;\n+        int64_t m_caller_line = 0;\n+        bool m_result = false;\n+\n+        Context& SetVersion(SigVersion v)\n+        {\n+            m_sig_version = v;\n+            return *this;\n+        }\n+\n+        Context& SetChecker(CHECKER_VALIDATION kind)\n+        {\n+            m_kind = kind;\n+            return *this;\n+        }\n+\n+        Context& SetRemainingWeight(int64_t w)\n+        {\n+            m_execdata.m_validation_weight_left = w;\n+            return *this;\n+        }\n+\n+        Context& AddFlags(uint32_t f)\n+        {\n+            m_flags |= f;\n+            return *this;\n+        }\n+\n+        CScript& SetScript()\n+        {\n+            return m_script;\n+        }\n+\n+        Context& DoTest(int64_t line)\n+        {\n+            SignatureCheckerMock checker_mock(m_kind);\n+            m_caller_line = line;\n+            m_result = EvalScript(m_stack, m_script,\n+                                  SCRIPT_VERIFY_TAPROOT | m_flags,\n+                                  checker_mock,\n+                                  m_sig_version,\n+                                  m_execdata,\n+                                  &m_err);\n+            m_sigchecker_was_called = checker_mock.CheckerWasCalled();\n+            return *this;\n+        }\n+\n+        Context& CheckCallSucceeded()\n+        {\n+            BOOST_CHECK_MESSAGE(m_result,\n+                                Descr()\n+                                    << \": EvalScript succeeded, as expected\");\n+            BOOST_CHECK_MESSAGE(m_err == SCRIPT_ERR_OK,\n+                                Descr()\n+                                    << \": Error code expected OK, actual was \"\n+                                    << ScriptErrorString(m_err));\n+            return *this;\n+        }\n+\n+        Context& CheckCallFailed(ScriptError expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!m_result,\n+                                Descr()\n+                                    << \": EvalScript failed, as expected\");\n+            BOOST_CHECK_MESSAGE(m_err == expected,\n+                                Descr()\n+                                    << \": Error code expected \" << ScriptErrorString(expected)\n+                                    << \", actual was \" << ScriptErrorString(m_err));\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(m_sigchecker_was_called,\n+                                Descr() << \": CheckSchnorrSignature was called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasNotValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(!m_sigchecker_was_called,\n+                                Descr() << \": CheckSchnorrSignature was not called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckRemainingValidationWeight(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(m_execdata.m_validation_weight_left == expected,\n+                                Descr()\n+                                    << \": Remaining validation weight expected \"\n+                                    << expected << \", actual was \"\n+                                    << m_execdata.m_validation_weight_left);\n+            return *this;\n+        }\n+\n+        Context& CheckStackDepth(std::size_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(m_stack.size() == expected,\n+                                Descr()\n+                                    << \": Stack depth expected \" << expected\n+                                    << \", actual was \" << m_stack.size());\n+            return *this;\n+        }\n+\n+        Context& CheckTOS(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!m_stack.empty(),\n+                                Descr()\n+                                    << \": Stack expected at least one item, actually was empty\");\n+            const int64_t actual = CScriptNum(m_stack.at(0), false).GetInt64();\n+            BOOST_CHECK_MESSAGE(expected == actual,\n+                                Descr()\n+                                    << \": Top-of-stack expected \" << expected\n+                                    << \", actual was \" << actual);\n+            return *this;\n+        }\n+\n+    private:\n+        std::string Descr()\n+        {\n+            std::string descr;\n+            descr.reserve(m_test_description.size() + 20);\n+            descr += m_test_description;\n+            descr += \" (@\";\n+            descr += as_string(m_caller_line);\n+            descr += \")\";\n+            return descr;\n+        }\n+    };\n+\n+    {\n+        Context ctx(\"SigVersion must not be BASE\");\n+        ctx.SetVersion(SigVersion::BASE).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"SigVersion must not be WITNESS_V0\");\n+        ctx.SetVersion(SigVersion::WITNESS_V0).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Minimum stack height 3 for OP_CHECKSIGADD\");\n+        ctx.SetScript()\n+            << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_INVALID_STACK_OPERATION)\n+            .CheckStackDepth(2);\n+    }\n+\n+    {\n+        Context ctx(\"`n` (2nd arg) size > 4 must fail\");\n+        // This is probably meant to be a check on the _encoding_ - that it is\n+        // minimal, but it can also be a check on the _value_.  BIP342 doesn't\n+        // say which.  Could be both...\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(10000000000LL) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            // (IMO this is an _unsatisfactory_ error code to return for a required\n+            // BIP342 check, but see the `catch` clause in `EvalScript`)\n+            .CheckCallFailed(SCRIPT_ERR_UNKNOWN_ERROR)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Insufficient validation weight remaining\");\n+        ctx.SetRemainingWeight(BIP342_SIGOPS_LIMIT - 1)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + 32byte pubkey skips validation\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + non32byte pubkey skips validation\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey ('unknown pubkey type') _with_ discourage flag fails\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .AddFlags(SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .CheckSignatureWasNotValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation failure forced\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_FAILS)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_SCHNORR_SIG)\n+            .CheckSignatureWasValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation success forced\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasValidated()\n+            .CheckRemainingValidationWeight(END_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM + 1);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey + empty sig with validation success forced\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_failure_cases)\n+{\n+    // As defined by BIP-341 Signature Validation Rules\n+    // Here we pick an acceptable SigVersion\n+    const SigVersion sigversion = SigVersion::TAPROOT;\n+\n+    CMutableTransaction tx_to_m;\n+    tx_to_m.vin.push_back(CTxIn());\n+    const uint32_t in_pos{0};\n+\n+    PrecomputedTransactionData cache;\n+    cache.m_bip341_taproot_ready = true;\n+    cache.m_spent_outputs_ready = true;\n+\n+    ScriptExecutionData execdata;\n+    execdata.m_annex_init = true;\n+    execdata.m_annex_present = false;\n+    execdata.m_annex_hash = uint256::ZERO;\n+    execdata.m_tapleaf_hash_init = false;\n+    execdata.m_codeseparator_pos_init = true;\n+\n+    uint256 hash_out{0};\n+\n+    {\n+        // Check all invalid hash_type codes rejected\n+        const std::set<uint8_t> allowable_hash_types{0x00, 0x01, 0x02, 0x03, 0x81, 0x82, 0x83};\n+        for (unsigned ht = 0; ht <= 255; ht++) {\n+            const uint8_t hash_type = static_cast<uint8_t>(ht);\n+            if (allowable_hash_types.find(hash_type) != allowable_hash_types.end()) continue;\n+\n+            BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m, in_pos,\n+                                                      hash_type, sigversion, cache,\n+                                                      MissingDataBehavior::FAIL),\n+                                \"hash_type = \" << Hex(hash_type) << \" expected to fail\");\n+        }\n+    }\n+\n+    {\n+        // Check that if hash_type == SIGHASH_SINGLE then missing a \"corresponding\n+        // output\" fails.\n+        CMutableTransaction tx_to_m;\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+\n+        uint8_t in_pos = 1;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(1) > #tx_to==0 is expected to fail\");\n+\n+        tx_to_m.vout.push_back(CTxOut());\n+        in_pos = 2;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(2) > #tx_to==1 is expected to fail\");\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_all_success_paths)\n+{\n+    // Our approach here will be to follow BIP-341's signature algorithm (with\n+    // the BIP-342 extension) doing two things at once:\n+    //   1) We'll set up the input arguments to `SignatureHashSchnorr` function\n+    //      being tested, _and_\n+    //   2) we'll _compute the hash of those fields ourselves_ exaxctly as\n+    //      it is described in BIP-341 and BIP-342.\n+    // Then we can compare the two.  We'll do this in a data-driven way for each\n+    // of the different scenarios that the algorithm supports.\n+    //\n+    // In this way this test achieves 100% _path_ coverage of `SignatureHashSchnorr`\n+    // (not just 100% _branch_ coverage).\n+    // - Sadly, this isn't shown in the `lcov` reports.  There are still a few\n+    //   red `-` marks left.  This is because:\n+    //   1. `lcov` wasn't designed to handle death tests.\n+    //   2. ??? Some other unknown reasons, possibly due to the instrumentation,\n+    //      possibly due to `lcov` limitations.  You can see by the test output\n+    //      (`-log_level=all`) or within a debugger that in fact _all_ branches\n+    //      are taken when executing all the tests in this file.\n+\n+    // Here we define, and then generate, all combinations of the alternatives\n+    // for the parameters that vary the signature combination algorithm\n+\n+    const vn_sequence<SigVersion> SigVersion_alternatives{\n+        {SigVersion::TAPROOT, \"TAPROOT\"sv},\n+        {SigVersion::TAPSCRIPT, \"TAPSCRIPT\"sv}};\n+\n+    const vn_sequence<uint32_t> hash_type_output_alternatives{\n+        {SIGHASH_DEFAULT, \"SIGHASH_DEFAULT\"sv},\n+        {SIGHASH_ALL, \"SIGHASH_ALL\"sv},\n+        {SIGHASH_NONE, \"SIGHASH_NONE\"sv},\n+        {SIGHASH_SINGLE, \"SIGHASH_SINGLE\"sv}};\n+\n+    const vn_sequence<uint32_t> hash_type_input_alternatives{\n+        {0, \"N/A\"sv},\n+        {SIGHASH_ANYONECANPAY, \"SIGHASH_ANYONECANPAY\"sv}};\n+\n+    const vn_sequence<uint8_t> annex_alternatives{\n+        {0, \"no annex\"sv},\n+        {1, \"annex present\"sv}};\n+\n+    const vn_sequence<bool> output_hash_alternatives{\n+        {false, \"output hash missing\"sv},\n+        {true, \"output hash provided\"sv}};\n+\n+    for (const auto& sigversion_alternative : SigVersion_alternatives)\n+        for (const auto& hash_type_output_alternative : hash_type_output_alternatives)\n+            for (const auto& hash_type_input_alternative : hash_type_input_alternatives)\n+                for (const auto& annex_alternative : annex_alternatives)\n+                    for (const auto& output_hash_alternative : output_hash_alternatives) {\n+                        // Exclude the invalid combination of SIGHASH_DEFAULT with SIGHASH_ANYONECANPAY\n+                        if (hash_type_output_alternative.m_value == SIGHASH_DEFAULT && hash_type_input_alternative.m_value == SIGHASH_ANYONECANPAY) continue;\n+\n+                        // We're going to want to know which scenario it is if a check actually\n+                        // fails ...\n+                        std::string scenario_description;\n+                        {\n+                            std::ostringstream oss;\n+                            oss << sigversion_alternative.m_name << \", \"\n+                                << hash_type_output_alternative.m_name << \", \"\n+                                << hash_type_input_alternative.m_name << \", \"\n+                                << annex_alternative.m_name << \", \"\n+                                << output_hash_alternative.m_name;\n+                            scenario_description = oss.str();\n+                        }\n+\n+                        // Set up the scenario we're running now - these 4 variables define the scenario\n+                        const SigVersion sigversion{sigversion_alternative.m_value};\n+                        const uint8_t hash_type{static_cast<uint8_t>(hash_type_output_alternative.m_value | hash_type_input_alternative.m_value)};\n+                        const uint8_t annex_present{annex_alternative.m_value};\n+                        const bool have_output_hash{output_hash_alternative.m_value};\n+\n+                        // Compute some helper values that depend on scenario\n+                        const uint8_t ext_flag{sigversion == SigVersion::TAPSCRIPT};\n+                        const uint8_t hash_input_type{static_cast<uint8_t>(hash_type & SIGHASH_INPUT_MASK)};\n+                        const uint8_t hash_output_type{static_cast<uint8_t>((hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK))};\n+                        const uint8_t spend_type = (ext_flag * 2) + annex_present;\n+\n+                        // Fixed values (by algorithm)\n+                        const uint8_t epoch{0x00};\n+                        const uint8_t key_version{0};\n+\n+                        // Mocked values fixed for purposes of this unit test.  This is a long\n+                        // list of crufty things but that's because `SignatureHashSchnorr`, the\n+                        // function being tested, takes as arguments not just the transaction\n+                        // being signed (plus control data) but also some _precomputed values_\n+                        // in two different structs: `PrecomputedTransactionData`, and\n+                        // `ScriptExecutionData`.  On the one hand this is nice because a lot\n+                        // of complexity of the signature algorithm doesn't have to be duplicated\n+                        // here in this test: we can just use mocked values.  On the other hand,\n+                        // there's a lot of icky setup to do to get all the values in the right\n+                        // places both for our \"by the book\" implementation and to be set up to\n+                        // call `SignatureHashSchnorr`.\n+                        //\n+                        // Try to make things simpler by at least using the same names for the\n+                        // setup variables as for the fields in the parameter structs.\n+\n+                        const uint32_t in_pos{1};\n+                        const int32_t tx_version{FillWithPattern(0x01).i32[0]};\n+                        const uint32_t tx_lock_time{FillWithPattern(0x05).u32[0]};\n+                        const uint256 prevouts_single_hash{FillWithPattern(0x10).u256};\n+                        const uint256 spent_amounts_single_hash{FillWithPattern(0x18).u256};\n+                        const uint256 spent_scripts_single_hash{FillWithPattern(0x20).u256};\n+                        const uint256 sequences_single_hash{FillWithPattern(0x28).u256};\n+                        const uint256 outputs_single_hash{FillWithPattern(0x30).u256};\n+                        const uint256 output_hash{FillWithPattern(0x40).u256};\n+                        const uint256 annex_hash{FillWithPattern(0x48).u256};\n+                        const uint256 tapleaf_hash{FillWithPattern(0x50).u256};\n+                        const uint32_t codeseparator_pos{FillWithPattern(0x58).u32[0]};\n+                        const COutPoint tx_input_at_pos_prevout{FillWithPattern(0x60).u256,\n+                                                                FillWithPattern(0x68).u32[0]};\n+                        const uint32_t tx_input_at_pos_nsequence{FillWithPattern(0x70).u32[0]};\n+                        CTxOut spent_output_at_pos;\n+                        spent_output_at_pos.nValue = FillWithPattern(0x80).u64();\n+                        spent_output_at_pos.scriptPubKey /*random script, not even valid*/\n+                            << OP_DUP << OP_HASH160 << OP_EQUALVERIFY << OP_CHECKSIG;\n+                        CTxOut tx_output_at_pos;\n+                        tx_output_at_pos.nValue = FillWithPattern(0x90).u64();\n+                        tx_output_at_pos.scriptPubKey /*random script, not even valid*/\n+                            << OP_CHECKSIG << OP_EQUALVERIFY << OP_HASH160 << OP_DUP;\n+\n+                        // Now set up the arguments that are going to be passed to\n+                        // `SignatureHashSchnorr`\n+\n+                        CMutableTransaction tx_to;\n+                        tx_to.nVersion = tx_version;\n+                        tx_to.nLockTime = tx_lock_time;\n+                        for (uint32_t i = 0; i < in_pos + 2; i++) {\n+                            tx_to.vin.push_back(CTxIn());\n+                            tx_to.vout.push_back(CTxOut());\n+                        }\n+                        tx_to.vin[in_pos].prevout = tx_input_at_pos_prevout;\n+                        tx_to.vin[in_pos].nSequence = tx_input_at_pos_nsequence;\n+                        tx_to.vout[in_pos] = tx_output_at_pos;\n+\n+                        PrecomputedTransactionData cache;\n+                        cache.m_bip341_taproot_ready = true;\n+                        cache.m_prevouts_single_hash = prevouts_single_hash;\n+                        cache.m_spent_amounts_single_hash = spent_amounts_single_hash;\n+                        cache.m_spent_scripts_single_hash = spent_scripts_single_hash;\n+                        cache.m_sequences_single_hash = sequences_single_hash;\n+                        cache.m_spent_outputs_ready = true;\n+                        for (uint32_t i = 0; i < in_pos + 2; i++) {\n+                            cache.m_spent_outputs.push_back(CTxOut());\n+                        }\n+                        cache.m_spent_outputs[in_pos] = spent_output_at_pos;\n+                        cache.m_outputs_single_hash = outputs_single_hash;\n+\n+                        ScriptExecutionData execdata;\n+                        execdata.m_annex_init = true;\n+                        execdata.m_annex_present = !!annex_present;\n+                        execdata.m_annex_hash = annex_hash;\n+                        execdata.m_output_hash.reset();\n+                        if (have_output_hash) {\n+                            execdata.m_output_hash = output_hash;\n+                        }\n+                        if (sigversion == SigVersion::TAPSCRIPT) {\n+                            execdata.m_tapleaf_hash_init = true;\n+                            execdata.m_tapleaf_hash = tapleaf_hash;\n+                            execdata.m_codeseparator_pos_init = true;\n+                            execdata.m_codeseparator_pos = codeseparator_pos;\n+                        }\n+\n+                        // Now here is where we take all that data - _not_ the arguments to\n+                        // `SignatureHashSchnorr` but all the scenario parameters, the helpers,\n+                        // the values fixed by the algorithm, and our mocked values, and actually\n+                        // follow the BIP-341/BIP-342 signature calculation algorithm right from\n+                        // the spec ...\n+\n+                        // Start with a tagged hasher with the correct tag\n+                        CHashWriter hasher = TaggedHash(\"TapSighash\");\n+\n+                        // First byte to hash is always the \"epoch\", 0x00 (BIP-341, footnote 20)\n+                        hasher << epoch;\n+\n+                        // Next: hash_type (1 byte)\n+                        hasher << hash_type;\n+\n+                        // Next: transaction version (4 bytes)\n+                        hasher << tx_version;\n+\n+                        // Next: transaction lock time (4 bytes)\n+                        hasher << tx_lock_time;\n+\n+                        // Next if _not_ SIGHASH_ANYONECANPAY:\n+                        // a) SHA256 of the serialization of all input outpoints (32 bytes)\n+                        // b) SHA256 of the serialization of all spent output amounts (32 bytes)\n+                        // c) SHA256 of the serialization of all spent outputs' _scriptPubKeys_\n+                        //    serialized as script (32 bytes)\n+                        // d) SHA256 of the serialization of all input `nSequence` (32 bytes)\n+                        if (hash_input_type != SIGHASH_ANYONECANPAY) {\n+                            hasher << prevouts_single_hash;\n+                            hasher << spent_amounts_single_hash;\n+                            hasher << spent_scripts_single_hash;\n+                            hasher << sequences_single_hash;\n+                        }\n+\n+                        // Next if _not_ SIGHASH_NONE _and not_ SIGHASH_SINGLE:\n+                        // SHA256 of the serialization of all outputs in CTxOut format (32 bytes)\n+                        if (hash_output_type != SIGHASH_NONE && hash_output_type != SIGHASH_SINGLE) {\n+                            hasher << outputs_single_hash;\n+                        }\n+\n+                        // Now, data about input/prevout being spent\n+\n+                        // The \"spend_type\" (1 byte) which is a function of ext_flag (above) and\n+                        // whether there is an annex present (here: no)\n+                        hasher << spend_type;\n+\n+                        // Here, if we are _not_ SIGHASH_ANYONECANPAY, we just add the index of\n+                        // the input in the transaction input vector (4 bytes). There must be a\n+                        // input transaction at this index but _in this scenario_ it doesn't have\n+                        // to have any data (it is never inspected).  Same for output transactions.\n+                        //\n+                        // On the other hand, if we _are_ SIGHASH_ANYONECANPAY, then we add the\n+                        // `COutPoint` of this input (36 bytes), the value of the previous\n+                        // output spent by this input (8 bytes), the `ScriptPubKey` of the\n+                        // previous output spent by this input (35 bytes), and the `nSequence`\n+                        // of this input.  These values are all precomputed and made available\n+                        // to `SignatureHashSchnorr` in the `PrecomputedTransactionData` struct.\n+                        if (hash_input_type == SIGHASH_ANYONECANPAY) {\n+                            hasher << tx_input_at_pos_prevout;\n+                            hasher << spent_output_at_pos.nValue;\n+                            hasher << spent_output_at_pos.scriptPubKey;\n+                            hasher << tx_input_at_pos_nsequence;\n+                        } else {\n+                            hasher << in_pos;\n+                        }\n+\n+                        // Now, if there is an \"annex\", add its hash (32 byte).  This is\n+                        // precomputed and we don't actually have to have an actual annex to\n+                        // pass in to `SignatureHashSchnorr`, nor do we have to hash it.\n+                        if (annex_present) {\n+                            hasher << annex_hash;\n+                        }\n+\n+                        // Here, iff the hash type is `SIGHASH_SINGLE`, add the hash of the\n+                        // corresponding transaction output (32 bytes).  The wrinkle here is that\n+                        // (for some reason) _sometimes_ this hash is precomputed, and _sometimes_\n+                        // it is _not_.  So `SignatureHashSchnorr` will either use it if it is\n+                        // provided or compute it from the corresponding output itself. (For our\n+                        // purposes in this test the output need not be valid - it just must be\n+                        // present.)\n+                        if (hash_output_type == SIGHASH_SINGLE) {\n+                            if (!have_output_hash) {\n+                                CHashWriter hasher2(SER_GETHASH, 0);\n+                                hasher2 << tx_output_at_pos;\n+                                hasher << hasher2.GetSHA256();\n+                            } else {\n+                                hasher << output_hash;\n+                            }\n+                        }\n+\n+                        // This is the TAPSCRIPT extension from BIP-342.  If the version is\n+                        // TAPSCRIPT then add the tapleaf hash (32 bytes), the key_version (1\n+                        // byte, fixed value of 0x00), and the \"opcode position of the last\n+                        // executed OP_CODESEPARATOR before the currently executed signature\n+                        // opcode\" (4 bytes).  The tapleaf hash and the code separator position\n+                        // are both precomputed values.\n+                        if (sigversion == SigVersion::TAPSCRIPT) {\n+                            hasher << tapleaf_hash;\n+                            hasher << key_version;\n+                            hasher << codeseparator_pos;\n+                        }\n+\n+                        // That's all that goes into the hasher for this signature\n+                        const uint256 expected_hash_out = hasher.GetSHA256();\n+\n+                        // Now, _finally_, we test the actual implemented algorithm under test:\n+                        uint256 actual_hash_out{0};\n+                        BOOST_TEST(SignatureHashSchnorr(actual_hash_out,\n+                                                        execdata, tx_to, in_pos,\n+                                                        hash_type, sigversion, cache,\n+                                                        MissingDataBehavior::FAIL),\n+                                   \"Scenario: \" << scenario_description);\n+                        BOOST_TEST(expected_hash_out == actual_hash_out,\n+                                   \"Scenario: \" << scenario_description\n+                                                << \" - expected \" << expected_hash_out.ToString()\n+                                                << \" == actual \" << actual_hash_out.ToString());\n+                    }\n+}\n+\n+namespace {\n+\n+// Valid Schnoor (pubkey, msg, signature) tuples (copied from `key_tests.cpp`)\n+\n+struct SchnorrTriplet {\n+    SchnorrTriplet(std::string pubkey, std::string sighash, std::string sig)\n+        : m_pubkey(ParseHex(pubkey)), m_sighash(uint256(ParseHex(sighash))), m_sig(ParseHex(sig)) {}\n+    valtype m_pubkey;\n+    uint256 m_sighash;\n+    valtype m_sig;\n+};\n+\n+static const std::vector<SchnorrTriplet> SCHNORR_TRIPLETS = {\n+    {\"F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9\", \"0000000000000000000000000000000000000000000000000000000000000000\", \"E907831F80848D1069A5371B402410364BDF1C5F8307B0084C55F1CE2DCA821525F66A4A85EA8B71E482A74F382D2CE5EBEEE8FDB2172F477DF4900D310536C0\"},\n+    {\"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659\", \"243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89\", \"6896BD60EEAE296DB48A229FF71DFE071BDE413E6D43F917DC8DCF8C78DE33418906D11AC976ABCCB20B091292BFF4EA897EFCB639EA871CFA95F6DE339E4B0A\"},\n+    {\"DD308AFEC5777E13121FA72B9CC1B7CC0139715309B086C960E18FD969774EB8\", \"7E2D58D8B3BCDF1ABADEC7829054F90DDA9805AAB56C77333024B9D0A508B75C\", \"5831AAEED7B44BB74E5EAB94BA9D4294C49BCF2A60728D8B4C200F50DD313C1BAB745879A5AD954A72C45A91C3A51D3C7ADEA98D82F8481E0E1E03674A6F3FB7\"},\n+    {\"25D1DFF95105F5253C4022F628A996AD3A0D95FBF21D468A1B33F8C160D8F517\", \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", \"7EB0509757E246F19449885651611CB965ECC1A187DD51B64FDA1EDC9637D5EC97582B9CB13DB3933705B32BA982AF5AF25FD78881EBB32771FC5922EFC66EA3\"},\n+    {\"D69C3509BB99E412E68B0FE8544E72837DFA30746D8BE2AA65975F29D22DC7B9\", \"4DF3C3F68FCC83B27E9D42C90431A72499F17875C81A599B566C9889B9696703\", \"00000000000000000000003B78CE563F89A0ED9414F5AA28AD0D96D6795F9C6376AFB1548AF603B3EB45C9F8207DEE1060CB71C04E80F593060B07D28308D7F4\"},\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(internal_test_validate_schnorr_testdata)\n+{\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(XOnlyPubKey(triplet.m_pubkey).VerifySchnorr(triplet.m_sighash, triplet.m_sig));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(verify_schnorr_signature)\n+{\n+    // Defeat, for test purposes, the protected access of\n+    // `GenericTransactionSignatureChecker::VerifySchnorrSignature`\n+    struct UnprotectedTransactionSignatureChecker : public MutableTransactionSignatureChecker {\n+        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;\n+        using MutableTransactionSignatureChecker::VerifySchnorrSignature;\n+    };\n+    UnprotectedTransactionSignatureChecker sut{nullptr, 0, {}, {}};\n+\n+    // Positive tests: triplets which verify\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(sut.VerifySchnorrSignature(triplet.m_sig,\n+                                              XOnlyPubKey{triplet.m_pubkey},\n+                                              triplet.m_sighash));\n+    }\n+\n+    // Negative tests: triplets which fail to verify (get these failing triplets\n+    // by modifying a valid triplet, one field at a time)\n+    auto diddle_front_byte = [](auto v) { v[0]++; return v; };\n+    auto& triplet = SCHNORR_TRIPLETS[0];\n+    BOOST_TEST(!sut.VerifySchnorrSignature(diddle_front_byte(triplet.m_sig),\n+                                           XOnlyPubKey{triplet.m_pubkey},\n+                                           triplet.m_sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.m_sig,\n+                                           XOnlyPubKey{diddle_front_byte(triplet.m_pubkey)},\n+                                           triplet.m_sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.m_sig,\n+                                           XOnlyPubKey{triplet.m_pubkey},\n+                                           uint256::ONE));\n+}\n+\n+BOOST_AUTO_TEST_CASE(check_schnorr_signature)\n+{\n+    // Provide, for test purposes, a subclass of `GenericTransactionsSignatureChecker`\n+    // that mocks `VerifySchnorrSignature` so we can more easily test\n+    // `CheckSchnorrSignature` without going to the trouble of having a valid\n+    // transaction (which is unnecessary for this _unit_ test.)\n+    struct MockVerifyingTransactionSignatureChecker : public MutableTransactionSignatureChecker {\n+        uint256 m_expected_sighash = []() {\n+            uint256 h{};\n+            // This is the known sighash of the Tx and input data we set up (precomputed)\n+            h.SetHex(\"f614d8ae6dcc49e2ca2ef1c03f93c7326189e5575d446e825e5a2700fb1cb83c\");\n+            return h;\n+        }();\n+\n+        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;\n+\n+        enum class if_as_expected_return { False,\n+                                           True };\n+        if_as_expected_return m_iae{if_as_expected_return::True};",
      "path": "src/test/script_tapscript_tests.cpp",
      "position": 899,
      "original_position": 899,
      "commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "original_commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "in_reply_to_id": null,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin/bitcoin/pull/25097/commits/eeefec343592c6de85048e3b055ba49755cfb072\r\n\r\nWhat's the rationale not just to make `m_iae` a bool?",
      "created_at": "2022-07-12T19:00:05Z",
      "updated_at": "2022-07-12T20:25:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r919308845",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/919308845"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 899,
      "original_line": 899,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/919316320",
      "pull_request_review_id": 1036328057,
      "id": 919316320,
      "node_id": "PRRC_kwDOABII5842y6dg",
      "diff_hunk": "@@ -0,0 +1,1711 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+// TODO: Don't know whether Taproot/Tapscript tests should be exercising\n+// `libconsensus` the way the tests in `script_tests` do\n+\n+#include <core_io.h>\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <script/script_error.h>\n+#include <span.h>\n+#include <test/util/boost_test_boosts.h>\n+#include <test/util/pretty_data.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/transaction_utils.h>\n+#include <test/util/vector.h>\n+#include <univalue.h>\n+#include <util/strencodings.h>\n+\n+#include <boost/test/execution_monitor.hpp>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <array>\n+#include <charconv>\n+#include <cstddef>\n+#include <iomanip>\n+#include <iterator>\n+#include <limits>\n+#include <ostream>\n+#include <set>\n+#include <stdexcept>\n+#include <string>\n+#include <string_view>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+using namespace std::literals::string_literals;\n+using namespace std::literals::string_view_literals;\n+using namespace test::util::literals;\n+\n+namespace {\n+\n+typedef std::vector<unsigned char> valtype;\n+\n+/**\n+ * Value/Name pair used in data-driven tests\n+ */\n+template <typename V>\n+struct vn_pair {\n+    vn_pair(V value, std::string_view name) : m_value(value), m_name(name) {}\n+\n+    const V m_value;\n+    const std::string_view m_name;\n+};\n+\n+/**\n+ * Sequence of value/name pairs used in data-driven tests\n+ */\n+template <typename V>\n+using vn_sequence = std::vector<vn_pair<V>>;\n+\n+/**\n+ * Invokes undefined behavior.  See `std::unreachable` in C++23.\n+ */\n+[[noreturn]] inline void declare_unreachable()\n+{\n+#ifdef _MSC_VER\n+    __assume(false);\n+#else\n+    // Assume all other compilers than MSVC implement this GCC builtin.\n+    __builtin_unreachable();\n+#endif\n+}\n+\n+/**\n+ * Representation changer to fill an integral type with a known pattern.\n+ *\n+ * Pattern is successive byte values given a starting point.  Endianness doesn't\n+ * matter.\n+ */\n+union FillWithPattern {\n+    uint256 u256{0};\n+    uint64_t u64raw[sizeof(uint256) / sizeof(uint64_t)];\n+    uint32_t u32[sizeof(uint256) / sizeof(uint32_t)];\n+    int32_t i32[sizeof(uint256) / sizeof(int32_t)];\n+    uint8_t u8[sizeof(uint256)];\n+\n+    constexpr FillWithPattern(uint8_t start)\n+    {\n+        for (auto it = std::begin(u8); it != std::end(u8); ++it) {\n+            *it = start++;\n+        }\n+    }\n+\n+    uint64_t u64() const\n+    {\n+        // It is desirable to force high bit off\n+        return u64raw[0] & static_cast<uint64_t>(std::numeric_limits<int64_t>::max());\n+    }\n+};\n+\n+/**\n+ * The two possible actions for our mock signature checker\n+ */\n+enum class CHECKER_VALIDATION { ALWAYS_SUCCEEDS,\n+                                ALWAYS_FAILS };\n+\n+/**\n+ * For these tests don't need _real_ signature/pubkey validation.  That is\n+ * tested elsewhere.  So we just _mock_ the signature checker and force it\n+ * to answer valid/invalid as we wish.\n+ */\n+class SignatureCheckerMock : public BaseSignatureChecker\n+{\n+    //! What kind of mock checker is this?\n+    CHECKER_VALIDATION m_kind = CHECKER_VALIDATION::ALWAYS_FAILS;\n+\n+    //! True _iff_ CheckSchnorrSignature was actually called\n+    mutable bool m_was_called = false;\n+\n+public:\n+    //! Whether this mock always validates, or always fails, the signature/pubkey check.\n+    explicit SignatureCheckerMock(CHECKER_VALIDATION kind) : m_kind(kind) {}\n+\n+    //! Mocks the actual checking of the validity of the Schnorr signature by always succeeding or always failing\n+    bool CheckSchnorrSignature(Span<const unsigned char> sig,\n+                               Span<const unsigned char> pubkey,\n+                               SigVersion sigversion,\n+                               ScriptExecutionData& execdata,\n+                               ScriptError* serror = nullptr) const override\n+    {\n+        m_was_called = true;\n+        switch (m_kind) {\n+        case CHECKER_VALIDATION::ALWAYS_SUCCEEDS:\n+            if (serror) *serror = SCRIPT_ERR_OK;\n+            return true;\n+\n+        case CHECKER_VALIDATION::ALWAYS_FAILS:\n+            if (serror) *serror = SCRIPT_ERR_SCHNORR_SIG;\n+            return false;\n+        }\n+        declare_unreachable();\n+    }\n+\n+    bool CheckerWasCalled() const\n+    {\n+        return m_was_called;\n+    }\n+};\n+\n+} // namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(script_tapscript_tests, BasicTestingSetup)\n+\n+/**\n+ * Testing EvalScript OP_CHECKSIGADD branch and EvalChecksigTapscript, both in\n+ * interpreter.cpp, against the BIP342 \"Rules for signature opcodes\".\n+ */\n+BOOST_AUTO_TEST_CASE(eval_checksigadd_basic_checks)\n+{\n+    const valtype SIG_64BYTES(64, 0); // N.B.: Must be () not {}!\n+    const valtype SIG_65BYTES(65, 0);\n+    const valtype SIG_EMPTY{};\n+\n+    const valtype PUBKEY_32BYTES(32, 0);\n+    const valtype PUBKEY_15BYTES(15, 0);\n+    const valtype PUBKEY_EMPTY{};\n+\n+    constexpr int64_t TEST_NUM = 10;\n+\n+    constexpr int64_t START_VALIDATION_WEIGHT{90};\n+    constexpr int64_t BIP342_SIGOPS_LIMIT{50};\n+    constexpr int64_t END_VALIDATION_WEIGHT{START_VALIDATION_WEIGHT - BIP342_SIGOPS_LIMIT};\n+\n+    /**\n+     * A fluent API for running these tests.\n+     *\n+     * (Easiest way to understand this class is to look at the actual tests\n+     * that follow in this function.)\n+     */\n+    struct Context {\n+        explicit Context(std::string_view descr) : m_test_description(descr)\n+        {\n+            m_execdata.m_validation_weight_left_init = true;\n+            m_execdata.m_validation_weight_left = START_VALIDATION_WEIGHT;\n+        }\n+\n+        std::string m_test_description;\n+        SigVersion m_sig_version = SigVersion::TAPSCRIPT;\n+        uint32_t m_flags = 0;\n+        CScript m_script;\n+        ScriptError m_err = SCRIPT_ERR_OK;\n+        std::vector<valtype> m_stack;\n+        ScriptExecutionData m_execdata;\n+        CHECKER_VALIDATION m_kind;\n+        bool m_sigchecker_was_called = false;\n+        int64_t m_caller_line = 0;\n+        bool m_result = false;\n+\n+        Context& SetVersion(SigVersion v)\n+        {\n+            m_sig_version = v;\n+            return *this;\n+        }\n+\n+        Context& SetChecker(CHECKER_VALIDATION kind)\n+        {\n+            m_kind = kind;\n+            return *this;\n+        }\n+\n+        Context& SetRemainingWeight(int64_t w)\n+        {\n+            m_execdata.m_validation_weight_left = w;\n+            return *this;\n+        }\n+\n+        Context& AddFlags(uint32_t f)\n+        {\n+            m_flags |= f;\n+            return *this;\n+        }\n+\n+        CScript& SetScript()\n+        {\n+            return m_script;\n+        }\n+\n+        Context& DoTest(int64_t line)\n+        {\n+            SignatureCheckerMock checker_mock(m_kind);\n+            m_caller_line = line;\n+            m_result = EvalScript(m_stack, m_script,\n+                                  SCRIPT_VERIFY_TAPROOT | m_flags,\n+                                  checker_mock,\n+                                  m_sig_version,\n+                                  m_execdata,\n+                                  &m_err);\n+            m_sigchecker_was_called = checker_mock.CheckerWasCalled();\n+            return *this;\n+        }\n+\n+        Context& CheckCallSucceeded()\n+        {\n+            BOOST_CHECK_MESSAGE(m_result,\n+                                Descr()\n+                                    << \": EvalScript succeeded, as expected\");\n+            BOOST_CHECK_MESSAGE(m_err == SCRIPT_ERR_OK,\n+                                Descr()\n+                                    << \": Error code expected OK, actual was \"\n+                                    << ScriptErrorString(m_err));\n+            return *this;\n+        }\n+\n+        Context& CheckCallFailed(ScriptError expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!m_result,\n+                                Descr()\n+                                    << \": EvalScript failed, as expected\");\n+            BOOST_CHECK_MESSAGE(m_err == expected,\n+                                Descr()\n+                                    << \": Error code expected \" << ScriptErrorString(expected)\n+                                    << \", actual was \" << ScriptErrorString(m_err));\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(m_sigchecker_was_called,\n+                                Descr() << \": CheckSchnorrSignature was called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasNotValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(!m_sigchecker_was_called,\n+                                Descr() << \": CheckSchnorrSignature was not called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckRemainingValidationWeight(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(m_execdata.m_validation_weight_left == expected,\n+                                Descr()\n+                                    << \": Remaining validation weight expected \"\n+                                    << expected << \", actual was \"\n+                                    << m_execdata.m_validation_weight_left);\n+            return *this;\n+        }\n+\n+        Context& CheckStackDepth(std::size_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(m_stack.size() == expected,\n+                                Descr()\n+                                    << \": Stack depth expected \" << expected\n+                                    << \", actual was \" << m_stack.size());\n+            return *this;\n+        }\n+\n+        Context& CheckTOS(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!m_stack.empty(),\n+                                Descr()\n+                                    << \": Stack expected at least one item, actually was empty\");\n+            const int64_t actual = CScriptNum(m_stack.at(0), false).GetInt64();\n+            BOOST_CHECK_MESSAGE(expected == actual,\n+                                Descr()\n+                                    << \": Top-of-stack expected \" << expected\n+                                    << \", actual was \" << actual);\n+            return *this;\n+        }\n+\n+    private:\n+        std::string Descr()\n+        {\n+            std::string descr;\n+            descr.reserve(m_test_description.size() + 20);\n+            descr += m_test_description;\n+            descr += \" (@\";\n+            descr += as_string(m_caller_line);\n+            descr += \")\";\n+            return descr;\n+        }\n+    };\n+\n+    {\n+        Context ctx(\"SigVersion must not be BASE\");\n+        ctx.SetVersion(SigVersion::BASE).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"SigVersion must not be WITNESS_V0\");\n+        ctx.SetVersion(SigVersion::WITNESS_V0).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Minimum stack height 3 for OP_CHECKSIGADD\");\n+        ctx.SetScript()\n+            << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_INVALID_STACK_OPERATION)\n+            .CheckStackDepth(2);\n+    }\n+\n+    {\n+        Context ctx(\"`n` (2nd arg) size > 4 must fail\");\n+        // This is probably meant to be a check on the _encoding_ - that it is\n+        // minimal, but it can also be a check on the _value_.  BIP342 doesn't\n+        // say which.  Could be both...\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(10000000000LL) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            // (IMO this is an _unsatisfactory_ error code to return for a required\n+            // BIP342 check, but see the `catch` clause in `EvalScript`)\n+            .CheckCallFailed(SCRIPT_ERR_UNKNOWN_ERROR)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Insufficient validation weight remaining\");\n+        ctx.SetRemainingWeight(BIP342_SIGOPS_LIMIT - 1)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + 32byte pubkey skips validation\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + non32byte pubkey skips validation\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey ('unknown pubkey type') _with_ discourage flag fails\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .AddFlags(SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .CheckSignatureWasNotValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation failure forced\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_FAILS)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_SCHNORR_SIG)\n+            .CheckSignatureWasValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation success forced\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasValidated()\n+            .CheckRemainingValidationWeight(END_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM + 1);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey + empty sig with validation success forced\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_failure_cases)\n+{\n+    // As defined by BIP-341 Signature Validation Rules\n+    // Here we pick an acceptable SigVersion\n+    const SigVersion sigversion = SigVersion::TAPROOT;\n+\n+    CMutableTransaction tx_to_m;\n+    tx_to_m.vin.push_back(CTxIn());\n+    const uint32_t in_pos{0};\n+\n+    PrecomputedTransactionData cache;\n+    cache.m_bip341_taproot_ready = true;\n+    cache.m_spent_outputs_ready = true;\n+\n+    ScriptExecutionData execdata;\n+    execdata.m_annex_init = true;\n+    execdata.m_annex_present = false;\n+    execdata.m_annex_hash = uint256::ZERO;\n+    execdata.m_tapleaf_hash_init = false;\n+    execdata.m_codeseparator_pos_init = true;\n+\n+    uint256 hash_out{0};\n+\n+    {\n+        // Check all invalid hash_type codes rejected\n+        const std::set<uint8_t> allowable_hash_types{0x00, 0x01, 0x02, 0x03, 0x81, 0x82, 0x83};\n+        for (unsigned ht = 0; ht <= 255; ht++) {\n+            const uint8_t hash_type = static_cast<uint8_t>(ht);\n+            if (allowable_hash_types.find(hash_type) != allowable_hash_types.end()) continue;\n+\n+            BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m, in_pos,\n+                                                      hash_type, sigversion, cache,\n+                                                      MissingDataBehavior::FAIL),\n+                                \"hash_type = \" << Hex(hash_type) << \" expected to fail\");\n+        }\n+    }\n+\n+    {\n+        // Check that if hash_type == SIGHASH_SINGLE then missing a \"corresponding\n+        // output\" fails.\n+        CMutableTransaction tx_to_m;\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+\n+        uint8_t in_pos = 1;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(1) > #tx_to==0 is expected to fail\");\n+\n+        tx_to_m.vout.push_back(CTxOut());\n+        in_pos = 2;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(2) > #tx_to==1 is expected to fail\");\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_all_success_paths)\n+{\n+    // Our approach here will be to follow BIP-341's signature algorithm (with\n+    // the BIP-342 extension) doing two things at once:\n+    //   1) We'll set up the input arguments to `SignatureHashSchnorr` function\n+    //      being tested, _and_\n+    //   2) we'll _compute the hash of those fields ourselves_ exaxctly as\n+    //      it is described in BIP-341 and BIP-342.\n+    // Then we can compare the two.  We'll do this in a data-driven way for each\n+    // of the different scenarios that the algorithm supports.\n+    //\n+    // In this way this test achieves 100% _path_ coverage of `SignatureHashSchnorr`\n+    // (not just 100% _branch_ coverage).\n+    // - Sadly, this isn't shown in the `lcov` reports.  There are still a few\n+    //   red `-` marks left.  This is because:\n+    //   1. `lcov` wasn't designed to handle death tests.\n+    //   2. ??? Some other unknown reasons, possibly due to the instrumentation,\n+    //      possibly due to `lcov` limitations.  You can see by the test output\n+    //      (`-log_level=all`) or within a debugger that in fact _all_ branches\n+    //      are taken when executing all the tests in this file.\n+\n+    // Here we define, and then generate, all combinations of the alternatives\n+    // for the parameters that vary the signature combination algorithm\n+\n+    const vn_sequence<SigVersion> SigVersion_alternatives{\n+        {SigVersion::TAPROOT, \"TAPROOT\"sv},\n+        {SigVersion::TAPSCRIPT, \"TAPSCRIPT\"sv}};\n+\n+    const vn_sequence<uint32_t> hash_type_output_alternatives{\n+        {SIGHASH_DEFAULT, \"SIGHASH_DEFAULT\"sv},\n+        {SIGHASH_ALL, \"SIGHASH_ALL\"sv},\n+        {SIGHASH_NONE, \"SIGHASH_NONE\"sv},\n+        {SIGHASH_SINGLE, \"SIGHASH_SINGLE\"sv}};\n+\n+    const vn_sequence<uint32_t> hash_type_input_alternatives{\n+        {0, \"N/A\"sv},\n+        {SIGHASH_ANYONECANPAY, \"SIGHASH_ANYONECANPAY\"sv}};\n+\n+    const vn_sequence<uint8_t> annex_alternatives{\n+        {0, \"no annex\"sv},\n+        {1, \"annex present\"sv}};\n+\n+    const vn_sequence<bool> output_hash_alternatives{\n+        {false, \"output hash missing\"sv},\n+        {true, \"output hash provided\"sv}};\n+\n+    for (const auto& sigversion_alternative : SigVersion_alternatives)\n+        for (const auto& hash_type_output_alternative : hash_type_output_alternatives)\n+            for (const auto& hash_type_input_alternative : hash_type_input_alternatives)\n+                for (const auto& annex_alternative : annex_alternatives)\n+                    for (const auto& output_hash_alternative : output_hash_alternatives) {\n+                        // Exclude the invalid combination of SIGHASH_DEFAULT with SIGHASH_ANYONECANPAY\n+                        if (hash_type_output_alternative.m_value == SIGHASH_DEFAULT && hash_type_input_alternative.m_value == SIGHASH_ANYONECANPAY) continue;\n+\n+                        // We're going to want to know which scenario it is if a check actually\n+                        // fails ...\n+                        std::string scenario_description;\n+                        {\n+                            std::ostringstream oss;\n+                            oss << sigversion_alternative.m_name << \", \"\n+                                << hash_type_output_alternative.m_name << \", \"\n+                                << hash_type_input_alternative.m_name << \", \"\n+                                << annex_alternative.m_name << \", \"\n+                                << output_hash_alternative.m_name;\n+                            scenario_description = oss.str();\n+                        }\n+\n+                        // Set up the scenario we're running now - these 4 variables define the scenario\n+                        const SigVersion sigversion{sigversion_alternative.m_value};\n+                        const uint8_t hash_type{static_cast<uint8_t>(hash_type_output_alternative.m_value | hash_type_input_alternative.m_value)};\n+                        const uint8_t annex_present{annex_alternative.m_value};\n+                        const bool have_output_hash{output_hash_alternative.m_value};\n+\n+                        // Compute some helper values that depend on scenario\n+                        const uint8_t ext_flag{sigversion == SigVersion::TAPSCRIPT};\n+                        const uint8_t hash_input_type{static_cast<uint8_t>(hash_type & SIGHASH_INPUT_MASK)};\n+                        const uint8_t hash_output_type{static_cast<uint8_t>((hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK))};\n+                        const uint8_t spend_type = (ext_flag * 2) + annex_present;\n+\n+                        // Fixed values (by algorithm)\n+                        const uint8_t epoch{0x00};\n+                        const uint8_t key_version{0};\n+\n+                        // Mocked values fixed for purposes of this unit test.  This is a long\n+                        // list of crufty things but that's because `SignatureHashSchnorr`, the\n+                        // function being tested, takes as arguments not just the transaction\n+                        // being signed (plus control data) but also some _precomputed values_\n+                        // in two different structs: `PrecomputedTransactionData`, and\n+                        // `ScriptExecutionData`.  On the one hand this is nice because a lot\n+                        // of complexity of the signature algorithm doesn't have to be duplicated\n+                        // here in this test: we can just use mocked values.  On the other hand,\n+                        // there's a lot of icky setup to do to get all the values in the right\n+                        // places both for our \"by the book\" implementation and to be set up to\n+                        // call `SignatureHashSchnorr`.\n+                        //\n+                        // Try to make things simpler by at least using the same names for the\n+                        // setup variables as for the fields in the parameter structs.\n+\n+                        const uint32_t in_pos{1};\n+                        const int32_t tx_version{FillWithPattern(0x01).i32[0]};\n+                        const uint32_t tx_lock_time{FillWithPattern(0x05).u32[0]};\n+                        const uint256 prevouts_single_hash{FillWithPattern(0x10).u256};\n+                        const uint256 spent_amounts_single_hash{FillWithPattern(0x18).u256};\n+                        const uint256 spent_scripts_single_hash{FillWithPattern(0x20).u256};\n+                        const uint256 sequences_single_hash{FillWithPattern(0x28).u256};\n+                        const uint256 outputs_single_hash{FillWithPattern(0x30).u256};\n+                        const uint256 output_hash{FillWithPattern(0x40).u256};\n+                        const uint256 annex_hash{FillWithPattern(0x48).u256};\n+                        const uint256 tapleaf_hash{FillWithPattern(0x50).u256};\n+                        const uint32_t codeseparator_pos{FillWithPattern(0x58).u32[0]};\n+                        const COutPoint tx_input_at_pos_prevout{FillWithPattern(0x60).u256,\n+                                                                FillWithPattern(0x68).u32[0]};\n+                        const uint32_t tx_input_at_pos_nsequence{FillWithPattern(0x70).u32[0]};\n+                        CTxOut spent_output_at_pos;\n+                        spent_output_at_pos.nValue = FillWithPattern(0x80).u64();\n+                        spent_output_at_pos.scriptPubKey /*random script, not even valid*/\n+                            << OP_DUP << OP_HASH160 << OP_EQUALVERIFY << OP_CHECKSIG;\n+                        CTxOut tx_output_at_pos;\n+                        tx_output_at_pos.nValue = FillWithPattern(0x90).u64();\n+                        tx_output_at_pos.scriptPubKey /*random script, not even valid*/\n+                            << OP_CHECKSIG << OP_EQUALVERIFY << OP_HASH160 << OP_DUP;\n+\n+                        // Now set up the arguments that are going to be passed to\n+                        // `SignatureHashSchnorr`\n+\n+                        CMutableTransaction tx_to;\n+                        tx_to.nVersion = tx_version;\n+                        tx_to.nLockTime = tx_lock_time;\n+                        for (uint32_t i = 0; i < in_pos + 2; i++) {\n+                            tx_to.vin.push_back(CTxIn());\n+                            tx_to.vout.push_back(CTxOut());\n+                        }\n+                        tx_to.vin[in_pos].prevout = tx_input_at_pos_prevout;\n+                        tx_to.vin[in_pos].nSequence = tx_input_at_pos_nsequence;\n+                        tx_to.vout[in_pos] = tx_output_at_pos;\n+\n+                        PrecomputedTransactionData cache;\n+                        cache.m_bip341_taproot_ready = true;\n+                        cache.m_prevouts_single_hash = prevouts_single_hash;\n+                        cache.m_spent_amounts_single_hash = spent_amounts_single_hash;\n+                        cache.m_spent_scripts_single_hash = spent_scripts_single_hash;\n+                        cache.m_sequences_single_hash = sequences_single_hash;\n+                        cache.m_spent_outputs_ready = true;\n+                        for (uint32_t i = 0; i < in_pos + 2; i++) {\n+                            cache.m_spent_outputs.push_back(CTxOut());\n+                        }\n+                        cache.m_spent_outputs[in_pos] = spent_output_at_pos;\n+                        cache.m_outputs_single_hash = outputs_single_hash;\n+\n+                        ScriptExecutionData execdata;\n+                        execdata.m_annex_init = true;\n+                        execdata.m_annex_present = !!annex_present;\n+                        execdata.m_annex_hash = annex_hash;\n+                        execdata.m_output_hash.reset();\n+                        if (have_output_hash) {\n+                            execdata.m_output_hash = output_hash;\n+                        }\n+                        if (sigversion == SigVersion::TAPSCRIPT) {\n+                            execdata.m_tapleaf_hash_init = true;\n+                            execdata.m_tapleaf_hash = tapleaf_hash;\n+                            execdata.m_codeseparator_pos_init = true;\n+                            execdata.m_codeseparator_pos = codeseparator_pos;\n+                        }\n+\n+                        // Now here is where we take all that data - _not_ the arguments to\n+                        // `SignatureHashSchnorr` but all the scenario parameters, the helpers,\n+                        // the values fixed by the algorithm, and our mocked values, and actually\n+                        // follow the BIP-341/BIP-342 signature calculation algorithm right from\n+                        // the spec ...\n+\n+                        // Start with a tagged hasher with the correct tag\n+                        CHashWriter hasher = TaggedHash(\"TapSighash\");\n+\n+                        // First byte to hash is always the \"epoch\", 0x00 (BIP-341, footnote 20)\n+                        hasher << epoch;\n+\n+                        // Next: hash_type (1 byte)\n+                        hasher << hash_type;\n+\n+                        // Next: transaction version (4 bytes)\n+                        hasher << tx_version;\n+\n+                        // Next: transaction lock time (4 bytes)\n+                        hasher << tx_lock_time;\n+\n+                        // Next if _not_ SIGHASH_ANYONECANPAY:\n+                        // a) SHA256 of the serialization of all input outpoints (32 bytes)\n+                        // b) SHA256 of the serialization of all spent output amounts (32 bytes)\n+                        // c) SHA256 of the serialization of all spent outputs' _scriptPubKeys_\n+                        //    serialized as script (32 bytes)\n+                        // d) SHA256 of the serialization of all input `nSequence` (32 bytes)\n+                        if (hash_input_type != SIGHASH_ANYONECANPAY) {\n+                            hasher << prevouts_single_hash;\n+                            hasher << spent_amounts_single_hash;\n+                            hasher << spent_scripts_single_hash;\n+                            hasher << sequences_single_hash;\n+                        }\n+\n+                        // Next if _not_ SIGHASH_NONE _and not_ SIGHASH_SINGLE:\n+                        // SHA256 of the serialization of all outputs in CTxOut format (32 bytes)\n+                        if (hash_output_type != SIGHASH_NONE && hash_output_type != SIGHASH_SINGLE) {\n+                            hasher << outputs_single_hash;\n+                        }\n+\n+                        // Now, data about input/prevout being spent\n+\n+                        // The \"spend_type\" (1 byte) which is a function of ext_flag (above) and\n+                        // whether there is an annex present (here: no)\n+                        hasher << spend_type;\n+\n+                        // Here, if we are _not_ SIGHASH_ANYONECANPAY, we just add the index of\n+                        // the input in the transaction input vector (4 bytes). There must be a\n+                        // input transaction at this index but _in this scenario_ it doesn't have\n+                        // to have any data (it is never inspected).  Same for output transactions.\n+                        //\n+                        // On the other hand, if we _are_ SIGHASH_ANYONECANPAY, then we add the\n+                        // `COutPoint` of this input (36 bytes), the value of the previous\n+                        // output spent by this input (8 bytes), the `ScriptPubKey` of the\n+                        // previous output spent by this input (35 bytes), and the `nSequence`\n+                        // of this input.  These values are all precomputed and made available\n+                        // to `SignatureHashSchnorr` in the `PrecomputedTransactionData` struct.\n+                        if (hash_input_type == SIGHASH_ANYONECANPAY) {\n+                            hasher << tx_input_at_pos_prevout;\n+                            hasher << spent_output_at_pos.nValue;\n+                            hasher << spent_output_at_pos.scriptPubKey;\n+                            hasher << tx_input_at_pos_nsequence;\n+                        } else {\n+                            hasher << in_pos;\n+                        }\n+\n+                        // Now, if there is an \"annex\", add its hash (32 byte).  This is\n+                        // precomputed and we don't actually have to have an actual annex to\n+                        // pass in to `SignatureHashSchnorr`, nor do we have to hash it.\n+                        if (annex_present) {\n+                            hasher << annex_hash;\n+                        }\n+\n+                        // Here, iff the hash type is `SIGHASH_SINGLE`, add the hash of the\n+                        // corresponding transaction output (32 bytes).  The wrinkle here is that\n+                        // (for some reason) _sometimes_ this hash is precomputed, and _sometimes_\n+                        // it is _not_.  So `SignatureHashSchnorr` will either use it if it is\n+                        // provided or compute it from the corresponding output itself. (For our\n+                        // purposes in this test the output need not be valid - it just must be\n+                        // present.)\n+                        if (hash_output_type == SIGHASH_SINGLE) {\n+                            if (!have_output_hash) {\n+                                CHashWriter hasher2(SER_GETHASH, 0);\n+                                hasher2 << tx_output_at_pos;\n+                                hasher << hasher2.GetSHA256();\n+                            } else {\n+                                hasher << output_hash;\n+                            }\n+                        }\n+\n+                        // This is the TAPSCRIPT extension from BIP-342.  If the version is\n+                        // TAPSCRIPT then add the tapleaf hash (32 bytes), the key_version (1\n+                        // byte, fixed value of 0x00), and the \"opcode position of the last\n+                        // executed OP_CODESEPARATOR before the currently executed signature\n+                        // opcode\" (4 bytes).  The tapleaf hash and the code separator position\n+                        // are both precomputed values.\n+                        if (sigversion == SigVersion::TAPSCRIPT) {\n+                            hasher << tapleaf_hash;\n+                            hasher << key_version;\n+                            hasher << codeseparator_pos;\n+                        }\n+\n+                        // That's all that goes into the hasher for this signature\n+                        const uint256 expected_hash_out = hasher.GetSHA256();\n+\n+                        // Now, _finally_, we test the actual implemented algorithm under test:\n+                        uint256 actual_hash_out{0};\n+                        BOOST_TEST(SignatureHashSchnorr(actual_hash_out,\n+                                                        execdata, tx_to, in_pos,\n+                                                        hash_type, sigversion, cache,\n+                                                        MissingDataBehavior::FAIL),\n+                                   \"Scenario: \" << scenario_description);\n+                        BOOST_TEST(expected_hash_out == actual_hash_out,\n+                                   \"Scenario: \" << scenario_description\n+                                                << \" - expected \" << expected_hash_out.ToString()\n+                                                << \" == actual \" << actual_hash_out.ToString());\n+                    }\n+}\n+\n+namespace {\n+\n+// Valid Schnoor (pubkey, msg, signature) tuples (copied from `key_tests.cpp`)\n+\n+struct SchnorrTriplet {\n+    SchnorrTriplet(std::string pubkey, std::string sighash, std::string sig)\n+        : m_pubkey(ParseHex(pubkey)), m_sighash(uint256(ParseHex(sighash))), m_sig(ParseHex(sig)) {}\n+    valtype m_pubkey;\n+    uint256 m_sighash;\n+    valtype m_sig;\n+};\n+\n+static const std::vector<SchnorrTriplet> SCHNORR_TRIPLETS = {\n+    {\"F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9\", \"0000000000000000000000000000000000000000000000000000000000000000\", \"E907831F80848D1069A5371B402410364BDF1C5F8307B0084C55F1CE2DCA821525F66A4A85EA8B71E482A74F382D2CE5EBEEE8FDB2172F477DF4900D310536C0\"},\n+    {\"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659\", \"243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89\", \"6896BD60EEAE296DB48A229FF71DFE071BDE413E6D43F917DC8DCF8C78DE33418906D11AC976ABCCB20B091292BFF4EA897EFCB639EA871CFA95F6DE339E4B0A\"},\n+    {\"DD308AFEC5777E13121FA72B9CC1B7CC0139715309B086C960E18FD969774EB8\", \"7E2D58D8B3BCDF1ABADEC7829054F90DDA9805AAB56C77333024B9D0A508B75C\", \"5831AAEED7B44BB74E5EAB94BA9D4294C49BCF2A60728D8B4C200F50DD313C1BAB745879A5AD954A72C45A91C3A51D3C7ADEA98D82F8481E0E1E03674A6F3FB7\"},\n+    {\"25D1DFF95105F5253C4022F628A996AD3A0D95FBF21D468A1B33F8C160D8F517\", \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", \"7EB0509757E246F19449885651611CB965ECC1A187DD51B64FDA1EDC9637D5EC97582B9CB13DB3933705B32BA982AF5AF25FD78881EBB32771FC5922EFC66EA3\"},\n+    {\"D69C3509BB99E412E68B0FE8544E72837DFA30746D8BE2AA65975F29D22DC7B9\", \"4DF3C3F68FCC83B27E9D42C90431A72499F17875C81A599B566C9889B9696703\", \"00000000000000000000003B78CE563F89A0ED9414F5AA28AD0D96D6795F9C6376AFB1548AF603B3EB45C9F8207DEE1060CB71C04E80F593060B07D28308D7F4\"},\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(internal_test_validate_schnorr_testdata)\n+{\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(XOnlyPubKey(triplet.m_pubkey).VerifySchnorr(triplet.m_sighash, triplet.m_sig));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(verify_schnorr_signature)\n+{\n+    // Defeat, for test purposes, the protected access of\n+    // `GenericTransactionSignatureChecker::VerifySchnorrSignature`\n+    struct UnprotectedTransactionSignatureChecker : public MutableTransactionSignatureChecker {\n+        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;\n+        using MutableTransactionSignatureChecker::VerifySchnorrSignature;\n+    };\n+    UnprotectedTransactionSignatureChecker sut{nullptr, 0, {}, {}};\n+\n+    // Positive tests: triplets which verify\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(sut.VerifySchnorrSignature(triplet.m_sig,\n+                                              XOnlyPubKey{triplet.m_pubkey},\n+                                              triplet.m_sighash));\n+    }\n+\n+    // Negative tests: triplets which fail to verify (get these failing triplets\n+    // by modifying a valid triplet, one field at a time)\n+    auto diddle_front_byte = [](auto v) { v[0]++; return v; };\n+    auto& triplet = SCHNORR_TRIPLETS[0];\n+    BOOST_TEST(!sut.VerifySchnorrSignature(diddle_front_byte(triplet.m_sig),\n+                                           XOnlyPubKey{triplet.m_pubkey},\n+                                           triplet.m_sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.m_sig,\n+                                           XOnlyPubKey{diddle_front_byte(triplet.m_pubkey)},\n+                                           triplet.m_sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.m_sig,\n+                                           XOnlyPubKey{triplet.m_pubkey},\n+                                           uint256::ONE));\n+}\n+\n+BOOST_AUTO_TEST_CASE(check_schnorr_signature)\n+{\n+    // Provide, for test purposes, a subclass of `GenericTransactionsSignatureChecker`\n+    // that mocks `VerifySchnorrSignature` so we can more easily test\n+    // `CheckSchnorrSignature` without going to the trouble of having a valid\n+    // transaction (which is unnecessary for this _unit_ test.)\n+    struct MockVerifyingTransactionSignatureChecker : public MutableTransactionSignatureChecker {\n+        uint256 m_expected_sighash = []() {\n+            uint256 h{};\n+            // This is the known sighash of the Tx and input data we set up (precomputed)\n+            h.SetHex(\"f614d8ae6dcc49e2ca2ef1c03f93c7326189e5575d446e825e5a2700fb1cb83c\");\n+            return h;\n+        }();\n+\n+        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;\n+\n+        enum class if_as_expected_return { False,\n+                                           True };\n+        if_as_expected_return m_iae{if_as_expected_return::True};\n+        void SetExpectation(if_as_expected_return iaer) { m_iae = iaer; }\n+\n+        bool VerifySchnorrSignature(Span<const unsigned char> sig,\n+                                    const XOnlyPubKey& pubkey,\n+                                    const uint256& sighash) const override\n+        {\n+            // Following line used only to determine the known canned `expected_sighash` above:\n+            // BOOST_TEST_MESSAGE(\"MockVerifySchnorrSignature: sighash == \" << sighash.ToString());\n+\n+            bool as_expected = sighash == m_expected_sighash;\n+            if (m_iae == if_as_expected_return::True)\n+                return as_expected;\n+            else\n+                return !as_expected;\n+        };\n+    };\n+\n+    const auto triplet = SCHNORR_TRIPLETS[0];\n+    const CMutableTransaction txToIn{};\n+    ScriptExecutionData execdata{};\n+\n+    {\n+        // Signature must be 64 or 65 bytes long\n+        for (size_t i = 0; i <= 99; i++) {\n+            valtype testsig(i, i);\n+            if (testsig.size() == 64 || testsig.size() == 65) continue;\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_SIZE);\n+        }\n+    }\n+\n+    {\n+        // Iff signature is 65 bytes long last byte must **NOT** be SIGHASH_DEFAULT (0x00) per BIP-342\n+        {\n+            // Negative test: last byte _is_ SIGHASH_DEFAULT\n+            valtype testsig(65, 65);\n+            testsig.back() = SIGHASH_DEFAULT;\n+\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);\n+        }\n+        {\n+            // Negative tests: last byte is _not_ SIGHASH_DEFAULT, but we early exit _without changing\n+            // serror_ because we don't provide a txDataIn (🡄 this requires knowledge of how",
      "path": "src/test/script_tapscript_tests.cpp",
      "position": 947,
      "original_position": 947,
      "commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "original_commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "in_reply_to_id": null,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin/bitcoin/pull/25097/commits/eeefec343592c6de85048e3b055ba49755cfb072\r\n\r\nIsn't \"txDataIn\" actually called `txdata` on the original class? (https://github.com/jamesob/bitcoin/blob/eeefec343592c6de85048e3b055ba49755cfb072/src/script/interpreter.h#L289)",
      "created_at": "2022-07-12T19:10:19Z",
      "updated_at": "2022-07-12T20:25:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r919316320",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/919316320"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 947,
      "original_line": 947,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/919317189",
      "pull_request_review_id": 1036328057,
      "id": 919317189,
      "node_id": "PRRC_kwDOABII5842y6rF",
      "diff_hunk": "@@ -0,0 +1,1711 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+// TODO: Don't know whether Taproot/Tapscript tests should be exercising\n+// `libconsensus` the way the tests in `script_tests` do\n+\n+#include <core_io.h>\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <script/script_error.h>\n+#include <span.h>\n+#include <test/util/boost_test_boosts.h>\n+#include <test/util/pretty_data.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/transaction_utils.h>\n+#include <test/util/vector.h>\n+#include <univalue.h>\n+#include <util/strencodings.h>\n+\n+#include <boost/test/execution_monitor.hpp>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <array>\n+#include <charconv>\n+#include <cstddef>\n+#include <iomanip>\n+#include <iterator>\n+#include <limits>\n+#include <ostream>\n+#include <set>\n+#include <stdexcept>\n+#include <string>\n+#include <string_view>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+using namespace std::literals::string_literals;\n+using namespace std::literals::string_view_literals;\n+using namespace test::util::literals;\n+\n+namespace {\n+\n+typedef std::vector<unsigned char> valtype;\n+\n+/**\n+ * Value/Name pair used in data-driven tests\n+ */\n+template <typename V>\n+struct vn_pair {\n+    vn_pair(V value, std::string_view name) : m_value(value), m_name(name) {}\n+\n+    const V m_value;\n+    const std::string_view m_name;\n+};\n+\n+/**\n+ * Sequence of value/name pairs used in data-driven tests\n+ */\n+template <typename V>\n+using vn_sequence = std::vector<vn_pair<V>>;\n+\n+/**\n+ * Invokes undefined behavior.  See `std::unreachable` in C++23.\n+ */\n+[[noreturn]] inline void declare_unreachable()\n+{\n+#ifdef _MSC_VER\n+    __assume(false);\n+#else\n+    // Assume all other compilers than MSVC implement this GCC builtin.\n+    __builtin_unreachable();\n+#endif\n+}\n+\n+/**\n+ * Representation changer to fill an integral type with a known pattern.\n+ *\n+ * Pattern is successive byte values given a starting point.  Endianness doesn't\n+ * matter.\n+ */\n+union FillWithPattern {\n+    uint256 u256{0};\n+    uint64_t u64raw[sizeof(uint256) / sizeof(uint64_t)];\n+    uint32_t u32[sizeof(uint256) / sizeof(uint32_t)];\n+    int32_t i32[sizeof(uint256) / sizeof(int32_t)];\n+    uint8_t u8[sizeof(uint256)];\n+\n+    constexpr FillWithPattern(uint8_t start)\n+    {\n+        for (auto it = std::begin(u8); it != std::end(u8); ++it) {\n+            *it = start++;\n+        }\n+    }\n+\n+    uint64_t u64() const\n+    {\n+        // It is desirable to force high bit off\n+        return u64raw[0] & static_cast<uint64_t>(std::numeric_limits<int64_t>::max());\n+    }\n+};\n+\n+/**\n+ * The two possible actions for our mock signature checker\n+ */\n+enum class CHECKER_VALIDATION { ALWAYS_SUCCEEDS,\n+                                ALWAYS_FAILS };\n+\n+/**\n+ * For these tests don't need _real_ signature/pubkey validation.  That is\n+ * tested elsewhere.  So we just _mock_ the signature checker and force it\n+ * to answer valid/invalid as we wish.\n+ */\n+class SignatureCheckerMock : public BaseSignatureChecker\n+{\n+    //! What kind of mock checker is this?\n+    CHECKER_VALIDATION m_kind = CHECKER_VALIDATION::ALWAYS_FAILS;\n+\n+    //! True _iff_ CheckSchnorrSignature was actually called\n+    mutable bool m_was_called = false;\n+\n+public:\n+    //! Whether this mock always validates, or always fails, the signature/pubkey check.\n+    explicit SignatureCheckerMock(CHECKER_VALIDATION kind) : m_kind(kind) {}\n+\n+    //! Mocks the actual checking of the validity of the Schnorr signature by always succeeding or always failing\n+    bool CheckSchnorrSignature(Span<const unsigned char> sig,\n+                               Span<const unsigned char> pubkey,\n+                               SigVersion sigversion,\n+                               ScriptExecutionData& execdata,\n+                               ScriptError* serror = nullptr) const override\n+    {\n+        m_was_called = true;\n+        switch (m_kind) {\n+        case CHECKER_VALIDATION::ALWAYS_SUCCEEDS:\n+            if (serror) *serror = SCRIPT_ERR_OK;\n+            return true;\n+\n+        case CHECKER_VALIDATION::ALWAYS_FAILS:\n+            if (serror) *serror = SCRIPT_ERR_SCHNORR_SIG;\n+            return false;\n+        }\n+        declare_unreachable();\n+    }\n+\n+    bool CheckerWasCalled() const\n+    {\n+        return m_was_called;\n+    }\n+};\n+\n+} // namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(script_tapscript_tests, BasicTestingSetup)\n+\n+/**\n+ * Testing EvalScript OP_CHECKSIGADD branch and EvalChecksigTapscript, both in\n+ * interpreter.cpp, against the BIP342 \"Rules for signature opcodes\".\n+ */\n+BOOST_AUTO_TEST_CASE(eval_checksigadd_basic_checks)\n+{\n+    const valtype SIG_64BYTES(64, 0); // N.B.: Must be () not {}!\n+    const valtype SIG_65BYTES(65, 0);\n+    const valtype SIG_EMPTY{};\n+\n+    const valtype PUBKEY_32BYTES(32, 0);\n+    const valtype PUBKEY_15BYTES(15, 0);\n+    const valtype PUBKEY_EMPTY{};\n+\n+    constexpr int64_t TEST_NUM = 10;\n+\n+    constexpr int64_t START_VALIDATION_WEIGHT{90};\n+    constexpr int64_t BIP342_SIGOPS_LIMIT{50};\n+    constexpr int64_t END_VALIDATION_WEIGHT{START_VALIDATION_WEIGHT - BIP342_SIGOPS_LIMIT};\n+\n+    /**\n+     * A fluent API for running these tests.\n+     *\n+     * (Easiest way to understand this class is to look at the actual tests\n+     * that follow in this function.)\n+     */\n+    struct Context {\n+        explicit Context(std::string_view descr) : m_test_description(descr)\n+        {\n+            m_execdata.m_validation_weight_left_init = true;\n+            m_execdata.m_validation_weight_left = START_VALIDATION_WEIGHT;\n+        }\n+\n+        std::string m_test_description;\n+        SigVersion m_sig_version = SigVersion::TAPSCRIPT;\n+        uint32_t m_flags = 0;\n+        CScript m_script;\n+        ScriptError m_err = SCRIPT_ERR_OK;\n+        std::vector<valtype> m_stack;\n+        ScriptExecutionData m_execdata;\n+        CHECKER_VALIDATION m_kind;\n+        bool m_sigchecker_was_called = false;\n+        int64_t m_caller_line = 0;\n+        bool m_result = false;\n+\n+        Context& SetVersion(SigVersion v)\n+        {\n+            m_sig_version = v;\n+            return *this;\n+        }\n+\n+        Context& SetChecker(CHECKER_VALIDATION kind)\n+        {\n+            m_kind = kind;\n+            return *this;\n+        }\n+\n+        Context& SetRemainingWeight(int64_t w)\n+        {\n+            m_execdata.m_validation_weight_left = w;\n+            return *this;\n+        }\n+\n+        Context& AddFlags(uint32_t f)\n+        {\n+            m_flags |= f;\n+            return *this;\n+        }\n+\n+        CScript& SetScript()\n+        {\n+            return m_script;\n+        }\n+\n+        Context& DoTest(int64_t line)\n+        {\n+            SignatureCheckerMock checker_mock(m_kind);\n+            m_caller_line = line;\n+            m_result = EvalScript(m_stack, m_script,\n+                                  SCRIPT_VERIFY_TAPROOT | m_flags,\n+                                  checker_mock,\n+                                  m_sig_version,\n+                                  m_execdata,\n+                                  &m_err);\n+            m_sigchecker_was_called = checker_mock.CheckerWasCalled();\n+            return *this;\n+        }\n+\n+        Context& CheckCallSucceeded()\n+        {\n+            BOOST_CHECK_MESSAGE(m_result,\n+                                Descr()\n+                                    << \": EvalScript succeeded, as expected\");\n+            BOOST_CHECK_MESSAGE(m_err == SCRIPT_ERR_OK,\n+                                Descr()\n+                                    << \": Error code expected OK, actual was \"\n+                                    << ScriptErrorString(m_err));\n+            return *this;\n+        }\n+\n+        Context& CheckCallFailed(ScriptError expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!m_result,\n+                                Descr()\n+                                    << \": EvalScript failed, as expected\");\n+            BOOST_CHECK_MESSAGE(m_err == expected,\n+                                Descr()\n+                                    << \": Error code expected \" << ScriptErrorString(expected)\n+                                    << \", actual was \" << ScriptErrorString(m_err));\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(m_sigchecker_was_called,\n+                                Descr() << \": CheckSchnorrSignature was called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasNotValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(!m_sigchecker_was_called,\n+                                Descr() << \": CheckSchnorrSignature was not called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckRemainingValidationWeight(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(m_execdata.m_validation_weight_left == expected,\n+                                Descr()\n+                                    << \": Remaining validation weight expected \"\n+                                    << expected << \", actual was \"\n+                                    << m_execdata.m_validation_weight_left);\n+            return *this;\n+        }\n+\n+        Context& CheckStackDepth(std::size_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(m_stack.size() == expected,\n+                                Descr()\n+                                    << \": Stack depth expected \" << expected\n+                                    << \", actual was \" << m_stack.size());\n+            return *this;\n+        }\n+\n+        Context& CheckTOS(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!m_stack.empty(),\n+                                Descr()\n+                                    << \": Stack expected at least one item, actually was empty\");\n+            const int64_t actual = CScriptNum(m_stack.at(0), false).GetInt64();\n+            BOOST_CHECK_MESSAGE(expected == actual,\n+                                Descr()\n+                                    << \": Top-of-stack expected \" << expected\n+                                    << \", actual was \" << actual);\n+            return *this;\n+        }\n+\n+    private:\n+        std::string Descr()\n+        {\n+            std::string descr;\n+            descr.reserve(m_test_description.size() + 20);\n+            descr += m_test_description;\n+            descr += \" (@\";\n+            descr += as_string(m_caller_line);\n+            descr += \")\";\n+            return descr;\n+        }\n+    };\n+\n+    {\n+        Context ctx(\"SigVersion must not be BASE\");\n+        ctx.SetVersion(SigVersion::BASE).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"SigVersion must not be WITNESS_V0\");\n+        ctx.SetVersion(SigVersion::WITNESS_V0).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Minimum stack height 3 for OP_CHECKSIGADD\");\n+        ctx.SetScript()\n+            << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_INVALID_STACK_OPERATION)\n+            .CheckStackDepth(2);\n+    }\n+\n+    {\n+        Context ctx(\"`n` (2nd arg) size > 4 must fail\");\n+        // This is probably meant to be a check on the _encoding_ - that it is\n+        // minimal, but it can also be a check on the _value_.  BIP342 doesn't\n+        // say which.  Could be both...\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(10000000000LL) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            // (IMO this is an _unsatisfactory_ error code to return for a required\n+            // BIP342 check, but see the `catch` clause in `EvalScript`)\n+            .CheckCallFailed(SCRIPT_ERR_UNKNOWN_ERROR)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Insufficient validation weight remaining\");\n+        ctx.SetRemainingWeight(BIP342_SIGOPS_LIMIT - 1)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + 32byte pubkey skips validation\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + non32byte pubkey skips validation\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey ('unknown pubkey type') _with_ discourage flag fails\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .AddFlags(SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .CheckSignatureWasNotValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation failure forced\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_FAILS)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_SCHNORR_SIG)\n+            .CheckSignatureWasValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation success forced\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasValidated()\n+            .CheckRemainingValidationWeight(END_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM + 1);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey + empty sig with validation success forced\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_failure_cases)\n+{\n+    // As defined by BIP-341 Signature Validation Rules\n+    // Here we pick an acceptable SigVersion\n+    const SigVersion sigversion = SigVersion::TAPROOT;\n+\n+    CMutableTransaction tx_to_m;\n+    tx_to_m.vin.push_back(CTxIn());\n+    const uint32_t in_pos{0};\n+\n+    PrecomputedTransactionData cache;\n+    cache.m_bip341_taproot_ready = true;\n+    cache.m_spent_outputs_ready = true;\n+\n+    ScriptExecutionData execdata;\n+    execdata.m_annex_init = true;\n+    execdata.m_annex_present = false;\n+    execdata.m_annex_hash = uint256::ZERO;\n+    execdata.m_tapleaf_hash_init = false;\n+    execdata.m_codeseparator_pos_init = true;\n+\n+    uint256 hash_out{0};\n+\n+    {\n+        // Check all invalid hash_type codes rejected\n+        const std::set<uint8_t> allowable_hash_types{0x00, 0x01, 0x02, 0x03, 0x81, 0x82, 0x83};\n+        for (unsigned ht = 0; ht <= 255; ht++) {\n+            const uint8_t hash_type = static_cast<uint8_t>(ht);\n+            if (allowable_hash_types.find(hash_type) != allowable_hash_types.end()) continue;\n+\n+            BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m, in_pos,\n+                                                      hash_type, sigversion, cache,\n+                                                      MissingDataBehavior::FAIL),\n+                                \"hash_type = \" << Hex(hash_type) << \" expected to fail\");\n+        }\n+    }\n+\n+    {\n+        // Check that if hash_type == SIGHASH_SINGLE then missing a \"corresponding\n+        // output\" fails.\n+        CMutableTransaction tx_to_m;\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+\n+        uint8_t in_pos = 1;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(1) > #tx_to==0 is expected to fail\");\n+\n+        tx_to_m.vout.push_back(CTxOut());\n+        in_pos = 2;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(2) > #tx_to==1 is expected to fail\");\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_all_success_paths)\n+{\n+    // Our approach here will be to follow BIP-341's signature algorithm (with\n+    // the BIP-342 extension) doing two things at once:\n+    //   1) We'll set up the input arguments to `SignatureHashSchnorr` function\n+    //      being tested, _and_\n+    //   2) we'll _compute the hash of those fields ourselves_ exaxctly as\n+    //      it is described in BIP-341 and BIP-342.\n+    // Then we can compare the two.  We'll do this in a data-driven way for each\n+    // of the different scenarios that the algorithm supports.\n+    //\n+    // In this way this test achieves 100% _path_ coverage of `SignatureHashSchnorr`\n+    // (not just 100% _branch_ coverage).\n+    // - Sadly, this isn't shown in the `lcov` reports.  There are still a few\n+    //   red `-` marks left.  This is because:\n+    //   1. `lcov` wasn't designed to handle death tests.\n+    //   2. ??? Some other unknown reasons, possibly due to the instrumentation,\n+    //      possibly due to `lcov` limitations.  You can see by the test output\n+    //      (`-log_level=all`) or within a debugger that in fact _all_ branches\n+    //      are taken when executing all the tests in this file.\n+\n+    // Here we define, and then generate, all combinations of the alternatives\n+    // for the parameters that vary the signature combination algorithm\n+\n+    const vn_sequence<SigVersion> SigVersion_alternatives{\n+        {SigVersion::TAPROOT, \"TAPROOT\"sv},\n+        {SigVersion::TAPSCRIPT, \"TAPSCRIPT\"sv}};\n+\n+    const vn_sequence<uint32_t> hash_type_output_alternatives{\n+        {SIGHASH_DEFAULT, \"SIGHASH_DEFAULT\"sv},\n+        {SIGHASH_ALL, \"SIGHASH_ALL\"sv},\n+        {SIGHASH_NONE, \"SIGHASH_NONE\"sv},\n+        {SIGHASH_SINGLE, \"SIGHASH_SINGLE\"sv}};\n+\n+    const vn_sequence<uint32_t> hash_type_input_alternatives{\n+        {0, \"N/A\"sv},\n+        {SIGHASH_ANYONECANPAY, \"SIGHASH_ANYONECANPAY\"sv}};\n+\n+    const vn_sequence<uint8_t> annex_alternatives{\n+        {0, \"no annex\"sv},\n+        {1, \"annex present\"sv}};\n+\n+    const vn_sequence<bool> output_hash_alternatives{\n+        {false, \"output hash missing\"sv},\n+        {true, \"output hash provided\"sv}};\n+\n+    for (const auto& sigversion_alternative : SigVersion_alternatives)\n+        for (const auto& hash_type_output_alternative : hash_type_output_alternatives)\n+            for (const auto& hash_type_input_alternative : hash_type_input_alternatives)\n+                for (const auto& annex_alternative : annex_alternatives)\n+                    for (const auto& output_hash_alternative : output_hash_alternatives) {\n+                        // Exclude the invalid combination of SIGHASH_DEFAULT with SIGHASH_ANYONECANPAY\n+                        if (hash_type_output_alternative.m_value == SIGHASH_DEFAULT && hash_type_input_alternative.m_value == SIGHASH_ANYONECANPAY) continue;\n+\n+                        // We're going to want to know which scenario it is if a check actually\n+                        // fails ...\n+                        std::string scenario_description;\n+                        {\n+                            std::ostringstream oss;\n+                            oss << sigversion_alternative.m_name << \", \"\n+                                << hash_type_output_alternative.m_name << \", \"\n+                                << hash_type_input_alternative.m_name << \", \"\n+                                << annex_alternative.m_name << \", \"\n+                                << output_hash_alternative.m_name;\n+                            scenario_description = oss.str();\n+                        }\n+\n+                        // Set up the scenario we're running now - these 4 variables define the scenario\n+                        const SigVersion sigversion{sigversion_alternative.m_value};\n+                        const uint8_t hash_type{static_cast<uint8_t>(hash_type_output_alternative.m_value | hash_type_input_alternative.m_value)};\n+                        const uint8_t annex_present{annex_alternative.m_value};\n+                        const bool have_output_hash{output_hash_alternative.m_value};\n+\n+                        // Compute some helper values that depend on scenario\n+                        const uint8_t ext_flag{sigversion == SigVersion::TAPSCRIPT};\n+                        const uint8_t hash_input_type{static_cast<uint8_t>(hash_type & SIGHASH_INPUT_MASK)};\n+                        const uint8_t hash_output_type{static_cast<uint8_t>((hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK))};\n+                        const uint8_t spend_type = (ext_flag * 2) + annex_present;\n+\n+                        // Fixed values (by algorithm)\n+                        const uint8_t epoch{0x00};\n+                        const uint8_t key_version{0};\n+\n+                        // Mocked values fixed for purposes of this unit test.  This is a long\n+                        // list of crufty things but that's because `SignatureHashSchnorr`, the\n+                        // function being tested, takes as arguments not just the transaction\n+                        // being signed (plus control data) but also some _precomputed values_\n+                        // in two different structs: `PrecomputedTransactionData`, and\n+                        // `ScriptExecutionData`.  On the one hand this is nice because a lot\n+                        // of complexity of the signature algorithm doesn't have to be duplicated\n+                        // here in this test: we can just use mocked values.  On the other hand,\n+                        // there's a lot of icky setup to do to get all the values in the right\n+                        // places both for our \"by the book\" implementation and to be set up to\n+                        // call `SignatureHashSchnorr`.\n+                        //\n+                        // Try to make things simpler by at least using the same names for the\n+                        // setup variables as for the fields in the parameter structs.\n+\n+                        const uint32_t in_pos{1};\n+                        const int32_t tx_version{FillWithPattern(0x01).i32[0]};\n+                        const uint32_t tx_lock_time{FillWithPattern(0x05).u32[0]};\n+                        const uint256 prevouts_single_hash{FillWithPattern(0x10).u256};\n+                        const uint256 spent_amounts_single_hash{FillWithPattern(0x18).u256};\n+                        const uint256 spent_scripts_single_hash{FillWithPattern(0x20).u256};\n+                        const uint256 sequences_single_hash{FillWithPattern(0x28).u256};\n+                        const uint256 outputs_single_hash{FillWithPattern(0x30).u256};\n+                        const uint256 output_hash{FillWithPattern(0x40).u256};\n+                        const uint256 annex_hash{FillWithPattern(0x48).u256};\n+                        const uint256 tapleaf_hash{FillWithPattern(0x50).u256};\n+                        const uint32_t codeseparator_pos{FillWithPattern(0x58).u32[0]};\n+                        const COutPoint tx_input_at_pos_prevout{FillWithPattern(0x60).u256,\n+                                                                FillWithPattern(0x68).u32[0]};\n+                        const uint32_t tx_input_at_pos_nsequence{FillWithPattern(0x70).u32[0]};\n+                        CTxOut spent_output_at_pos;\n+                        spent_output_at_pos.nValue = FillWithPattern(0x80).u64();\n+                        spent_output_at_pos.scriptPubKey /*random script, not even valid*/\n+                            << OP_DUP << OP_HASH160 << OP_EQUALVERIFY << OP_CHECKSIG;\n+                        CTxOut tx_output_at_pos;\n+                        tx_output_at_pos.nValue = FillWithPattern(0x90).u64();\n+                        tx_output_at_pos.scriptPubKey /*random script, not even valid*/\n+                            << OP_CHECKSIG << OP_EQUALVERIFY << OP_HASH160 << OP_DUP;\n+\n+                        // Now set up the arguments that are going to be passed to\n+                        // `SignatureHashSchnorr`\n+\n+                        CMutableTransaction tx_to;\n+                        tx_to.nVersion = tx_version;\n+                        tx_to.nLockTime = tx_lock_time;\n+                        for (uint32_t i = 0; i < in_pos + 2; i++) {\n+                            tx_to.vin.push_back(CTxIn());\n+                            tx_to.vout.push_back(CTxOut());\n+                        }\n+                        tx_to.vin[in_pos].prevout = tx_input_at_pos_prevout;\n+                        tx_to.vin[in_pos].nSequence = tx_input_at_pos_nsequence;\n+                        tx_to.vout[in_pos] = tx_output_at_pos;\n+\n+                        PrecomputedTransactionData cache;\n+                        cache.m_bip341_taproot_ready = true;\n+                        cache.m_prevouts_single_hash = prevouts_single_hash;\n+                        cache.m_spent_amounts_single_hash = spent_amounts_single_hash;\n+                        cache.m_spent_scripts_single_hash = spent_scripts_single_hash;\n+                        cache.m_sequences_single_hash = sequences_single_hash;\n+                        cache.m_spent_outputs_ready = true;\n+                        for (uint32_t i = 0; i < in_pos + 2; i++) {\n+                            cache.m_spent_outputs.push_back(CTxOut());\n+                        }\n+                        cache.m_spent_outputs[in_pos] = spent_output_at_pos;\n+                        cache.m_outputs_single_hash = outputs_single_hash;\n+\n+                        ScriptExecutionData execdata;\n+                        execdata.m_annex_init = true;\n+                        execdata.m_annex_present = !!annex_present;\n+                        execdata.m_annex_hash = annex_hash;\n+                        execdata.m_output_hash.reset();\n+                        if (have_output_hash) {\n+                            execdata.m_output_hash = output_hash;\n+                        }\n+                        if (sigversion == SigVersion::TAPSCRIPT) {\n+                            execdata.m_tapleaf_hash_init = true;\n+                            execdata.m_tapleaf_hash = tapleaf_hash;\n+                            execdata.m_codeseparator_pos_init = true;\n+                            execdata.m_codeseparator_pos = codeseparator_pos;\n+                        }\n+\n+                        // Now here is where we take all that data - _not_ the arguments to\n+                        // `SignatureHashSchnorr` but all the scenario parameters, the helpers,\n+                        // the values fixed by the algorithm, and our mocked values, and actually\n+                        // follow the BIP-341/BIP-342 signature calculation algorithm right from\n+                        // the spec ...\n+\n+                        // Start with a tagged hasher with the correct tag\n+                        CHashWriter hasher = TaggedHash(\"TapSighash\");\n+\n+                        // First byte to hash is always the \"epoch\", 0x00 (BIP-341, footnote 20)\n+                        hasher << epoch;\n+\n+                        // Next: hash_type (1 byte)\n+                        hasher << hash_type;\n+\n+                        // Next: transaction version (4 bytes)\n+                        hasher << tx_version;\n+\n+                        // Next: transaction lock time (4 bytes)\n+                        hasher << tx_lock_time;\n+\n+                        // Next if _not_ SIGHASH_ANYONECANPAY:\n+                        // a) SHA256 of the serialization of all input outpoints (32 bytes)\n+                        // b) SHA256 of the serialization of all spent output amounts (32 bytes)\n+                        // c) SHA256 of the serialization of all spent outputs' _scriptPubKeys_\n+                        //    serialized as script (32 bytes)\n+                        // d) SHA256 of the serialization of all input `nSequence` (32 bytes)\n+                        if (hash_input_type != SIGHASH_ANYONECANPAY) {\n+                            hasher << prevouts_single_hash;\n+                            hasher << spent_amounts_single_hash;\n+                            hasher << spent_scripts_single_hash;\n+                            hasher << sequences_single_hash;\n+                        }\n+\n+                        // Next if _not_ SIGHASH_NONE _and not_ SIGHASH_SINGLE:\n+                        // SHA256 of the serialization of all outputs in CTxOut format (32 bytes)\n+                        if (hash_output_type != SIGHASH_NONE && hash_output_type != SIGHASH_SINGLE) {\n+                            hasher << outputs_single_hash;\n+                        }\n+\n+                        // Now, data about input/prevout being spent\n+\n+                        // The \"spend_type\" (1 byte) which is a function of ext_flag (above) and\n+                        // whether there is an annex present (here: no)\n+                        hasher << spend_type;\n+\n+                        // Here, if we are _not_ SIGHASH_ANYONECANPAY, we just add the index of\n+                        // the input in the transaction input vector (4 bytes). There must be a\n+                        // input transaction at this index but _in this scenario_ it doesn't have\n+                        // to have any data (it is never inspected).  Same for output transactions.\n+                        //\n+                        // On the other hand, if we _are_ SIGHASH_ANYONECANPAY, then we add the\n+                        // `COutPoint` of this input (36 bytes), the value of the previous\n+                        // output spent by this input (8 bytes), the `ScriptPubKey` of the\n+                        // previous output spent by this input (35 bytes), and the `nSequence`\n+                        // of this input.  These values are all precomputed and made available\n+                        // to `SignatureHashSchnorr` in the `PrecomputedTransactionData` struct.\n+                        if (hash_input_type == SIGHASH_ANYONECANPAY) {\n+                            hasher << tx_input_at_pos_prevout;\n+                            hasher << spent_output_at_pos.nValue;\n+                            hasher << spent_output_at_pos.scriptPubKey;\n+                            hasher << tx_input_at_pos_nsequence;\n+                        } else {\n+                            hasher << in_pos;\n+                        }\n+\n+                        // Now, if there is an \"annex\", add its hash (32 byte).  This is\n+                        // precomputed and we don't actually have to have an actual annex to\n+                        // pass in to `SignatureHashSchnorr`, nor do we have to hash it.\n+                        if (annex_present) {\n+                            hasher << annex_hash;\n+                        }\n+\n+                        // Here, iff the hash type is `SIGHASH_SINGLE`, add the hash of the\n+                        // corresponding transaction output (32 bytes).  The wrinkle here is that\n+                        // (for some reason) _sometimes_ this hash is precomputed, and _sometimes_\n+                        // it is _not_.  So `SignatureHashSchnorr` will either use it if it is\n+                        // provided or compute it from the corresponding output itself. (For our\n+                        // purposes in this test the output need not be valid - it just must be\n+                        // present.)\n+                        if (hash_output_type == SIGHASH_SINGLE) {\n+                            if (!have_output_hash) {\n+                                CHashWriter hasher2(SER_GETHASH, 0);\n+                                hasher2 << tx_output_at_pos;\n+                                hasher << hasher2.GetSHA256();\n+                            } else {\n+                                hasher << output_hash;\n+                            }\n+                        }\n+\n+                        // This is the TAPSCRIPT extension from BIP-342.  If the version is\n+                        // TAPSCRIPT then add the tapleaf hash (32 bytes), the key_version (1\n+                        // byte, fixed value of 0x00), and the \"opcode position of the last\n+                        // executed OP_CODESEPARATOR before the currently executed signature\n+                        // opcode\" (4 bytes).  The tapleaf hash and the code separator position\n+                        // are both precomputed values.\n+                        if (sigversion == SigVersion::TAPSCRIPT) {\n+                            hasher << tapleaf_hash;\n+                            hasher << key_version;\n+                            hasher << codeseparator_pos;\n+                        }\n+\n+                        // That's all that goes into the hasher for this signature\n+                        const uint256 expected_hash_out = hasher.GetSHA256();\n+\n+                        // Now, _finally_, we test the actual implemented algorithm under test:\n+                        uint256 actual_hash_out{0};\n+                        BOOST_TEST(SignatureHashSchnorr(actual_hash_out,\n+                                                        execdata, tx_to, in_pos,\n+                                                        hash_type, sigversion, cache,\n+                                                        MissingDataBehavior::FAIL),\n+                                   \"Scenario: \" << scenario_description);\n+                        BOOST_TEST(expected_hash_out == actual_hash_out,\n+                                   \"Scenario: \" << scenario_description\n+                                                << \" - expected \" << expected_hash_out.ToString()\n+                                                << \" == actual \" << actual_hash_out.ToString());\n+                    }\n+}\n+\n+namespace {\n+\n+// Valid Schnoor (pubkey, msg, signature) tuples (copied from `key_tests.cpp`)\n+\n+struct SchnorrTriplet {\n+    SchnorrTriplet(std::string pubkey, std::string sighash, std::string sig)\n+        : m_pubkey(ParseHex(pubkey)), m_sighash(uint256(ParseHex(sighash))), m_sig(ParseHex(sig)) {}\n+    valtype m_pubkey;\n+    uint256 m_sighash;\n+    valtype m_sig;\n+};\n+\n+static const std::vector<SchnorrTriplet> SCHNORR_TRIPLETS = {\n+    {\"F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9\", \"0000000000000000000000000000000000000000000000000000000000000000\", \"E907831F80848D1069A5371B402410364BDF1C5F8307B0084C55F1CE2DCA821525F66A4A85EA8B71E482A74F382D2CE5EBEEE8FDB2172F477DF4900D310536C0\"},\n+    {\"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659\", \"243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89\", \"6896BD60EEAE296DB48A229FF71DFE071BDE413E6D43F917DC8DCF8C78DE33418906D11AC976ABCCB20B091292BFF4EA897EFCB639EA871CFA95F6DE339E4B0A\"},\n+    {\"DD308AFEC5777E13121FA72B9CC1B7CC0139715309B086C960E18FD969774EB8\", \"7E2D58D8B3BCDF1ABADEC7829054F90DDA9805AAB56C77333024B9D0A508B75C\", \"5831AAEED7B44BB74E5EAB94BA9D4294C49BCF2A60728D8B4C200F50DD313C1BAB745879A5AD954A72C45A91C3A51D3C7ADEA98D82F8481E0E1E03674A6F3FB7\"},\n+    {\"25D1DFF95105F5253C4022F628A996AD3A0D95FBF21D468A1B33F8C160D8F517\", \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", \"7EB0509757E246F19449885651611CB965ECC1A187DD51B64FDA1EDC9637D5EC97582B9CB13DB3933705B32BA982AF5AF25FD78881EBB32771FC5922EFC66EA3\"},\n+    {\"D69C3509BB99E412E68B0FE8544E72837DFA30746D8BE2AA65975F29D22DC7B9\", \"4DF3C3F68FCC83B27E9D42C90431A72499F17875C81A599B566C9889B9696703\", \"00000000000000000000003B78CE563F89A0ED9414F5AA28AD0D96D6795F9C6376AFB1548AF603B3EB45C9F8207DEE1060CB71C04E80F593060B07D28308D7F4\"},\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(internal_test_validate_schnorr_testdata)\n+{\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(XOnlyPubKey(triplet.m_pubkey).VerifySchnorr(triplet.m_sighash, triplet.m_sig));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(verify_schnorr_signature)\n+{\n+    // Defeat, for test purposes, the protected access of\n+    // `GenericTransactionSignatureChecker::VerifySchnorrSignature`\n+    struct UnprotectedTransactionSignatureChecker : public MutableTransactionSignatureChecker {\n+        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;\n+        using MutableTransactionSignatureChecker::VerifySchnorrSignature;\n+    };\n+    UnprotectedTransactionSignatureChecker sut{nullptr, 0, {}, {}};\n+\n+    // Positive tests: triplets which verify\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(sut.VerifySchnorrSignature(triplet.m_sig,\n+                                              XOnlyPubKey{triplet.m_pubkey},\n+                                              triplet.m_sighash));\n+    }\n+\n+    // Negative tests: triplets which fail to verify (get these failing triplets\n+    // by modifying a valid triplet, one field at a time)\n+    auto diddle_front_byte = [](auto v) { v[0]++; return v; };\n+    auto& triplet = SCHNORR_TRIPLETS[0];\n+    BOOST_TEST(!sut.VerifySchnorrSignature(diddle_front_byte(triplet.m_sig),\n+                                           XOnlyPubKey{triplet.m_pubkey},\n+                                           triplet.m_sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.m_sig,\n+                                           XOnlyPubKey{diddle_front_byte(triplet.m_pubkey)},\n+                                           triplet.m_sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.m_sig,\n+                                           XOnlyPubKey{triplet.m_pubkey},\n+                                           uint256::ONE));\n+}\n+\n+BOOST_AUTO_TEST_CASE(check_schnorr_signature)\n+{\n+    // Provide, for test purposes, a subclass of `GenericTransactionsSignatureChecker`\n+    // that mocks `VerifySchnorrSignature` so we can more easily test\n+    // `CheckSchnorrSignature` without going to the trouble of having a valid\n+    // transaction (which is unnecessary for this _unit_ test.)\n+    struct MockVerifyingTransactionSignatureChecker : public MutableTransactionSignatureChecker {\n+        uint256 m_expected_sighash = []() {\n+            uint256 h{};\n+            // This is the known sighash of the Tx and input data we set up (precomputed)\n+            h.SetHex(\"f614d8ae6dcc49e2ca2ef1c03f93c7326189e5575d446e825e5a2700fb1cb83c\");\n+            return h;\n+        }();\n+\n+        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;\n+\n+        enum class if_as_expected_return { False,\n+                                           True };\n+        if_as_expected_return m_iae{if_as_expected_return::True};\n+        void SetExpectation(if_as_expected_return iaer) { m_iae = iaer; }\n+\n+        bool VerifySchnorrSignature(Span<const unsigned char> sig,\n+                                    const XOnlyPubKey& pubkey,\n+                                    const uint256& sighash) const override\n+        {\n+            // Following line used only to determine the known canned `expected_sighash` above:\n+            // BOOST_TEST_MESSAGE(\"MockVerifySchnorrSignature: sighash == \" << sighash.ToString());\n+\n+            bool as_expected = sighash == m_expected_sighash;\n+            if (m_iae == if_as_expected_return::True)\n+                return as_expected;\n+            else\n+                return !as_expected;\n+        };\n+    };\n+\n+    const auto triplet = SCHNORR_TRIPLETS[0];\n+    const CMutableTransaction txToIn{};\n+    ScriptExecutionData execdata{};\n+\n+    {\n+        // Signature must be 64 or 65 bytes long\n+        for (size_t i = 0; i <= 99; i++) {\n+            valtype testsig(i, i);\n+            if (testsig.size() == 64 || testsig.size() == 65) continue;\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_SIZE);\n+        }\n+    }\n+\n+    {\n+        // Iff signature is 65 bytes long last byte must **NOT** be SIGHASH_DEFAULT (0x00) per BIP-342\n+        {\n+            // Negative test: last byte _is_ SIGHASH_DEFAULT\n+            valtype testsig(65, 65);\n+            testsig.back() = SIGHASH_DEFAULT;\n+\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);\n+        }\n+        {\n+            // Negative tests: last byte is _not_ SIGHASH_DEFAULT, but we early exit _without changing\n+            // serror_ because we don't provide a txDataIn (🡄 this requires knowledge of how\n+            // `CheckSchnorrSignature` is written).\n+            for (size_t i = 1; i <= 255; i++) {\n+                valtype testsig(65, i);\n+\n+                MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+                ScriptError serror{SCRIPT_ERR_OK};\n+                BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));\n+                BOOST_TEST(serror == SCRIPT_ERR_OK);\n+            }\n+        }\n+    }\n+\n+    {\n+        // Now check that, given the parameters, if `SignatureHashSchnorr fails there's an error exit.",
      "path": "src/test/script_tapscript_tests.cpp",
      "position": 961,
      "original_position": 961,
      "commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "original_commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "in_reply_to_id": null,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin/bitcoin/pull/25097/commits/eeefec343592c6de85048e3b055ba49755cfb072\r\n\r\nnit: missing a tick",
      "created_at": "2022-07-12T19:11:31Z",
      "updated_at": "2022-07-12T20:25:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r919317189",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/919317189"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 961,
      "original_line": 961,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/919349029",
      "pull_request_review_id": 1036328057,
      "id": 919349029,
      "node_id": "PRRC_kwDOABII5842zCcl",
      "diff_hunk": "@@ -0,0 +1,1711 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+// TODO: Don't know whether Taproot/Tapscript tests should be exercising\n+// `libconsensus` the way the tests in `script_tests` do\n+\n+#include <core_io.h>\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <script/script_error.h>\n+#include <span.h>\n+#include <test/util/boost_test_boosts.h>\n+#include <test/util/pretty_data.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/transaction_utils.h>\n+#include <test/util/vector.h>\n+#include <univalue.h>\n+#include <util/strencodings.h>\n+\n+#include <boost/test/execution_monitor.hpp>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <array>\n+#include <charconv>\n+#include <cstddef>\n+#include <iomanip>\n+#include <iterator>\n+#include <limits>\n+#include <ostream>\n+#include <set>\n+#include <stdexcept>\n+#include <string>\n+#include <string_view>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+using namespace std::literals::string_literals;\n+using namespace std::literals::string_view_literals;\n+using namespace test::util::literals;\n+\n+namespace {\n+\n+typedef std::vector<unsigned char> valtype;\n+\n+/**\n+ * Value/Name pair used in data-driven tests\n+ */\n+template <typename V>\n+struct vn_pair {\n+    vn_pair(V value, std::string_view name) : m_value(value), m_name(name) {}\n+\n+    const V m_value;\n+    const std::string_view m_name;\n+};\n+\n+/**\n+ * Sequence of value/name pairs used in data-driven tests\n+ */\n+template <typename V>\n+using vn_sequence = std::vector<vn_pair<V>>;\n+\n+/**\n+ * Invokes undefined behavior.  See `std::unreachable` in C++23.\n+ */\n+[[noreturn]] inline void declare_unreachable()\n+{\n+#ifdef _MSC_VER\n+    __assume(false);\n+#else\n+    // Assume all other compilers than MSVC implement this GCC builtin.\n+    __builtin_unreachable();\n+#endif\n+}\n+\n+/**\n+ * Representation changer to fill an integral type with a known pattern.\n+ *\n+ * Pattern is successive byte values given a starting point.  Endianness doesn't\n+ * matter.\n+ */\n+union FillWithPattern {\n+    uint256 u256{0};\n+    uint64_t u64raw[sizeof(uint256) / sizeof(uint64_t)];\n+    uint32_t u32[sizeof(uint256) / sizeof(uint32_t)];\n+    int32_t i32[sizeof(uint256) / sizeof(int32_t)];\n+    uint8_t u8[sizeof(uint256)];\n+\n+    constexpr FillWithPattern(uint8_t start)\n+    {\n+        for (auto it = std::begin(u8); it != std::end(u8); ++it) {\n+            *it = start++;\n+        }\n+    }\n+\n+    uint64_t u64() const\n+    {\n+        // It is desirable to force high bit off\n+        return u64raw[0] & static_cast<uint64_t>(std::numeric_limits<int64_t>::max());\n+    }\n+};\n+\n+/**\n+ * The two possible actions for our mock signature checker\n+ */\n+enum class CHECKER_VALIDATION { ALWAYS_SUCCEEDS,\n+                                ALWAYS_FAILS };\n+\n+/**\n+ * For these tests don't need _real_ signature/pubkey validation.  That is\n+ * tested elsewhere.  So we just _mock_ the signature checker and force it\n+ * to answer valid/invalid as we wish.\n+ */\n+class SignatureCheckerMock : public BaseSignatureChecker\n+{\n+    //! What kind of mock checker is this?\n+    CHECKER_VALIDATION m_kind = CHECKER_VALIDATION::ALWAYS_FAILS;\n+\n+    //! True _iff_ CheckSchnorrSignature was actually called\n+    mutable bool m_was_called = false;\n+\n+public:\n+    //! Whether this mock always validates, or always fails, the signature/pubkey check.\n+    explicit SignatureCheckerMock(CHECKER_VALIDATION kind) : m_kind(kind) {}\n+\n+    //! Mocks the actual checking of the validity of the Schnorr signature by always succeeding or always failing\n+    bool CheckSchnorrSignature(Span<const unsigned char> sig,\n+                               Span<const unsigned char> pubkey,\n+                               SigVersion sigversion,\n+                               ScriptExecutionData& execdata,\n+                               ScriptError* serror = nullptr) const override\n+    {\n+        m_was_called = true;\n+        switch (m_kind) {\n+        case CHECKER_VALIDATION::ALWAYS_SUCCEEDS:\n+            if (serror) *serror = SCRIPT_ERR_OK;\n+            return true;\n+\n+        case CHECKER_VALIDATION::ALWAYS_FAILS:\n+            if (serror) *serror = SCRIPT_ERR_SCHNORR_SIG;\n+            return false;\n+        }\n+        declare_unreachable();\n+    }\n+\n+    bool CheckerWasCalled() const\n+    {\n+        return m_was_called;\n+    }\n+};\n+\n+} // namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(script_tapscript_tests, BasicTestingSetup)\n+\n+/**\n+ * Testing EvalScript OP_CHECKSIGADD branch and EvalChecksigTapscript, both in\n+ * interpreter.cpp, against the BIP342 \"Rules for signature opcodes\".\n+ */\n+BOOST_AUTO_TEST_CASE(eval_checksigadd_basic_checks)\n+{\n+    const valtype SIG_64BYTES(64, 0); // N.B.: Must be () not {}!\n+    const valtype SIG_65BYTES(65, 0);\n+    const valtype SIG_EMPTY{};\n+\n+    const valtype PUBKEY_32BYTES(32, 0);\n+    const valtype PUBKEY_15BYTES(15, 0);\n+    const valtype PUBKEY_EMPTY{};\n+\n+    constexpr int64_t TEST_NUM = 10;\n+\n+    constexpr int64_t START_VALIDATION_WEIGHT{90};\n+    constexpr int64_t BIP342_SIGOPS_LIMIT{50};\n+    constexpr int64_t END_VALIDATION_WEIGHT{START_VALIDATION_WEIGHT - BIP342_SIGOPS_LIMIT};\n+\n+    /**\n+     * A fluent API for running these tests.\n+     *\n+     * (Easiest way to understand this class is to look at the actual tests\n+     * that follow in this function.)\n+     */\n+    struct Context {\n+        explicit Context(std::string_view descr) : m_test_description(descr)\n+        {\n+            m_execdata.m_validation_weight_left_init = true;\n+            m_execdata.m_validation_weight_left = START_VALIDATION_WEIGHT;\n+        }\n+\n+        std::string m_test_description;\n+        SigVersion m_sig_version = SigVersion::TAPSCRIPT;\n+        uint32_t m_flags = 0;\n+        CScript m_script;\n+        ScriptError m_err = SCRIPT_ERR_OK;\n+        std::vector<valtype> m_stack;\n+        ScriptExecutionData m_execdata;\n+        CHECKER_VALIDATION m_kind;\n+        bool m_sigchecker_was_called = false;\n+        int64_t m_caller_line = 0;\n+        bool m_result = false;\n+\n+        Context& SetVersion(SigVersion v)\n+        {\n+            m_sig_version = v;\n+            return *this;\n+        }\n+\n+        Context& SetChecker(CHECKER_VALIDATION kind)\n+        {\n+            m_kind = kind;\n+            return *this;\n+        }\n+\n+        Context& SetRemainingWeight(int64_t w)\n+        {\n+            m_execdata.m_validation_weight_left = w;\n+            return *this;\n+        }\n+\n+        Context& AddFlags(uint32_t f)\n+        {\n+            m_flags |= f;\n+            return *this;\n+        }\n+\n+        CScript& SetScript()\n+        {\n+            return m_script;\n+        }\n+\n+        Context& DoTest(int64_t line)\n+        {\n+            SignatureCheckerMock checker_mock(m_kind);\n+            m_caller_line = line;\n+            m_result = EvalScript(m_stack, m_script,\n+                                  SCRIPT_VERIFY_TAPROOT | m_flags,\n+                                  checker_mock,\n+                                  m_sig_version,\n+                                  m_execdata,\n+                                  &m_err);\n+            m_sigchecker_was_called = checker_mock.CheckerWasCalled();\n+            return *this;\n+        }\n+\n+        Context& CheckCallSucceeded()\n+        {\n+            BOOST_CHECK_MESSAGE(m_result,\n+                                Descr()\n+                                    << \": EvalScript succeeded, as expected\");\n+            BOOST_CHECK_MESSAGE(m_err == SCRIPT_ERR_OK,\n+                                Descr()\n+                                    << \": Error code expected OK, actual was \"\n+                                    << ScriptErrorString(m_err));\n+            return *this;\n+        }\n+\n+        Context& CheckCallFailed(ScriptError expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!m_result,\n+                                Descr()\n+                                    << \": EvalScript failed, as expected\");\n+            BOOST_CHECK_MESSAGE(m_err == expected,\n+                                Descr()\n+                                    << \": Error code expected \" << ScriptErrorString(expected)\n+                                    << \", actual was \" << ScriptErrorString(m_err));\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(m_sigchecker_was_called,\n+                                Descr() << \": CheckSchnorrSignature was called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasNotValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(!m_sigchecker_was_called,\n+                                Descr() << \": CheckSchnorrSignature was not called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckRemainingValidationWeight(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(m_execdata.m_validation_weight_left == expected,\n+                                Descr()\n+                                    << \": Remaining validation weight expected \"\n+                                    << expected << \", actual was \"\n+                                    << m_execdata.m_validation_weight_left);\n+            return *this;\n+        }\n+\n+        Context& CheckStackDepth(std::size_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(m_stack.size() == expected,\n+                                Descr()\n+                                    << \": Stack depth expected \" << expected\n+                                    << \", actual was \" << m_stack.size());\n+            return *this;\n+        }\n+\n+        Context& CheckTOS(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!m_stack.empty(),\n+                                Descr()\n+                                    << \": Stack expected at least one item, actually was empty\");\n+            const int64_t actual = CScriptNum(m_stack.at(0), false).GetInt64();\n+            BOOST_CHECK_MESSAGE(expected == actual,\n+                                Descr()\n+                                    << \": Top-of-stack expected \" << expected\n+                                    << \", actual was \" << actual);\n+            return *this;\n+        }\n+\n+    private:\n+        std::string Descr()\n+        {\n+            std::string descr;\n+            descr.reserve(m_test_description.size() + 20);\n+            descr += m_test_description;\n+            descr += \" (@\";\n+            descr += as_string(m_caller_line);\n+            descr += \")\";\n+            return descr;\n+        }\n+    };\n+\n+    {\n+        Context ctx(\"SigVersion must not be BASE\");\n+        ctx.SetVersion(SigVersion::BASE).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"SigVersion must not be WITNESS_V0\");\n+        ctx.SetVersion(SigVersion::WITNESS_V0).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Minimum stack height 3 for OP_CHECKSIGADD\");\n+        ctx.SetScript()\n+            << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_INVALID_STACK_OPERATION)\n+            .CheckStackDepth(2);\n+    }\n+\n+    {\n+        Context ctx(\"`n` (2nd arg) size > 4 must fail\");\n+        // This is probably meant to be a check on the _encoding_ - that it is\n+        // minimal, but it can also be a check on the _value_.  BIP342 doesn't\n+        // say which.  Could be both...\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(10000000000LL) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            // (IMO this is an _unsatisfactory_ error code to return for a required\n+            // BIP342 check, but see the `catch` clause in `EvalScript`)\n+            .CheckCallFailed(SCRIPT_ERR_UNKNOWN_ERROR)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Insufficient validation weight remaining\");\n+        ctx.SetRemainingWeight(BIP342_SIGOPS_LIMIT - 1)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + 32byte pubkey skips validation\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + non32byte pubkey skips validation\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey ('unknown pubkey type') _with_ discourage flag fails\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .AddFlags(SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .CheckSignatureWasNotValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation failure forced\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_FAILS)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_SCHNORR_SIG)\n+            .CheckSignatureWasValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation success forced\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasValidated()\n+            .CheckRemainingValidationWeight(END_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM + 1);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey + empty sig with validation success forced\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_failure_cases)\n+{\n+    // As defined by BIP-341 Signature Validation Rules\n+    // Here we pick an acceptable SigVersion\n+    const SigVersion sigversion = SigVersion::TAPROOT;\n+\n+    CMutableTransaction tx_to_m;\n+    tx_to_m.vin.push_back(CTxIn());\n+    const uint32_t in_pos{0};\n+\n+    PrecomputedTransactionData cache;\n+    cache.m_bip341_taproot_ready = true;\n+    cache.m_spent_outputs_ready = true;\n+\n+    ScriptExecutionData execdata;\n+    execdata.m_annex_init = true;\n+    execdata.m_annex_present = false;\n+    execdata.m_annex_hash = uint256::ZERO;\n+    execdata.m_tapleaf_hash_init = false;\n+    execdata.m_codeseparator_pos_init = true;\n+\n+    uint256 hash_out{0};\n+\n+    {\n+        // Check all invalid hash_type codes rejected\n+        const std::set<uint8_t> allowable_hash_types{0x00, 0x01, 0x02, 0x03, 0x81, 0x82, 0x83};\n+        for (unsigned ht = 0; ht <= 255; ht++) {\n+            const uint8_t hash_type = static_cast<uint8_t>(ht);\n+            if (allowable_hash_types.find(hash_type) != allowable_hash_types.end()) continue;\n+\n+            BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m, in_pos,\n+                                                      hash_type, sigversion, cache,\n+                                                      MissingDataBehavior::FAIL),\n+                                \"hash_type = \" << Hex(hash_type) << \" expected to fail\");\n+        }\n+    }\n+\n+    {\n+        // Check that if hash_type == SIGHASH_SINGLE then missing a \"corresponding\n+        // output\" fails.\n+        CMutableTransaction tx_to_m;\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+\n+        uint8_t in_pos = 1;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(1) > #tx_to==0 is expected to fail\");\n+\n+        tx_to_m.vout.push_back(CTxOut());\n+        in_pos = 2;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(2) > #tx_to==1 is expected to fail\");\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_all_success_paths)\n+{\n+    // Our approach here will be to follow BIP-341's signature algorithm (with\n+    // the BIP-342 extension) doing two things at once:\n+    //   1) We'll set up the input arguments to `SignatureHashSchnorr` function\n+    //      being tested, _and_\n+    //   2) we'll _compute the hash of those fields ourselves_ exaxctly as\n+    //      it is described in BIP-341 and BIP-342.\n+    // Then we can compare the two.  We'll do this in a data-driven way for each\n+    // of the different scenarios that the algorithm supports.\n+    //\n+    // In this way this test achieves 100% _path_ coverage of `SignatureHashSchnorr`\n+    // (not just 100% _branch_ coverage).\n+    // - Sadly, this isn't shown in the `lcov` reports.  There are still a few\n+    //   red `-` marks left.  This is because:\n+    //   1. `lcov` wasn't designed to handle death tests.\n+    //   2. ??? Some other unknown reasons, possibly due to the instrumentation,\n+    //      possibly due to `lcov` limitations.  You can see by the test output\n+    //      (`-log_level=all`) or within a debugger that in fact _all_ branches\n+    //      are taken when executing all the tests in this file.\n+\n+    // Here we define, and then generate, all combinations of the alternatives\n+    // for the parameters that vary the signature combination algorithm\n+\n+    const vn_sequence<SigVersion> SigVersion_alternatives{\n+        {SigVersion::TAPROOT, \"TAPROOT\"sv},\n+        {SigVersion::TAPSCRIPT, \"TAPSCRIPT\"sv}};\n+\n+    const vn_sequence<uint32_t> hash_type_output_alternatives{\n+        {SIGHASH_DEFAULT, \"SIGHASH_DEFAULT\"sv},\n+        {SIGHASH_ALL, \"SIGHASH_ALL\"sv},\n+        {SIGHASH_NONE, \"SIGHASH_NONE\"sv},\n+        {SIGHASH_SINGLE, \"SIGHASH_SINGLE\"sv}};\n+\n+    const vn_sequence<uint32_t> hash_type_input_alternatives{\n+        {0, \"N/A\"sv},\n+        {SIGHASH_ANYONECANPAY, \"SIGHASH_ANYONECANPAY\"sv}};\n+\n+    const vn_sequence<uint8_t> annex_alternatives{\n+        {0, \"no annex\"sv},\n+        {1, \"annex present\"sv}};\n+\n+    const vn_sequence<bool> output_hash_alternatives{\n+        {false, \"output hash missing\"sv},\n+        {true, \"output hash provided\"sv}};\n+\n+    for (const auto& sigversion_alternative : SigVersion_alternatives)\n+        for (const auto& hash_type_output_alternative : hash_type_output_alternatives)\n+            for (const auto& hash_type_input_alternative : hash_type_input_alternatives)\n+                for (const auto& annex_alternative : annex_alternatives)\n+                    for (const auto& output_hash_alternative : output_hash_alternatives) {\n+                        // Exclude the invalid combination of SIGHASH_DEFAULT with SIGHASH_ANYONECANPAY\n+                        if (hash_type_output_alternative.m_value == SIGHASH_DEFAULT && hash_type_input_alternative.m_value == SIGHASH_ANYONECANPAY) continue;\n+\n+                        // We're going to want to know which scenario it is if a check actually\n+                        // fails ...\n+                        std::string scenario_description;\n+                        {\n+                            std::ostringstream oss;\n+                            oss << sigversion_alternative.m_name << \", \"\n+                                << hash_type_output_alternative.m_name << \", \"\n+                                << hash_type_input_alternative.m_name << \", \"\n+                                << annex_alternative.m_name << \", \"\n+                                << output_hash_alternative.m_name;\n+                            scenario_description = oss.str();\n+                        }\n+\n+                        // Set up the scenario we're running now - these 4 variables define the scenario\n+                        const SigVersion sigversion{sigversion_alternative.m_value};\n+                        const uint8_t hash_type{static_cast<uint8_t>(hash_type_output_alternative.m_value | hash_type_input_alternative.m_value)};\n+                        const uint8_t annex_present{annex_alternative.m_value};\n+                        const bool have_output_hash{output_hash_alternative.m_value};\n+\n+                        // Compute some helper values that depend on scenario\n+                        const uint8_t ext_flag{sigversion == SigVersion::TAPSCRIPT};\n+                        const uint8_t hash_input_type{static_cast<uint8_t>(hash_type & SIGHASH_INPUT_MASK)};\n+                        const uint8_t hash_output_type{static_cast<uint8_t>((hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK))};\n+                        const uint8_t spend_type = (ext_flag * 2) + annex_present;\n+\n+                        // Fixed values (by algorithm)\n+                        const uint8_t epoch{0x00};\n+                        const uint8_t key_version{0};\n+\n+                        // Mocked values fixed for purposes of this unit test.  This is a long\n+                        // list of crufty things but that's because `SignatureHashSchnorr`, the\n+                        // function being tested, takes as arguments not just the transaction\n+                        // being signed (plus control data) but also some _precomputed values_\n+                        // in two different structs: `PrecomputedTransactionData`, and\n+                        // `ScriptExecutionData`.  On the one hand this is nice because a lot\n+                        // of complexity of the signature algorithm doesn't have to be duplicated\n+                        // here in this test: we can just use mocked values.  On the other hand,\n+                        // there's a lot of icky setup to do to get all the values in the right\n+                        // places both for our \"by the book\" implementation and to be set up to\n+                        // call `SignatureHashSchnorr`.\n+                        //\n+                        // Try to make things simpler by at least using the same names for the\n+                        // setup variables as for the fields in the parameter structs.\n+\n+                        const uint32_t in_pos{1};\n+                        const int32_t tx_version{FillWithPattern(0x01).i32[0]};\n+                        const uint32_t tx_lock_time{FillWithPattern(0x05).u32[0]};\n+                        const uint256 prevouts_single_hash{FillWithPattern(0x10).u256};\n+                        const uint256 spent_amounts_single_hash{FillWithPattern(0x18).u256};\n+                        const uint256 spent_scripts_single_hash{FillWithPattern(0x20).u256};\n+                        const uint256 sequences_single_hash{FillWithPattern(0x28).u256};\n+                        const uint256 outputs_single_hash{FillWithPattern(0x30).u256};\n+                        const uint256 output_hash{FillWithPattern(0x40).u256};\n+                        const uint256 annex_hash{FillWithPattern(0x48).u256};\n+                        const uint256 tapleaf_hash{FillWithPattern(0x50).u256};\n+                        const uint32_t codeseparator_pos{FillWithPattern(0x58).u32[0]};\n+                        const COutPoint tx_input_at_pos_prevout{FillWithPattern(0x60).u256,\n+                                                                FillWithPattern(0x68).u32[0]};\n+                        const uint32_t tx_input_at_pos_nsequence{FillWithPattern(0x70).u32[0]};\n+                        CTxOut spent_output_at_pos;\n+                        spent_output_at_pos.nValue = FillWithPattern(0x80).u64();\n+                        spent_output_at_pos.scriptPubKey /*random script, not even valid*/\n+                            << OP_DUP << OP_HASH160 << OP_EQUALVERIFY << OP_CHECKSIG;\n+                        CTxOut tx_output_at_pos;\n+                        tx_output_at_pos.nValue = FillWithPattern(0x90).u64();\n+                        tx_output_at_pos.scriptPubKey /*random script, not even valid*/\n+                            << OP_CHECKSIG << OP_EQUALVERIFY << OP_HASH160 << OP_DUP;\n+\n+                        // Now set up the arguments that are going to be passed to\n+                        // `SignatureHashSchnorr`\n+\n+                        CMutableTransaction tx_to;\n+                        tx_to.nVersion = tx_version;\n+                        tx_to.nLockTime = tx_lock_time;\n+                        for (uint32_t i = 0; i < in_pos + 2; i++) {\n+                            tx_to.vin.push_back(CTxIn());\n+                            tx_to.vout.push_back(CTxOut());\n+                        }\n+                        tx_to.vin[in_pos].prevout = tx_input_at_pos_prevout;\n+                        tx_to.vin[in_pos].nSequence = tx_input_at_pos_nsequence;\n+                        tx_to.vout[in_pos] = tx_output_at_pos;\n+\n+                        PrecomputedTransactionData cache;\n+                        cache.m_bip341_taproot_ready = true;\n+                        cache.m_prevouts_single_hash = prevouts_single_hash;\n+                        cache.m_spent_amounts_single_hash = spent_amounts_single_hash;\n+                        cache.m_spent_scripts_single_hash = spent_scripts_single_hash;\n+                        cache.m_sequences_single_hash = sequences_single_hash;\n+                        cache.m_spent_outputs_ready = true;\n+                        for (uint32_t i = 0; i < in_pos + 2; i++) {\n+                            cache.m_spent_outputs.push_back(CTxOut());\n+                        }\n+                        cache.m_spent_outputs[in_pos] = spent_output_at_pos;\n+                        cache.m_outputs_single_hash = outputs_single_hash;\n+\n+                        ScriptExecutionData execdata;\n+                        execdata.m_annex_init = true;\n+                        execdata.m_annex_present = !!annex_present;\n+                        execdata.m_annex_hash = annex_hash;\n+                        execdata.m_output_hash.reset();\n+                        if (have_output_hash) {\n+                            execdata.m_output_hash = output_hash;\n+                        }\n+                        if (sigversion == SigVersion::TAPSCRIPT) {\n+                            execdata.m_tapleaf_hash_init = true;\n+                            execdata.m_tapleaf_hash = tapleaf_hash;\n+                            execdata.m_codeseparator_pos_init = true;\n+                            execdata.m_codeseparator_pos = codeseparator_pos;\n+                        }\n+\n+                        // Now here is where we take all that data - _not_ the arguments to\n+                        // `SignatureHashSchnorr` but all the scenario parameters, the helpers,\n+                        // the values fixed by the algorithm, and our mocked values, and actually\n+                        // follow the BIP-341/BIP-342 signature calculation algorithm right from\n+                        // the spec ...\n+\n+                        // Start with a tagged hasher with the correct tag\n+                        CHashWriter hasher = TaggedHash(\"TapSighash\");\n+\n+                        // First byte to hash is always the \"epoch\", 0x00 (BIP-341, footnote 20)\n+                        hasher << epoch;\n+\n+                        // Next: hash_type (1 byte)\n+                        hasher << hash_type;\n+\n+                        // Next: transaction version (4 bytes)\n+                        hasher << tx_version;\n+\n+                        // Next: transaction lock time (4 bytes)\n+                        hasher << tx_lock_time;\n+\n+                        // Next if _not_ SIGHASH_ANYONECANPAY:\n+                        // a) SHA256 of the serialization of all input outpoints (32 bytes)\n+                        // b) SHA256 of the serialization of all spent output amounts (32 bytes)\n+                        // c) SHA256 of the serialization of all spent outputs' _scriptPubKeys_\n+                        //    serialized as script (32 bytes)\n+                        // d) SHA256 of the serialization of all input `nSequence` (32 bytes)\n+                        if (hash_input_type != SIGHASH_ANYONECANPAY) {\n+                            hasher << prevouts_single_hash;\n+                            hasher << spent_amounts_single_hash;\n+                            hasher << spent_scripts_single_hash;\n+                            hasher << sequences_single_hash;\n+                        }\n+\n+                        // Next if _not_ SIGHASH_NONE _and not_ SIGHASH_SINGLE:\n+                        // SHA256 of the serialization of all outputs in CTxOut format (32 bytes)\n+                        if (hash_output_type != SIGHASH_NONE && hash_output_type != SIGHASH_SINGLE) {\n+                            hasher << outputs_single_hash;\n+                        }\n+\n+                        // Now, data about input/prevout being spent\n+\n+                        // The \"spend_type\" (1 byte) which is a function of ext_flag (above) and\n+                        // whether there is an annex present (here: no)\n+                        hasher << spend_type;\n+\n+                        // Here, if we are _not_ SIGHASH_ANYONECANPAY, we just add the index of\n+                        // the input in the transaction input vector (4 bytes). There must be a\n+                        // input transaction at this index but _in this scenario_ it doesn't have\n+                        // to have any data (it is never inspected).  Same for output transactions.\n+                        //\n+                        // On the other hand, if we _are_ SIGHASH_ANYONECANPAY, then we add the\n+                        // `COutPoint` of this input (36 bytes), the value of the previous\n+                        // output spent by this input (8 bytes), the `ScriptPubKey` of the\n+                        // previous output spent by this input (35 bytes), and the `nSequence`\n+                        // of this input.  These values are all precomputed and made available\n+                        // to `SignatureHashSchnorr` in the `PrecomputedTransactionData` struct.\n+                        if (hash_input_type == SIGHASH_ANYONECANPAY) {\n+                            hasher << tx_input_at_pos_prevout;\n+                            hasher << spent_output_at_pos.nValue;\n+                            hasher << spent_output_at_pos.scriptPubKey;\n+                            hasher << tx_input_at_pos_nsequence;\n+                        } else {\n+                            hasher << in_pos;\n+                        }\n+\n+                        // Now, if there is an \"annex\", add its hash (32 byte).  This is\n+                        // precomputed and we don't actually have to have an actual annex to\n+                        // pass in to `SignatureHashSchnorr`, nor do we have to hash it.\n+                        if (annex_present) {\n+                            hasher << annex_hash;\n+                        }\n+\n+                        // Here, iff the hash type is `SIGHASH_SINGLE`, add the hash of the\n+                        // corresponding transaction output (32 bytes).  The wrinkle here is that\n+                        // (for some reason) _sometimes_ this hash is precomputed, and _sometimes_\n+                        // it is _not_.  So `SignatureHashSchnorr` will either use it if it is\n+                        // provided or compute it from the corresponding output itself. (For our\n+                        // purposes in this test the output need not be valid - it just must be\n+                        // present.)\n+                        if (hash_output_type == SIGHASH_SINGLE) {\n+                            if (!have_output_hash) {\n+                                CHashWriter hasher2(SER_GETHASH, 0);\n+                                hasher2 << tx_output_at_pos;\n+                                hasher << hasher2.GetSHA256();\n+                            } else {\n+                                hasher << output_hash;\n+                            }\n+                        }\n+\n+                        // This is the TAPSCRIPT extension from BIP-342.  If the version is\n+                        // TAPSCRIPT then add the tapleaf hash (32 bytes), the key_version (1\n+                        // byte, fixed value of 0x00), and the \"opcode position of the last\n+                        // executed OP_CODESEPARATOR before the currently executed signature\n+                        // opcode\" (4 bytes).  The tapleaf hash and the code separator position\n+                        // are both precomputed values.\n+                        if (sigversion == SigVersion::TAPSCRIPT) {\n+                            hasher << tapleaf_hash;\n+                            hasher << key_version;\n+                            hasher << codeseparator_pos;\n+                        }\n+\n+                        // That's all that goes into the hasher for this signature\n+                        const uint256 expected_hash_out = hasher.GetSHA256();\n+\n+                        // Now, _finally_, we test the actual implemented algorithm under test:\n+                        uint256 actual_hash_out{0};\n+                        BOOST_TEST(SignatureHashSchnorr(actual_hash_out,\n+                                                        execdata, tx_to, in_pos,\n+                                                        hash_type, sigversion, cache,\n+                                                        MissingDataBehavior::FAIL),\n+                                   \"Scenario: \" << scenario_description);\n+                        BOOST_TEST(expected_hash_out == actual_hash_out,\n+                                   \"Scenario: \" << scenario_description\n+                                                << \" - expected \" << expected_hash_out.ToString()\n+                                                << \" == actual \" << actual_hash_out.ToString());\n+                    }\n+}\n+\n+namespace {\n+\n+// Valid Schnoor (pubkey, msg, signature) tuples (copied from `key_tests.cpp`)\n+\n+struct SchnorrTriplet {\n+    SchnorrTriplet(std::string pubkey, std::string sighash, std::string sig)\n+        : m_pubkey(ParseHex(pubkey)), m_sighash(uint256(ParseHex(sighash))), m_sig(ParseHex(sig)) {}\n+    valtype m_pubkey;\n+    uint256 m_sighash;\n+    valtype m_sig;\n+};\n+\n+static const std::vector<SchnorrTriplet> SCHNORR_TRIPLETS = {\n+    {\"F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9\", \"0000000000000000000000000000000000000000000000000000000000000000\", \"E907831F80848D1069A5371B402410364BDF1C5F8307B0084C55F1CE2DCA821525F66A4A85EA8B71E482A74F382D2CE5EBEEE8FDB2172F477DF4900D310536C0\"},\n+    {\"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659\", \"243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89\", \"6896BD60EEAE296DB48A229FF71DFE071BDE413E6D43F917DC8DCF8C78DE33418906D11AC976ABCCB20B091292BFF4EA897EFCB639EA871CFA95F6DE339E4B0A\"},\n+    {\"DD308AFEC5777E13121FA72B9CC1B7CC0139715309B086C960E18FD969774EB8\", \"7E2D58D8B3BCDF1ABADEC7829054F90DDA9805AAB56C77333024B9D0A508B75C\", \"5831AAEED7B44BB74E5EAB94BA9D4294C49BCF2A60728D8B4C200F50DD313C1BAB745879A5AD954A72C45A91C3A51D3C7ADEA98D82F8481E0E1E03674A6F3FB7\"},\n+    {\"25D1DFF95105F5253C4022F628A996AD3A0D95FBF21D468A1B33F8C160D8F517\", \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", \"7EB0509757E246F19449885651611CB965ECC1A187DD51B64FDA1EDC9637D5EC97582B9CB13DB3933705B32BA982AF5AF25FD78881EBB32771FC5922EFC66EA3\"},\n+    {\"D69C3509BB99E412E68B0FE8544E72837DFA30746D8BE2AA65975F29D22DC7B9\", \"4DF3C3F68FCC83B27E9D42C90431A72499F17875C81A599B566C9889B9696703\", \"00000000000000000000003B78CE563F89A0ED9414F5AA28AD0D96D6795F9C6376AFB1548AF603B3EB45C9F8207DEE1060CB71C04E80F593060B07D28308D7F4\"},\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(internal_test_validate_schnorr_testdata)\n+{\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(XOnlyPubKey(triplet.m_pubkey).VerifySchnorr(triplet.m_sighash, triplet.m_sig));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(verify_schnorr_signature)\n+{\n+    // Defeat, for test purposes, the protected access of\n+    // `GenericTransactionSignatureChecker::VerifySchnorrSignature`\n+    struct UnprotectedTransactionSignatureChecker : public MutableTransactionSignatureChecker {\n+        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;\n+        using MutableTransactionSignatureChecker::VerifySchnorrSignature;\n+    };\n+    UnprotectedTransactionSignatureChecker sut{nullptr, 0, {}, {}};\n+\n+    // Positive tests: triplets which verify\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(sut.VerifySchnorrSignature(triplet.m_sig,\n+                                              XOnlyPubKey{triplet.m_pubkey},\n+                                              triplet.m_sighash));\n+    }\n+\n+    // Negative tests: triplets which fail to verify (get these failing triplets\n+    // by modifying a valid triplet, one field at a time)\n+    auto diddle_front_byte = [](auto v) { v[0]++; return v; };\n+    auto& triplet = SCHNORR_TRIPLETS[0];\n+    BOOST_TEST(!sut.VerifySchnorrSignature(diddle_front_byte(triplet.m_sig),\n+                                           XOnlyPubKey{triplet.m_pubkey},\n+                                           triplet.m_sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.m_sig,\n+                                           XOnlyPubKey{diddle_front_byte(triplet.m_pubkey)},\n+                                           triplet.m_sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.m_sig,\n+                                           XOnlyPubKey{triplet.m_pubkey},\n+                                           uint256::ONE));\n+}\n+\n+BOOST_AUTO_TEST_CASE(check_schnorr_signature)\n+{\n+    // Provide, for test purposes, a subclass of `GenericTransactionsSignatureChecker`\n+    // that mocks `VerifySchnorrSignature` so we can more easily test\n+    // `CheckSchnorrSignature` without going to the trouble of having a valid\n+    // transaction (which is unnecessary for this _unit_ test.)\n+    struct MockVerifyingTransactionSignatureChecker : public MutableTransactionSignatureChecker {\n+        uint256 m_expected_sighash = []() {\n+            uint256 h{};\n+            // This is the known sighash of the Tx and input data we set up (precomputed)\n+            h.SetHex(\"f614d8ae6dcc49e2ca2ef1c03f93c7326189e5575d446e825e5a2700fb1cb83c\");\n+            return h;\n+        }();\n+\n+        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;\n+\n+        enum class if_as_expected_return { False,\n+                                           True };\n+        if_as_expected_return m_iae{if_as_expected_return::True};\n+        void SetExpectation(if_as_expected_return iaer) { m_iae = iaer; }\n+\n+        bool VerifySchnorrSignature(Span<const unsigned char> sig,\n+                                    const XOnlyPubKey& pubkey,\n+                                    const uint256& sighash) const override\n+        {\n+            // Following line used only to determine the known canned `expected_sighash` above:\n+            // BOOST_TEST_MESSAGE(\"MockVerifySchnorrSignature: sighash == \" << sighash.ToString());\n+\n+            bool as_expected = sighash == m_expected_sighash;\n+            if (m_iae == if_as_expected_return::True)\n+                return as_expected;\n+            else\n+                return !as_expected;\n+        };\n+    };\n+\n+    const auto triplet = SCHNORR_TRIPLETS[0];\n+    const CMutableTransaction txToIn{};\n+    ScriptExecutionData execdata{};\n+\n+    {\n+        // Signature must be 64 or 65 bytes long\n+        for (size_t i = 0; i <= 99; i++) {\n+            valtype testsig(i, i);\n+            if (testsig.size() == 64 || testsig.size() == 65) continue;\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_SIZE);\n+        }\n+    }\n+\n+    {\n+        // Iff signature is 65 bytes long last byte must **NOT** be SIGHASH_DEFAULT (0x00) per BIP-342\n+        {\n+            // Negative test: last byte _is_ SIGHASH_DEFAULT\n+            valtype testsig(65, 65);\n+            testsig.back() = SIGHASH_DEFAULT;\n+\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);\n+        }\n+        {\n+            // Negative tests: last byte is _not_ SIGHASH_DEFAULT, but we early exit _without changing\n+            // serror_ because we don't provide a txDataIn (🡄 this requires knowledge of how\n+            // `CheckSchnorrSignature` is written).\n+            for (size_t i = 1; i <= 255; i++) {\n+                valtype testsig(65, i);\n+\n+                MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+                ScriptError serror{SCRIPT_ERR_OK};\n+                BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));\n+                BOOST_TEST(serror == SCRIPT_ERR_OK);\n+            }\n+        }\n+    }\n+\n+    {\n+        // Now check that, given the parameters, if `SignatureHashSchnorr fails there's an error exit.\n+        // Otherwise, if it succeeds, it proceeds to call `VerifySchnorrSignature` and depending on\n+        // _that_ result `SignatureHashSchnorr` either succeeds or fails.\n+        //\n+        // We do this using the mocked `VerifySchnorrSignature` so we only need to pass parameters\n+        // that work with `SignatureHashSchnorr`, they don't _also_ have to validate with\n+        // `VerifySchnorrSignature`.\n+\n+        const uint32_t in_pos{0};\n+        CMutableTransaction txToIn{};\n+        txToIn.nVersion = 0;\n+        txToIn.nLockTime = 0;\n+        txToIn.vin.push_back(CTxIn());\n+        txToIn.vin[in_pos].prevout = COutPoint(uint256::ZERO, 0);\n+        txToIn.vin[in_pos].nSequence = 0;\n+        txToIn.vout.push_back(CTxOut());\n+\n+        PrecomputedTransactionData txDataIn{};\n+        txDataIn.m_bip341_taproot_ready = true;\n+        txDataIn.m_prevouts_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_amounts_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_scripts_single_hash = uint256::ZERO;\n+        txDataIn.m_sequences_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_outputs_ready = true;\n+        txDataIn.m_spent_outputs.push_back(CTxOut());\n+        txDataIn.m_spent_outputs[in_pos].nValue = 0;\n+        txDataIn.m_spent_outputs[in_pos].scriptPubKey << OP_DUP << OP_CHECKSIG;\n+        txDataIn.m_outputs_single_hash = uint256::ZERO;\n+\n+        ScriptExecutionData execdata{};\n+        execdata.m_annex_init = true;\n+        execdata.m_annex_present = true;\n+        execdata.m_annex_hash = uint256::ZERO;\n+        execdata.m_output_hash.reset();\n+\n+        {\n+            // Confirm that we can force `SignatureHashSchnorr` to fail (via an early exit)\n+            PrecomputedTransactionData txDataIn{};\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(triplet.m_sig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);\n+        }\n+\n+        {\n+            // Now `SignatureHashSchnorr` will return true but we'll fail `VerifySchnorrSignature`\n+            // and show it returns the correct error.\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            sut.SetExpectation(MockVerifyingTransactionSignatureChecker::if_as_expected_return::False);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(triplet.m_sig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG);\n+        }\n+\n+        {\n+            // Finally, same as previous, except we'll force `VerifySchnorrSignature` to succeed and\n+            // show now that `CheckSchnorrSignature` finally succeeds.\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            sut.SetExpectation(MockVerifyingTransactionSignatureChecker::if_as_expected_return::True);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(sut.CheckSchnorrSignature(triplet.m_sig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_OK);\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(compute_tapleaf_hash)\n+{\n+    // Try two examples, reimplementing the BIP-341 specification\n+    {\n+        uint8_t leaf_version = 0;\n+        CScript cs{};\n+        auto expected = (TaggedHash(\"TapLeaf\") << leaf_version << CScript()).GetSHA256();\n+        auto actual = ComputeTapleafHash(leaf_version, CScript());\n+        BOOST_TEST(expected == actual,\n+                   \"leaf version 0, empty CScript - expected \"\n+                       << expected.ToString() << \" actual \" << actual.ToString());\n+    }\n+\n+    {\n+        uint8_t leaf_version = 0x4a;\n+        CScript cs{};\n+        cs << OP_CHECKLOCKTIMEVERIFY << OP_CHECKSIGADD; // just a random CScript\n+        auto expected = (TaggedHash(\"TapLeaf\") << leaf_version << cs).GetSHA256();\n+        auto actual = ComputeTapleafHash(leaf_version, cs);\n+        BOOST_TEST(expected == actual,\n+                   \"leaf version 0x4A, CScript w/ 2 opcodes - expected \"\n+                       << expected.ToString() << \" actual \" << actual.ToString());\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(compute_taproot_merkle_root)\n+{\n+    using namespace test::util::vector_ops;\n+\n+    // Test by using a small enhancement to a `vector<unsigned char>` that makes\n+    // it easy to convert to/from strings so the tests are more easily readable,\n+    // and also adds directly the two necessary operations from BIP-340: byte\n+    // vector concatenation and byte vector select subrange.\n+\n+    // Use an arbitrary tapleaf hash throughout\n+    const uint256 tapleaf_hash1 = ComputeTapleafHash(0x10, CScript{} << OP_CHECKMULTISIG);\n+    const uint256 tapleaf_hash2 = ComputeTapleafHash(0x20, CScript{} << OP_CHECKSEQUENCEVERIFY);\n+\n+    //                         \".........|.........|.........|...\"      33 bytes\n+    const auto control_base1 = \"[point (#1) - 33 bytes of junk!!>\"_bv;\n+    const auto control_base2 = \"[point (#2) - 33 more bad bytes!>\"_bv;\n+    assert(control_base1.size() == 33 && control_base2.size() == 33);\n+\n+    // Nodes `node_low` and `node_high` are constructed to be _forced_ lower/higher\n+    // (respectively) than arbitrary hash.  This isn't exactly true, of course:\n+    // only the _first byte_ of these nodes are low or high.  If the first byte\n+    // of the \"arbitrary\" hash is `0x00` or `0xff` we've got a problem .. but\n+    // this isn't the case for this test data.\n+\n+    //                                     \".........|.........|.........|..\"       32 bytes\n+    const auto node_low = []() { auto r  = \"(this is node to-be-diddled low)\"_bv; r.front() = 0x00; return r; }();\n+    const auto node_high = []() { auto r = \"(this is nod to-be-diddled high)\"_bv; r.front() = 0xFF; return r; }();\n+    assert(node_low.size() == 32 && node_high.size() == 32);\n+\n+    assert(node_low < from_base_blob(tapleaf_hash1) && from_base_blob(tapleaf_hash1) < node_high);\n+    assert(node_low < from_base_blob(tapleaf_hash2) && from_base_blob(tapleaf_hash2) < node_high);\n+\n+    const CHashWriter hw_branch{TaggedHash(\"TapBranch\")};\n+\n+    {\n+        // Control block contains only the initial point, no nodes - always returns\n+        // the tapleaf hash, doesn't matter what the control block is\n+        uint256 expected1 = tapleaf_hash1;\n+        uint256 actual1a = ComputeTaprootMerkleRoot(control_base1, tapleaf_hash1);\n+        BOOST_TEST(expected1 == actual1a,\n+                   \"expected \" << HexStr(expected1) << \", actual \" << HexStr(actual1a));\n+        uint256 actual1b = ComputeTaprootMerkleRoot(control_base2, tapleaf_hash1);\n+        BOOST_TEST(expected1 == actual1b,\n+                   \"expected \" << HexStr(expected1) << \", actual \" << HexStr(actual1b));\n+        uint256 expected2 = tapleaf_hash2;\n+        uint256 actual2 = ComputeTaprootMerkleRoot(control_base2, tapleaf_hash2);\n+        BOOST_TEST(expected2 == actual2,\n+                   \"expected \" << HexStr(expected2) << \", actual \" << HexStr(actual2));\n+    }\n+\n+    {\n+        // Control block contains one node - check both lexicographic orders\n+\n+        {\n+            uint256 expected = (CHashWriter{hw_branch} << Span{node_low} << tapleaf_hash1).GetSHA256();\n+            uint256 actual = ComputeTaprootMerkleRoot(Span{control_base1 || node_low}, tapleaf_hash1);\n+            BOOST_TEST(expected == actual,\n+                    \"expected \" << HexStr(expected) << \", actual \" << HexStr(actual));\n+        }\n+        {\n+            uint256 expected = (CHashWriter{hw_branch} << tapleaf_hash1 << Span{node_high}).GetSHA256();\n+            uint256 actual = ComputeTaprootMerkleRoot(Span{control_base1 || node_high}, tapleaf_hash1);\n+            BOOST_TEST(expected == actual,\n+                    \"expected \" << HexStr(expected) << \", actual \" << HexStr(actual));\n+        }\n+    }\n+\n+    {\n+        // With a control block with more than one node (here: two nodes), each subsequent node\n+        // is hashed with the hash of the previous nodes in _lexicographic_ order.\n+\n+        // Control block is going to be `point1 || node_high || node_{low,high}`\n+        uint256 intermediate_k = (CHashWriter{hw_branch} << tapleaf_hash1 << Span{node_high}).GetSHA256();\n+\n+        // Verify that the intermediate hash is less than `node_high`\n+        assert(from_base_blob(intermediate_k) < node_high);\n+\n+        {\n+            // 2nd node lexicographically _less than_ intermediate hash\n+            uint256 expected = (CHashWriter{hw_branch} << Span{node_low} << intermediate_k).GetSHA256();\n+            uint256 actual = ComputeTaprootMerkleRoot(control_base1 || node_high || node_low, tapleaf_hash1);\n+            BOOST_TEST(expected == actual,\n+                    \"expected \" << HexStr(expected) << \", actual \" << HexStr(actual));\n+        }\n+\n+        {\n+            // 2nd node lexicographically _greater than_ intermediate hash\n+            uint256 expected = (CHashWriter{hw_branch} << intermediate_k << Span{node_high}).GetSHA256();\n+            uint256 actual = ComputeTaprootMerkleRoot(control_base1 || node_high || node_high, tapleaf_hash1);\n+            BOOST_TEST(expected == actual,\n+                    \"expected \" << HexStr(expected) << \", actual \" << HexStr(actual));\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(taproot_v1_verify_script)\n+{\n+    // Testing Taproot code paths in `VerifyWitnessProgram` and\n+    // `SigVersion::TAPSCRIPT` code paths in `ExecuteWitnessScript`.\n+\n+    // Both `VerifyWitnessProgram` and `ExecuteWitnessScript` are `static`\n+    // inside of `interpreter.cpp` and thus inaccessible to a unit test.\n+    // The way to get to them is indirectly via `VerifyScript`.\n+\n+    // Tests all success and failure paths mentioned in BIP-341 and\n+    // BIP-342.\n+\n+    // This is a _unit test_ not a _functional test_ and the unit being\n+    // tested here does _not_ include actually verifying the signature.\n+    // That is tested elsewhere (e.g., by tests `verify_schnorr_signature`\n+    // and `check_schnorr_signature` in this file).  _This_ test _mocks_\n+    // the Schnorr signature verfication.  Thus the test data need not\n+    // actually have valid signatures (and is thus easier to prepare).\n+\n+    /**\n+     * A fluent API for running these tests.  Swiped and adapted from\n+     * `script_tests.cpp`.\n+     *\n+     * (Easiest way to understand this class is to look at the actual tests\n+     * that follow in this function.)\n+     */\n+\n+    struct Context {\n+        // raw key data from `key_tests.cpp` @305\n+        valtype m_sec{ParseHex(\"0000000000000000000000000000000000000000000000000000000000000003\")};\n+        valtype m_pub{ParseHex(\"F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9\")};\n+        valtype m_sig{ParseHex(\"E907831F80848D1069A5371B402410364BDF1C5F8307B0084C55F1CE2DCA821525F66A4A85EA8B71E482A74F382D2CE5EBEEE8FDB2172F477DF4900D310536C0\")};\n+\n+        CKey m_sec_key;\n+        XOnlyPubKey m_pub_key;\n+\n+    private:\n+        void SetupKeys()\n+        {\n+            BOOST_TEST(m_sec.size() == 32);\n+            BOOST_TEST(m_pub.size() == 32);\n+            BOOST_TEST(m_sig.size() == 64);\n+\n+            m_sec_key.Set(m_sec.begin(), m_sec.end(), true /*compressed*/);\n+            m_pub_key = XOnlyPubKey(m_sec_key.GetPubKey());\n+\n+            BOOST_TEST(m_pub_key.IsFullyValid());\n+        }\n+\n+    public:\n+        explicit Context(std::string_view descr) : m_test_description(descr)\n+        {\n+            SetupKeys();\n+\n+            // For Taproot v1 force SegWit version 1\n+            m_scriptPubKey << OP_1;\n+        }\n+\n+        const std::string m_test_description;\n+\n+        bool m_p2sh_wrapped = false;\n+        CScript m_scriptPubKey;\n+        unsigned int m_hash_type = SIGHASH_DEFAULT;\n+        valtype m_annex;\n+        std::vector<valtype> m_initial_witness_stack;\n+        valtype m_witness_signature;\n+        bool m_witness_init = false;\n+        CScriptWitness m_witness;\n+        CScript m_tapscript;\n+        bool m_control_block_init = false;\n+        valtype m_control_block;\n+        unsigned int m_leaf_version = 0;\n+        unsigned int m_pubkey_parity = 0;\n+        valtype m_taproot_internal_key;\n+        valtype m_control_block_field;\n+        unsigned int m_flags = 0;\n+        CHECKER_VALIDATION m_checker_validation = CHECKER_VALIDATION::ALWAYS_FAILS;\n+\n+        int64_t m_caller_line = 0;\n+        bool m_result = false;\n+        ScriptError m_serror = SCRIPT_ERR_OK;\n+        bool m_checker_was_called = false;\n+\n+        //\n+        // N.B.: Some methods herein temporarily marked [[maybe_unused]]\n+        // until the Tapscript tests get written\n+        //\n+\n+        Context& SetValidPublicKey()\n+        {\n+            m_scriptPubKey << m_pub;\n+            return *this;\n+        }\n+\n+        [[maybe_unused]] Context& SetPublicKey(valtype key)\n+        {\n+            BOOST_TEST(key.size() == 32);\n+            m_scriptPubKey << key;\n+            return *this;\n+        }\n+\n+        Context& SetNBytePublicKey(size_t n)\n+        {\n+            valtype pub(n, 0xAB);\n+            m_scriptPubKey << pub;\n+            return *this;\n+        }\n+\n+        Context& SetSignatureAnnex(const valtype& annex_without_suffix)\n+        {\n+            m_annex.push_back(0x50); // by definition of annex\n+            m_annex.insert(m_annex.end(), annex_without_suffix.begin(), annex_without_suffix.end());\n+            return *this;\n+        }\n+\n+        // Used to directly set a witness (presumably, invalid for Taproot key path spending)\n+        Context& SetWitness(const std::vector<valtype>& witness)\n+        {\n+            m_witness_init = true;\n+            m_witness.stack = witness;\n+            return *this;\n+        }\n+\n+        [[maybe_unused]] Context& PushToWitnessStack(const valtype& v)\n+        {\n+            m_initial_witness_stack.push_back(v);\n+            return *this;\n+        }\n+\n+        Context& SetValidSignatureInWitness(unsigned char hash_type = SIGHASH_DEFAULT)\n+        {\n+            m_hash_type = hash_type;\n+            m_witness_signature = m_sig;\n+            if (hash_type) m_witness_signature.push_back(hash_type);",
      "path": "src/test/script_tapscript_tests.cpp",
      "position": 1280,
      "original_position": 1280,
      "commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "original_commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "in_reply_to_id": null,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin/bitcoin/pull/25097/commits/eeefec343592c6de85048e3b055ba49755cfb072\r\n\r\nIf you wind up having to retouch this commit, I might advise changing `if (hash_type)` to `if (hash_type != SIGHASH_DEFAULT)` here and below; to me it's a little clearer and less tricky... I had to verify that SIGHASH_DEFAULT would evaluate to false in this context.",
      "created_at": "2022-07-12T19:42:17Z",
      "updated_at": "2022-07-12T20:25:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r919349029",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/919349029"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1280,
      "original_line": 1280,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/919374256",
      "pull_request_review_id": 1036328057,
      "id": 919374256,
      "node_id": "PRRC_kwDOABII5842zImw",
      "diff_hunk": "@@ -0,0 +1,1711 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+// TODO: Don't know whether Taproot/Tapscript tests should be exercising\n+// `libconsensus` the way the tests in `script_tests` do\n+\n+#include <core_io.h>\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <script/script_error.h>\n+#include <span.h>\n+#include <test/util/boost_test_boosts.h>\n+#include <test/util/pretty_data.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/transaction_utils.h>\n+#include <test/util/vector.h>\n+#include <univalue.h>\n+#include <util/strencodings.h>\n+\n+#include <boost/test/execution_monitor.hpp>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <array>\n+#include <charconv>\n+#include <cstddef>\n+#include <iomanip>\n+#include <iterator>\n+#include <limits>\n+#include <ostream>\n+#include <set>\n+#include <stdexcept>\n+#include <string>\n+#include <string_view>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+using namespace std::literals::string_literals;\n+using namespace std::literals::string_view_literals;\n+using namespace test::util::literals;\n+\n+namespace {\n+\n+typedef std::vector<unsigned char> valtype;\n+\n+/**\n+ * Value/Name pair used in data-driven tests\n+ */\n+template <typename V>\n+struct vn_pair {\n+    vn_pair(V value, std::string_view name) : m_value(value), m_name(name) {}\n+\n+    const V m_value;\n+    const std::string_view m_name;\n+};\n+\n+/**\n+ * Sequence of value/name pairs used in data-driven tests\n+ */\n+template <typename V>\n+using vn_sequence = std::vector<vn_pair<V>>;\n+\n+/**\n+ * Invokes undefined behavior.  See `std::unreachable` in C++23.\n+ */\n+[[noreturn]] inline void declare_unreachable()\n+{\n+#ifdef _MSC_VER\n+    __assume(false);\n+#else\n+    // Assume all other compilers than MSVC implement this GCC builtin.\n+    __builtin_unreachable();\n+#endif\n+}\n+\n+/**\n+ * Representation changer to fill an integral type with a known pattern.\n+ *\n+ * Pattern is successive byte values given a starting point.  Endianness doesn't\n+ * matter.\n+ */\n+union FillWithPattern {\n+    uint256 u256{0};\n+    uint64_t u64raw[sizeof(uint256) / sizeof(uint64_t)];\n+    uint32_t u32[sizeof(uint256) / sizeof(uint32_t)];\n+    int32_t i32[sizeof(uint256) / sizeof(int32_t)];\n+    uint8_t u8[sizeof(uint256)];\n+\n+    constexpr FillWithPattern(uint8_t start)\n+    {\n+        for (auto it = std::begin(u8); it != std::end(u8); ++it) {\n+            *it = start++;\n+        }\n+    }\n+\n+    uint64_t u64() const\n+    {\n+        // It is desirable to force high bit off\n+        return u64raw[0] & static_cast<uint64_t>(std::numeric_limits<int64_t>::max());\n+    }\n+};\n+\n+/**\n+ * The two possible actions for our mock signature checker\n+ */\n+enum class CHECKER_VALIDATION { ALWAYS_SUCCEEDS,\n+                                ALWAYS_FAILS };\n+\n+/**\n+ * For these tests don't need _real_ signature/pubkey validation.  That is\n+ * tested elsewhere.  So we just _mock_ the signature checker and force it\n+ * to answer valid/invalid as we wish.\n+ */\n+class SignatureCheckerMock : public BaseSignatureChecker\n+{\n+    //! What kind of mock checker is this?\n+    CHECKER_VALIDATION m_kind = CHECKER_VALIDATION::ALWAYS_FAILS;\n+\n+    //! True _iff_ CheckSchnorrSignature was actually called\n+    mutable bool m_was_called = false;\n+\n+public:\n+    //! Whether this mock always validates, or always fails, the signature/pubkey check.\n+    explicit SignatureCheckerMock(CHECKER_VALIDATION kind) : m_kind(kind) {}\n+\n+    //! Mocks the actual checking of the validity of the Schnorr signature by always succeeding or always failing\n+    bool CheckSchnorrSignature(Span<const unsigned char> sig,\n+                               Span<const unsigned char> pubkey,\n+                               SigVersion sigversion,\n+                               ScriptExecutionData& execdata,\n+                               ScriptError* serror = nullptr) const override\n+    {\n+        m_was_called = true;\n+        switch (m_kind) {\n+        case CHECKER_VALIDATION::ALWAYS_SUCCEEDS:\n+            if (serror) *serror = SCRIPT_ERR_OK;\n+            return true;\n+\n+        case CHECKER_VALIDATION::ALWAYS_FAILS:\n+            if (serror) *serror = SCRIPT_ERR_SCHNORR_SIG;\n+            return false;\n+        }\n+        declare_unreachable();\n+    }\n+\n+    bool CheckerWasCalled() const\n+    {\n+        return m_was_called;\n+    }\n+};\n+\n+} // namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(script_tapscript_tests, BasicTestingSetup)\n+\n+/**\n+ * Testing EvalScript OP_CHECKSIGADD branch and EvalChecksigTapscript, both in\n+ * interpreter.cpp, against the BIP342 \"Rules for signature opcodes\".\n+ */\n+BOOST_AUTO_TEST_CASE(eval_checksigadd_basic_checks)\n+{\n+    const valtype SIG_64BYTES(64, 0); // N.B.: Must be () not {}!\n+    const valtype SIG_65BYTES(65, 0);\n+    const valtype SIG_EMPTY{};\n+\n+    const valtype PUBKEY_32BYTES(32, 0);\n+    const valtype PUBKEY_15BYTES(15, 0);\n+    const valtype PUBKEY_EMPTY{};\n+\n+    constexpr int64_t TEST_NUM = 10;\n+\n+    constexpr int64_t START_VALIDATION_WEIGHT{90};\n+    constexpr int64_t BIP342_SIGOPS_LIMIT{50};\n+    constexpr int64_t END_VALIDATION_WEIGHT{START_VALIDATION_WEIGHT - BIP342_SIGOPS_LIMIT};\n+\n+    /**\n+     * A fluent API for running these tests.\n+     *\n+     * (Easiest way to understand this class is to look at the actual tests\n+     * that follow in this function.)\n+     */\n+    struct Context {\n+        explicit Context(std::string_view descr) : m_test_description(descr)\n+        {\n+            m_execdata.m_validation_weight_left_init = true;\n+            m_execdata.m_validation_weight_left = START_VALIDATION_WEIGHT;\n+        }\n+\n+        std::string m_test_description;\n+        SigVersion m_sig_version = SigVersion::TAPSCRIPT;\n+        uint32_t m_flags = 0;\n+        CScript m_script;\n+        ScriptError m_err = SCRIPT_ERR_OK;\n+        std::vector<valtype> m_stack;\n+        ScriptExecutionData m_execdata;\n+        CHECKER_VALIDATION m_kind;\n+        bool m_sigchecker_was_called = false;\n+        int64_t m_caller_line = 0;\n+        bool m_result = false;\n+\n+        Context& SetVersion(SigVersion v)\n+        {\n+            m_sig_version = v;\n+            return *this;\n+        }\n+\n+        Context& SetChecker(CHECKER_VALIDATION kind)\n+        {\n+            m_kind = kind;\n+            return *this;\n+        }\n+\n+        Context& SetRemainingWeight(int64_t w)\n+        {\n+            m_execdata.m_validation_weight_left = w;\n+            return *this;\n+        }\n+\n+        Context& AddFlags(uint32_t f)\n+        {\n+            m_flags |= f;\n+            return *this;\n+        }\n+\n+        CScript& SetScript()\n+        {\n+            return m_script;\n+        }\n+\n+        Context& DoTest(int64_t line)\n+        {\n+            SignatureCheckerMock checker_mock(m_kind);\n+            m_caller_line = line;\n+            m_result = EvalScript(m_stack, m_script,\n+                                  SCRIPT_VERIFY_TAPROOT | m_flags,\n+                                  checker_mock,\n+                                  m_sig_version,\n+                                  m_execdata,\n+                                  &m_err);\n+            m_sigchecker_was_called = checker_mock.CheckerWasCalled();\n+            return *this;\n+        }\n+\n+        Context& CheckCallSucceeded()\n+        {\n+            BOOST_CHECK_MESSAGE(m_result,\n+                                Descr()\n+                                    << \": EvalScript succeeded, as expected\");\n+            BOOST_CHECK_MESSAGE(m_err == SCRIPT_ERR_OK,\n+                                Descr()\n+                                    << \": Error code expected OK, actual was \"\n+                                    << ScriptErrorString(m_err));\n+            return *this;\n+        }\n+\n+        Context& CheckCallFailed(ScriptError expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!m_result,\n+                                Descr()\n+                                    << \": EvalScript failed, as expected\");\n+            BOOST_CHECK_MESSAGE(m_err == expected,\n+                                Descr()\n+                                    << \": Error code expected \" << ScriptErrorString(expected)\n+                                    << \", actual was \" << ScriptErrorString(m_err));\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(m_sigchecker_was_called,\n+                                Descr() << \": CheckSchnorrSignature was called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasNotValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(!m_sigchecker_was_called,\n+                                Descr() << \": CheckSchnorrSignature was not called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckRemainingValidationWeight(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(m_execdata.m_validation_weight_left == expected,\n+                                Descr()\n+                                    << \": Remaining validation weight expected \"\n+                                    << expected << \", actual was \"\n+                                    << m_execdata.m_validation_weight_left);\n+            return *this;\n+        }\n+\n+        Context& CheckStackDepth(std::size_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(m_stack.size() == expected,\n+                                Descr()\n+                                    << \": Stack depth expected \" << expected\n+                                    << \", actual was \" << m_stack.size());\n+            return *this;\n+        }\n+\n+        Context& CheckTOS(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!m_stack.empty(),\n+                                Descr()\n+                                    << \": Stack expected at least one item, actually was empty\");\n+            const int64_t actual = CScriptNum(m_stack.at(0), false).GetInt64();\n+            BOOST_CHECK_MESSAGE(expected == actual,\n+                                Descr()\n+                                    << \": Top-of-stack expected \" << expected\n+                                    << \", actual was \" << actual);\n+            return *this;\n+        }\n+\n+    private:\n+        std::string Descr()\n+        {\n+            std::string descr;\n+            descr.reserve(m_test_description.size() + 20);\n+            descr += m_test_description;\n+            descr += \" (@\";\n+            descr += as_string(m_caller_line);\n+            descr += \")\";\n+            return descr;\n+        }\n+    };\n+\n+    {\n+        Context ctx(\"SigVersion must not be BASE\");\n+        ctx.SetVersion(SigVersion::BASE).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"SigVersion must not be WITNESS_V0\");\n+        ctx.SetVersion(SigVersion::WITNESS_V0).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Minimum stack height 3 for OP_CHECKSIGADD\");\n+        ctx.SetScript()\n+            << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_INVALID_STACK_OPERATION)\n+            .CheckStackDepth(2);\n+    }\n+\n+    {\n+        Context ctx(\"`n` (2nd arg) size > 4 must fail\");\n+        // This is probably meant to be a check on the _encoding_ - that it is\n+        // minimal, but it can also be a check on the _value_.  BIP342 doesn't\n+        // say which.  Could be both...\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(10000000000LL) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            // (IMO this is an _unsatisfactory_ error code to return for a required\n+            // BIP342 check, but see the `catch` clause in `EvalScript`)\n+            .CheckCallFailed(SCRIPT_ERR_UNKNOWN_ERROR)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Insufficient validation weight remaining\");\n+        ctx.SetRemainingWeight(BIP342_SIGOPS_LIMIT - 1)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + 32byte pubkey skips validation\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + non32byte pubkey skips validation\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey ('unknown pubkey type') _with_ discourage flag fails\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .AddFlags(SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .CheckSignatureWasNotValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation failure forced\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_FAILS)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_SCHNORR_SIG)\n+            .CheckSignatureWasValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation success forced\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasValidated()\n+            .CheckRemainingValidationWeight(END_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM + 1);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey + empty sig with validation success forced\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_failure_cases)\n+{\n+    // As defined by BIP-341 Signature Validation Rules\n+    // Here we pick an acceptable SigVersion\n+    const SigVersion sigversion = SigVersion::TAPROOT;\n+\n+    CMutableTransaction tx_to_m;\n+    tx_to_m.vin.push_back(CTxIn());\n+    const uint32_t in_pos{0};\n+\n+    PrecomputedTransactionData cache;\n+    cache.m_bip341_taproot_ready = true;\n+    cache.m_spent_outputs_ready = true;\n+\n+    ScriptExecutionData execdata;\n+    execdata.m_annex_init = true;\n+    execdata.m_annex_present = false;\n+    execdata.m_annex_hash = uint256::ZERO;\n+    execdata.m_tapleaf_hash_init = false;\n+    execdata.m_codeseparator_pos_init = true;\n+\n+    uint256 hash_out{0};\n+\n+    {\n+        // Check all invalid hash_type codes rejected\n+        const std::set<uint8_t> allowable_hash_types{0x00, 0x01, 0x02, 0x03, 0x81, 0x82, 0x83};\n+        for (unsigned ht = 0; ht <= 255; ht++) {\n+            const uint8_t hash_type = static_cast<uint8_t>(ht);\n+            if (allowable_hash_types.find(hash_type) != allowable_hash_types.end()) continue;\n+\n+            BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m, in_pos,\n+                                                      hash_type, sigversion, cache,\n+                                                      MissingDataBehavior::FAIL),\n+                                \"hash_type = \" << Hex(hash_type) << \" expected to fail\");\n+        }\n+    }\n+\n+    {\n+        // Check that if hash_type == SIGHASH_SINGLE then missing a \"corresponding\n+        // output\" fails.\n+        CMutableTransaction tx_to_m;\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+\n+        uint8_t in_pos = 1;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(1) > #tx_to==0 is expected to fail\");\n+\n+        tx_to_m.vout.push_back(CTxOut());\n+        in_pos = 2;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(2) > #tx_to==1 is expected to fail\");\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_all_success_paths)\n+{\n+    // Our approach here will be to follow BIP-341's signature algorithm (with\n+    // the BIP-342 extension) doing two things at once:\n+    //   1) We'll set up the input arguments to `SignatureHashSchnorr` function\n+    //      being tested, _and_\n+    //   2) we'll _compute the hash of those fields ourselves_ exaxctly as\n+    //      it is described in BIP-341 and BIP-342.\n+    // Then we can compare the two.  We'll do this in a data-driven way for each\n+    // of the different scenarios that the algorithm supports.\n+    //\n+    // In this way this test achieves 100% _path_ coverage of `SignatureHashSchnorr`\n+    // (not just 100% _branch_ coverage).\n+    // - Sadly, this isn't shown in the `lcov` reports.  There are still a few\n+    //   red `-` marks left.  This is because:\n+    //   1. `lcov` wasn't designed to handle death tests.\n+    //   2. ??? Some other unknown reasons, possibly due to the instrumentation,\n+    //      possibly due to `lcov` limitations.  You can see by the test output\n+    //      (`-log_level=all`) or within a debugger that in fact _all_ branches\n+    //      are taken when executing all the tests in this file.\n+\n+    // Here we define, and then generate, all combinations of the alternatives\n+    // for the parameters that vary the signature combination algorithm\n+\n+    const vn_sequence<SigVersion> SigVersion_alternatives{\n+        {SigVersion::TAPROOT, \"TAPROOT\"sv},\n+        {SigVersion::TAPSCRIPT, \"TAPSCRIPT\"sv}};\n+\n+    const vn_sequence<uint32_t> hash_type_output_alternatives{\n+        {SIGHASH_DEFAULT, \"SIGHASH_DEFAULT\"sv},\n+        {SIGHASH_ALL, \"SIGHASH_ALL\"sv},\n+        {SIGHASH_NONE, \"SIGHASH_NONE\"sv},\n+        {SIGHASH_SINGLE, \"SIGHASH_SINGLE\"sv}};\n+\n+    const vn_sequence<uint32_t> hash_type_input_alternatives{\n+        {0, \"N/A\"sv},\n+        {SIGHASH_ANYONECANPAY, \"SIGHASH_ANYONECANPAY\"sv}};\n+\n+    const vn_sequence<uint8_t> annex_alternatives{\n+        {0, \"no annex\"sv},\n+        {1, \"annex present\"sv}};\n+\n+    const vn_sequence<bool> output_hash_alternatives{\n+        {false, \"output hash missing\"sv},\n+        {true, \"output hash provided\"sv}};\n+\n+    for (const auto& sigversion_alternative : SigVersion_alternatives)\n+        for (const auto& hash_type_output_alternative : hash_type_output_alternatives)\n+            for (const auto& hash_type_input_alternative : hash_type_input_alternatives)\n+                for (const auto& annex_alternative : annex_alternatives)\n+                    for (const auto& output_hash_alternative : output_hash_alternatives) {\n+                        // Exclude the invalid combination of SIGHASH_DEFAULT with SIGHASH_ANYONECANPAY\n+                        if (hash_type_output_alternative.m_value == SIGHASH_DEFAULT && hash_type_input_alternative.m_value == SIGHASH_ANYONECANPAY) continue;\n+\n+                        // We're going to want to know which scenario it is if a check actually\n+                        // fails ...\n+                        std::string scenario_description;\n+                        {\n+                            std::ostringstream oss;\n+                            oss << sigversion_alternative.m_name << \", \"\n+                                << hash_type_output_alternative.m_name << \", \"\n+                                << hash_type_input_alternative.m_name << \", \"\n+                                << annex_alternative.m_name << \", \"\n+                                << output_hash_alternative.m_name;\n+                            scenario_description = oss.str();\n+                        }\n+\n+                        // Set up the scenario we're running now - these 4 variables define the scenario\n+                        const SigVersion sigversion{sigversion_alternative.m_value};\n+                        const uint8_t hash_type{static_cast<uint8_t>(hash_type_output_alternative.m_value | hash_type_input_alternative.m_value)};\n+                        const uint8_t annex_present{annex_alternative.m_value};\n+                        const bool have_output_hash{output_hash_alternative.m_value};\n+\n+                        // Compute some helper values that depend on scenario\n+                        const uint8_t ext_flag{sigversion == SigVersion::TAPSCRIPT};\n+                        const uint8_t hash_input_type{static_cast<uint8_t>(hash_type & SIGHASH_INPUT_MASK)};\n+                        const uint8_t hash_output_type{static_cast<uint8_t>((hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK))};\n+                        const uint8_t spend_type = (ext_flag * 2) + annex_present;\n+\n+                        // Fixed values (by algorithm)\n+                        const uint8_t epoch{0x00};\n+                        const uint8_t key_version{0};\n+\n+                        // Mocked values fixed for purposes of this unit test.  This is a long\n+                        // list of crufty things but that's because `SignatureHashSchnorr`, the\n+                        // function being tested, takes as arguments not just the transaction\n+                        // being signed (plus control data) but also some _precomputed values_\n+                        // in two different structs: `PrecomputedTransactionData`, and\n+                        // `ScriptExecutionData`.  On the one hand this is nice because a lot\n+                        // of complexity of the signature algorithm doesn't have to be duplicated\n+                        // here in this test: we can just use mocked values.  On the other hand,\n+                        // there's a lot of icky setup to do to get all the values in the right\n+                        // places both for our \"by the book\" implementation and to be set up to\n+                        // call `SignatureHashSchnorr`.\n+                        //\n+                        // Try to make things simpler by at least using the same names for the\n+                        // setup variables as for the fields in the parameter structs.\n+\n+                        const uint32_t in_pos{1};\n+                        const int32_t tx_version{FillWithPattern(0x01).i32[0]};\n+                        const uint32_t tx_lock_time{FillWithPattern(0x05).u32[0]};\n+                        const uint256 prevouts_single_hash{FillWithPattern(0x10).u256};\n+                        const uint256 spent_amounts_single_hash{FillWithPattern(0x18).u256};\n+                        const uint256 spent_scripts_single_hash{FillWithPattern(0x20).u256};\n+                        const uint256 sequences_single_hash{FillWithPattern(0x28).u256};\n+                        const uint256 outputs_single_hash{FillWithPattern(0x30).u256};\n+                        const uint256 output_hash{FillWithPattern(0x40).u256};\n+                        const uint256 annex_hash{FillWithPattern(0x48).u256};\n+                        const uint256 tapleaf_hash{FillWithPattern(0x50).u256};\n+                        const uint32_t codeseparator_pos{FillWithPattern(0x58).u32[0]};\n+                        const COutPoint tx_input_at_pos_prevout{FillWithPattern(0x60).u256,\n+                                                                FillWithPattern(0x68).u32[0]};\n+                        const uint32_t tx_input_at_pos_nsequence{FillWithPattern(0x70).u32[0]};\n+                        CTxOut spent_output_at_pos;\n+                        spent_output_at_pos.nValue = FillWithPattern(0x80).u64();\n+                        spent_output_at_pos.scriptPubKey /*random script, not even valid*/\n+                            << OP_DUP << OP_HASH160 << OP_EQUALVERIFY << OP_CHECKSIG;\n+                        CTxOut tx_output_at_pos;\n+                        tx_output_at_pos.nValue = FillWithPattern(0x90).u64();\n+                        tx_output_at_pos.scriptPubKey /*random script, not even valid*/\n+                            << OP_CHECKSIG << OP_EQUALVERIFY << OP_HASH160 << OP_DUP;\n+\n+                        // Now set up the arguments that are going to be passed to\n+                        // `SignatureHashSchnorr`\n+\n+                        CMutableTransaction tx_to;\n+                        tx_to.nVersion = tx_version;\n+                        tx_to.nLockTime = tx_lock_time;\n+                        for (uint32_t i = 0; i < in_pos + 2; i++) {\n+                            tx_to.vin.push_back(CTxIn());\n+                            tx_to.vout.push_back(CTxOut());\n+                        }\n+                        tx_to.vin[in_pos].prevout = tx_input_at_pos_prevout;\n+                        tx_to.vin[in_pos].nSequence = tx_input_at_pos_nsequence;\n+                        tx_to.vout[in_pos] = tx_output_at_pos;\n+\n+                        PrecomputedTransactionData cache;\n+                        cache.m_bip341_taproot_ready = true;\n+                        cache.m_prevouts_single_hash = prevouts_single_hash;\n+                        cache.m_spent_amounts_single_hash = spent_amounts_single_hash;\n+                        cache.m_spent_scripts_single_hash = spent_scripts_single_hash;\n+                        cache.m_sequences_single_hash = sequences_single_hash;\n+                        cache.m_spent_outputs_ready = true;\n+                        for (uint32_t i = 0; i < in_pos + 2; i++) {\n+                            cache.m_spent_outputs.push_back(CTxOut());\n+                        }\n+                        cache.m_spent_outputs[in_pos] = spent_output_at_pos;\n+                        cache.m_outputs_single_hash = outputs_single_hash;\n+\n+                        ScriptExecutionData execdata;\n+                        execdata.m_annex_init = true;\n+                        execdata.m_annex_present = !!annex_present;\n+                        execdata.m_annex_hash = annex_hash;\n+                        execdata.m_output_hash.reset();\n+                        if (have_output_hash) {\n+                            execdata.m_output_hash = output_hash;\n+                        }\n+                        if (sigversion == SigVersion::TAPSCRIPT) {\n+                            execdata.m_tapleaf_hash_init = true;\n+                            execdata.m_tapleaf_hash = tapleaf_hash;\n+                            execdata.m_codeseparator_pos_init = true;\n+                            execdata.m_codeseparator_pos = codeseparator_pos;\n+                        }\n+\n+                        // Now here is where we take all that data - _not_ the arguments to\n+                        // `SignatureHashSchnorr` but all the scenario parameters, the helpers,\n+                        // the values fixed by the algorithm, and our mocked values, and actually\n+                        // follow the BIP-341/BIP-342 signature calculation algorithm right from\n+                        // the spec ...\n+\n+                        // Start with a tagged hasher with the correct tag\n+                        CHashWriter hasher = TaggedHash(\"TapSighash\");\n+\n+                        // First byte to hash is always the \"epoch\", 0x00 (BIP-341, footnote 20)\n+                        hasher << epoch;\n+\n+                        // Next: hash_type (1 byte)\n+                        hasher << hash_type;\n+\n+                        // Next: transaction version (4 bytes)\n+                        hasher << tx_version;\n+\n+                        // Next: transaction lock time (4 bytes)\n+                        hasher << tx_lock_time;\n+\n+                        // Next if _not_ SIGHASH_ANYONECANPAY:\n+                        // a) SHA256 of the serialization of all input outpoints (32 bytes)\n+                        // b) SHA256 of the serialization of all spent output amounts (32 bytes)\n+                        // c) SHA256 of the serialization of all spent outputs' _scriptPubKeys_\n+                        //    serialized as script (32 bytes)\n+                        // d) SHA256 of the serialization of all input `nSequence` (32 bytes)\n+                        if (hash_input_type != SIGHASH_ANYONECANPAY) {\n+                            hasher << prevouts_single_hash;\n+                            hasher << spent_amounts_single_hash;\n+                            hasher << spent_scripts_single_hash;\n+                            hasher << sequences_single_hash;\n+                        }\n+\n+                        // Next if _not_ SIGHASH_NONE _and not_ SIGHASH_SINGLE:\n+                        // SHA256 of the serialization of all outputs in CTxOut format (32 bytes)\n+                        if (hash_output_type != SIGHASH_NONE && hash_output_type != SIGHASH_SINGLE) {\n+                            hasher << outputs_single_hash;\n+                        }\n+\n+                        // Now, data about input/prevout being spent\n+\n+                        // The \"spend_type\" (1 byte) which is a function of ext_flag (above) and\n+                        // whether there is an annex present (here: no)\n+                        hasher << spend_type;\n+\n+                        // Here, if we are _not_ SIGHASH_ANYONECANPAY, we just add the index of\n+                        // the input in the transaction input vector (4 bytes). There must be a\n+                        // input transaction at this index but _in this scenario_ it doesn't have\n+                        // to have any data (it is never inspected).  Same for output transactions.\n+                        //\n+                        // On the other hand, if we _are_ SIGHASH_ANYONECANPAY, then we add the\n+                        // `COutPoint` of this input (36 bytes), the value of the previous\n+                        // output spent by this input (8 bytes), the `ScriptPubKey` of the\n+                        // previous output spent by this input (35 bytes), and the `nSequence`\n+                        // of this input.  These values are all precomputed and made available\n+                        // to `SignatureHashSchnorr` in the `PrecomputedTransactionData` struct.\n+                        if (hash_input_type == SIGHASH_ANYONECANPAY) {\n+                            hasher << tx_input_at_pos_prevout;\n+                            hasher << spent_output_at_pos.nValue;\n+                            hasher << spent_output_at_pos.scriptPubKey;\n+                            hasher << tx_input_at_pos_nsequence;\n+                        } else {\n+                            hasher << in_pos;\n+                        }\n+\n+                        // Now, if there is an \"annex\", add its hash (32 byte).  This is\n+                        // precomputed and we don't actually have to have an actual annex to\n+                        // pass in to `SignatureHashSchnorr`, nor do we have to hash it.\n+                        if (annex_present) {\n+                            hasher << annex_hash;\n+                        }\n+\n+                        // Here, iff the hash type is `SIGHASH_SINGLE`, add the hash of the\n+                        // corresponding transaction output (32 bytes).  The wrinkle here is that\n+                        // (for some reason) _sometimes_ this hash is precomputed, and _sometimes_\n+                        // it is _not_.  So `SignatureHashSchnorr` will either use it if it is\n+                        // provided or compute it from the corresponding output itself. (For our\n+                        // purposes in this test the output need not be valid - it just must be\n+                        // present.)\n+                        if (hash_output_type == SIGHASH_SINGLE) {\n+                            if (!have_output_hash) {\n+                                CHashWriter hasher2(SER_GETHASH, 0);\n+                                hasher2 << tx_output_at_pos;\n+                                hasher << hasher2.GetSHA256();\n+                            } else {\n+                                hasher << output_hash;\n+                            }\n+                        }\n+\n+                        // This is the TAPSCRIPT extension from BIP-342.  If the version is\n+                        // TAPSCRIPT then add the tapleaf hash (32 bytes), the key_version (1\n+                        // byte, fixed value of 0x00), and the \"opcode position of the last\n+                        // executed OP_CODESEPARATOR before the currently executed signature\n+                        // opcode\" (4 bytes).  The tapleaf hash and the code separator position\n+                        // are both precomputed values.\n+                        if (sigversion == SigVersion::TAPSCRIPT) {\n+                            hasher << tapleaf_hash;\n+                            hasher << key_version;\n+                            hasher << codeseparator_pos;\n+                        }\n+\n+                        // That's all that goes into the hasher for this signature\n+                        const uint256 expected_hash_out = hasher.GetSHA256();\n+\n+                        // Now, _finally_, we test the actual implemented algorithm under test:\n+                        uint256 actual_hash_out{0};\n+                        BOOST_TEST(SignatureHashSchnorr(actual_hash_out,\n+                                                        execdata, tx_to, in_pos,\n+                                                        hash_type, sigversion, cache,\n+                                                        MissingDataBehavior::FAIL),\n+                                   \"Scenario: \" << scenario_description);\n+                        BOOST_TEST(expected_hash_out == actual_hash_out,\n+                                   \"Scenario: \" << scenario_description\n+                                                << \" - expected \" << expected_hash_out.ToString()\n+                                                << \" == actual \" << actual_hash_out.ToString());\n+                    }\n+}\n+\n+namespace {\n+\n+// Valid Schnoor (pubkey, msg, signature) tuples (copied from `key_tests.cpp`)\n+\n+struct SchnorrTriplet {\n+    SchnorrTriplet(std::string pubkey, std::string sighash, std::string sig)\n+        : m_pubkey(ParseHex(pubkey)), m_sighash(uint256(ParseHex(sighash))), m_sig(ParseHex(sig)) {}\n+    valtype m_pubkey;\n+    uint256 m_sighash;\n+    valtype m_sig;\n+};\n+\n+static const std::vector<SchnorrTriplet> SCHNORR_TRIPLETS = {\n+    {\"F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9\", \"0000000000000000000000000000000000000000000000000000000000000000\", \"E907831F80848D1069A5371B402410364BDF1C5F8307B0084C55F1CE2DCA821525F66A4A85EA8B71E482A74F382D2CE5EBEEE8FDB2172F477DF4900D310536C0\"},\n+    {\"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659\", \"243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89\", \"6896BD60EEAE296DB48A229FF71DFE071BDE413E6D43F917DC8DCF8C78DE33418906D11AC976ABCCB20B091292BFF4EA897EFCB639EA871CFA95F6DE339E4B0A\"},\n+    {\"DD308AFEC5777E13121FA72B9CC1B7CC0139715309B086C960E18FD969774EB8\", \"7E2D58D8B3BCDF1ABADEC7829054F90DDA9805AAB56C77333024B9D0A508B75C\", \"5831AAEED7B44BB74E5EAB94BA9D4294C49BCF2A60728D8B4C200F50DD313C1BAB745879A5AD954A72C45A91C3A51D3C7ADEA98D82F8481E0E1E03674A6F3FB7\"},\n+    {\"25D1DFF95105F5253C4022F628A996AD3A0D95FBF21D468A1B33F8C160D8F517\", \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", \"7EB0509757E246F19449885651611CB965ECC1A187DD51B64FDA1EDC9637D5EC97582B9CB13DB3933705B32BA982AF5AF25FD78881EBB32771FC5922EFC66EA3\"},\n+    {\"D69C3509BB99E412E68B0FE8544E72837DFA30746D8BE2AA65975F29D22DC7B9\", \"4DF3C3F68FCC83B27E9D42C90431A72499F17875C81A599B566C9889B9696703\", \"00000000000000000000003B78CE563F89A0ED9414F5AA28AD0D96D6795F9C6376AFB1548AF603B3EB45C9F8207DEE1060CB71C04E80F593060B07D28308D7F4\"},\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(internal_test_validate_schnorr_testdata)\n+{\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(XOnlyPubKey(triplet.m_pubkey).VerifySchnorr(triplet.m_sighash, triplet.m_sig));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(verify_schnorr_signature)\n+{\n+    // Defeat, for test purposes, the protected access of\n+    // `GenericTransactionSignatureChecker::VerifySchnorrSignature`\n+    struct UnprotectedTransactionSignatureChecker : public MutableTransactionSignatureChecker {\n+        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;\n+        using MutableTransactionSignatureChecker::VerifySchnorrSignature;\n+    };\n+    UnprotectedTransactionSignatureChecker sut{nullptr, 0, {}, {}};\n+\n+    // Positive tests: triplets which verify\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(sut.VerifySchnorrSignature(triplet.m_sig,\n+                                              XOnlyPubKey{triplet.m_pubkey},\n+                                              triplet.m_sighash));\n+    }\n+\n+    // Negative tests: triplets which fail to verify (get these failing triplets\n+    // by modifying a valid triplet, one field at a time)\n+    auto diddle_front_byte = [](auto v) { v[0]++; return v; };\n+    auto& triplet = SCHNORR_TRIPLETS[0];\n+    BOOST_TEST(!sut.VerifySchnorrSignature(diddle_front_byte(triplet.m_sig),\n+                                           XOnlyPubKey{triplet.m_pubkey},\n+                                           triplet.m_sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.m_sig,\n+                                           XOnlyPubKey{diddle_front_byte(triplet.m_pubkey)},\n+                                           triplet.m_sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.m_sig,\n+                                           XOnlyPubKey{triplet.m_pubkey},\n+                                           uint256::ONE));\n+}\n+\n+BOOST_AUTO_TEST_CASE(check_schnorr_signature)\n+{\n+    // Provide, for test purposes, a subclass of `GenericTransactionsSignatureChecker`\n+    // that mocks `VerifySchnorrSignature` so we can more easily test\n+    // `CheckSchnorrSignature` without going to the trouble of having a valid\n+    // transaction (which is unnecessary for this _unit_ test.)\n+    struct MockVerifyingTransactionSignatureChecker : public MutableTransactionSignatureChecker {\n+        uint256 m_expected_sighash = []() {\n+            uint256 h{};\n+            // This is the known sighash of the Tx and input data we set up (precomputed)\n+            h.SetHex(\"f614d8ae6dcc49e2ca2ef1c03f93c7326189e5575d446e825e5a2700fb1cb83c\");\n+            return h;\n+        }();\n+\n+        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;\n+\n+        enum class if_as_expected_return { False,\n+                                           True };\n+        if_as_expected_return m_iae{if_as_expected_return::True};\n+        void SetExpectation(if_as_expected_return iaer) { m_iae = iaer; }\n+\n+        bool VerifySchnorrSignature(Span<const unsigned char> sig,\n+                                    const XOnlyPubKey& pubkey,\n+                                    const uint256& sighash) const override\n+        {\n+            // Following line used only to determine the known canned `expected_sighash` above:\n+            // BOOST_TEST_MESSAGE(\"MockVerifySchnorrSignature: sighash == \" << sighash.ToString());\n+\n+            bool as_expected = sighash == m_expected_sighash;\n+            if (m_iae == if_as_expected_return::True)\n+                return as_expected;\n+            else\n+                return !as_expected;\n+        };\n+    };\n+\n+    const auto triplet = SCHNORR_TRIPLETS[0];\n+    const CMutableTransaction txToIn{};\n+    ScriptExecutionData execdata{};\n+\n+    {\n+        // Signature must be 64 or 65 bytes long\n+        for (size_t i = 0; i <= 99; i++) {\n+            valtype testsig(i, i);\n+            if (testsig.size() == 64 || testsig.size() == 65) continue;\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_SIZE);\n+        }\n+    }\n+\n+    {\n+        // Iff signature is 65 bytes long last byte must **NOT** be SIGHASH_DEFAULT (0x00) per BIP-342\n+        {\n+            // Negative test: last byte _is_ SIGHASH_DEFAULT\n+            valtype testsig(65, 65);\n+            testsig.back() = SIGHASH_DEFAULT;\n+\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);\n+        }\n+        {\n+            // Negative tests: last byte is _not_ SIGHASH_DEFAULT, but we early exit _without changing\n+            // serror_ because we don't provide a txDataIn (🡄 this requires knowledge of how\n+            // `CheckSchnorrSignature` is written).\n+            for (size_t i = 1; i <= 255; i++) {\n+                valtype testsig(65, i);\n+\n+                MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+                ScriptError serror{SCRIPT_ERR_OK};\n+                BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));\n+                BOOST_TEST(serror == SCRIPT_ERR_OK);\n+            }\n+        }\n+    }\n+\n+    {\n+        // Now check that, given the parameters, if `SignatureHashSchnorr fails there's an error exit.\n+        // Otherwise, if it succeeds, it proceeds to call `VerifySchnorrSignature` and depending on\n+        // _that_ result `SignatureHashSchnorr` either succeeds or fails.\n+        //\n+        // We do this using the mocked `VerifySchnorrSignature` so we only need to pass parameters\n+        // that work with `SignatureHashSchnorr`, they don't _also_ have to validate with\n+        // `VerifySchnorrSignature`.\n+\n+        const uint32_t in_pos{0};\n+        CMutableTransaction txToIn{};\n+        txToIn.nVersion = 0;\n+        txToIn.nLockTime = 0;\n+        txToIn.vin.push_back(CTxIn());\n+        txToIn.vin[in_pos].prevout = COutPoint(uint256::ZERO, 0);\n+        txToIn.vin[in_pos].nSequence = 0;\n+        txToIn.vout.push_back(CTxOut());\n+\n+        PrecomputedTransactionData txDataIn{};\n+        txDataIn.m_bip341_taproot_ready = true;\n+        txDataIn.m_prevouts_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_amounts_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_scripts_single_hash = uint256::ZERO;\n+        txDataIn.m_sequences_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_outputs_ready = true;\n+        txDataIn.m_spent_outputs.push_back(CTxOut());\n+        txDataIn.m_spent_outputs[in_pos].nValue = 0;\n+        txDataIn.m_spent_outputs[in_pos].scriptPubKey << OP_DUP << OP_CHECKSIG;\n+        txDataIn.m_outputs_single_hash = uint256::ZERO;\n+\n+        ScriptExecutionData execdata{};\n+        execdata.m_annex_init = true;\n+        execdata.m_annex_present = true;\n+        execdata.m_annex_hash = uint256::ZERO;\n+        execdata.m_output_hash.reset();\n+\n+        {\n+            // Confirm that we can force `SignatureHashSchnorr` to fail (via an early exit)\n+            PrecomputedTransactionData txDataIn{};\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(triplet.m_sig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);\n+        }\n+\n+        {\n+            // Now `SignatureHashSchnorr` will return true but we'll fail `VerifySchnorrSignature`\n+            // and show it returns the correct error.\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            sut.SetExpectation(MockVerifyingTransactionSignatureChecker::if_as_expected_return::False);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(triplet.m_sig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG);\n+        }\n+\n+        {\n+            // Finally, same as previous, except we'll force `VerifySchnorrSignature` to succeed and\n+            // show now that `CheckSchnorrSignature` finally succeeds.\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            sut.SetExpectation(MockVerifyingTransactionSignatureChecker::if_as_expected_return::True);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(sut.CheckSchnorrSignature(triplet.m_sig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_OK);\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(compute_tapleaf_hash)\n+{\n+    // Try two examples, reimplementing the BIP-341 specification\n+    {\n+        uint8_t leaf_version = 0;\n+        CScript cs{};\n+        auto expected = (TaggedHash(\"TapLeaf\") << leaf_version << CScript()).GetSHA256();\n+        auto actual = ComputeTapleafHash(leaf_version, CScript());\n+        BOOST_TEST(expected == actual,\n+                   \"leaf version 0, empty CScript - expected \"\n+                       << expected.ToString() << \" actual \" << actual.ToString());\n+    }\n+\n+    {\n+        uint8_t leaf_version = 0x4a;\n+        CScript cs{};\n+        cs << OP_CHECKLOCKTIMEVERIFY << OP_CHECKSIGADD; // just a random CScript\n+        auto expected = (TaggedHash(\"TapLeaf\") << leaf_version << cs).GetSHA256();\n+        auto actual = ComputeTapleafHash(leaf_version, cs);\n+        BOOST_TEST(expected == actual,\n+                   \"leaf version 0x4A, CScript w/ 2 opcodes - expected \"\n+                       << expected.ToString() << \" actual \" << actual.ToString());\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(compute_taproot_merkle_root)\n+{\n+    using namespace test::util::vector_ops;\n+\n+    // Test by using a small enhancement to a `vector<unsigned char>` that makes\n+    // it easy to convert to/from strings so the tests are more easily readable,\n+    // and also adds directly the two necessary operations from BIP-340: byte\n+    // vector concatenation and byte vector select subrange.\n+\n+    // Use an arbitrary tapleaf hash throughout\n+    const uint256 tapleaf_hash1 = ComputeTapleafHash(0x10, CScript{} << OP_CHECKMULTISIG);\n+    const uint256 tapleaf_hash2 = ComputeTapleafHash(0x20, CScript{} << OP_CHECKSEQUENCEVERIFY);\n+\n+    //                         \".........|.........|.........|...\"      33 bytes\n+    const auto control_base1 = \"[point (#1) - 33 bytes of junk!!>\"_bv;\n+    const auto control_base2 = \"[point (#2) - 33 more bad bytes!>\"_bv;\n+    assert(control_base1.size() == 33 && control_base2.size() == 33);\n+\n+    // Nodes `node_low` and `node_high` are constructed to be _forced_ lower/higher\n+    // (respectively) than arbitrary hash.  This isn't exactly true, of course:\n+    // only the _first byte_ of these nodes are low or high.  If the first byte\n+    // of the \"arbitrary\" hash is `0x00` or `0xff` we've got a problem .. but\n+    // this isn't the case for this test data.\n+\n+    //                                     \".........|.........|.........|..\"       32 bytes\n+    const auto node_low = []() { auto r  = \"(this is node to-be-diddled low)\"_bv; r.front() = 0x00; return r; }();\n+    const auto node_high = []() { auto r = \"(this is nod to-be-diddled high)\"_bv; r.front() = 0xFF; return r; }();\n+    assert(node_low.size() == 32 && node_high.size() == 32);\n+\n+    assert(node_low < from_base_blob(tapleaf_hash1) && from_base_blob(tapleaf_hash1) < node_high);\n+    assert(node_low < from_base_blob(tapleaf_hash2) && from_base_blob(tapleaf_hash2) < node_high);\n+\n+    const CHashWriter hw_branch{TaggedHash(\"TapBranch\")};\n+\n+    {\n+        // Control block contains only the initial point, no nodes - always returns\n+        // the tapleaf hash, doesn't matter what the control block is\n+        uint256 expected1 = tapleaf_hash1;\n+        uint256 actual1a = ComputeTaprootMerkleRoot(control_base1, tapleaf_hash1);\n+        BOOST_TEST(expected1 == actual1a,\n+                   \"expected \" << HexStr(expected1) << \", actual \" << HexStr(actual1a));\n+        uint256 actual1b = ComputeTaprootMerkleRoot(control_base2, tapleaf_hash1);\n+        BOOST_TEST(expected1 == actual1b,\n+                   \"expected \" << HexStr(expected1) << \", actual \" << HexStr(actual1b));\n+        uint256 expected2 = tapleaf_hash2;\n+        uint256 actual2 = ComputeTaprootMerkleRoot(control_base2, tapleaf_hash2);\n+        BOOST_TEST(expected2 == actual2,\n+                   \"expected \" << HexStr(expected2) << \", actual \" << HexStr(actual2));\n+    }\n+\n+    {\n+        // Control block contains one node - check both lexicographic orders\n+\n+        {\n+            uint256 expected = (CHashWriter{hw_branch} << Span{node_low} << tapleaf_hash1).GetSHA256();\n+            uint256 actual = ComputeTaprootMerkleRoot(Span{control_base1 || node_low}, tapleaf_hash1);\n+            BOOST_TEST(expected == actual,\n+                    \"expected \" << HexStr(expected) << \", actual \" << HexStr(actual));\n+        }\n+        {\n+            uint256 expected = (CHashWriter{hw_branch} << tapleaf_hash1 << Span{node_high}).GetSHA256();\n+            uint256 actual = ComputeTaprootMerkleRoot(Span{control_base1 || node_high}, tapleaf_hash1);\n+            BOOST_TEST(expected == actual,\n+                    \"expected \" << HexStr(expected) << \", actual \" << HexStr(actual));\n+        }\n+    }\n+\n+    {\n+        // With a control block with more than one node (here: two nodes), each subsequent node\n+        // is hashed with the hash of the previous nodes in _lexicographic_ order.\n+\n+        // Control block is going to be `point1 || node_high || node_{low,high}`\n+        uint256 intermediate_k = (CHashWriter{hw_branch} << tapleaf_hash1 << Span{node_high}).GetSHA256();\n+\n+        // Verify that the intermediate hash is less than `node_high`\n+        assert(from_base_blob(intermediate_k) < node_high);\n+\n+        {\n+            // 2nd node lexicographically _less than_ intermediate hash\n+            uint256 expected = (CHashWriter{hw_branch} << Span{node_low} << intermediate_k).GetSHA256();\n+            uint256 actual = ComputeTaprootMerkleRoot(control_base1 || node_high || node_low, tapleaf_hash1);\n+            BOOST_TEST(expected == actual,\n+                    \"expected \" << HexStr(expected) << \", actual \" << HexStr(actual));\n+        }\n+\n+        {\n+            // 2nd node lexicographically _greater than_ intermediate hash\n+            uint256 expected = (CHashWriter{hw_branch} << intermediate_k << Span{node_high}).GetSHA256();\n+            uint256 actual = ComputeTaprootMerkleRoot(control_base1 || node_high || node_high, tapleaf_hash1);\n+            BOOST_TEST(expected == actual,\n+                    \"expected \" << HexStr(expected) << \", actual \" << HexStr(actual));\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(taproot_v1_verify_script)\n+{\n+    // Testing Taproot code paths in `VerifyWitnessProgram` and\n+    // `SigVersion::TAPSCRIPT` code paths in `ExecuteWitnessScript`.\n+\n+    // Both `VerifyWitnessProgram` and `ExecuteWitnessScript` are `static`\n+    // inside of `interpreter.cpp` and thus inaccessible to a unit test.\n+    // The way to get to them is indirectly via `VerifyScript`.\n+\n+    // Tests all success and failure paths mentioned in BIP-341 and\n+    // BIP-342.\n+\n+    // This is a _unit test_ not a _functional test_ and the unit being\n+    // tested here does _not_ include actually verifying the signature.\n+    // That is tested elsewhere (e.g., by tests `verify_schnorr_signature`\n+    // and `check_schnorr_signature` in this file).  _This_ test _mocks_\n+    // the Schnorr signature verfication.  Thus the test data need not\n+    // actually have valid signatures (and is thus easier to prepare).\n+\n+    /**\n+     * A fluent API for running these tests.  Swiped and adapted from\n+     * `script_tests.cpp`.\n+     *\n+     * (Easiest way to understand this class is to look at the actual tests\n+     * that follow in this function.)\n+     */\n+\n+    struct Context {\n+        // raw key data from `key_tests.cpp` @305\n+        valtype m_sec{ParseHex(\"0000000000000000000000000000000000000000000000000000000000000003\")};\n+        valtype m_pub{ParseHex(\"F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9\")};\n+        valtype m_sig{ParseHex(\"E907831F80848D1069A5371B402410364BDF1C5F8307B0084C55F1CE2DCA821525F66A4A85EA8B71E482A74F382D2CE5EBEEE8FDB2172F477DF4900D310536C0\")};\n+\n+        CKey m_sec_key;\n+        XOnlyPubKey m_pub_key;\n+\n+    private:\n+        void SetupKeys()\n+        {\n+            BOOST_TEST(m_sec.size() == 32);\n+            BOOST_TEST(m_pub.size() == 32);\n+            BOOST_TEST(m_sig.size() == 64);\n+\n+            m_sec_key.Set(m_sec.begin(), m_sec.end(), true /*compressed*/);\n+            m_pub_key = XOnlyPubKey(m_sec_key.GetPubKey());\n+\n+            BOOST_TEST(m_pub_key.IsFullyValid());\n+        }\n+\n+    public:\n+        explicit Context(std::string_view descr) : m_test_description(descr)\n+        {\n+            SetupKeys();\n+\n+            // For Taproot v1 force SegWit version 1\n+            m_scriptPubKey << OP_1;\n+        }\n+\n+        const std::string m_test_description;\n+\n+        bool m_p2sh_wrapped = false;\n+        CScript m_scriptPubKey;\n+        unsigned int m_hash_type = SIGHASH_DEFAULT;\n+        valtype m_annex;\n+        std::vector<valtype> m_initial_witness_stack;\n+        valtype m_witness_signature;\n+        bool m_witness_init = false;\n+        CScriptWitness m_witness;\n+        CScript m_tapscript;\n+        bool m_control_block_init = false;\n+        valtype m_control_block;\n+        unsigned int m_leaf_version = 0;\n+        unsigned int m_pubkey_parity = 0;\n+        valtype m_taproot_internal_key;\n+        valtype m_control_block_field;\n+        unsigned int m_flags = 0;\n+        CHECKER_VALIDATION m_checker_validation = CHECKER_VALIDATION::ALWAYS_FAILS;\n+\n+        int64_t m_caller_line = 0;\n+        bool m_result = false;\n+        ScriptError m_serror = SCRIPT_ERR_OK;\n+        bool m_checker_was_called = false;\n+\n+        //\n+        // N.B.: Some methods herein temporarily marked [[maybe_unused]]\n+        // until the Tapscript tests get written\n+        //\n+\n+        Context& SetValidPublicKey()\n+        {\n+            m_scriptPubKey << m_pub;\n+            return *this;\n+        }\n+\n+        [[maybe_unused]] Context& SetPublicKey(valtype key)\n+        {\n+            BOOST_TEST(key.size() == 32);\n+            m_scriptPubKey << key;\n+            return *this;\n+        }\n+\n+        Context& SetNBytePublicKey(size_t n)\n+        {\n+            valtype pub(n, 0xAB);\n+            m_scriptPubKey << pub;\n+            return *this;\n+        }\n+\n+        Context& SetSignatureAnnex(const valtype& annex_without_suffix)\n+        {\n+            m_annex.push_back(0x50); // by definition of annex\n+            m_annex.insert(m_annex.end(), annex_without_suffix.begin(), annex_without_suffix.end());\n+            return *this;\n+        }\n+\n+        // Used to directly set a witness (presumably, invalid for Taproot key path spending)\n+        Context& SetWitness(const std::vector<valtype>& witness)\n+        {\n+            m_witness_init = true;\n+            m_witness.stack = witness;\n+            return *this;\n+        }\n+\n+        [[maybe_unused]] Context& PushToWitnessStack(const valtype& v)\n+        {\n+            m_initial_witness_stack.push_back(v);\n+            return *this;\n+        }\n+\n+        Context& SetValidSignatureInWitness(unsigned char hash_type = SIGHASH_DEFAULT)\n+        {\n+            m_hash_type = hash_type;\n+            m_witness_signature = m_sig;\n+            if (hash_type) m_witness_signature.push_back(hash_type);\n+\n+            BOOST_TEST((hash_type ? m_witness_signature.size() == 65 : m_witness_signature.size() == 64));\n+            return *this;\n+        }\n+\n+        // Used to directly set the signature in the witness (presumably, invalid for Taproot key path spending)\n+        Context& SetSignatureInWitness(const valtype& sig)\n+        {\n+            m_hash_type = SIGHASH_DEFAULT;\n+            m_witness_signature = sig;\n+            return *this;\n+        }\n+\n+        [[maybe_unused]] CScript& SetTapscript()\n+        {\n+            return m_tapscript;\n+        }\n+\n+        [[maybe_unused]] Context& SetTapscriptLeafVersion()\n+        {\n+            m_leaf_version = 0xC0;\n+            return *this;\n+        }\n+\n+        [[maybe_unused]] Context& SetLeafVersion(unsigned int lv, unsigned int pubkey_parity)\n+        {\n+            BOOST_TEST(lv < 256);\n+            BOOST_TEST(pubkey_parity < 2);\n+\n+            m_leaf_version = lv;\n+            m_pubkey_parity = pubkey_parity;\n+            return *this;\n+        }\n+\n+        [[maybe_unused]] Context& SetTaprootInternalKey(const valtype& p)\n+        {\n+            BOOST_TEST(p.size() == 32);\n+            m_taproot_internal_key = p;\n+            return *this;\n+        }\n+\n+        [[maybe_unused]] Context& AddControlBlockField(const valtype& f)\n+        {\n+            BOOST_TEST(f.size() = 32);\n+            m_control_block_field.insert(m_control_block_field.end(), f.begin(), f.end());\n+            return *this;\n+        }\n+\n+        [[maybe_unused]] Context& SetControlBlock(const valtype& cb)\n+        {\n+            m_control_block_init = true;\n+            m_control_block = cb;\n+            return *this;\n+        }\n+\n+        // Used to directly set the flags (presumably, not the usual Taproot key path spending flags)\n+        Context& SetVerifyFlags(unsigned int flags)\n+        {\n+            m_flags = flags;\n+            return *this;\n+        }\n+\n+        Context& SetSchnorrSignatureValidation(CHECKER_VALIDATION checker_validation)\n+        {\n+            m_checker_validation = checker_validation;\n+            return *this;\n+        }\n+\n+        Context& SetP2SHWrapped()\n+        {\n+            m_p2sh_wrapped = true;\n+            return *this;\n+        }\n+\n+        Context& DoTest(int64_t line)\n+        {\n+            m_caller_line = line;\n+\n+            BOOST_TEST_MESSAGE(Descr() << \"doing test\");\n+\n+            // Build control block\n+            bool have_control_block = m_control_block_init;\n+            valtype control_block(m_control_block);\n+            if (!have_control_block) {\n+                BOOST_TEST_MESSAGE(\"maybe building control block\");\n+                if (m_leaf_version) {\n+                    BOOST_TEST_MESSAGE(\"have !=0 leaf version, definitely building control block\");\n+                    have_control_block = true;\n+                    control_block.push_back(static_cast<unsigned char>(m_leaf_version | m_pubkey_parity));\n+                    control_block.insert(control_block.end(), m_taproot_internal_key.begin(), m_taproot_internal_key.end());\n+                    control_block.insert(control_block.end(), m_control_block_field.begin(), m_control_block_field.end());\n+                    BOOST_TEST_MESSAGE(\"control block size \" << control_block.size());\n+                }\n+            }\n+\n+            // build the witness if necessary\n+            if (!m_witness_init) {\n+                if (have_control_block) {\n+                    // Taproot script path spend\n+                    for (const auto& elem : m_initial_witness_stack)\n+                        m_witness.stack.push_back(elem);\n+                    m_witness.stack.push_back(valtype(m_tapscript.begin(), m_tapscript.end()));\n+                    m_witness.stack.push_back(control_block);\n+                } else {\n+                    // Taproot key path spend\n+                    if (!m_witness_signature.empty()) m_witness.stack.push_back(m_witness_signature);\n+                }\n+                if (!m_annex.empty()) m_witness.stack.push_back(m_annex);\n+            }\n+\n+            if (!m_flags) {\n+                m_flags = SCRIPT_VERIFY_SIGPUSHONLY | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_TAPROOT;\n+            }\n+\n+            SignatureCheckerMock checker_mock(m_checker_validation);\n+            CScript script_sig; // must be empty for actual Taproot\n+            if (m_p2sh_wrapped) {\n+                // But BIP-341 allows all SegWit v1 P2SH-wrapped outputs to pass\n+                valtype fake_hash(20, 0x00);\n+                script_sig << OP_0 << fake_hash;",
      "path": "src/test/script_tapscript_tests.cpp",
      "position": 1400,
      "original_position": 1400,
      "commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "original_commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "in_reply_to_id": null,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin/bitcoin/pull/25097/commits/eeefec343592c6de85048e3b055ba49755cfb072\r\n\r\nInteresting... if I change this to `OP_1` or remove the `OP_0 <<` altogether, all tests still pass. ",
      "created_at": "2022-07-12T20:00:46Z",
      "updated_at": "2022-07-12T20:25:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r919374256",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/919374256"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1400,
      "original_line": 1400,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/919375518",
      "pull_request_review_id": 1036328057,
      "id": 919375518,
      "node_id": "PRRC_kwDOABII5842zI6e",
      "diff_hunk": "@@ -0,0 +1,1711 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+// TODO: Don't know whether Taproot/Tapscript tests should be exercising\n+// `libconsensus` the way the tests in `script_tests` do\n+\n+#include <core_io.h>\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <script/script_error.h>\n+#include <span.h>\n+#include <test/util/boost_test_boosts.h>\n+#include <test/util/pretty_data.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/transaction_utils.h>\n+#include <test/util/vector.h>\n+#include <univalue.h>\n+#include <util/strencodings.h>\n+\n+#include <boost/test/execution_monitor.hpp>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <array>\n+#include <charconv>\n+#include <cstddef>\n+#include <iomanip>\n+#include <iterator>\n+#include <limits>\n+#include <ostream>\n+#include <set>\n+#include <stdexcept>\n+#include <string>\n+#include <string_view>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+using namespace std::literals::string_literals;\n+using namespace std::literals::string_view_literals;\n+using namespace test::util::literals;\n+\n+namespace {\n+\n+typedef std::vector<unsigned char> valtype;\n+\n+/**\n+ * Value/Name pair used in data-driven tests\n+ */\n+template <typename V>\n+struct vn_pair {\n+    vn_pair(V value, std::string_view name) : m_value(value), m_name(name) {}\n+\n+    const V m_value;\n+    const std::string_view m_name;\n+};\n+\n+/**\n+ * Sequence of value/name pairs used in data-driven tests\n+ */\n+template <typename V>\n+using vn_sequence = std::vector<vn_pair<V>>;\n+\n+/**\n+ * Invokes undefined behavior.  See `std::unreachable` in C++23.\n+ */\n+[[noreturn]] inline void declare_unreachable()\n+{\n+#ifdef _MSC_VER\n+    __assume(false);\n+#else\n+    // Assume all other compilers than MSVC implement this GCC builtin.\n+    __builtin_unreachable();\n+#endif\n+}\n+\n+/**\n+ * Representation changer to fill an integral type with a known pattern.\n+ *\n+ * Pattern is successive byte values given a starting point.  Endianness doesn't\n+ * matter.\n+ */\n+union FillWithPattern {\n+    uint256 u256{0};\n+    uint64_t u64raw[sizeof(uint256) / sizeof(uint64_t)];\n+    uint32_t u32[sizeof(uint256) / sizeof(uint32_t)];\n+    int32_t i32[sizeof(uint256) / sizeof(int32_t)];\n+    uint8_t u8[sizeof(uint256)];\n+\n+    constexpr FillWithPattern(uint8_t start)\n+    {\n+        for (auto it = std::begin(u8); it != std::end(u8); ++it) {\n+            *it = start++;\n+        }\n+    }\n+\n+    uint64_t u64() const\n+    {\n+        // It is desirable to force high bit off\n+        return u64raw[0] & static_cast<uint64_t>(std::numeric_limits<int64_t>::max());\n+    }\n+};\n+\n+/**\n+ * The two possible actions for our mock signature checker\n+ */\n+enum class CHECKER_VALIDATION { ALWAYS_SUCCEEDS,\n+                                ALWAYS_FAILS };\n+\n+/**\n+ * For these tests don't need _real_ signature/pubkey validation.  That is\n+ * tested elsewhere.  So we just _mock_ the signature checker and force it\n+ * to answer valid/invalid as we wish.\n+ */\n+class SignatureCheckerMock : public BaseSignatureChecker\n+{\n+    //! What kind of mock checker is this?\n+    CHECKER_VALIDATION m_kind = CHECKER_VALIDATION::ALWAYS_FAILS;\n+\n+    //! True _iff_ CheckSchnorrSignature was actually called\n+    mutable bool m_was_called = false;\n+\n+public:\n+    //! Whether this mock always validates, or always fails, the signature/pubkey check.\n+    explicit SignatureCheckerMock(CHECKER_VALIDATION kind) : m_kind(kind) {}\n+\n+    //! Mocks the actual checking of the validity of the Schnorr signature by always succeeding or always failing\n+    bool CheckSchnorrSignature(Span<const unsigned char> sig,\n+                               Span<const unsigned char> pubkey,\n+                               SigVersion sigversion,\n+                               ScriptExecutionData& execdata,\n+                               ScriptError* serror = nullptr) const override\n+    {\n+        m_was_called = true;\n+        switch (m_kind) {\n+        case CHECKER_VALIDATION::ALWAYS_SUCCEEDS:\n+            if (serror) *serror = SCRIPT_ERR_OK;\n+            return true;\n+\n+        case CHECKER_VALIDATION::ALWAYS_FAILS:\n+            if (serror) *serror = SCRIPT_ERR_SCHNORR_SIG;\n+            return false;\n+        }\n+        declare_unreachable();\n+    }\n+\n+    bool CheckerWasCalled() const\n+    {\n+        return m_was_called;\n+    }\n+};\n+\n+} // namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(script_tapscript_tests, BasicTestingSetup)\n+\n+/**\n+ * Testing EvalScript OP_CHECKSIGADD branch and EvalChecksigTapscript, both in\n+ * interpreter.cpp, against the BIP342 \"Rules for signature opcodes\".\n+ */\n+BOOST_AUTO_TEST_CASE(eval_checksigadd_basic_checks)\n+{\n+    const valtype SIG_64BYTES(64, 0); // N.B.: Must be () not {}!\n+    const valtype SIG_65BYTES(65, 0);\n+    const valtype SIG_EMPTY{};\n+\n+    const valtype PUBKEY_32BYTES(32, 0);\n+    const valtype PUBKEY_15BYTES(15, 0);\n+    const valtype PUBKEY_EMPTY{};\n+\n+    constexpr int64_t TEST_NUM = 10;\n+\n+    constexpr int64_t START_VALIDATION_WEIGHT{90};\n+    constexpr int64_t BIP342_SIGOPS_LIMIT{50};\n+    constexpr int64_t END_VALIDATION_WEIGHT{START_VALIDATION_WEIGHT - BIP342_SIGOPS_LIMIT};\n+\n+    /**\n+     * A fluent API for running these tests.\n+     *\n+     * (Easiest way to understand this class is to look at the actual tests\n+     * that follow in this function.)\n+     */\n+    struct Context {\n+        explicit Context(std::string_view descr) : m_test_description(descr)\n+        {\n+            m_execdata.m_validation_weight_left_init = true;\n+            m_execdata.m_validation_weight_left = START_VALIDATION_WEIGHT;\n+        }\n+\n+        std::string m_test_description;\n+        SigVersion m_sig_version = SigVersion::TAPSCRIPT;\n+        uint32_t m_flags = 0;\n+        CScript m_script;\n+        ScriptError m_err = SCRIPT_ERR_OK;\n+        std::vector<valtype> m_stack;\n+        ScriptExecutionData m_execdata;\n+        CHECKER_VALIDATION m_kind;\n+        bool m_sigchecker_was_called = false;\n+        int64_t m_caller_line = 0;\n+        bool m_result = false;\n+\n+        Context& SetVersion(SigVersion v)\n+        {\n+            m_sig_version = v;\n+            return *this;\n+        }\n+\n+        Context& SetChecker(CHECKER_VALIDATION kind)\n+        {\n+            m_kind = kind;\n+            return *this;\n+        }\n+\n+        Context& SetRemainingWeight(int64_t w)\n+        {\n+            m_execdata.m_validation_weight_left = w;\n+            return *this;\n+        }\n+\n+        Context& AddFlags(uint32_t f)\n+        {\n+            m_flags |= f;\n+            return *this;\n+        }\n+\n+        CScript& SetScript()\n+        {\n+            return m_script;\n+        }\n+\n+        Context& DoTest(int64_t line)\n+        {\n+            SignatureCheckerMock checker_mock(m_kind);\n+            m_caller_line = line;\n+            m_result = EvalScript(m_stack, m_script,\n+                                  SCRIPT_VERIFY_TAPROOT | m_flags,\n+                                  checker_mock,\n+                                  m_sig_version,\n+                                  m_execdata,\n+                                  &m_err);\n+            m_sigchecker_was_called = checker_mock.CheckerWasCalled();\n+            return *this;\n+        }\n+\n+        Context& CheckCallSucceeded()\n+        {\n+            BOOST_CHECK_MESSAGE(m_result,\n+                                Descr()\n+                                    << \": EvalScript succeeded, as expected\");\n+            BOOST_CHECK_MESSAGE(m_err == SCRIPT_ERR_OK,\n+                                Descr()\n+                                    << \": Error code expected OK, actual was \"\n+                                    << ScriptErrorString(m_err));\n+            return *this;\n+        }\n+\n+        Context& CheckCallFailed(ScriptError expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!m_result,\n+                                Descr()\n+                                    << \": EvalScript failed, as expected\");\n+            BOOST_CHECK_MESSAGE(m_err == expected,\n+                                Descr()\n+                                    << \": Error code expected \" << ScriptErrorString(expected)\n+                                    << \", actual was \" << ScriptErrorString(m_err));\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(m_sigchecker_was_called,\n+                                Descr() << \": CheckSchnorrSignature was called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasNotValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(!m_sigchecker_was_called,\n+                                Descr() << \": CheckSchnorrSignature was not called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckRemainingValidationWeight(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(m_execdata.m_validation_weight_left == expected,\n+                                Descr()\n+                                    << \": Remaining validation weight expected \"\n+                                    << expected << \", actual was \"\n+                                    << m_execdata.m_validation_weight_left);\n+            return *this;\n+        }\n+\n+        Context& CheckStackDepth(std::size_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(m_stack.size() == expected,\n+                                Descr()\n+                                    << \": Stack depth expected \" << expected\n+                                    << \", actual was \" << m_stack.size());\n+            return *this;\n+        }\n+\n+        Context& CheckTOS(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!m_stack.empty(),\n+                                Descr()\n+                                    << \": Stack expected at least one item, actually was empty\");\n+            const int64_t actual = CScriptNum(m_stack.at(0), false).GetInt64();\n+            BOOST_CHECK_MESSAGE(expected == actual,\n+                                Descr()\n+                                    << \": Top-of-stack expected \" << expected\n+                                    << \", actual was \" << actual);\n+            return *this;\n+        }\n+\n+    private:\n+        std::string Descr()\n+        {\n+            std::string descr;\n+            descr.reserve(m_test_description.size() + 20);\n+            descr += m_test_description;\n+            descr += \" (@\";\n+            descr += as_string(m_caller_line);\n+            descr += \")\";\n+            return descr;\n+        }\n+    };\n+\n+    {\n+        Context ctx(\"SigVersion must not be BASE\");\n+        ctx.SetVersion(SigVersion::BASE).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"SigVersion must not be WITNESS_V0\");\n+        ctx.SetVersion(SigVersion::WITNESS_V0).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Minimum stack height 3 for OP_CHECKSIGADD\");\n+        ctx.SetScript()\n+            << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_INVALID_STACK_OPERATION)\n+            .CheckStackDepth(2);\n+    }\n+\n+    {\n+        Context ctx(\"`n` (2nd arg) size > 4 must fail\");\n+        // This is probably meant to be a check on the _encoding_ - that it is\n+        // minimal, but it can also be a check on the _value_.  BIP342 doesn't\n+        // say which.  Could be both...\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(10000000000LL) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            // (IMO this is an _unsatisfactory_ error code to return for a required\n+            // BIP342 check, but see the `catch` clause in `EvalScript`)\n+            .CheckCallFailed(SCRIPT_ERR_UNKNOWN_ERROR)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Insufficient validation weight remaining\");\n+        ctx.SetRemainingWeight(BIP342_SIGOPS_LIMIT - 1)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + 32byte pubkey skips validation\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + non32byte pubkey skips validation\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey ('unknown pubkey type') _with_ discourage flag fails\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .AddFlags(SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .CheckSignatureWasNotValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation failure forced\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_FAILS)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_SCHNORR_SIG)\n+            .CheckSignatureWasValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation success forced\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasValidated()\n+            .CheckRemainingValidationWeight(END_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM + 1);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey + empty sig with validation success forced\");\n+        ctx.SetChecker(CHECKER_VALIDATION::ALWAYS_SUCCEEDS)\n+                .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_failure_cases)\n+{\n+    // As defined by BIP-341 Signature Validation Rules\n+    // Here we pick an acceptable SigVersion\n+    const SigVersion sigversion = SigVersion::TAPROOT;\n+\n+    CMutableTransaction tx_to_m;\n+    tx_to_m.vin.push_back(CTxIn());\n+    const uint32_t in_pos{0};\n+\n+    PrecomputedTransactionData cache;\n+    cache.m_bip341_taproot_ready = true;\n+    cache.m_spent_outputs_ready = true;\n+\n+    ScriptExecutionData execdata;\n+    execdata.m_annex_init = true;\n+    execdata.m_annex_present = false;\n+    execdata.m_annex_hash = uint256::ZERO;\n+    execdata.m_tapleaf_hash_init = false;\n+    execdata.m_codeseparator_pos_init = true;\n+\n+    uint256 hash_out{0};\n+\n+    {\n+        // Check all invalid hash_type codes rejected\n+        const std::set<uint8_t> allowable_hash_types{0x00, 0x01, 0x02, 0x03, 0x81, 0x82, 0x83};\n+        for (unsigned ht = 0; ht <= 255; ht++) {\n+            const uint8_t hash_type = static_cast<uint8_t>(ht);\n+            if (allowable_hash_types.find(hash_type) != allowable_hash_types.end()) continue;\n+\n+            BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m, in_pos,\n+                                                      hash_type, sigversion, cache,\n+                                                      MissingDataBehavior::FAIL),\n+                                \"hash_type = \" << Hex(hash_type) << \" expected to fail\");\n+        }\n+    }\n+\n+    {\n+        // Check that if hash_type == SIGHASH_SINGLE then missing a \"corresponding\n+        // output\" fails.\n+        CMutableTransaction tx_to_m;\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+\n+        uint8_t in_pos = 1;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(1) > #tx_to==0 is expected to fail\");\n+\n+        tx_to_m.vout.push_back(CTxOut());\n+        in_pos = 2;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(2) > #tx_to==1 is expected to fail\");\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_all_success_paths)\n+{\n+    // Our approach here will be to follow BIP-341's signature algorithm (with\n+    // the BIP-342 extension) doing two things at once:\n+    //   1) We'll set up the input arguments to `SignatureHashSchnorr` function\n+    //      being tested, _and_\n+    //   2) we'll _compute the hash of those fields ourselves_ exaxctly as\n+    //      it is described in BIP-341 and BIP-342.\n+    // Then we can compare the two.  We'll do this in a data-driven way for each\n+    // of the different scenarios that the algorithm supports.\n+    //\n+    // In this way this test achieves 100% _path_ coverage of `SignatureHashSchnorr`\n+    // (not just 100% _branch_ coverage).\n+    // - Sadly, this isn't shown in the `lcov` reports.  There are still a few\n+    //   red `-` marks left.  This is because:\n+    //   1. `lcov` wasn't designed to handle death tests.\n+    //   2. ??? Some other unknown reasons, possibly due to the instrumentation,\n+    //      possibly due to `lcov` limitations.  You can see by the test output\n+    //      (`-log_level=all`) or within a debugger that in fact _all_ branches\n+    //      are taken when executing all the tests in this file.\n+\n+    // Here we define, and then generate, all combinations of the alternatives\n+    // for the parameters that vary the signature combination algorithm\n+\n+    const vn_sequence<SigVersion> SigVersion_alternatives{\n+        {SigVersion::TAPROOT, \"TAPROOT\"sv},\n+        {SigVersion::TAPSCRIPT, \"TAPSCRIPT\"sv}};\n+\n+    const vn_sequence<uint32_t> hash_type_output_alternatives{\n+        {SIGHASH_DEFAULT, \"SIGHASH_DEFAULT\"sv},\n+        {SIGHASH_ALL, \"SIGHASH_ALL\"sv},\n+        {SIGHASH_NONE, \"SIGHASH_NONE\"sv},\n+        {SIGHASH_SINGLE, \"SIGHASH_SINGLE\"sv}};\n+\n+    const vn_sequence<uint32_t> hash_type_input_alternatives{\n+        {0, \"N/A\"sv},\n+        {SIGHASH_ANYONECANPAY, \"SIGHASH_ANYONECANPAY\"sv}};\n+\n+    const vn_sequence<uint8_t> annex_alternatives{\n+        {0, \"no annex\"sv},\n+        {1, \"annex present\"sv}};\n+\n+    const vn_sequence<bool> output_hash_alternatives{\n+        {false, \"output hash missing\"sv},\n+        {true, \"output hash provided\"sv}};\n+\n+    for (const auto& sigversion_alternative : SigVersion_alternatives)\n+        for (const auto& hash_type_output_alternative : hash_type_output_alternatives)\n+            for (const auto& hash_type_input_alternative : hash_type_input_alternatives)\n+                for (const auto& annex_alternative : annex_alternatives)\n+                    for (const auto& output_hash_alternative : output_hash_alternatives) {\n+                        // Exclude the invalid combination of SIGHASH_DEFAULT with SIGHASH_ANYONECANPAY\n+                        if (hash_type_output_alternative.m_value == SIGHASH_DEFAULT && hash_type_input_alternative.m_value == SIGHASH_ANYONECANPAY) continue;\n+\n+                        // We're going to want to know which scenario it is if a check actually\n+                        // fails ...\n+                        std::string scenario_description;\n+                        {\n+                            std::ostringstream oss;\n+                            oss << sigversion_alternative.m_name << \", \"\n+                                << hash_type_output_alternative.m_name << \", \"\n+                                << hash_type_input_alternative.m_name << \", \"\n+                                << annex_alternative.m_name << \", \"\n+                                << output_hash_alternative.m_name;\n+                            scenario_description = oss.str();\n+                        }\n+\n+                        // Set up the scenario we're running now - these 4 variables define the scenario\n+                        const SigVersion sigversion{sigversion_alternative.m_value};\n+                        const uint8_t hash_type{static_cast<uint8_t>(hash_type_output_alternative.m_value | hash_type_input_alternative.m_value)};\n+                        const uint8_t annex_present{annex_alternative.m_value};\n+                        const bool have_output_hash{output_hash_alternative.m_value};\n+\n+                        // Compute some helper values that depend on scenario\n+                        const uint8_t ext_flag{sigversion == SigVersion::TAPSCRIPT};\n+                        const uint8_t hash_input_type{static_cast<uint8_t>(hash_type & SIGHASH_INPUT_MASK)};\n+                        const uint8_t hash_output_type{static_cast<uint8_t>((hash_type == SIGHASH_DEFAULT) ? SIGHASH_ALL : (hash_type & SIGHASH_OUTPUT_MASK))};\n+                        const uint8_t spend_type = (ext_flag * 2) + annex_present;\n+\n+                        // Fixed values (by algorithm)\n+                        const uint8_t epoch{0x00};\n+                        const uint8_t key_version{0};\n+\n+                        // Mocked values fixed for purposes of this unit test.  This is a long\n+                        // list of crufty things but that's because `SignatureHashSchnorr`, the\n+                        // function being tested, takes as arguments not just the transaction\n+                        // being signed (plus control data) but also some _precomputed values_\n+                        // in two different structs: `PrecomputedTransactionData`, and\n+                        // `ScriptExecutionData`.  On the one hand this is nice because a lot\n+                        // of complexity of the signature algorithm doesn't have to be duplicated\n+                        // here in this test: we can just use mocked values.  On the other hand,\n+                        // there's a lot of icky setup to do to get all the values in the right\n+                        // places both for our \"by the book\" implementation and to be set up to\n+                        // call `SignatureHashSchnorr`.\n+                        //\n+                        // Try to make things simpler by at least using the same names for the\n+                        // setup variables as for the fields in the parameter structs.\n+\n+                        const uint32_t in_pos{1};\n+                        const int32_t tx_version{FillWithPattern(0x01).i32[0]};\n+                        const uint32_t tx_lock_time{FillWithPattern(0x05).u32[0]};\n+                        const uint256 prevouts_single_hash{FillWithPattern(0x10).u256};\n+                        const uint256 spent_amounts_single_hash{FillWithPattern(0x18).u256};\n+                        const uint256 spent_scripts_single_hash{FillWithPattern(0x20).u256};\n+                        const uint256 sequences_single_hash{FillWithPattern(0x28).u256};\n+                        const uint256 outputs_single_hash{FillWithPattern(0x30).u256};\n+                        const uint256 output_hash{FillWithPattern(0x40).u256};\n+                        const uint256 annex_hash{FillWithPattern(0x48).u256};\n+                        const uint256 tapleaf_hash{FillWithPattern(0x50).u256};\n+                        const uint32_t codeseparator_pos{FillWithPattern(0x58).u32[0]};\n+                        const COutPoint tx_input_at_pos_prevout{FillWithPattern(0x60).u256,\n+                                                                FillWithPattern(0x68).u32[0]};\n+                        const uint32_t tx_input_at_pos_nsequence{FillWithPattern(0x70).u32[0]};\n+                        CTxOut spent_output_at_pos;\n+                        spent_output_at_pos.nValue = FillWithPattern(0x80).u64();\n+                        spent_output_at_pos.scriptPubKey /*random script, not even valid*/\n+                            << OP_DUP << OP_HASH160 << OP_EQUALVERIFY << OP_CHECKSIG;\n+                        CTxOut tx_output_at_pos;\n+                        tx_output_at_pos.nValue = FillWithPattern(0x90).u64();\n+                        tx_output_at_pos.scriptPubKey /*random script, not even valid*/\n+                            << OP_CHECKSIG << OP_EQUALVERIFY << OP_HASH160 << OP_DUP;\n+\n+                        // Now set up the arguments that are going to be passed to\n+                        // `SignatureHashSchnorr`\n+\n+                        CMutableTransaction tx_to;\n+                        tx_to.nVersion = tx_version;\n+                        tx_to.nLockTime = tx_lock_time;\n+                        for (uint32_t i = 0; i < in_pos + 2; i++) {\n+                            tx_to.vin.push_back(CTxIn());\n+                            tx_to.vout.push_back(CTxOut());\n+                        }\n+                        tx_to.vin[in_pos].prevout = tx_input_at_pos_prevout;\n+                        tx_to.vin[in_pos].nSequence = tx_input_at_pos_nsequence;\n+                        tx_to.vout[in_pos] = tx_output_at_pos;\n+\n+                        PrecomputedTransactionData cache;\n+                        cache.m_bip341_taproot_ready = true;\n+                        cache.m_prevouts_single_hash = prevouts_single_hash;\n+                        cache.m_spent_amounts_single_hash = spent_amounts_single_hash;\n+                        cache.m_spent_scripts_single_hash = spent_scripts_single_hash;\n+                        cache.m_sequences_single_hash = sequences_single_hash;\n+                        cache.m_spent_outputs_ready = true;\n+                        for (uint32_t i = 0; i < in_pos + 2; i++) {\n+                            cache.m_spent_outputs.push_back(CTxOut());\n+                        }\n+                        cache.m_spent_outputs[in_pos] = spent_output_at_pos;\n+                        cache.m_outputs_single_hash = outputs_single_hash;\n+\n+                        ScriptExecutionData execdata;\n+                        execdata.m_annex_init = true;\n+                        execdata.m_annex_present = !!annex_present;\n+                        execdata.m_annex_hash = annex_hash;\n+                        execdata.m_output_hash.reset();\n+                        if (have_output_hash) {\n+                            execdata.m_output_hash = output_hash;\n+                        }\n+                        if (sigversion == SigVersion::TAPSCRIPT) {\n+                            execdata.m_tapleaf_hash_init = true;\n+                            execdata.m_tapleaf_hash = tapleaf_hash;\n+                            execdata.m_codeseparator_pos_init = true;\n+                            execdata.m_codeseparator_pos = codeseparator_pos;\n+                        }\n+\n+                        // Now here is where we take all that data - _not_ the arguments to\n+                        // `SignatureHashSchnorr` but all the scenario parameters, the helpers,\n+                        // the values fixed by the algorithm, and our mocked values, and actually\n+                        // follow the BIP-341/BIP-342 signature calculation algorithm right from\n+                        // the spec ...\n+\n+                        // Start with a tagged hasher with the correct tag\n+                        CHashWriter hasher = TaggedHash(\"TapSighash\");\n+\n+                        // First byte to hash is always the \"epoch\", 0x00 (BIP-341, footnote 20)\n+                        hasher << epoch;\n+\n+                        // Next: hash_type (1 byte)\n+                        hasher << hash_type;\n+\n+                        // Next: transaction version (4 bytes)\n+                        hasher << tx_version;\n+\n+                        // Next: transaction lock time (4 bytes)\n+                        hasher << tx_lock_time;\n+\n+                        // Next if _not_ SIGHASH_ANYONECANPAY:\n+                        // a) SHA256 of the serialization of all input outpoints (32 bytes)\n+                        // b) SHA256 of the serialization of all spent output amounts (32 bytes)\n+                        // c) SHA256 of the serialization of all spent outputs' _scriptPubKeys_\n+                        //    serialized as script (32 bytes)\n+                        // d) SHA256 of the serialization of all input `nSequence` (32 bytes)\n+                        if (hash_input_type != SIGHASH_ANYONECANPAY) {\n+                            hasher << prevouts_single_hash;\n+                            hasher << spent_amounts_single_hash;\n+                            hasher << spent_scripts_single_hash;\n+                            hasher << sequences_single_hash;\n+                        }\n+\n+                        // Next if _not_ SIGHASH_NONE _and not_ SIGHASH_SINGLE:\n+                        // SHA256 of the serialization of all outputs in CTxOut format (32 bytes)\n+                        if (hash_output_type != SIGHASH_NONE && hash_output_type != SIGHASH_SINGLE) {\n+                            hasher << outputs_single_hash;\n+                        }\n+\n+                        // Now, data about input/prevout being spent\n+\n+                        // The \"spend_type\" (1 byte) which is a function of ext_flag (above) and\n+                        // whether there is an annex present (here: no)\n+                        hasher << spend_type;\n+\n+                        // Here, if we are _not_ SIGHASH_ANYONECANPAY, we just add the index of\n+                        // the input in the transaction input vector (4 bytes). There must be a\n+                        // input transaction at this index but _in this scenario_ it doesn't have\n+                        // to have any data (it is never inspected).  Same for output transactions.\n+                        //\n+                        // On the other hand, if we _are_ SIGHASH_ANYONECANPAY, then we add the\n+                        // `COutPoint` of this input (36 bytes), the value of the previous\n+                        // output spent by this input (8 bytes), the `ScriptPubKey` of the\n+                        // previous output spent by this input (35 bytes), and the `nSequence`\n+                        // of this input.  These values are all precomputed and made available\n+                        // to `SignatureHashSchnorr` in the `PrecomputedTransactionData` struct.\n+                        if (hash_input_type == SIGHASH_ANYONECANPAY) {\n+                            hasher << tx_input_at_pos_prevout;\n+                            hasher << spent_output_at_pos.nValue;\n+                            hasher << spent_output_at_pos.scriptPubKey;\n+                            hasher << tx_input_at_pos_nsequence;\n+                        } else {\n+                            hasher << in_pos;\n+                        }\n+\n+                        // Now, if there is an \"annex\", add its hash (32 byte).  This is\n+                        // precomputed and we don't actually have to have an actual annex to\n+                        // pass in to `SignatureHashSchnorr`, nor do we have to hash it.\n+                        if (annex_present) {\n+                            hasher << annex_hash;\n+                        }\n+\n+                        // Here, iff the hash type is `SIGHASH_SINGLE`, add the hash of the\n+                        // corresponding transaction output (32 bytes).  The wrinkle here is that\n+                        // (for some reason) _sometimes_ this hash is precomputed, and _sometimes_\n+                        // it is _not_.  So `SignatureHashSchnorr` will either use it if it is\n+                        // provided or compute it from the corresponding output itself. (For our\n+                        // purposes in this test the output need not be valid - it just must be\n+                        // present.)\n+                        if (hash_output_type == SIGHASH_SINGLE) {\n+                            if (!have_output_hash) {\n+                                CHashWriter hasher2(SER_GETHASH, 0);\n+                                hasher2 << tx_output_at_pos;\n+                                hasher << hasher2.GetSHA256();\n+                            } else {\n+                                hasher << output_hash;\n+                            }\n+                        }\n+\n+                        // This is the TAPSCRIPT extension from BIP-342.  If the version is\n+                        // TAPSCRIPT then add the tapleaf hash (32 bytes), the key_version (1\n+                        // byte, fixed value of 0x00), and the \"opcode position of the last\n+                        // executed OP_CODESEPARATOR before the currently executed signature\n+                        // opcode\" (4 bytes).  The tapleaf hash and the code separator position\n+                        // are both precomputed values.\n+                        if (sigversion == SigVersion::TAPSCRIPT) {\n+                            hasher << tapleaf_hash;\n+                            hasher << key_version;\n+                            hasher << codeseparator_pos;\n+                        }\n+\n+                        // That's all that goes into the hasher for this signature\n+                        const uint256 expected_hash_out = hasher.GetSHA256();\n+\n+                        // Now, _finally_, we test the actual implemented algorithm under test:\n+                        uint256 actual_hash_out{0};\n+                        BOOST_TEST(SignatureHashSchnorr(actual_hash_out,\n+                                                        execdata, tx_to, in_pos,\n+                                                        hash_type, sigversion, cache,\n+                                                        MissingDataBehavior::FAIL),\n+                                   \"Scenario: \" << scenario_description);\n+                        BOOST_TEST(expected_hash_out == actual_hash_out,\n+                                   \"Scenario: \" << scenario_description\n+                                                << \" - expected \" << expected_hash_out.ToString()\n+                                                << \" == actual \" << actual_hash_out.ToString());\n+                    }\n+}\n+\n+namespace {\n+\n+// Valid Schnoor (pubkey, msg, signature) tuples (copied from `key_tests.cpp`)\n+\n+struct SchnorrTriplet {\n+    SchnorrTriplet(std::string pubkey, std::string sighash, std::string sig)\n+        : m_pubkey(ParseHex(pubkey)), m_sighash(uint256(ParseHex(sighash))), m_sig(ParseHex(sig)) {}\n+    valtype m_pubkey;\n+    uint256 m_sighash;\n+    valtype m_sig;\n+};\n+\n+static const std::vector<SchnorrTriplet> SCHNORR_TRIPLETS = {\n+    {\"F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9\", \"0000000000000000000000000000000000000000000000000000000000000000\", \"E907831F80848D1069A5371B402410364BDF1C5F8307B0084C55F1CE2DCA821525F66A4A85EA8B71E482A74F382D2CE5EBEEE8FDB2172F477DF4900D310536C0\"},\n+    {\"DFF1D77F2A671C5F36183726DB2341BE58FEAE1DA2DECED843240F7B502BA659\", \"243F6A8885A308D313198A2E03707344A4093822299F31D0082EFA98EC4E6C89\", \"6896BD60EEAE296DB48A229FF71DFE071BDE413E6D43F917DC8DCF8C78DE33418906D11AC976ABCCB20B091292BFF4EA897EFCB639EA871CFA95F6DE339E4B0A\"},\n+    {\"DD308AFEC5777E13121FA72B9CC1B7CC0139715309B086C960E18FD969774EB8\", \"7E2D58D8B3BCDF1ABADEC7829054F90DDA9805AAB56C77333024B9D0A508B75C\", \"5831AAEED7B44BB74E5EAB94BA9D4294C49BCF2A60728D8B4C200F50DD313C1BAB745879A5AD954A72C45A91C3A51D3C7ADEA98D82F8481E0E1E03674A6F3FB7\"},\n+    {\"25D1DFF95105F5253C4022F628A996AD3A0D95FBF21D468A1B33F8C160D8F517\", \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\", \"7EB0509757E246F19449885651611CB965ECC1A187DD51B64FDA1EDC9637D5EC97582B9CB13DB3933705B32BA982AF5AF25FD78881EBB32771FC5922EFC66EA3\"},\n+    {\"D69C3509BB99E412E68B0FE8544E72837DFA30746D8BE2AA65975F29D22DC7B9\", \"4DF3C3F68FCC83B27E9D42C90431A72499F17875C81A599B566C9889B9696703\", \"00000000000000000000003B78CE563F89A0ED9414F5AA28AD0D96D6795F9C6376AFB1548AF603B3EB45C9F8207DEE1060CB71C04E80F593060B07D28308D7F4\"},\n+};\n+\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(internal_test_validate_schnorr_testdata)\n+{\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(XOnlyPubKey(triplet.m_pubkey).VerifySchnorr(triplet.m_sighash, triplet.m_sig));\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(verify_schnorr_signature)\n+{\n+    // Defeat, for test purposes, the protected access of\n+    // `GenericTransactionSignatureChecker::VerifySchnorrSignature`\n+    struct UnprotectedTransactionSignatureChecker : public MutableTransactionSignatureChecker {\n+        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;\n+        using MutableTransactionSignatureChecker::VerifySchnorrSignature;\n+    };\n+    UnprotectedTransactionSignatureChecker sut{nullptr, 0, {}, {}};\n+\n+    // Positive tests: triplets which verify\n+    for (const auto& triplet : SCHNORR_TRIPLETS) {\n+        BOOST_TEST(sut.VerifySchnorrSignature(triplet.m_sig,\n+                                              XOnlyPubKey{triplet.m_pubkey},\n+                                              triplet.m_sighash));\n+    }\n+\n+    // Negative tests: triplets which fail to verify (get these failing triplets\n+    // by modifying a valid triplet, one field at a time)\n+    auto diddle_front_byte = [](auto v) { v[0]++; return v; };\n+    auto& triplet = SCHNORR_TRIPLETS[0];\n+    BOOST_TEST(!sut.VerifySchnorrSignature(diddle_front_byte(triplet.m_sig),\n+                                           XOnlyPubKey{triplet.m_pubkey},\n+                                           triplet.m_sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.m_sig,\n+                                           XOnlyPubKey{diddle_front_byte(triplet.m_pubkey)},\n+                                           triplet.m_sighash));\n+    BOOST_TEST(!sut.VerifySchnorrSignature(triplet.m_sig,\n+                                           XOnlyPubKey{triplet.m_pubkey},\n+                                           uint256::ONE));\n+}\n+\n+BOOST_AUTO_TEST_CASE(check_schnorr_signature)\n+{\n+    // Provide, for test purposes, a subclass of `GenericTransactionsSignatureChecker`\n+    // that mocks `VerifySchnorrSignature` so we can more easily test\n+    // `CheckSchnorrSignature` without going to the trouble of having a valid\n+    // transaction (which is unnecessary for this _unit_ test.)\n+    struct MockVerifyingTransactionSignatureChecker : public MutableTransactionSignatureChecker {\n+        uint256 m_expected_sighash = []() {\n+            uint256 h{};\n+            // This is the known sighash of the Tx and input data we set up (precomputed)\n+            h.SetHex(\"f614d8ae6dcc49e2ca2ef1c03f93c7326189e5575d446e825e5a2700fb1cb83c\");\n+            return h;\n+        }();\n+\n+        using MutableTransactionSignatureChecker::MutableTransactionSignatureChecker;\n+\n+        enum class if_as_expected_return { False,\n+                                           True };\n+        if_as_expected_return m_iae{if_as_expected_return::True};\n+        void SetExpectation(if_as_expected_return iaer) { m_iae = iaer; }\n+\n+        bool VerifySchnorrSignature(Span<const unsigned char> sig,\n+                                    const XOnlyPubKey& pubkey,\n+                                    const uint256& sighash) const override\n+        {\n+            // Following line used only to determine the known canned `expected_sighash` above:\n+            // BOOST_TEST_MESSAGE(\"MockVerifySchnorrSignature: sighash == \" << sighash.ToString());\n+\n+            bool as_expected = sighash == m_expected_sighash;\n+            if (m_iae == if_as_expected_return::True)\n+                return as_expected;\n+            else\n+                return !as_expected;\n+        };\n+    };\n+\n+    const auto triplet = SCHNORR_TRIPLETS[0];\n+    const CMutableTransaction txToIn{};\n+    ScriptExecutionData execdata{};\n+\n+    {\n+        // Signature must be 64 or 65 bytes long\n+        for (size_t i = 0; i <= 99; i++) {\n+            valtype testsig(i, i);\n+            if (testsig.size() == 64 || testsig.size() == 65) continue;\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_SIZE);\n+        }\n+    }\n+\n+    {\n+        // Iff signature is 65 bytes long last byte must **NOT** be SIGHASH_DEFAULT (0x00) per BIP-342\n+        {\n+            // Negative test: last byte _is_ SIGHASH_DEFAULT\n+            valtype testsig(65, 65);\n+            testsig.back() = SIGHASH_DEFAULT;\n+\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);\n+        }\n+        {\n+            // Negative tests: last byte is _not_ SIGHASH_DEFAULT, but we early exit _without changing\n+            // serror_ because we don't provide a txDataIn (🡄 this requires knowledge of how\n+            // `CheckSchnorrSignature` is written).\n+            for (size_t i = 1; i <= 255; i++) {\n+                valtype testsig(65, i);\n+\n+                MockVerifyingTransactionSignatureChecker sut(&txToIn, 0, {}, MissingDataBehavior::FAIL);\n+                ScriptError serror{SCRIPT_ERR_OK};\n+                BOOST_TEST(!sut.CheckSchnorrSignature(testsig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));\n+                BOOST_TEST(serror == SCRIPT_ERR_OK);\n+            }\n+        }\n+    }\n+\n+    {\n+        // Now check that, given the parameters, if `SignatureHashSchnorr fails there's an error exit.\n+        // Otherwise, if it succeeds, it proceeds to call `VerifySchnorrSignature` and depending on\n+        // _that_ result `SignatureHashSchnorr` either succeeds or fails.\n+        //\n+        // We do this using the mocked `VerifySchnorrSignature` so we only need to pass parameters\n+        // that work with `SignatureHashSchnorr`, they don't _also_ have to validate with\n+        // `VerifySchnorrSignature`.\n+\n+        const uint32_t in_pos{0};\n+        CMutableTransaction txToIn{};\n+        txToIn.nVersion = 0;\n+        txToIn.nLockTime = 0;\n+        txToIn.vin.push_back(CTxIn());\n+        txToIn.vin[in_pos].prevout = COutPoint(uint256::ZERO, 0);\n+        txToIn.vin[in_pos].nSequence = 0;\n+        txToIn.vout.push_back(CTxOut());\n+\n+        PrecomputedTransactionData txDataIn{};\n+        txDataIn.m_bip341_taproot_ready = true;\n+        txDataIn.m_prevouts_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_amounts_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_scripts_single_hash = uint256::ZERO;\n+        txDataIn.m_sequences_single_hash = uint256::ZERO;\n+        txDataIn.m_spent_outputs_ready = true;\n+        txDataIn.m_spent_outputs.push_back(CTxOut());\n+        txDataIn.m_spent_outputs[in_pos].nValue = 0;\n+        txDataIn.m_spent_outputs[in_pos].scriptPubKey << OP_DUP << OP_CHECKSIG;\n+        txDataIn.m_outputs_single_hash = uint256::ZERO;\n+\n+        ScriptExecutionData execdata{};\n+        execdata.m_annex_init = true;\n+        execdata.m_annex_present = true;\n+        execdata.m_annex_hash = uint256::ZERO;\n+        execdata.m_output_hash.reset();\n+\n+        {\n+            // Confirm that we can force `SignatureHashSchnorr` to fail (via an early exit)\n+            PrecomputedTransactionData txDataIn{};\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(triplet.m_sig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG_HASHTYPE);\n+        }\n+\n+        {\n+            // Now `SignatureHashSchnorr` will return true but we'll fail `VerifySchnorrSignature`\n+            // and show it returns the correct error.\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            sut.SetExpectation(MockVerifyingTransactionSignatureChecker::if_as_expected_return::False);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(!sut.CheckSchnorrSignature(triplet.m_sig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_SCHNORR_SIG);\n+        }\n+\n+        {\n+            // Finally, same as previous, except we'll force `VerifySchnorrSignature` to succeed and\n+            // show now that `CheckSchnorrSignature` finally succeeds.\n+            MockVerifyingTransactionSignatureChecker sut(&txToIn, in_pos, {}, txDataIn, MissingDataBehavior::FAIL);\n+            sut.SetExpectation(MockVerifyingTransactionSignatureChecker::if_as_expected_return::True);\n+            ScriptError serror{SCRIPT_ERR_OK};\n+            BOOST_TEST(sut.CheckSchnorrSignature(triplet.m_sig, triplet.m_pubkey, SigVersion::TAPROOT, execdata, &serror));\n+            BOOST_TEST(serror == SCRIPT_ERR_OK);\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(compute_tapleaf_hash)\n+{\n+    // Try two examples, reimplementing the BIP-341 specification\n+    {\n+        uint8_t leaf_version = 0;\n+        CScript cs{};\n+        auto expected = (TaggedHash(\"TapLeaf\") << leaf_version << CScript()).GetSHA256();\n+        auto actual = ComputeTapleafHash(leaf_version, CScript());\n+        BOOST_TEST(expected == actual,\n+                   \"leaf version 0, empty CScript - expected \"\n+                       << expected.ToString() << \" actual \" << actual.ToString());\n+    }\n+\n+    {\n+        uint8_t leaf_version = 0x4a;\n+        CScript cs{};\n+        cs << OP_CHECKLOCKTIMEVERIFY << OP_CHECKSIGADD; // just a random CScript\n+        auto expected = (TaggedHash(\"TapLeaf\") << leaf_version << cs).GetSHA256();\n+        auto actual = ComputeTapleafHash(leaf_version, cs);\n+        BOOST_TEST(expected == actual,\n+                   \"leaf version 0x4A, CScript w/ 2 opcodes - expected \"\n+                       << expected.ToString() << \" actual \" << actual.ToString());\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(compute_taproot_merkle_root)\n+{\n+    using namespace test::util::vector_ops;\n+\n+    // Test by using a small enhancement to a `vector<unsigned char>` that makes\n+    // it easy to convert to/from strings so the tests are more easily readable,\n+    // and also adds directly the two necessary operations from BIP-340: byte\n+    // vector concatenation and byte vector select subrange.\n+\n+    // Use an arbitrary tapleaf hash throughout\n+    const uint256 tapleaf_hash1 = ComputeTapleafHash(0x10, CScript{} << OP_CHECKMULTISIG);\n+    const uint256 tapleaf_hash2 = ComputeTapleafHash(0x20, CScript{} << OP_CHECKSEQUENCEVERIFY);\n+\n+    //                         \".........|.........|.........|...\"      33 bytes\n+    const auto control_base1 = \"[point (#1) - 33 bytes of junk!!>\"_bv;\n+    const auto control_base2 = \"[point (#2) - 33 more bad bytes!>\"_bv;\n+    assert(control_base1.size() == 33 && control_base2.size() == 33);\n+\n+    // Nodes `node_low` and `node_high` are constructed to be _forced_ lower/higher\n+    // (respectively) than arbitrary hash.  This isn't exactly true, of course:\n+    // only the _first byte_ of these nodes are low or high.  If the first byte\n+    // of the \"arbitrary\" hash is `0x00` or `0xff` we've got a problem .. but\n+    // this isn't the case for this test data.\n+\n+    //                                     \".........|.........|.........|..\"       32 bytes\n+    const auto node_low = []() { auto r  = \"(this is node to-be-diddled low)\"_bv; r.front() = 0x00; return r; }();\n+    const auto node_high = []() { auto r = \"(this is nod to-be-diddled high)\"_bv; r.front() = 0xFF; return r; }();\n+    assert(node_low.size() == 32 && node_high.size() == 32);\n+\n+    assert(node_low < from_base_blob(tapleaf_hash1) && from_base_blob(tapleaf_hash1) < node_high);\n+    assert(node_low < from_base_blob(tapleaf_hash2) && from_base_blob(tapleaf_hash2) < node_high);\n+\n+    const CHashWriter hw_branch{TaggedHash(\"TapBranch\")};\n+\n+    {\n+        // Control block contains only the initial point, no nodes - always returns\n+        // the tapleaf hash, doesn't matter what the control block is\n+        uint256 expected1 = tapleaf_hash1;\n+        uint256 actual1a = ComputeTaprootMerkleRoot(control_base1, tapleaf_hash1);\n+        BOOST_TEST(expected1 == actual1a,\n+                   \"expected \" << HexStr(expected1) << \", actual \" << HexStr(actual1a));\n+        uint256 actual1b = ComputeTaprootMerkleRoot(control_base2, tapleaf_hash1);\n+        BOOST_TEST(expected1 == actual1b,\n+                   \"expected \" << HexStr(expected1) << \", actual \" << HexStr(actual1b));\n+        uint256 expected2 = tapleaf_hash2;\n+        uint256 actual2 = ComputeTaprootMerkleRoot(control_base2, tapleaf_hash2);\n+        BOOST_TEST(expected2 == actual2,\n+                   \"expected \" << HexStr(expected2) << \", actual \" << HexStr(actual2));\n+    }\n+\n+    {\n+        // Control block contains one node - check both lexicographic orders\n+\n+        {\n+            uint256 expected = (CHashWriter{hw_branch} << Span{node_low} << tapleaf_hash1).GetSHA256();\n+            uint256 actual = ComputeTaprootMerkleRoot(Span{control_base1 || node_low}, tapleaf_hash1);\n+            BOOST_TEST(expected == actual,\n+                    \"expected \" << HexStr(expected) << \", actual \" << HexStr(actual));\n+        }\n+        {\n+            uint256 expected = (CHashWriter{hw_branch} << tapleaf_hash1 << Span{node_high}).GetSHA256();\n+            uint256 actual = ComputeTaprootMerkleRoot(Span{control_base1 || node_high}, tapleaf_hash1);\n+            BOOST_TEST(expected == actual,\n+                    \"expected \" << HexStr(expected) << \", actual \" << HexStr(actual));\n+        }\n+    }\n+\n+    {\n+        // With a control block with more than one node (here: two nodes), each subsequent node\n+        // is hashed with the hash of the previous nodes in _lexicographic_ order.\n+\n+        // Control block is going to be `point1 || node_high || node_{low,high}`\n+        uint256 intermediate_k = (CHashWriter{hw_branch} << tapleaf_hash1 << Span{node_high}).GetSHA256();\n+\n+        // Verify that the intermediate hash is less than `node_high`\n+        assert(from_base_blob(intermediate_k) < node_high);\n+\n+        {\n+            // 2nd node lexicographically _less than_ intermediate hash\n+            uint256 expected = (CHashWriter{hw_branch} << Span{node_low} << intermediate_k).GetSHA256();\n+            uint256 actual = ComputeTaprootMerkleRoot(control_base1 || node_high || node_low, tapleaf_hash1);\n+            BOOST_TEST(expected == actual,\n+                    \"expected \" << HexStr(expected) << \", actual \" << HexStr(actual));\n+        }\n+\n+        {\n+            // 2nd node lexicographically _greater than_ intermediate hash\n+            uint256 expected = (CHashWriter{hw_branch} << intermediate_k << Span{node_high}).GetSHA256();\n+            uint256 actual = ComputeTaprootMerkleRoot(control_base1 || node_high || node_high, tapleaf_hash1);\n+            BOOST_TEST(expected == actual,\n+                    \"expected \" << HexStr(expected) << \", actual \" << HexStr(actual));\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(taproot_v1_verify_script)\n+{\n+    // Testing Taproot code paths in `VerifyWitnessProgram` and\n+    // `SigVersion::TAPSCRIPT` code paths in `ExecuteWitnessScript`.\n+\n+    // Both `VerifyWitnessProgram` and `ExecuteWitnessScript` are `static`\n+    // inside of `interpreter.cpp` and thus inaccessible to a unit test.\n+    // The way to get to them is indirectly via `VerifyScript`.\n+\n+    // Tests all success and failure paths mentioned in BIP-341 and\n+    // BIP-342.\n+\n+    // This is a _unit test_ not a _functional test_ and the unit being\n+    // tested here does _not_ include actually verifying the signature.\n+    // That is tested elsewhere (e.g., by tests `verify_schnorr_signature`\n+    // and `check_schnorr_signature` in this file).  _This_ test _mocks_\n+    // the Schnorr signature verfication.  Thus the test data need not\n+    // actually have valid signatures (and is thus easier to prepare).\n+\n+    /**\n+     * A fluent API for running these tests.  Swiped and adapted from\n+     * `script_tests.cpp`.\n+     *\n+     * (Easiest way to understand this class is to look at the actual tests\n+     * that follow in this function.)\n+     */\n+\n+    struct Context {\n+        // raw key data from `key_tests.cpp` @305\n+        valtype m_sec{ParseHex(\"0000000000000000000000000000000000000000000000000000000000000003\")};\n+        valtype m_pub{ParseHex(\"F9308A019258C31049344F85F89D5229B531C845836F99B08601F113BCE036F9\")};\n+        valtype m_sig{ParseHex(\"E907831F80848D1069A5371B402410364BDF1C5F8307B0084C55F1CE2DCA821525F66A4A85EA8B71E482A74F382D2CE5EBEEE8FDB2172F477DF4900D310536C0\")};\n+\n+        CKey m_sec_key;\n+        XOnlyPubKey m_pub_key;\n+\n+    private:\n+        void SetupKeys()\n+        {\n+            BOOST_TEST(m_sec.size() == 32);\n+            BOOST_TEST(m_pub.size() == 32);\n+            BOOST_TEST(m_sig.size() == 64);\n+\n+            m_sec_key.Set(m_sec.begin(), m_sec.end(), true /*compressed*/);\n+            m_pub_key = XOnlyPubKey(m_sec_key.GetPubKey());\n+\n+            BOOST_TEST(m_pub_key.IsFullyValid());\n+        }\n+\n+    public:\n+        explicit Context(std::string_view descr) : m_test_description(descr)\n+        {\n+            SetupKeys();\n+\n+            // For Taproot v1 force SegWit version 1\n+            m_scriptPubKey << OP_1;\n+        }\n+\n+        const std::string m_test_description;\n+\n+        bool m_p2sh_wrapped = false;\n+        CScript m_scriptPubKey;\n+        unsigned int m_hash_type = SIGHASH_DEFAULT;\n+        valtype m_annex;\n+        std::vector<valtype> m_initial_witness_stack;\n+        valtype m_witness_signature;\n+        bool m_witness_init = false;\n+        CScriptWitness m_witness;\n+        CScript m_tapscript;\n+        bool m_control_block_init = false;\n+        valtype m_control_block;\n+        unsigned int m_leaf_version = 0;\n+        unsigned int m_pubkey_parity = 0;\n+        valtype m_taproot_internal_key;\n+        valtype m_control_block_field;\n+        unsigned int m_flags = 0;\n+        CHECKER_VALIDATION m_checker_validation = CHECKER_VALIDATION::ALWAYS_FAILS;\n+\n+        int64_t m_caller_line = 0;\n+        bool m_result = false;\n+        ScriptError m_serror = SCRIPT_ERR_OK;\n+        bool m_checker_was_called = false;\n+\n+        //\n+        // N.B.: Some methods herein temporarily marked [[maybe_unused]]\n+        // until the Tapscript tests get written\n+        //\n+\n+        Context& SetValidPublicKey()\n+        {\n+            m_scriptPubKey << m_pub;\n+            return *this;\n+        }\n+\n+        [[maybe_unused]] Context& SetPublicKey(valtype key)\n+        {\n+            BOOST_TEST(key.size() == 32);\n+            m_scriptPubKey << key;\n+            return *this;\n+        }\n+\n+        Context& SetNBytePublicKey(size_t n)\n+        {\n+            valtype pub(n, 0xAB);\n+            m_scriptPubKey << pub;\n+            return *this;\n+        }\n+\n+        Context& SetSignatureAnnex(const valtype& annex_without_suffix)\n+        {\n+            m_annex.push_back(0x50); // by definition of annex\n+            m_annex.insert(m_annex.end(), annex_without_suffix.begin(), annex_without_suffix.end());\n+            return *this;\n+        }\n+\n+        // Used to directly set a witness (presumably, invalid for Taproot key path spending)\n+        Context& SetWitness(const std::vector<valtype>& witness)\n+        {\n+            m_witness_init = true;\n+            m_witness.stack = witness;\n+            return *this;\n+        }\n+\n+        [[maybe_unused]] Context& PushToWitnessStack(const valtype& v)\n+        {\n+            m_initial_witness_stack.push_back(v);\n+            return *this;\n+        }\n+\n+        Context& SetValidSignatureInWitness(unsigned char hash_type = SIGHASH_DEFAULT)\n+        {\n+            m_hash_type = hash_type;\n+            m_witness_signature = m_sig;\n+            if (hash_type) m_witness_signature.push_back(hash_type);\n+\n+            BOOST_TEST((hash_type ? m_witness_signature.size() == 65 : m_witness_signature.size() == 64));\n+            return *this;\n+        }\n+\n+        // Used to directly set the signature in the witness (presumably, invalid for Taproot key path spending)\n+        Context& SetSignatureInWitness(const valtype& sig)\n+        {\n+            m_hash_type = SIGHASH_DEFAULT;\n+            m_witness_signature = sig;\n+            return *this;\n+        }\n+\n+        [[maybe_unused]] CScript& SetTapscript()\n+        {\n+            return m_tapscript;\n+        }\n+\n+        [[maybe_unused]] Context& SetTapscriptLeafVersion()\n+        {\n+            m_leaf_version = 0xC0;\n+            return *this;\n+        }\n+\n+        [[maybe_unused]] Context& SetLeafVersion(unsigned int lv, unsigned int pubkey_parity)\n+        {\n+            BOOST_TEST(lv < 256);\n+            BOOST_TEST(pubkey_parity < 2);\n+\n+            m_leaf_version = lv;\n+            m_pubkey_parity = pubkey_parity;\n+            return *this;\n+        }\n+\n+        [[maybe_unused]] Context& SetTaprootInternalKey(const valtype& p)\n+        {\n+            BOOST_TEST(p.size() == 32);\n+            m_taproot_internal_key = p;\n+            return *this;\n+        }\n+\n+        [[maybe_unused]] Context& AddControlBlockField(const valtype& f)\n+        {\n+            BOOST_TEST(f.size() = 32);\n+            m_control_block_field.insert(m_control_block_field.end(), f.begin(), f.end());\n+            return *this;\n+        }\n+\n+        [[maybe_unused]] Context& SetControlBlock(const valtype& cb)\n+        {\n+            m_control_block_init = true;\n+            m_control_block = cb;\n+            return *this;\n+        }\n+\n+        // Used to directly set the flags (presumably, not the usual Taproot key path spending flags)\n+        Context& SetVerifyFlags(unsigned int flags)\n+        {\n+            m_flags = flags;\n+            return *this;\n+        }\n+\n+        Context& SetSchnorrSignatureValidation(CHECKER_VALIDATION checker_validation)\n+        {\n+            m_checker_validation = checker_validation;\n+            return *this;\n+        }\n+\n+        Context& SetP2SHWrapped()\n+        {\n+            m_p2sh_wrapped = true;\n+            return *this;\n+        }\n+\n+        Context& DoTest(int64_t line)\n+        {\n+            m_caller_line = line;\n+\n+            BOOST_TEST_MESSAGE(Descr() << \"doing test\");\n+\n+            // Build control block\n+            bool have_control_block = m_control_block_init;\n+            valtype control_block(m_control_block);\n+            if (!have_control_block) {\n+                BOOST_TEST_MESSAGE(\"maybe building control block\");\n+                if (m_leaf_version) {\n+                    BOOST_TEST_MESSAGE(\"have !=0 leaf version, definitely building control block\");\n+                    have_control_block = true;\n+                    control_block.push_back(static_cast<unsigned char>(m_leaf_version | m_pubkey_parity));\n+                    control_block.insert(control_block.end(), m_taproot_internal_key.begin(), m_taproot_internal_key.end());\n+                    control_block.insert(control_block.end(), m_control_block_field.begin(), m_control_block_field.end());\n+                    BOOST_TEST_MESSAGE(\"control block size \" << control_block.size());\n+                }\n+            }\n+\n+            // build the witness if necessary\n+            if (!m_witness_init) {\n+                if (have_control_block) {\n+                    // Taproot script path spend\n+                    for (const auto& elem : m_initial_witness_stack)\n+                        m_witness.stack.push_back(elem);\n+                    m_witness.stack.push_back(valtype(m_tapscript.begin(), m_tapscript.end()));\n+                    m_witness.stack.push_back(control_block);\n+                } else {\n+                    // Taproot key path spend\n+                    if (!m_witness_signature.empty()) m_witness.stack.push_back(m_witness_signature);\n+                }\n+                if (!m_annex.empty()) m_witness.stack.push_back(m_annex);\n+            }\n+\n+            if (!m_flags) {\n+                m_flags = SCRIPT_VERIFY_SIGPUSHONLY | SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_TAPROOT;\n+            }\n+\n+            SignatureCheckerMock checker_mock(m_checker_validation);\n+            CScript script_sig; // must be empty for actual Taproot\n+            if (m_p2sh_wrapped) {\n+                // But BIP-341 allows all SegWit v1 P2SH-wrapped outputs to pass\n+                valtype fake_hash(20, 0x00);\n+                script_sig << OP_0 << fake_hash;\n+            }\n+\n+            m_result = VerifyScript(script_sig,\n+                                    m_scriptPubKey,\n+                                    &m_witness,\n+                                    m_flags,\n+                                    checker_mock,\n+                                    &m_serror);\n+\n+            m_checker_was_called = checker_mock.CheckerWasCalled();\n+\n+            return *this;\n+        }\n+\n+        Context& CheckCallSucceeded()\n+        {\n+            BOOST_CHECK_MESSAGE(m_result,\n+                                Descr() << \": VerifyScript succeeded, as expected\");\n+            BOOST_CHECK_MESSAGE(m_serror == SCRIPT_ERR_OK,\n+                                Descr() << \": error code expected OK, actual was \"\n+                                        << ScriptErrorString(m_serror));\n+            return *this;\n+        }\n+\n+        Context& CheckCallFailed(ScriptError expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!m_result,\n+                                Descr() << \": VerifyScript failed, as expected\");\n+            BOOST_CHECK_MESSAGE(m_serror == expected,\n+                                Descr() << \": Error code expected \" << ScriptErrorString(expected)\n+                                        << \", actual was \" << ScriptErrorString(m_serror));\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureCheckerWasCalled()\n+        {\n+            BOOST_CHECK_MESSAGE(m_checker_was_called,\n+                                Descr() << \": Schnoor signature checker was called, as expected\");",
      "path": "src/test/script_tapscript_tests.cpp",
      "position": 1438,
      "original_position": 1438,
      "commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "original_commit_id": "eeefec343592c6de85048e3b055ba49755cfb072",
      "in_reply_to_id": null,
      "user": {
        "login": "jamesob",
        "id": 73197,
        "node_id": "MDQ6VXNlcjczMTk3",
        "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jamesob",
        "html_url": "https://github.com/jamesob",
        "followers_url": "https://api.github.com/users/jamesob/followers",
        "following_url": "https://api.github.com/users/jamesob/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jamesob/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jamesob/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
        "organizations_url": "https://api.github.com/users/jamesob/orgs",
        "repos_url": "https://api.github.com/users/jamesob/repos",
        "events_url": "https://api.github.com/users/jamesob/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jamesob/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "https://github.com/bitcoin/bitcoin/pull/25097/commits/eeefec343592c6de85048e3b055ba49755cfb072\r\n\r\n\"Schnoor\" misspelling here and elsewhere",
      "created_at": "2022-07-12T20:01:44Z",
      "updated_at": "2022-07-12T20:25:07Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r919375518",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/919375518"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1438,
      "original_line": 1438,
      "side": "RIGHT"
    }
  ]
}