{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938",
    "id": 109467555,
    "node_id": "MDExOlB1bGxSZXF1ZXN0MTA5NDY3NTU1",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/9938",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/9938.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/9938.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/9938",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/9938/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/39397bb40cc0ead65a131492376d6a219c99c8d2",
    "number": 9938,
    "state": "closed",
    "locked": true,
    "maintainer_can_modify": false,
    "title": "Lock-Free CheckQueue",
    "user": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "TL;DR: This PR introduces a new hopefully easy-to-review Lock-Free CheckQueue algorithm. It's really fast!\r\n\r\n## Summary & Problem Statement\r\n\r\nIn Bitcoin-Qt 0.8, parallel script validation was introduced to improve the speed at which a block could be validated. The basic way in which this worked is that the master thread creates a task for every script of each input in a transaction being checked, and enqueues it to a work queue. After adding all tasks, the master also becomes a worker. Each worker thread claims a number of tasks from the queue (based on how many tasks are available and how many workers are available) and then runs each task, reporting if any errors were encountered. The core approach has not changed significantly since 0.8. The current approach is deficient for four main reasons which these changes address over 2 major commits (and 1 minor one introducing API change only, and 2 others covered in previous PRs).\r\n\r\n## Deficiencies in Current CheckQueue & Solutions\r\n\r\n### 1. Memory Instability: \r\nEach task must be moved to three different memory locations during its lifetime:\r\n1) the place where the master creates the task.\r\n2) the shared work queue.\r\n3) the worker-local work queue.\r\nThis also makes it difficult to write multithreaded code, because memory is modified more than once during validation.\r\n#### Solution:\r\nThe new algorithm uses stable memory: during block validation, enough memory for the worst case number of checks is allocated, and then tasks are directly placed and read out of that memory. Instead, each worker thread claims a pointer to the task. See 89a1f93\r\n### 2. Lock-Heavy algorithm: \r\nIn the original algorithm, each worker thread and the master contend for a single lock for enqueuing and dequeuing tasks. This is highly inefficient, each worker spends significant amount of time acquiring the lock to be able to dequeue a task, and the master spends time waiting to enqueue tasks. \r\n#### Solution:\r\nThe new algorithm is Lock-Free; during block validation no locks are taken for enqueuing or dequeuing tasks, only atomic memory is read or written. The use of a different piece of atomic memory for enqueuing and most dequeuing operations means that the master and worker threads infrequently interact during validation, meaning low contention. See 6e24aa8\r\n### 3. Sleeping during validation:\r\nIn the original algorithm, while waiting for a task to be enqueued by the master, each thread sleeps. This means that the OS’s scheduler might choose to pre-empt the thread, thrashing it’s cache with another process’s memory. Furthermore, the latency for a wake up operation is high, as it requires the operating system to awaken a thread.\r\n#### Solution:\r\nthe new algorithm only sleeps before and after block validation, and busy-spins waiting for tasks until the master joins and there are no more tasks available (then sleeps). See 6e24aa8\r\n### 4. Arbitrary batch size selection: \r\nThe original batch size algorithm was selected as an experimental tuning for reasonable performance. If the batch size is too small, workers spend too much time getting a new task and not enough time running the tasks. The problem with any form of batching is that you may run into an imbalanced case where one worker has a batch (say of size five) and another worker has no tasks. In order to improve that, a batch size of one is optimal.\r\n#### Solution:\r\nThe new algorithm uses a batch size of one, so that all threads finish their work at as close to the same time as possible. See 6e24aa8.\r\n\r\n## Reviewing this PR\r\n\r\n### Code Organization\r\nIn writing this PR, I used many small-step iterations to get to the final design. While I am fairly confident that the commits in this PR should be easily reviewable, I have left the unsquashed version available here for anyone to reference\r\nhttps://github.com/JeremyRubin/bitcoin/tree/PR-lockfree-checkqueue-unsquashed\r\n\r\n### Testing\r\n\r\n#9497 introduces a fairly comprehensive set of tests, which these changes pass, as well as the earlier CheckQueue. See #9497 for details on the conditions tested.\r\n\r\n### Performance\r\n Test results are from a 2011 MacBook Pro 13\", 2.7 GHz Intel Core i7, 8 GB 1333 MHz DDR3.\r\n#### MicroBenchmark Performance (2.9 to 5.7X faster)\r\n#9498 introduced two new microbenchmarks for the CheckQueue. One which tests tasks which are empty, and another which tests tasks that do a little bit of work. These are microbenchmarks, so they need to be taken with a grain of salt.\r\n\r\n```\r\n#Before (7ff4a538a8682cdf02a4bcd6f15499c841001b73)\r\n#Benchmark,count,min,max,average,min_cycles,max_cycles,average_cycles\r\nCCheckQueueSpeed,896,0.001128047704697,0.001315370202065,0.001167648338846,3038807,3543440,3145483\r\nCCheckQueueSpeedPrevectorJob,320,0.002763845026493,0.003494121134281,0.003255434334278,7445473,9415834,8770003\r\n\r\n#After (6e24aa818be4b494fc1809a7ca3ee568e253deb6)\r\n#Benchmark,count,min,max,average,min_cycles,max_cycles,average_cycles\r\nCCheckQueueSpeed,5120,0.000198634807020,0.000226773321629,0.000202708039433,535092,610897,546067\r\nCCheckQueueSpeedPrevectorJob,896,0.000990316271782,0.001982234418392,0.001142452071820,2667680,5339862,3077721\r\n```\r\n\r\nSo we see for trivial jobs, it's about 5.7X faster, and for more involved jobs, about 2.9X faster. \r\n\r\n#### Test Performance (10X faster)\r\nI have observed very nice performance improvements when it comes to how long it takes to run the checkqueue_tests.\r\n\r\n```\r\n#before (08e4e1ea89427a2594415d0b37011692a5109c39)\r\n$ time ./test_bitcoin -t checkqueue_tests\r\n./test/test_bitcoin -t checkqueue_tests  12.39s user 58.12s system 116% cpu 1:00.31 total\r\n#after (6e24aa818be4b494fc1809a7ca3ee568e253deb6)\r\n$ time ./test_bitcoin -t checkqueue_tests\r\n./test/test_bitcoin -t checkqueue_tests  3.43s user 1.40s system 78% cpu 6.180 total\r\n```\r\nSo we see about a 10x performance improvement here.\r\n\r\n#### Cross Platform\r\nIt would be good to have reviewers comment with cross platform performance testing, as some of the lock free instructions may be slower on some platforms than others, and I don't have access to a large enough swath of machines. If you're reviewing performance, you may find the benchdiff.py tool I wrote useful https://github.com/JeremyRubin/bitcoin/commit/14aa19a35cbf0cff742f36a2c9ca00af162918ee.\r\n\r\n#### Real World/Simulated Numbers\r\n\r\nI don't have great real-world-node numbers yet for these changes, but I'll wait for others (e.g., @morcos) to report back on those.\r\n\r\n_edit: I have run a simulation on a month of block validation on a 4-core machine and seen no difference in aggregate performance. I'll poke around to see if the design can be tweaked a little bit for some advantage with fewer cores, but the more important simulations are for machines with >7 cores or multiple cpus, where the contention relieved by this PR becomes more significant._\r\n\r\n### Notes\r\n\r\nThis builds on #9497 (and #9495). There were a couple minor nits on those PR's outstanding, but I figure they can be addressed here later with a squashme (rather than having to squash those, get them re-reviewed, and then issue this PR). An earlier (and worse) attempt at a similar design can be seen here for comparison https://github.com/bitcoin/bitcoin/pull/8464.\r\n\r\n\r\n## Acknowledgements\r\n\r\nThanks to @morcos and @sdaftuar for supporting and helping in the development of this work, and to various others (@TheBlueMatt, @theuni, and others) for review in feedback at various stages of this project.",
    "labels": [
      {
        "id": 118379652,
        "node_id": "MDU6TGFiZWwxMTgzNzk2NTI=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Validation",
        "name": "Validation",
        "color": "6060aa",
        "default": false
      }
    ],
    "active_lock_reason": "resolved",
    "created_at": "2017-03-07T12:20:29Z",
    "updated_at": "2022-08-18T18:19:47Z",
    "closed_at": "2018-03-06T18:07:17Z",
    "mergeable": false,
    "mergeable_state": "dirty",
    "merge_commit_sha": "37ad9c9bea5c4c52674da568111351d3f4e50302",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": false,
    "head": {
      "label": "JeremyRubin:PR-lockfree-checkqueue",
      "ref": "PR-lockfree-checkqueue",
      "sha": "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "user": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 53111803,
        "node_id": "MDEwOlJlcG9zaXRvcnk1MzExMTgwMw==",
        "name": "bitcoin",
        "full_name": "JeremyRubin/bitcoin",
        "owner": {
          "login": "JeremyRubin",
          "id": 886523,
          "node_id": "MDQ6VXNlcjg4NjUyMw==",
          "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/JeremyRubin",
          "html_url": "https://github.com/JeremyRubin",
          "followers_url": "https://api.github.com/users/JeremyRubin/followers",
          "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
          "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
          "repos_url": "https://api.github.com/users/JeremyRubin/repos",
          "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/JeremyRubin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/JeremyRubin/bitcoin",
        "archive_url": "https://api.github.com/repos/JeremyRubin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/JeremyRubin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/JeremyRubin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/JeremyRubin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/JeremyRubin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/JeremyRubin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/JeremyRubin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/JeremyRubin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/JeremyRubin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/JeremyRubin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/JeremyRubin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/JeremyRubin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/JeremyRubin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/JeremyRubin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/JeremyRubin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/JeremyRubin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/JeremyRubin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/JeremyRubin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/JeremyRubin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/JeremyRubin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/JeremyRubin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/JeremyRubin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/JeremyRubin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/JeremyRubin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/JeremyRubin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/JeremyRubin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/JeremyRubin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/JeremyRubin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/JeremyRubin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:JeremyRubin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/JeremyRubin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/JeremyRubin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/JeremyRubin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/JeremyRubin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/JeremyRubin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/JeremyRubin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/JeremyRubin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/JeremyRubin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/JeremyRubin/bitcoin/hooks",
        "svn_url": "https://github.com/JeremyRubin/bitcoin",
        "homepage": "https://bitcoin.org/en/download",
        "language": "C++",
        "forks_count": 7,
        "stargazers_count": 10,
        "watchers_count": 10,
        "size": 203232,
        "default_branch": "master",
        "open_issues_count": 2,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-01-04T19:39:36Z",
        "created_at": "2016-03-04T06:06:13Z",
        "updated_at": "2023-01-05T18:14:42Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "efae3663a772169f9ef5172d76f938e0bb02eca4",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 34324,
        "stargazers_count": 69818,
        "watchers_count": 69818,
        "size": 233879,
        "default_branch": "master",
        "open_issues_count": 627,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-06-06T22:42:00Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2023-06-06T22:16:48Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
      }
    },
    "author_association": "CONTRIBUTOR",
    "draft": false,
    "additions": 199,
    "deletions": 152,
    "changed_files": 6,
    "commits": 3,
    "review_comments": 20,
    "comments": 3
  },
  "events": [
    {
      "event": "mentioned",
      "id": 989458953,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50OTg5NDU4OTUz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/989458953",
      "actor": {
        "login": "morcos",
        "id": 4360349,
        "node_id": "MDQ6VXNlcjQzNjAzNDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/morcos",
        "html_url": "https://github.com/morcos",
        "followers_url": "https://api.github.com/users/morcos/followers",
        "following_url": "https://api.github.com/users/morcos/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/morcos/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/morcos/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
        "organizations_url": "https://api.github.com/users/morcos/orgs",
        "repos_url": "https://api.github.com/users/morcos/repos",
        "events_url": "https://api.github.com/users/morcos/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/morcos/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-03-07T12:20:29Z"
    },
    {
      "event": "subscribed",
      "id": 989458955,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDk4OTQ1ODk1NQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/989458955",
      "actor": {
        "login": "morcos",
        "id": 4360349,
        "node_id": "MDQ6VXNlcjQzNjAzNDk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/morcos",
        "html_url": "https://github.com/morcos",
        "followers_url": "https://api.github.com/users/morcos/followers",
        "following_url": "https://api.github.com/users/morcos/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/morcos/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/morcos/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
        "organizations_url": "https://api.github.com/users/morcos/orgs",
        "repos_url": "https://api.github.com/users/morcos/repos",
        "events_url": "https://api.github.com/users/morcos/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/morcos/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-03-07T12:20:29Z"
    },
    {
      "event": "mentioned",
      "id": 989458956,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50OTg5NDU4OTU2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/989458956",
      "actor": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-03-07T12:20:29Z"
    },
    {
      "event": "subscribed",
      "id": 989458957,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDk4OTQ1ODk1Nw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/989458957",
      "actor": {
        "login": "sdaftuar",
        "id": 7463573,
        "node_id": "MDQ6VXNlcjc0NjM1NzM=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7463573?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sdaftuar",
        "html_url": "https://github.com/sdaftuar",
        "followers_url": "https://api.github.com/users/sdaftuar/followers",
        "following_url": "https://api.github.com/users/sdaftuar/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sdaftuar/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sdaftuar/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sdaftuar/subscriptions",
        "organizations_url": "https://api.github.com/users/sdaftuar/orgs",
        "repos_url": "https://api.github.com/users/sdaftuar/repos",
        "events_url": "https://api.github.com/users/sdaftuar/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sdaftuar/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-03-07T12:20:29Z"
    },
    {
      "event": "mentioned",
      "id": 989458958,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50OTg5NDU4OTU4",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/989458958",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-03-07T12:20:29Z"
    },
    {
      "event": "subscribed",
      "id": 989458959,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDk4OTQ1ODk1OQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/989458959",
      "actor": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-03-07T12:20:29Z"
    },
    {
      "event": "mentioned",
      "id": 989458960,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50OTg5NDU4OTYw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/989458960",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-03-07T12:20:29Z"
    },
    {
      "event": "subscribed",
      "id": 989458961,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDk4OTQ1ODk2MQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/989458961",
      "actor": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-03-07T12:20:29Z"
    },
    {
      "event": "labeled",
      "id": 989865494,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDk4OTg2NTQ5NA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/989865494",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-03-07T16:25:29Z",
      "label": {
        "name": "Validation",
        "color": "6060aa"
      }
    },
    {
      "event": "reviewed",
      "id": 25891086,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4OTEwODY=",
      "url": null,
      "actor": null,
      "commit_id": "08e4e1ea89427a2594415d0b37011692a5109c39",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Generally looks good. I'm curious if you've benchmarked the lock-free version vs just dropping the last commit (possibly after removing the batching, if that was actually a loss). Given the contention on fAllOk (which could be trivially removed since you dont quit early on !fAllOk, btw) and check_mem_top/check_mem_bot, I'm surprised there is much of a win to be had on the last commit.",
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9938#pullrequestreview-25891086",
      "submitted_at": "2017-03-08T23:08:19Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMjMyYzA3YzgyMmIyZWIzZWYyOTEwOTYyZGI3NWIwZTZlOTFhNTRi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0232c07c822b2eb3ef2910962db75b0e6e91a54b",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/0232c07c822b2eb3ef2910962db75b0e6e91a54b",
      "tree": {
        "sha": "ad92a0ab88e06cf051e6a16254358674608b8c34",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ad92a0ab88e06cf051e6a16254358674608b8c34"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5114f8113627791b871c88998bd5a3d36961c241",
          "sha": "5114f8113627791b871c88998bd5a3d36961c241",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/5114f8113627791b871c88998bd5a3d36961c241"
        }
      ],
      "message": "CheckQueue: Add size constants to validation.{h,cpp}.\nUpdate code to pass MAX_SCRIPTCHECKS_PER_BLOCK to CCheckQueueControl",
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2017-03-27T17:34:29Z"
      },
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2017-01-12T21:38:43Z"
      },
      "sha": "0232c07c822b2eb3ef2910962db75b0e6e91a54b"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMmU5Y2Q0NzJkNDFhY2ZkYTVlMWFlZDVlNTJmYTdjYzQ3YjE3MDYz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/12e9cd472d41acfda5e1aed5e52fa7cc47b17063",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/12e9cd472d41acfda5e1aed5e52fa7cc47b17063",
      "tree": {
        "sha": "d32cc1d8e970fbf4d8eb5537fa4d061dd1717d8c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d32cc1d8e970fbf4d8eb5537fa4d061dd1717d8c"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0232c07c822b2eb3ef2910962db75b0e6e91a54b",
          "sha": "0232c07c822b2eb3ef2910962db75b0e6e91a54b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/0232c07c822b2eb3ef2910962db75b0e6e91a54b"
        }
      ],
      "message": "CheckQueue: Make the checkqueue's checks \"memory-stable\". Before this commit,\nchecks were stored in three separate vectors. First, a vector was made locally\nto pass to a call to CCheckQueueControl::Add. In that call, checks were added to\nthe main CCheckQueue memory, then each thread had to locally (per batch) put the\ncheck into a new, local vector. This means the location of the Check moved 2\ntimes. In this patch, the check is created in a buffer associated with the\nCCheckQueueControl. Instead of moving the check, a counter is incremented to\nkeep track of which threads have claimed which checks.\n\nAlso updates benchmark to use new in-place CheckQueue API",
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2017-03-27T17:34:29Z"
      },
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2017-01-12T20:33:53Z"
      },
      "sha": "12e9cd472d41acfda5e1aed5e52fa7cc47b17063"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzozOTM5N2JiNDBjYzBlYWQ2NWExMzE0OTIzNzZkNmEyMTljOTljOGQy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/39397bb40cc0ead65a131492376d6a219c99c8d2",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/39397bb40cc0ead65a131492376d6a219c99c8d2",
      "tree": {
        "sha": "850bf96cf8ed3fdd85cc875ce9dab845764b5f66",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/850bf96cf8ed3fdd85cc875ce9dab845764b5f66"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/12e9cd472d41acfda5e1aed5e52fa7cc47b17063",
          "sha": "12e9cd472d41acfda5e1aed5e52fa7cc47b17063",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/12e9cd472d41acfda5e1aed5e52fa7cc47b17063"
        }
      ],
      "message": "CheckQueue: This commit refactors the CheckQueue to be written \"lock free\" style\nto improve the concurrency on multicore machines.  In effect, it eliminates the\nuse of any \"critical section\" during block validation.",
      "committer": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2017-03-27T17:34:29Z"
      },
      "author": {
        "name": "Jeremy Rubin",
        "email": "jeremy.l.rubin@gmail.com",
        "date": "2017-01-13T00:51:19Z"
      },
      "sha": "39397bb40cc0ead65a131492376d6a219c99c8d2"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 1017127592,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50MTAxNzEyNzU5Mg==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/1017127592",
      "actor": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2017-03-27T17:41:25Z"
    },
    {
      "event": "referenced",
      "id": 1017208924,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDEwMTcyMDg5MjQ=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/1017208924",
      "actor": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "b36ad42d0a21690d039c90d106ca48229570aba6",
      "commit_url": "https://api.github.com/repos/JeremyRubin/bitcoin/commits/b36ad42d0a21690d039c90d106ca48229570aba6",
      "created_at": "2017-03-27T18:26:51Z"
    },
    {
      "event": "reviewed",
      "id": 29299191,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkyOTkxOTE=",
      "url": null,
      "actor": null,
      "commit_id": "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9938#pullrequestreview-29299191",
      "submitted_at": "2017-03-27T20:54:16Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
    },
    {
      "event": "referenced",
      "id": 1020612808,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDEwMjA2MTI4MDg=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/1020612808",
      "actor": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "5004e460638cbe460e5023f8297c414af6cf642f",
      "commit_url": "https://api.github.com/repos/JeremyRubin/bitcoin/commits/5004e460638cbe460e5023f8297c414af6cf642f",
      "created_at": "2017-03-29T15:06:23Z"
    },
    {
      "event": "referenced",
      "id": 1198689798,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDExOTg2ODk3OTg=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/1198689798",
      "actor": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "9cdb246e81e10a93a2e7bae1458c200e3e858a03",
      "commit_url": "https://api.github.com/repos/JeremyRubin/bitcoin/commits/9cdb246e81e10a93a2e7bae1458c200e3e858a03",
      "created_at": "2017-08-09T09:00:32Z"
    },
    {
      "event": "referenced",
      "id": 1198700654,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDExOTg3MDA2NTQ=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/1198700654",
      "actor": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "8c2f4b88828b3e40f6cc690261657e66b2653432",
      "commit_url": "https://api.github.com/repos/JeremyRubin/bitcoin/commits/8c2f4b88828b3e40f6cc690261657e66b2653432",
      "created_at": "2017-08-09T09:07:38Z"
    },
    {
      "event": "referenced",
      "id": 1291275618,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDEyOTEyNzU2MTg=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/1291275618",
      "actor": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "424be03305143cbe5da5d5adb54d73d3dc3747b6",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/424be03305143cbe5da5d5adb54d73d3dc3747b6",
      "created_at": "2017-10-12T22:35:38Z"
    },
    {
      "event": "commented",
      "id": 370873619,
      "node_id": "MDEyOklzc3VlQ29tbWVudDM3MDg3MzYxOQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/370873619",
      "actor": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-03-06T18:07:09Z",
      "updated_at": "2018-03-06T23:23:46Z",
      "author_association": "CONTRIBUTOR",
      "body": "Going to close this for now; it is a good target for future work if someone wants to take another crack at it.\r\n\r\nI have a number of further relaxations/tweaks (which need more review) to this PR available here https://github.com/JeremyRubin/bitcoin/pull/1 if anyone is taking it over, they should review those too.",
      "user": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9938#issuecomment-370873619",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/9938"
    },
    {
      "event": "closed",
      "id": 1507144600,
      "node_id": "MDExOkNsb3NlZEV2ZW50MTUwNzE0NDYwMA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/1507144600",
      "actor": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-03-06T18:07:17Z"
    },
    {
      "event": "commented",
      "id": 370882242,
      "node_id": "MDEyOklzc3VlQ29tbWVudDM3MDg4MjI0Mg==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/370882242",
      "actor": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-03-06T18:34:39Z",
      "updated_at": "2018-03-06T18:34:39Z",
      "author_association": "MEMBER",
      "body": "Should be tagged [up for grabs](https://github.com/bitcoin/bitcoin/issues?q=label%3A%22Up+for+grabs%22)",
      "user": {
        "login": "ryanofsky",
        "id": 7133040,
        "node_id": "MDQ6VXNlcjcxMzMwNDA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ryanofsky",
        "html_url": "https://github.com/ryanofsky",
        "followers_url": "https://api.github.com/users/ryanofsky/followers",
        "following_url": "https://api.github.com/users/ryanofsky/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ryanofsky/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ryanofsky/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
        "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
        "repos_url": "https://api.github.com/users/ryanofsky/repos",
        "events_url": "https://api.github.com/users/ryanofsky/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9938#issuecomment-370882242",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/9938"
    },
    {
      "event": "labeled",
      "id": 1507202505,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDE1MDcyMDI1MDU=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/1507202505",
      "actor": {
        "login": "fanquake",
        "id": 863730,
        "node_id": "MDQ6VXNlcjg2MzczMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fanquake",
        "html_url": "https://github.com/fanquake",
        "followers_url": "https://api.github.com/users/fanquake/followers",
        "following_url": "https://api.github.com/users/fanquake/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/fanquake/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/fanquake/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
        "organizations_url": "https://api.github.com/users/fanquake/orgs",
        "repos_url": "https://api.github.com/users/fanquake/repos",
        "events_url": "https://api.github.com/users/fanquake/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/fanquake/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2018-03-06T18:35:28Z",
      "label": {
        "name": "Up for grabs",
        "color": "99a810"
      }
    },
    {
      "event": "referenced",
      "id": 1516920651,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDE1MTY5MjA2NTE=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/1516920651",
      "actor": {
        "login": "HashUnlimited",
        "id": 26601261,
        "node_id": "MDQ6VXNlcjI2NjAxMjYx",
        "avatar_url": "https://avatars.githubusercontent.com/u/26601261?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/HashUnlimited",
        "html_url": "https://github.com/HashUnlimited",
        "followers_url": "https://api.github.com/users/HashUnlimited/followers",
        "following_url": "https://api.github.com/users/HashUnlimited/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/HashUnlimited/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/HashUnlimited/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/HashUnlimited/subscriptions",
        "organizations_url": "https://api.github.com/users/HashUnlimited/orgs",
        "repos_url": "https://api.github.com/users/HashUnlimited/repos",
        "events_url": "https://api.github.com/users/HashUnlimited/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/HashUnlimited/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "d83b93f000f41f0f42f2be36270054a87c733e6c",
      "commit_url": "https://api.github.com/repos/chaincoin/chaincoin/commits/d83b93f000f41f0f42f2be36270054a87c733e6c",
      "created_at": "2018-03-12T18:13:22Z"
    },
    {
      "event": "referenced",
      "id": 2903027678,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDI5MDMwMjc2Nzg=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2903027678",
      "actor": {
        "login": "PastaPastaPasta",
        "id": 6443210,
        "node_id": "MDQ6VXNlcjY0NDMyMTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6443210?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/PastaPastaPasta",
        "html_url": "https://github.com/PastaPastaPasta",
        "followers_url": "https://api.github.com/users/PastaPastaPasta/followers",
        "following_url": "https://api.github.com/users/PastaPastaPasta/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/PastaPastaPasta/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/PastaPastaPasta/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/PastaPastaPasta/subscriptions",
        "organizations_url": "https://api.github.com/users/PastaPastaPasta/orgs",
        "repos_url": "https://api.github.com/users/PastaPastaPasta/repos",
        "events_url": "https://api.github.com/users/PastaPastaPasta/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/PastaPastaPasta/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "67513d3df3f39c6fdb97b7b88c90b8c752f96f27",
      "commit_url": "https://api.github.com/repos/PastaPastaPasta/dash/commits/67513d3df3f39c6fdb97b7b88c90b8c752f96f27",
      "created_at": "2019-12-22T05:15:42Z"
    },
    {
      "event": "referenced",
      "id": 2919018695,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDI5MTkwMTg2OTU=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2919018695",
      "actor": {
        "login": "PastaPastaPasta",
        "id": 6443210,
        "node_id": "MDQ6VXNlcjY0NDMyMTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6443210?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/PastaPastaPasta",
        "html_url": "https://github.com/PastaPastaPasta",
        "followers_url": "https://api.github.com/users/PastaPastaPasta/followers",
        "following_url": "https://api.github.com/users/PastaPastaPasta/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/PastaPastaPasta/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/PastaPastaPasta/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/PastaPastaPasta/subscriptions",
        "organizations_url": "https://api.github.com/users/PastaPastaPasta/orgs",
        "repos_url": "https://api.github.com/users/PastaPastaPasta/repos",
        "events_url": "https://api.github.com/users/PastaPastaPasta/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/PastaPastaPasta/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "b85ffe17e558bdf5959546bcdfa6535d1752a569",
      "commit_url": "https://api.github.com/repos/PastaPastaPasta/dash/commits/b85ffe17e558bdf5959546bcdfa6535d1752a569",
      "created_at": "2020-01-02T22:59:28Z"
    },
    {
      "event": "referenced",
      "id": 2921937391,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDI5MjE5MzczOTE=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2921937391",
      "actor": {
        "login": "PastaPastaPasta",
        "id": 6443210,
        "node_id": "MDQ6VXNlcjY0NDMyMTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6443210?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/PastaPastaPasta",
        "html_url": "https://github.com/PastaPastaPasta",
        "followers_url": "https://api.github.com/users/PastaPastaPasta/followers",
        "following_url": "https://api.github.com/users/PastaPastaPasta/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/PastaPastaPasta/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/PastaPastaPasta/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/PastaPastaPasta/subscriptions",
        "organizations_url": "https://api.github.com/users/PastaPastaPasta/orgs",
        "repos_url": "https://api.github.com/users/PastaPastaPasta/repos",
        "events_url": "https://api.github.com/users/PastaPastaPasta/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/PastaPastaPasta/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "84a3603b8716e2efbdcea9a3521770f67508879b",
      "commit_url": "https://api.github.com/repos/PastaPastaPasta/dash/commits/84a3603b8716e2efbdcea9a3521770f67508879b",
      "created_at": "2020-01-04T16:52:28Z"
    },
    {
      "event": "referenced",
      "id": 2940914137,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDI5NDA5MTQxMzc=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2940914137",
      "actor": {
        "login": "PastaPastaPasta",
        "id": 6443210,
        "node_id": "MDQ6VXNlcjY0NDMyMTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6443210?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/PastaPastaPasta",
        "html_url": "https://github.com/PastaPastaPasta",
        "followers_url": "https://api.github.com/users/PastaPastaPasta/followers",
        "following_url": "https://api.github.com/users/PastaPastaPasta/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/PastaPastaPasta/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/PastaPastaPasta/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/PastaPastaPasta/subscriptions",
        "organizations_url": "https://api.github.com/users/PastaPastaPasta/orgs",
        "repos_url": "https://api.github.com/users/PastaPastaPasta/repos",
        "events_url": "https://api.github.com/users/PastaPastaPasta/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/PastaPastaPasta/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "84ab39d4008dd09bd569b5ae46c231414b53e3ec",
      "commit_url": "https://api.github.com/repos/PastaPastaPasta/dash/commits/84ab39d4008dd09bd569b5ae46c231414b53e3ec",
      "created_at": "2020-01-12T00:03:07Z"
    },
    {
      "event": "referenced",
      "id": 2940920353,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDI5NDA5MjAzNTM=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2940920353",
      "actor": {
        "login": "PastaPastaPasta",
        "id": 6443210,
        "node_id": "MDQ6VXNlcjY0NDMyMTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6443210?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/PastaPastaPasta",
        "html_url": "https://github.com/PastaPastaPasta",
        "followers_url": "https://api.github.com/users/PastaPastaPasta/followers",
        "following_url": "https://api.github.com/users/PastaPastaPasta/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/PastaPastaPasta/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/PastaPastaPasta/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/PastaPastaPasta/subscriptions",
        "organizations_url": "https://api.github.com/users/PastaPastaPasta/orgs",
        "repos_url": "https://api.github.com/users/PastaPastaPasta/repos",
        "events_url": "https://api.github.com/users/PastaPastaPasta/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/PastaPastaPasta/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "962becc9eb8e74f0c0a6293410ef02e41fc98d5e",
      "commit_url": "https://api.github.com/repos/PastaPastaPasta/dash/commits/962becc9eb8e74f0c0a6293410ef02e41fc98d5e",
      "created_at": "2020-01-12T00:18:57Z"
    },
    {
      "event": "referenced",
      "id": 2940921133,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDI5NDA5MjExMzM=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2940921133",
      "actor": {
        "login": "PastaPastaPasta",
        "id": 6443210,
        "node_id": "MDQ6VXNlcjY0NDMyMTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6443210?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/PastaPastaPasta",
        "html_url": "https://github.com/PastaPastaPasta",
        "followers_url": "https://api.github.com/users/PastaPastaPasta/followers",
        "following_url": "https://api.github.com/users/PastaPastaPasta/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/PastaPastaPasta/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/PastaPastaPasta/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/PastaPastaPasta/subscriptions",
        "organizations_url": "https://api.github.com/users/PastaPastaPasta/orgs",
        "repos_url": "https://api.github.com/users/PastaPastaPasta/repos",
        "events_url": "https://api.github.com/users/PastaPastaPasta/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/PastaPastaPasta/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "69991c376477ea13f4ca6cebb0ff6f2280586bcd",
      "commit_url": "https://api.github.com/repos/PastaPastaPasta/dash/commits/69991c376477ea13f4ca6cebb0ff6f2280586bcd",
      "created_at": "2020-01-12T00:20:39Z"
    },
    {
      "event": "referenced",
      "id": 2940922073,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDI5NDA5MjIwNzM=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2940922073",
      "actor": {
        "login": "PastaPastaPasta",
        "id": 6443210,
        "node_id": "MDQ6VXNlcjY0NDMyMTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6443210?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/PastaPastaPasta",
        "html_url": "https://github.com/PastaPastaPasta",
        "followers_url": "https://api.github.com/users/PastaPastaPasta/followers",
        "following_url": "https://api.github.com/users/PastaPastaPasta/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/PastaPastaPasta/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/PastaPastaPasta/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/PastaPastaPasta/subscriptions",
        "organizations_url": "https://api.github.com/users/PastaPastaPasta/orgs",
        "repos_url": "https://api.github.com/users/PastaPastaPasta/repos",
        "events_url": "https://api.github.com/users/PastaPastaPasta/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/PastaPastaPasta/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "4d0475b592e075e68c4eeac981c9a9ef0e8078b2",
      "commit_url": "https://api.github.com/repos/PastaPastaPasta/dash/commits/4d0475b592e075e68c4eeac981c9a9ef0e8078b2",
      "created_at": "2020-01-12T00:23:01Z"
    },
    {
      "event": "referenced",
      "id": 2940932059,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDI5NDA5MzIwNTk=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2940932059",
      "actor": {
        "login": "PastaPastaPasta",
        "id": 6443210,
        "node_id": "MDQ6VXNlcjY0NDMyMTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6443210?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/PastaPastaPasta",
        "html_url": "https://github.com/PastaPastaPasta",
        "followers_url": "https://api.github.com/users/PastaPastaPasta/followers",
        "following_url": "https://api.github.com/users/PastaPastaPasta/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/PastaPastaPasta/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/PastaPastaPasta/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/PastaPastaPasta/subscriptions",
        "organizations_url": "https://api.github.com/users/PastaPastaPasta/orgs",
        "repos_url": "https://api.github.com/users/PastaPastaPasta/repos",
        "events_url": "https://api.github.com/users/PastaPastaPasta/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/PastaPastaPasta/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "920e3e709d86729edda9bfde8f58fc35fc8d2917",
      "commit_url": "https://api.github.com/repos/PastaPastaPasta/dash/commits/920e3e709d86729edda9bfde8f58fc35fc8d2917",
      "created_at": "2020-01-12T00:48:57Z"
    },
    {
      "event": "referenced",
      "id": 2941571045,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDI5NDE1NzEwNDU=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2941571045",
      "actor": {
        "login": "PastaPastaPasta",
        "id": 6443210,
        "node_id": "MDQ6VXNlcjY0NDMyMTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6443210?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/PastaPastaPasta",
        "html_url": "https://github.com/PastaPastaPasta",
        "followers_url": "https://api.github.com/users/PastaPastaPasta/followers",
        "following_url": "https://api.github.com/users/PastaPastaPasta/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/PastaPastaPasta/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/PastaPastaPasta/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/PastaPastaPasta/subscriptions",
        "organizations_url": "https://api.github.com/users/PastaPastaPasta/orgs",
        "repos_url": "https://api.github.com/users/PastaPastaPasta/repos",
        "events_url": "https://api.github.com/users/PastaPastaPasta/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/PastaPastaPasta/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "40f559ebbbc4d942d6b6a5783dc4441f3456a618",
      "commit_url": "https://api.github.com/repos/PastaPastaPasta/dash/commits/40f559ebbbc4d942d6b6a5783dc4441f3456a618",
      "created_at": "2020-01-12T23:03:06Z"
    },
    {
      "event": "referenced",
      "id": 2954961631,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDI5NTQ5NjE2MzE=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/2954961631",
      "actor": {
        "login": "PastaPastaPasta",
        "id": 6443210,
        "node_id": "MDQ6VXNlcjY0NDMyMTA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6443210?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/PastaPastaPasta",
        "html_url": "https://github.com/PastaPastaPasta",
        "followers_url": "https://api.github.com/users/PastaPastaPasta/followers",
        "following_url": "https://api.github.com/users/PastaPastaPasta/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/PastaPastaPasta/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/PastaPastaPasta/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/PastaPastaPasta/subscriptions",
        "organizations_url": "https://api.github.com/users/PastaPastaPasta/orgs",
        "repos_url": "https://api.github.com/users/PastaPastaPasta/repos",
        "events_url": "https://api.github.com/users/PastaPastaPasta/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/PastaPastaPasta/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "1e2ab7633f394a49ad76c177b2162a0519915d78",
      "commit_url": "https://api.github.com/repos/PastaPastaPasta/dash/commits/1e2ab7633f394a49ad76c177b2162a0519915d78",
      "created_at": "2020-01-16T15:23:41Z"
    },
    {
      "event": "mentioned",
      "id": 4189566206,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDE4OTU2NjIwNg==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4189566206",
      "actor": {
        "login": "JeremyRand",
        "id": 244188,
        "node_id": "MDQ6VXNlcjI0NDE4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/244188?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRand",
        "html_url": "https://github.com/JeremyRand",
        "followers_url": "https://api.github.com/users/JeremyRand/followers",
        "following_url": "https://api.github.com/users/JeremyRand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRand/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRand/orgs",
        "repos_url": "https://api.github.com/users/JeremyRand/repos",
        "events_url": "https://api.github.com/users/JeremyRand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRand/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-11T08:54:44Z"
    },
    {
      "event": "subscribed",
      "id": 4189566209,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQxODk1NjYyMDk=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4189566209",
      "actor": {
        "login": "JeremyRand",
        "id": 244188,
        "node_id": "MDQ6VXNlcjI0NDE4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/244188?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRand",
        "html_url": "https://github.com/JeremyRand",
        "followers_url": "https://api.github.com/users/JeremyRand/followers",
        "following_url": "https://api.github.com/users/JeremyRand/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRand/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRand/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRand/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRand/orgs",
        "repos_url": "https://api.github.com/users/JeremyRand/repos",
        "events_url": "https://api.github.com/users/JeremyRand/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRand/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-11T08:54:44Z"
    },
    {
      "event": "commented",
      "id": 757747967,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1Nzc0Nzk2Nw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/757747967",
      "actor": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-11T08:55:11Z",
      "updated_at": "2021-01-11T08:55:11Z",
      "author_association": "MEMBER",
      "body": "Thanks @JeremyRubin for the really nice exposition of the issues in this PR description, found it helpful for reviewing #18710.",
      "user": {
        "login": "jonatack",
        "id": 2415484,
        "node_id": "MDQ6VXNlcjI0MTU0ODQ=",
        "avatar_url": "https://avatars.githubusercontent.com/u/2415484?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jonatack",
        "html_url": "https://github.com/jonatack",
        "followers_url": "https://api.github.com/users/jonatack/followers",
        "following_url": "https://api.github.com/users/jonatack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jonatack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jonatack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jonatack/subscriptions",
        "organizations_url": "https://api.github.com/users/jonatack/orgs",
        "repos_url": "https://api.github.com/users/jonatack/repos",
        "events_url": "https://api.github.com/users/jonatack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jonatack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9938#issuecomment-757747967",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/9938"
    },
    {
      "event": "mentioned",
      "id": 4189568157,
      "node_id": "MDE0Ok1lbnRpb25lZEV2ZW50NDE4OTU2ODE1Nw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4189568157",
      "actor": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-11T08:55:11Z"
    },
    {
      "event": "subscribed",
      "id": 4189568166,
      "node_id": "MDE1OlN1YnNjcmliZWRFdmVudDQxODk1NjgxNjY=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4189568166",
      "actor": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-11T08:55:11Z"
    },
    {
      "event": "referenced",
      "id": 4247308793,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQyNDczMDg3OTM=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4247308793",
      "actor": {
        "login": "laanwj",
        "id": 126646,
        "node_id": "MDQ6VXNlcjEyNjY0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/laanwj",
        "html_url": "https://github.com/laanwj",
        "followers_url": "https://api.github.com/users/laanwj/followers",
        "following_url": "https://api.github.com/users/laanwj/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/laanwj/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/laanwj/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
        "organizations_url": "https://api.github.com/users/laanwj/orgs",
        "repos_url": "https://api.github.com/users/laanwj/repos",
        "events_url": "https://api.github.com/users/laanwj/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/laanwj/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "b386d373607466546be1f3ee1344370a8290558b",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b386d373607466546be1f3ee1344370a8290558b",
      "created_at": "2021-01-25T19:21:48Z"
    },
    {
      "event": "referenced",
      "id": 4247493707,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQyNDc0OTM3MDc=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4247493707",
      "actor": {
        "login": "sidhujag",
        "id": 6238042,
        "node_id": "MDQ6VXNlcjYyMzgwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6238042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sidhujag",
        "html_url": "https://github.com/sidhujag",
        "followers_url": "https://api.github.com/users/sidhujag/followers",
        "following_url": "https://api.github.com/users/sidhujag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sidhujag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sidhujag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sidhujag/subscriptions",
        "organizations_url": "https://api.github.com/users/sidhujag/orgs",
        "repos_url": "https://api.github.com/users/sidhujag/repos",
        "events_url": "https://api.github.com/users/sidhujag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sidhujag/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "af159bf7a72f8a9bfffe54c10eac6a00e390917c",
      "commit_url": "https://api.github.com/repos/syscoin/syscoin/commits/af159bf7a72f8a9bfffe54c10eac6a00e390917c",
      "created_at": "2021-01-25T20:07:49Z"
    },
    {
      "event": "unlabeled",
      "id": 4382586960,
      "node_id": "MDE0OlVubGFiZWxlZEV2ZW50NDM4MjU4Njk2MA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4382586960",
      "actor": {
        "login": "adamjonas",
        "id": 755825,
        "node_id": "MDQ6VXNlcjc1NTgyNQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/755825?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/adamjonas",
        "html_url": "https://github.com/adamjonas",
        "followers_url": "https://api.github.com/users/adamjonas/followers",
        "following_url": "https://api.github.com/users/adamjonas/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/adamjonas/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/adamjonas/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/adamjonas/subscriptions",
        "organizations_url": "https://api.github.com/users/adamjonas/orgs",
        "repos_url": "https://api.github.com/users/adamjonas/repos",
        "events_url": "https://api.github.com/users/adamjonas/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/adamjonas/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-02-26T16:02:54Z",
      "label": {
        "name": "Up for grabs",
        "color": "99a810"
      }
    },
    {
      "event": "referenced",
      "id": 4517981633,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQ1MTc5ODE2MzM=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4517981633",
      "actor": {
        "login": "ckti",
        "id": 7046769,
        "node_id": "MDQ6VXNlcjcwNDY3Njk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7046769?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ckti",
        "html_url": "https://github.com/ckti",
        "followers_url": "https://api.github.com/users/ckti/followers",
        "following_url": "https://api.github.com/users/ckti/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ckti/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ckti/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ckti/subscriptions",
        "organizations_url": "https://api.github.com/users/ckti/orgs",
        "repos_url": "https://api.github.com/users/ckti/repos",
        "events_url": "https://api.github.com/users/ckti/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ckti/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "72d0e25cddab8fa9ba924acd933ec2ff4bdcbe76",
      "commit_url": "https://api.github.com/repos/ckti-ioncore-current/ion/commits/72d0e25cddab8fa9ba924acd933ec2ff4bdcbe76",
      "created_at": "2021-03-28T10:03:00Z"
    },
    {
      "event": "referenced",
      "id": 6529237763,
      "node_id": "REFE_lADOABII584MqTf0zwAAAAGFLEMD",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/6529237763",
      "actor": {
        "login": "gades",
        "id": 4200730,
        "node_id": "MDQ6VXNlcjQyMDA3MzA=",
        "avatar_url": "https://avatars.githubusercontent.com/u/4200730?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/gades",
        "html_url": "https://github.com/gades",
        "followers_url": "https://api.github.com/users/gades/followers",
        "following_url": "https://api.github.com/users/gades/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/gades/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/gades/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/gades/subscriptions",
        "organizations_url": "https://api.github.com/users/gades/orgs",
        "repos_url": "https://api.github.com/users/gades/repos",
        "events_url": "https://api.github.com/users/gades/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/gades/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "482f526902230b4d2a467d1f93b2b31f675b2e33",
      "commit_url": "https://api.github.com/repos/cosanta/cosanta-core/commits/482f526902230b4d2a467d1f93b2b31f675b2e33",
      "created_at": "2022-05-01T09:41:40Z"
    },
    {
      "event": "locked",
      "id": 7216512265,
      "node_id": "LOE_lADOABII584MqTf0zwAAAAGuIz0J",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7216512265",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-08-18T18:19:47Z",
      "lock_reason": "resolved"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105029718",
      "pull_request_review_id": 25891086,
      "id": 105029718,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNTAyOTcxOA==",
      "diff_hunk": "@@ -0,0 +1,442 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 41,
      "commit_id": "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "original_commit_id": "08e4e1ea89427a2594415d0b37011692a5109c39",
      "in_reply_to_id": null,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "To make the test expose more parallellism, should probably use release/acquire here, no?",
      "created_at": "2017-03-08T21:39:33Z",
      "updated_at": "2017-03-27T17:41:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105029718",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105029718"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105030247",
      "pull_request_review_id": 25891086,
      "id": 105030247,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNTAzMDI0Nw==",
      "diff_hunk": "@@ -0,0 +1,442 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(const MemoryCheck& x)\n+    {\n+        // We have to do this to make sure that destructor calls are paired\n+        //\n+        // Really, copy constructor should be deletable, but CCheckQueue breaks\n+        // if it is deleted because of internal push_back.\n+        fake_allocated_memory += b;\n+    };\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        fake_allocated_memory += b;\n+    };\n+    ~MemoryCheck(){\n+        fake_allocated_memory -= b;\n+    ",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 99,
      "commit_id": "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "original_commit_id": "08e4e1ea89427a2594415d0b37011692a5109c39",
      "in_reply_to_id": null,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: whitespace at end of line (and stray line, it looks like).",
      "created_at": "2017-03-08T21:42:00Z",
      "updated_at": "2017-03-27T17:41:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105030247",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105030247"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105030963",
      "pull_request_review_id": 25891086,
      "id": 105030963,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNTAzMDk2Mw==",
      "diff_hunk": "@@ -0,0 +1,442 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(const MemoryCheck& x)\n+    {\n+        // We have to do this to make sure that destructor calls are paired\n+        //\n+        // Really, copy constructor should be deletable, but CCheckQueue breaks\n+        // if it is deleted because of internal push_back.\n+        fake_allocated_memory += b;\n+    };\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        fake_allocated_memory += b;\n+    };\n+    ~MemoryCheck(){\n+        fake_allocated_memory -= b;\n+    \n+    };\n+    void swap(MemoryCheck& x) { std::swap(b, x.b); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<uint64_t> nFrozen;\n+    static std::condition_variable cv;\n+    static std::mutex m;\n+    // Freezing can't be the default initialized behavior given how the queue\n+    // swaps in default initialized Checks.\n+    bool should_freeze {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        if (should_freeze) {\n+            std::unique_lock<std::mutex> l(m);\n+            nFrozen = 1;\n+            cv.notify_one();\n+            cv.wait(l, []{ return nFrozen == 0;});\n+        }\n+    }\n+    void swap(FrozenCleanupCheck& x){std::swap(should_freeze, x.should_freeze);};\n+};\n+\n+// Static Allocations\n+std::mutex FrozenCleanupCheck::m{};\n+std::atomic<uint64_t> FrozenCleanupCheck::nFrozen{0};\n+std::condition_variable FrozenCleanupCheck::cv{};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+std::atomic<size_t> MemoryCheck::fake_allocated_memory{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{small_queue->Thread();});\n+    }\n+    // Make vChecks here to save on malloc (this test can be slow...)\n+    std::vector<FakeCheckCheckCompletion> vChecks;\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+        while (total) {\n+            vChecks.resize(std::min(total, (size_t) GetRand(10)));\n+            total -= vChecks.size();\n+            control.Add(vChecks);\n+        }\n+        BOOST_REQUIRE(control.Wait());\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE_EQUAL(FakeCheckCheckCompletion::n_calls, i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    range.reserve(100000/1000);\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 227,
      "commit_id": "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "original_commit_id": "08e4e1ea89427a2594415d0b37011692a5109c39",
      "in_reply_to_id": null,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: something > 10 might test parallellism a bit more, no? (and in a few other places)",
      "created_at": "2017-03-08T21:45:26Z",
      "updated_at": "2017-03-27T17:41:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105030963",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105030963"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105031924",
      "pull_request_review_id": 25891086,
      "id": 105031924,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNTAzMTkyNA==",
      "diff_hunk": "@@ -0,0 +1,442 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(const MemoryCheck& x)\n+    {\n+        // We have to do this to make sure that destructor calls are paired\n+        //\n+        // Really, copy constructor should be deletable, but CCheckQueue breaks\n+        // if it is deleted because of internal push_back.\n+        fake_allocated_memory += b;\n+    };\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        fake_allocated_memory += b;\n+    };\n+    ~MemoryCheck(){\n+        fake_allocated_memory -= b;\n+    \n+    };\n+    void swap(MemoryCheck& x) { std::swap(b, x.b); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<uint64_t> nFrozen;\n+    static std::condition_variable cv;\n+    static std::mutex m;\n+    // Freezing can't be the default initialized behavior given how the queue\n+    // swaps in default initialized Checks.\n+    bool should_freeze {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        if (should_freeze) {\n+            std::unique_lock<std::mutex> l(m);\n+            nFrozen = 1;\n+            cv.notify_one();\n+            cv.wait(l, []{ return nFrozen == 0;});\n+        }\n+    }\n+    void swap(FrozenCleanupCheck& x){std::swap(should_freeze, x.should_freeze);};\n+};\n+\n+// Static Allocations\n+std::mutex FrozenCleanupCheck::m{};\n+std::atomic<uint64_t> FrozenCleanupCheck::nFrozen{0};\n+std::condition_variable FrozenCleanupCheck::cv{};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+std::atomic<size_t> MemoryCheck::fake_allocated_memory{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{small_queue->Thread();});\n+    }\n+    // Make vChecks here to save on malloc (this test can be slow...)\n+    std::vector<FakeCheckCheckCompletion> vChecks;\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+        while (total) {\n+            vChecks.resize(std::min(total, (size_t) GetRand(10)));\n+            total -= vChecks.size();\n+            control.Add(vChecks);\n+        }\n+        BOOST_REQUIRE(control.Wait());\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE_EQUAL(FakeCheckCheckCompletion::n_calls, i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    range.reserve(100000/1000);\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                vChecks.resize(100, false);\n+                vChecks[99] = end_fails;\n+                control.Add(vChecks);\n+            }\n+            bool r =control.Wait();\n+            BOOST_REQUIRE(r || end_fails);",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 265,
      "commit_id": "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "original_commit_id": "08e4e1ea89427a2594415d0b37011692a5109c39",
      "in_reply_to_id": null,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think you meant to have an XOR here.",
      "created_at": "2017-03-08T21:49:30Z",
      "updated_at": "2017-03-27T17:41:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105031924",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105031924"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105037465",
      "pull_request_review_id": 25891086,
      "id": 105037465,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNTAzNzQ2NQ==",
      "diff_hunk": "@@ -0,0 +1,442 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(const MemoryCheck& x)\n+    {\n+        // We have to do this to make sure that destructor calls are paired\n+        //\n+        // Really, copy constructor should be deletable, but CCheckQueue breaks\n+        // if it is deleted because of internal push_back.\n+        fake_allocated_memory += b;\n+    };\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        fake_allocated_memory += b;\n+    };\n+    ~MemoryCheck(){\n+        fake_allocated_memory -= b;\n+    \n+    };\n+    void swap(MemoryCheck& x) { std::swap(b, x.b); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<uint64_t> nFrozen;\n+    static std::condition_variable cv;\n+    static std::mutex m;\n+    // Freezing can't be the default initialized behavior given how the queue\n+    // swaps in default initialized Checks.\n+    bool should_freeze {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        if (should_freeze) {\n+            std::unique_lock<std::mutex> l(m);\n+            nFrozen = 1;\n+            cv.notify_one();\n+            cv.wait(l, []{ return nFrozen == 0;});\n+        }\n+    }\n+    void swap(FrozenCleanupCheck& x){std::swap(should_freeze, x.should_freeze);};\n+};\n+\n+// Static Allocations\n+std::mutex FrozenCleanupCheck::m{};\n+std::atomic<uint64_t> FrozenCleanupCheck::nFrozen{0};\n+std::condition_variable FrozenCleanupCheck::cv{};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+std::atomic<size_t> MemoryCheck::fake_allocated_memory{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{small_queue->Thread();});\n+    }\n+    // Make vChecks here to save on malloc (this test can be slow...)\n+    std::vector<FakeCheckCheckCompletion> vChecks;\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+        while (total) {\n+            vChecks.resize(std::min(total, (size_t) GetRand(10)));\n+            total -= vChecks.size();\n+            control.Add(vChecks);\n+        }\n+        BOOST_REQUIRE(control.Wait());\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE_EQUAL(FakeCheckCheckCompletion::n_calls, i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    range.reserve(100000/1000);\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                vChecks.resize(100, false);\n+                vChecks[99] = end_fails;\n+                control.Add(vChecks);\n+            }\n+            bool r =control.Wait();\n+            BOOST_REQUIRE(r || end_fails);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that unique checks are actually all called individually, rather than\n+// just one check being called repeatedly. Test that checks are not called\n+// more than once as well\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n+{\n+    auto queue = std::unique_ptr<Unique_Queue>(new Unique_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+\n+    }\n+\n+    size_t COUNT = 100000;\n+    size_t total = COUNT;\n+    {\n+        CCheckQueueControl<UniqueCheck> control(queue.get());\n+        while (total) {\n+            size_t r = GetRand(10);\n+            std::vector<UniqueCheck> vChecks;\n+            for (size_t k = 0; k < r && total; k++)\n+                vChecks.emplace_back(--total);\n+            control.Add(vChecks);\n+        }\n+    }\n+    bool r = true;\n+    BOOST_REQUIRE_EQUAL(UniqueCheck::results.size(), COUNT);\n+    for (size_t i = 0; i < COUNT; ++i)\n+        r = r && UniqueCheck::results.count(i) == 1;\n+    BOOST_REQUIRE(r);\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+\n+// Test that blocks which might allocate lots of memory free their memory agressively.\n+//\n+// This test attempts to catch a pathological case where by lazily freeing\n+// checks might mean leaving a check un-swapped out, and decreasing by 1 each\n+// time could leave the data hanging across a sequence of blocks.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n+{\n+    auto queue = std::unique_ptr<Memory_Queue>(new Memory_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+    }\n+    for (size_t i = 0; i < 1000; ++i) {\n+        size_t total = i;\n+        {\n+            CCheckQueueControl<MemoryCheck> control(queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<MemoryCheck> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    // Each iteration leaves data at the front, back, and middle\n+                    // to catch any sort of deallocation failure\n+                    vChecks.emplace_back(total == 0 || total == i || total == i/2);\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        BOOST_REQUIRE_EQUAL(MemoryCheck::fake_allocated_memory, 0);\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that a new verification cannot occur until all checks \n+// have been destructed\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_FrozenCleanup)\n+{\n+    auto queue = std::unique_ptr<FrozenCleanup_Queue>(new FrozenCleanup_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    bool fails = false;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+        tg.create_thread([&]{queue->Thread();});\n+    }\n+    std::thread t0([&]() {\n+        CCheckQueueControl<FrozenCleanupCheck> control(queue.get());\n+        std::vector<FrozenCleanupCheck> vChecks(1);\n+        // Freezing can't be the default initialized behavior given how the queue\n+        // swaps in default initialized Checks (otherwise freezing destructor\n+        // would get called twice).\n+        vChecks[0].should_freeze = true;\n+        control.Add(vChecks);\n+        control.Wait(); // Hangs here\n+    });\n+    {\n+        std::unique_lock<std::mutex> l(FrozenCleanupCheck::m);\n+        // Wait until the queue has finished all jobs and frozen\n+        FrozenCleanupCheck::cv.wait(l, [](){return FrozenCleanupCheck::nFrozen == 1;});",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 363,
      "commit_id": "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "original_commit_id": "08e4e1ea89427a2594415d0b37011692a5109c39",
      "in_reply_to_id": null,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: maybe close the \"l\" scope after this line so that the try_lock()s happen without FrozenCleanupCheck::m?",
      "created_at": "2017-03-08T22:13:51Z",
      "updated_at": "2017-03-27T17:41:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105037465",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105037465"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105037514",
      "pull_request_review_id": 25891086,
      "id": 105037514,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNTAzNzUxNA==",
      "diff_hunk": "@@ -0,0 +1,442 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(const MemoryCheck& x)\n+    {\n+        // We have to do this to make sure that destructor calls are paired\n+        //\n+        // Really, copy constructor should be deletable, but CCheckQueue breaks\n+        // if it is deleted because of internal push_back.\n+        fake_allocated_memory += b;\n+    };\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        fake_allocated_memory += b;\n+    };\n+    ~MemoryCheck(){\n+        fake_allocated_memory -= b;\n+    \n+    };\n+    void swap(MemoryCheck& x) { std::swap(b, x.b); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<uint64_t> nFrozen;\n+    static std::condition_variable cv;\n+    static std::mutex m;\n+    // Freezing can't be the default initialized behavior given how the queue\n+    // swaps in default initialized Checks.\n+    bool should_freeze {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        if (should_freeze) {\n+            std::unique_lock<std::mutex> l(m);\n+            nFrozen = 1;\n+            cv.notify_one();\n+            cv.wait(l, []{ return nFrozen == 0;});\n+        }\n+    }\n+    void swap(FrozenCleanupCheck& x){std::swap(should_freeze, x.should_freeze);};\n+};\n+\n+// Static Allocations\n+std::mutex FrozenCleanupCheck::m{};\n+std::atomic<uint64_t> FrozenCleanupCheck::nFrozen{0};\n+std::condition_variable FrozenCleanupCheck::cv{};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+std::atomic<size_t> MemoryCheck::fake_allocated_memory{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{small_queue->Thread();});\n+    }\n+    // Make vChecks here to save on malloc (this test can be slow...)\n+    std::vector<FakeCheckCheckCompletion> vChecks;\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+        while (total) {\n+            vChecks.resize(std::min(total, (size_t) GetRand(10)));\n+            total -= vChecks.size();\n+            control.Add(vChecks);\n+        }\n+        BOOST_REQUIRE(control.Wait());\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE_EQUAL(FakeCheckCheckCompletion::n_calls, i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    range.reserve(100000/1000);\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                vChecks.resize(100, false);\n+                vChecks[99] = end_fails;\n+                control.Add(vChecks);\n+            }\n+            bool r =control.Wait();\n+            BOOST_REQUIRE(r || end_fails);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that unique checks are actually all called individually, rather than\n+// just one check being called repeatedly. Test that checks are not called\n+// more than once as well\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n+{\n+    auto queue = std::unique_ptr<Unique_Queue>(new Unique_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+\n+    }\n+\n+    size_t COUNT = 100000;\n+    size_t total = COUNT;\n+    {\n+        CCheckQueueControl<UniqueCheck> control(queue.get());\n+        while (total) {\n+            size_t r = GetRand(10);\n+            std::vector<UniqueCheck> vChecks;\n+            for (size_t k = 0; k < r && total; k++)\n+                vChecks.emplace_back(--total);\n+            control.Add(vChecks);\n+        }\n+    }\n+    bool r = true;\n+    BOOST_REQUIRE_EQUAL(UniqueCheck::results.size(), COUNT);\n+    for (size_t i = 0; i < COUNT; ++i)\n+        r = r && UniqueCheck::results.count(i) == 1;\n+    BOOST_REQUIRE(r);\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+\n+// Test that blocks which might allocate lots of memory free their memory agressively.\n+//\n+// This test attempts to catch a pathological case where by lazily freeing\n+// checks might mean leaving a check un-swapped out, and decreasing by 1 each\n+// time could leave the data hanging across a sequence of blocks.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n+{\n+    auto queue = std::unique_ptr<Memory_Queue>(new Memory_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{queue->Thread();});\n+    }\n+    for (size_t i = 0; i < 1000; ++i) {\n+        size_t total = i;\n+        {\n+            CCheckQueueControl<MemoryCheck> control(queue.get());\n+            while (total) {\n+                size_t r = GetRand(10);\n+                std::vector<MemoryCheck> vChecks;\n+                for (size_t k = 0; k < r && total; k++) {\n+                    total--;\n+                    // Each iteration leaves data at the front, back, and middle\n+                    // to catch any sort of deallocation failure\n+                    vChecks.emplace_back(total == 0 || total == i || total == i/2);\n+                }\n+                control.Add(vChecks);\n+            }\n+        }\n+        BOOST_REQUIRE_EQUAL(MemoryCheck::fake_allocated_memory, 0);\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+// Test that a new verification cannot occur until all checks ",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 340,
      "commit_id": "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "original_commit_id": "08e4e1ea89427a2594415d0b37011692a5109c39",
      "in_reply_to_id": null,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: whitespace at EOL here.",
      "created_at": "2017-03-08T22:14:05Z",
      "updated_at": "2017-03-27T17:41:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105037514",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105037514"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105041481",
      "pull_request_review_id": 25891086,
      "id": 105041481,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNTA0MTQ4MQ==",
      "diff_hunk": "@@ -41,7 +41,6 @@ class CCheckQueue\n \n     //! The queue of elements to be processed.",
      "path": "src/checkqueue.h",
      "position": null,
      "original_position": 2,
      "commit_id": "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "original_commit_id": "89a1f939d28328f4355f83fb6ae50b475ddd6925",
      "in_reply_to_id": null,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think you meant to remove/move this comment as well?",
      "created_at": "2017-03-08T22:32:02Z",
      "updated_at": "2017-03-27T17:41:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105041481",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105041481"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105042472",
      "pull_request_review_id": 25891086,
      "id": 105042472,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNTA0MjQ3Mg==",
      "diff_hunk": "@@ -145,18 +140,25 @@ class CCheckQueue\n         return Loop(true);\n     }\n \n+    typename std::vector<T>::iterator check_mem;",
      "path": "src/checkqueue.h",
      "position": null,
      "original_position": 63,
      "commit_id": "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "original_commit_id": "89a1f939d28328f4355f83fb6ae50b475ddd6925",
      "in_reply_to_id": null,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Nit: can these be private?",
      "created_at": "2017-03-08T22:36:28Z",
      "updated_at": "2017-03-27T17:41:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105042472",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105042472"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105043019",
      "pull_request_review_id": 25891086,
      "id": 105043019,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNTA0MzAxOQ==",
      "diff_hunk": "@@ -200,8 +205,27 @@ class CCheckQueueControl\n \n     void Add(std::vector<T>& vChecks)\n     {\n-        if (pqueue != NULL)\n-            pqueue->Add(vChecks);\n+        if (pqueue != NULL) {\n+            auto s = vChecks.size();\n+            for (T& x : vChecks) {\n+                check_mem.emplace_back();\n+                check_mem.back().swap(x);\n+            }\n+            pqueue->Add(s);\n+        }\n+    }\n+    template<typename ... Args>\n+    void Add(Args && ... args)\n+    {\n+        if (pqueue != NULL) {\n+            check_mem.emplace_back(std::forward<Args>(args)...);\n+        }\n+    }\n+    void Flush(size_t s)",
      "path": "src/checkqueue.h",
      "position": null,
      "original_position": 139,
      "commit_id": "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "original_commit_id": "89a1f939d28328f4355f83fb6ae50b475ddd6925",
      "in_reply_to_id": null,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can you add some documentation for Flush() (and how it interacts with the two versions of Add()) here?",
      "created_at": "2017-03-08T22:38:42Z",
      "updated_at": "2017-03-27T17:41:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105043019",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105043019"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105043095",
      "pull_request_review_id": 25891086,
      "id": 105043095,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNTA0MzA5NQ==",
      "diff_hunk": "@@ -145,18 +140,25 @@ class CCheckQueue\n         return Loop(true);\n     }\n \n+    typename std::vector<T>::iterator check_mem;\n+    typename std::vector<T>::iterator check_mem_top;\n+    typename std::vector<T>::iterator check_mem_bottom;\n+    void Setup(typename std::vector<T>::iterator check_mem_in) ",
      "path": "src/checkqueue.h",
      "position": null,
      "original_position": 66,
      "commit_id": "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "original_commit_id": "89a1f939d28328f4355f83fb6ae50b475ddd6925",
      "in_reply_to_id": null,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: whitespace at EOL here.",
      "created_at": "2017-03-08T22:39:00Z",
      "updated_at": "2017-03-27T17:41:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105043095",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105043095"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105044600",
      "pull_request_review_id": 25891086,
      "id": 105044600,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNTA0NDYwMA==",
      "diff_hunk": "@@ -30,103 +30,112 @@ template <typename T>\n class CCheckQueue\n {\n private:\n-    //! Mutex to protect the inner state\n+    //! Mutex to ensure that sleeping threads are woken.\n     boost::mutex mutex;\n \n     //! Worker threads block on this when out of work\n     boost::condition_variable condWorker;\n \n-    //! Master thread blocks on this when out of work\n-    boost::condition_variable condMaster;\n-\n-    //! The queue of elements to be processed.\n-    //! As the order of booleans doesn't matter, it is used as a LIFO (stack)\n-\n-    //! The number of workers (including the master) that are idle.\n-    int nIdle;\n-\n-    //! The total number of workers (including the master).\n-    int nTotal;\n-\n     //! The temporary evaluation result.\n-    bool fAllOk;\n+    std::atomic<uint8_t> fAllOk;\n \n     /**\n-     * Number of verifications that haven't completed yet.\n-     * This includes elements that are no longer queued, but still in the\n-     * worker's own batches.\n+     * Number of verification threads that aren't in stand-by. When a thread is\n+     * awake it may have a job that will return false, but is yet to report the\n+     * result through fAllOk.\n      */\n-    unsigned int nTodo;\n+    std::atomic<unsigned int> nAwake;\n+\n+    /** If there is presently a master process either in the queue or adding jobs */\n+    std::atomic<bool> fMasterPresent;\n \n     //! Whether we're shutting down.\n     bool fQuit;\n \n     //! The maximum number of elements to be processed in one batch\n     unsigned int nBatchSize;\n \n+    //! A pointer to contiguous memory that contains all checks\n+    T* check_mem {nullptr};\n+\n+    /** The begin and end offsets into check_mem. 128 bytes of padding is\n+     * inserted before and after check_mem_top to eliminate false sharing*/\n+    std::atomic<uint32_t> check_mem_bot {0};\n+    unsigned char _padding[128];",
      "path": "src/checkqueue.h",
      "position": 63,
      "original_position": 62,
      "commit_id": "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "original_commit_id": "6e24aa818be4b494fc1809a7ca3ee568e253deb6",
      "in_reply_to_id": null,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Maybe ifdef hardware_destructive_interference_size use it?",
      "created_at": "2017-03-08T22:46:17Z",
      "updated_at": "2017-03-27T17:41:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105044600",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105044600"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 64,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105046758",
      "pull_request_review_id": 25891086,
      "id": 105046758,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNTA0Njc1OA==",
      "diff_hunk": "@@ -30,103 +30,112 @@ template <typename T>\n class CCheckQueue\n {\n private:\n-    //! Mutex to protect the inner state\n+    //! Mutex to ensure that sleeping threads are woken.\n     boost::mutex mutex;\n \n     //! Worker threads block on this when out of work\n     boost::condition_variable condWorker;\n \n-    //! Master thread blocks on this when out of work\n-    boost::condition_variable condMaster;\n-\n-    //! The queue of elements to be processed.\n-    //! As the order of booleans doesn't matter, it is used as a LIFO (stack)\n-\n-    //! The number of workers (including the master) that are idle.\n-    int nIdle;\n-\n-    //! The total number of workers (including the master).\n-    int nTotal;\n-\n     //! The temporary evaluation result.\n-    bool fAllOk;\n+    std::atomic<uint8_t> fAllOk;\n \n     /**\n-     * Number of verifications that haven't completed yet.\n-     * This includes elements that are no longer queued, but still in the\n-     * worker's own batches.\n+     * Number of verification threads that aren't in stand-by. When a thread is\n+     * awake it may have a job that will return false, but is yet to report the\n+     * result through fAllOk.\n      */\n-    unsigned int nTodo;\n+    std::atomic<unsigned int> nAwake;\n+\n+    /** If there is presently a master process either in the queue or adding jobs */\n+    std::atomic<bool> fMasterPresent;\n \n     //! Whether we're shutting down.\n     bool fQuit;\n \n     //! The maximum number of elements to be processed in one batch\n     unsigned int nBatchSize;\n \n+    //! A pointer to contiguous memory that contains all checks\n+    T* check_mem {nullptr};\n+\n+    /** The begin and end offsets into check_mem. 128 bytes of padding is\n+     * inserted before and after check_mem_top to eliminate false sharing*/\n+    std::atomic<uint32_t> check_mem_bot {0};\n+    unsigned char _padding[128];\n+    std::atomic<uint32_t> check_mem_top {0};\n+    unsigned char _padding2[128];\n+\n     /** Internal function that does bulk of the verification work. */\n     bool Loop(bool fMaster = false)\n     {\n-        boost::condition_variable& cond = fMaster ? condMaster : condWorker;\n-        typename std::vector<T>::iterator checks_iterator;\n-        unsigned int nNow = 0;\n-        bool fOk = true;\n-        do {\n+\n+        uint8_t fOk = 1;\n+        // first iteration, only count non-master threads\n+        if (!fMaster)\n+            ++nAwake;\n+        for (;;) {\n+            uint32_t top_cache = check_mem_top;\n+            uint32_t bottom_cache = check_mem_bot;\n+            // Try to increment bottom_cache by 1 if our version of bottom_cache\n+            // indicates that there is work to be done.\n+            // E.g., if bottom_cache = top_cache, don't attempt to exchange.\n+            //       if  bottom_cache < top_cache, then do attempt to exchange \n+            //\n+            // compare_exchange_weak, on failure, updates bottom_cache to latest\n+            while (top_cache > bottom_cache && \n+                    !check_mem_bot.compare_exchange_weak( bottom_cache, bottom_cache+1));\n+            // If our loop terminated because of no_work_left...\n+            if (top_cache <= bottom_cache)\n             {\n-                boost::unique_lock<boost::mutex> lock(mutex);\n-                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n-                if (nNow) {\n-                    fAllOk &= fOk;\n-                    nTodo -= nNow;\n-                    if (nTodo == 0 && !fMaster)\n-                        // We processed the last element; inform the master it can exit and return the result\n-                        condMaster.notify_one();\n-                } else {\n-                    // first iteration\n-                    nTotal++;\n-                }\n-                // logically, the do loop starts here\n-                while (check_mem_top == check_mem_bottom) { // while (empty)\n-                    if ((fMaster || fQuit) && nTodo == 0) {\n-                        nTotal--;\n-                        bool fRet = fAllOk;\n-                        // reset the status for new work later\n-                        if (fMaster)\n-                            fAllOk = true;\n-                        // return the current status\n-                        return fRet;\n+                if (fMaster) {\n+                    fMasterPresent = false;\n+                    // There's no harm to the master holding the lock\n+                    // at this point because all the jobs are taken.\n+                    // so busy spin until no one else is awake\n+                    while (nAwake) {}\n+                    bool fRet = fAllOk;\n+                    // reset the status for new work later\n+                    fAllOk = 1;\n+                    // return the current status\n+                    return fRet;\n+                } else  if (!fMasterPresent) { // Read once outside the lock and once inside\n+                    --nAwake; \n+                    // Unfortunately we need this lock for this to be safe\n+                    // We hold it for the min time possible\n+                    {\n+                        boost::unique_lock<boost::mutex> lock(mutex);\n+                        condWorker.wait(lock, [&]{ return fMasterPresent.load();});\n                     }\n-                    nIdle++;\n-                    cond.wait(lock); // wait\n-                    nIdle--;\n+                    ++nAwake;\n                 }\n-                // Decide how many work units to process now.\n-                // * Do not try to do everything at once, but aim for increasingly smaller batches so\n-                //   all workers finish approximately simultaneously.\n-                // * Try to account for idle jobs which will instantly start helping.\n-                // * Don't do batches smaller than 1 (duh), or larger than nBatchSize.\n-                nNow = std::max(1U, std::min(nBatchSize, (unsigned int)(check_mem_top - check_mem_bottom) / (nTotal + nIdle + 1)));\n-                checks_iterator = check_mem_bottom;\n-                std::advance(check_mem_bottom, nNow);\n-                // Check whether we need to do work at all\n+            } else {\n+                // We compute using bottom_cache (not bottom_cache + 1 as above) because it is 0-indexed\n+                T * pT = check_mem + bottom_cache;\n+                // Check whether we need to do work at all (can be read outside\n+                // of lock because it's fine if a worker executes checks\n+                // anyways)\n                 fOk = fAllOk;\n-            }\n-            // execute work\n-            for (unsigned int i = 0; i < nNow && fOk; i++) {\n-                fOk = (*checks_iterator)();\n+                // execute work\n+                fOk &= fOk && (*pT)();\n+                // We swap in a default constructed value onto pT before freeing\n+                // so that we don't accidentally double free when check_mem is\n+                // freed. We don't strictly need to free here, but it's good\n+                // practice in case T uses a lot of memory.\n                 auto t = T();\n-                checks_iterator->swap(t);\n-                std::advance(checks_iterator, 1);\n+                pT->swap(t);\n+                // Can't reveal result until after swapped, otherwise",
      "path": "src/checkqueue.h",
      "position": null,
      "original_position": 169,
      "commit_id": "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "original_commit_id": "6e24aa818be4b494fc1809a7ca3ee568e253deb6",
      "in_reply_to_id": null,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Huh? Sure we can, we just cant decrement nAwake until we've swap()ed. I assume you had a previous version with an early termination for !fAllOk?",
      "created_at": "2017-03-08T22:57:40Z",
      "updated_at": "2017-03-27T17:41:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105046758",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105046758"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105048119",
      "pull_request_review_id": 25891086,
      "id": 105048119,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNTA0ODExOQ==",
      "diff_hunk": "@@ -30,103 +30,112 @@ template <typename T>\n class CCheckQueue\n {\n private:\n-    //! Mutex to protect the inner state\n+    //! Mutex to ensure that sleeping threads are woken.\n     boost::mutex mutex;\n \n     //! Worker threads block on this when out of work\n     boost::condition_variable condWorker;\n \n-    //! Master thread blocks on this when out of work\n-    boost::condition_variable condMaster;\n-\n-    //! The queue of elements to be processed.\n-    //! As the order of booleans doesn't matter, it is used as a LIFO (stack)\n-\n-    //! The number of workers (including the master) that are idle.\n-    int nIdle;\n-\n-    //! The total number of workers (including the master).\n-    int nTotal;\n-\n     //! The temporary evaluation result.\n-    bool fAllOk;\n+    std::atomic<uint8_t> fAllOk;\n \n     /**\n-     * Number of verifications that haven't completed yet.\n-     * This includes elements that are no longer queued, but still in the\n-     * worker's own batches.\n+     * Number of verification threads that aren't in stand-by. When a thread is\n+     * awake it may have a job that will return false, but is yet to report the\n+     * result through fAllOk.\n      */\n-    unsigned int nTodo;\n+    std::atomic<unsigned int> nAwake;\n+\n+    /** If there is presently a master process either in the queue or adding jobs */\n+    std::atomic<bool> fMasterPresent;\n \n     //! Whether we're shutting down.\n     bool fQuit;\n \n     //! The maximum number of elements to be processed in one batch",
      "path": "src/checkqueue.h",
      "position": 54,
      "original_position": 53,
      "commit_id": "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "original_commit_id": "6e24aa818be4b494fc1809a7ca3ee568e253deb6",
      "in_reply_to_id": null,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Looks like, in the current version, you can remove nBatchSize as well (though I'm surprised its not a performance gain to batch operations?",
      "created_at": "2017-03-08T23:05:01Z",
      "updated_at": "2017-03-27T17:41:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105048119",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105048119"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 55,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105072948",
      "pull_request_review_id": 25934746,
      "id": 105072948,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNTA3Mjk0OA==",
      "diff_hunk": "@@ -30,103 +30,112 @@ template <typename T>\n class CCheckQueue\n {\n private:\n-    //! Mutex to protect the inner state\n+    //! Mutex to ensure that sleeping threads are woken.\n     boost::mutex mutex;\n \n     //! Worker threads block on this when out of work\n     boost::condition_variable condWorker;\n \n-    //! Master thread blocks on this when out of work\n-    boost::condition_variable condMaster;\n-\n-    //! The queue of elements to be processed.\n-    //! As the order of booleans doesn't matter, it is used as a LIFO (stack)\n-\n-    //! The number of workers (including the master) that are idle.\n-    int nIdle;\n-\n-    //! The total number of workers (including the master).\n-    int nTotal;\n-\n     //! The temporary evaluation result.\n-    bool fAllOk;\n+    std::atomic<uint8_t> fAllOk;\n \n     /**\n-     * Number of verifications that haven't completed yet.\n-     * This includes elements that are no longer queued, but still in the\n-     * worker's own batches.\n+     * Number of verification threads that aren't in stand-by. When a thread is\n+     * awake it may have a job that will return false, but is yet to report the\n+     * result through fAllOk.\n      */\n-    unsigned int nTodo;\n+    std::atomic<unsigned int> nAwake;\n+\n+    /** If there is presently a master process either in the queue or adding jobs */\n+    std::atomic<bool> fMasterPresent;\n \n     //! Whether we're shutting down.\n     bool fQuit;\n \n     //! The maximum number of elements to be processed in one batch",
      "path": "src/checkqueue.h",
      "position": 54,
      "original_position": 53,
      "commit_id": "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "original_commit_id": "6e24aa818be4b494fc1809a7ca3ee568e253deb6",
      "in_reply_to_id": 105048119,
      "user": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes, absolutely. I didn't change it to minimize changeset, but it no longer has a use.",
      "created_at": "2017-03-09T02:08:18Z",
      "updated_at": "2017-03-27T17:41:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105072948",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105072948"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 55,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105073250",
      "pull_request_review_id": 25935054,
      "id": 105073250,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNTA3MzI1MA==",
      "diff_hunk": "@@ -30,103 +30,112 @@ template <typename T>\n class CCheckQueue\n {\n private:\n-    //! Mutex to protect the inner state\n+    //! Mutex to ensure that sleeping threads are woken.\n     boost::mutex mutex;\n \n     //! Worker threads block on this when out of work\n     boost::condition_variable condWorker;\n \n-    //! Master thread blocks on this when out of work\n-    boost::condition_variable condMaster;\n-\n-    //! The queue of elements to be processed.\n-    //! As the order of booleans doesn't matter, it is used as a LIFO (stack)\n-\n-    //! The number of workers (including the master) that are idle.\n-    int nIdle;\n-\n-    //! The total number of workers (including the master).\n-    int nTotal;\n-\n     //! The temporary evaluation result.\n-    bool fAllOk;\n+    std::atomic<uint8_t> fAllOk;\n \n     /**\n-     * Number of verifications that haven't completed yet.\n-     * This includes elements that are no longer queued, but still in the\n-     * worker's own batches.\n+     * Number of verification threads that aren't in stand-by. When a thread is\n+     * awake it may have a job that will return false, but is yet to report the\n+     * result through fAllOk.\n      */\n-    unsigned int nTodo;\n+    std::atomic<unsigned int> nAwake;\n+\n+    /** If there is presently a master process either in the queue or adding jobs */\n+    std::atomic<bool> fMasterPresent;\n \n     //! Whether we're shutting down.\n     bool fQuit;\n \n     //! The maximum number of elements to be processed in one batch\n     unsigned int nBatchSize;\n \n+    //! A pointer to contiguous memory that contains all checks\n+    T* check_mem {nullptr};\n+\n+    /** The begin and end offsets into check_mem. 128 bytes of padding is\n+     * inserted before and after check_mem_top to eliminate false sharing*/\n+    std::atomic<uint32_t> check_mem_bot {0};\n+    unsigned char _padding[128];\n+    std::atomic<uint32_t> check_mem_top {0};\n+    unsigned char _padding2[128];\n+\n     /** Internal function that does bulk of the verification work. */\n     bool Loop(bool fMaster = false)\n     {\n-        boost::condition_variable& cond = fMaster ? condMaster : condWorker;\n-        typename std::vector<T>::iterator checks_iterator;\n-        unsigned int nNow = 0;\n-        bool fOk = true;\n-        do {\n+\n+        uint8_t fOk = 1;\n+        // first iteration, only count non-master threads\n+        if (!fMaster)\n+            ++nAwake;\n+        for (;;) {\n+            uint32_t top_cache = check_mem_top;\n+            uint32_t bottom_cache = check_mem_bot;\n+            // Try to increment bottom_cache by 1 if our version of bottom_cache\n+            // indicates that there is work to be done.\n+            // E.g., if bottom_cache = top_cache, don't attempt to exchange.\n+            //       if  bottom_cache < top_cache, then do attempt to exchange \n+            //\n+            // compare_exchange_weak, on failure, updates bottom_cache to latest\n+            while (top_cache > bottom_cache && \n+                    !check_mem_bot.compare_exchange_weak( bottom_cache, bottom_cache+1));\n+            // If our loop terminated because of no_work_left...\n+            if (top_cache <= bottom_cache)\n             {\n-                boost::unique_lock<boost::mutex> lock(mutex);\n-                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n-                if (nNow) {\n-                    fAllOk &= fOk;\n-                    nTodo -= nNow;\n-                    if (nTodo == 0 && !fMaster)\n-                        // We processed the last element; inform the master it can exit and return the result\n-                        condMaster.notify_one();\n-                } else {\n-                    // first iteration\n-                    nTotal++;\n-                }\n-                // logically, the do loop starts here\n-                while (check_mem_top == check_mem_bottom) { // while (empty)\n-                    if ((fMaster || fQuit) && nTodo == 0) {\n-                        nTotal--;\n-                        bool fRet = fAllOk;\n-                        // reset the status for new work later\n-                        if (fMaster)\n-                            fAllOk = true;\n-                        // return the current status\n-                        return fRet;\n+                if (fMaster) {\n+                    fMasterPresent = false;\n+                    // There's no harm to the master holding the lock\n+                    // at this point because all the jobs are taken.\n+                    // so busy spin until no one else is awake\n+                    while (nAwake) {}\n+                    bool fRet = fAllOk;\n+                    // reset the status for new work later\n+                    fAllOk = 1;\n+                    // return the current status\n+                    return fRet;\n+                } else  if (!fMasterPresent) { // Read once outside the lock and once inside\n+                    --nAwake; \n+                    // Unfortunately we need this lock for this to be safe\n+                    // We hold it for the min time possible\n+                    {\n+                        boost::unique_lock<boost::mutex> lock(mutex);\n+                        condWorker.wait(lock, [&]{ return fMasterPresent.load();});\n                     }\n-                    nIdle++;\n-                    cond.wait(lock); // wait\n-                    nIdle--;\n+                    ++nAwake;\n                 }\n-                // Decide how many work units to process now.\n-                // * Do not try to do everything at once, but aim for increasingly smaller batches so\n-                //   all workers finish approximately simultaneously.\n-                // * Try to account for idle jobs which will instantly start helping.\n-                // * Don't do batches smaller than 1 (duh), or larger than nBatchSize.\n-                nNow = std::max(1U, std::min(nBatchSize, (unsigned int)(check_mem_top - check_mem_bottom) / (nTotal + nIdle + 1)));\n-                checks_iterator = check_mem_bottom;\n-                std::advance(check_mem_bottom, nNow);\n-                // Check whether we need to do work at all\n+            } else {\n+                // We compute using bottom_cache (not bottom_cache + 1 as above) because it is 0-indexed\n+                T * pT = check_mem + bottom_cache;\n+                // Check whether we need to do work at all (can be read outside\n+                // of lock because it's fine if a worker executes checks\n+                // anyways)\n                 fOk = fAllOk;\n-            }\n-            // execute work\n-            for (unsigned int i = 0; i < nNow && fOk; i++) {\n-                fOk = (*checks_iterator)();\n+                // execute work\n+                fOk &= fOk && (*pT)();\n+                // We swap in a default constructed value onto pT before freeing\n+                // so that we don't accidentally double free when check_mem is\n+                // freed. We don't strictly need to free here, but it's good\n+                // practice in case T uses a lot of memory.\n                 auto t = T();\n-                checks_iterator->swap(t);\n-                std::advance(checks_iterator, 1);\n+                pT->swap(t);\n+                // Can't reveal result until after swapped, otherwise",
      "path": "src/checkqueue.h",
      "position": null,
      "original_position": 169,
      "commit_id": "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "original_commit_id": "6e24aa818be4b494fc1809a7ca3ee568e253deb6",
      "in_reply_to_id": 105046758,
      "user": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes; you're correct. Earlier version was like this.\r\n\r\nAlso termination does still occur \"early\", all the actual checks are skipped (they are just stilled dequeued). I suppose I could make it abort (may actually be nice to check if it aborted before calling checkinputs... but maybe that's best for another PR).\r\n\r\nI'll refactor to something which converges more quickly on abort (e.g., setting !fMasterPresent && !fAllOk)",
      "created_at": "2017-03-09T02:11:18Z",
      "updated_at": "2017-03-27T17:41:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105073250",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105073250"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105221818",
      "pull_request_review_id": 26090970,
      "id": 105221818,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNTIyMTgxOA==",
      "diff_hunk": "@@ -30,103 +30,112 @@ template <typename T>\n class CCheckQueue\n {\n private:\n-    //! Mutex to protect the inner state\n+    //! Mutex to ensure that sleeping threads are woken.\n     boost::mutex mutex;\n \n     //! Worker threads block on this when out of work\n     boost::condition_variable condWorker;\n \n-    //! Master thread blocks on this when out of work\n-    boost::condition_variable condMaster;\n-\n-    //! The queue of elements to be processed.\n-    //! As the order of booleans doesn't matter, it is used as a LIFO (stack)\n-\n-    //! The number of workers (including the master) that are idle.\n-    int nIdle;\n-\n-    //! The total number of workers (including the master).\n-    int nTotal;\n-\n     //! The temporary evaluation result.\n-    bool fAllOk;\n+    std::atomic<uint8_t> fAllOk;\n \n     /**\n-     * Number of verifications that haven't completed yet.\n-     * This includes elements that are no longer queued, but still in the\n-     * worker's own batches.\n+     * Number of verification threads that aren't in stand-by. When a thread is\n+     * awake it may have a job that will return false, but is yet to report the\n+     * result through fAllOk.\n      */\n-    unsigned int nTodo;\n+    std::atomic<unsigned int> nAwake;\n+\n+    /** If there is presently a master process either in the queue or adding jobs */\n+    std::atomic<bool> fMasterPresent;\n \n     //! Whether we're shutting down.\n     bool fQuit;\n \n     //! The maximum number of elements to be processed in one batch\n     unsigned int nBatchSize;\n \n+    //! A pointer to contiguous memory that contains all checks\n+    T* check_mem {nullptr};\n+\n+    /** The begin and end offsets into check_mem. 128 bytes of padding is\n+     * inserted before and after check_mem_top to eliminate false sharing*/\n+    std::atomic<uint32_t> check_mem_bot {0};\n+    unsigned char _padding[128];\n+    std::atomic<uint32_t> check_mem_top {0};\n+    unsigned char _padding2[128];\n+\n     /** Internal function that does bulk of the verification work. */\n     bool Loop(bool fMaster = false)\n     {\n-        boost::condition_variable& cond = fMaster ? condMaster : condWorker;\n-        typename std::vector<T>::iterator checks_iterator;\n-        unsigned int nNow = 0;\n-        bool fOk = true;\n-        do {\n+\n+        uint8_t fOk = 1;\n+        // first iteration, only count non-master threads\n+        if (!fMaster)\n+            ++nAwake;\n+        for (;;) {\n+            uint32_t top_cache = check_mem_top;\n+            uint32_t bottom_cache = check_mem_bot;\n+            // Try to increment bottom_cache by 1 if our version of bottom_cache\n+            // indicates that there is work to be done.\n+            // E.g., if bottom_cache = top_cache, don't attempt to exchange.\n+            //       if  bottom_cache < top_cache, then do attempt to exchange \n+            //\n+            // compare_exchange_weak, on failure, updates bottom_cache to latest\n+            while (top_cache > bottom_cache && \n+                    !check_mem_bot.compare_exchange_weak( bottom_cache, bottom_cache+1));\n+            // If our loop terminated because of no_work_left...\n+            if (top_cache <= bottom_cache)\n             {\n-                boost::unique_lock<boost::mutex> lock(mutex);\n-                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n-                if (nNow) {\n-                    fAllOk &= fOk;\n-                    nTodo -= nNow;\n-                    if (nTodo == 0 && !fMaster)\n-                        // We processed the last element; inform the master it can exit and return the result\n-                        condMaster.notify_one();\n-                } else {\n-                    // first iteration\n-                    nTotal++;\n-                }\n-                // logically, the do loop starts here\n-                while (check_mem_top == check_mem_bottom) { // while (empty)\n-                    if ((fMaster || fQuit) && nTodo == 0) {\n-                        nTotal--;\n-                        bool fRet = fAllOk;\n-                        // reset the status for new work later\n-                        if (fMaster)\n-                            fAllOk = true;\n-                        // return the current status\n-                        return fRet;\n+                if (fMaster) {\n+                    fMasterPresent = false;\n+                    // There's no harm to the master holding the lock\n+                    // at this point because all the jobs are taken.\n+                    // so busy spin until no one else is awake\n+                    while (nAwake) {}\n+                    bool fRet = fAllOk;\n+                    // reset the status for new work later\n+                    fAllOk = 1;\n+                    // return the current status\n+                    return fRet;\n+                } else  if (!fMasterPresent) { // Read once outside the lock and once inside\n+                    --nAwake; \n+                    // Unfortunately we need this lock for this to be safe\n+                    // We hold it for the min time possible\n+                    {\n+                        boost::unique_lock<boost::mutex> lock(mutex);\n+                        condWorker.wait(lock, [&]{ return fMasterPresent.load();});\n                     }\n-                    nIdle++;\n-                    cond.wait(lock); // wait\n-                    nIdle--;\n+                    ++nAwake;\n                 }\n-                // Decide how many work units to process now.\n-                // * Do not try to do everything at once, but aim for increasingly smaller batches so\n-                //   all workers finish approximately simultaneously.\n-                // * Try to account for idle jobs which will instantly start helping.\n-                // * Don't do batches smaller than 1 (duh), or larger than nBatchSize.\n-                nNow = std::max(1U, std::min(nBatchSize, (unsigned int)(check_mem_top - check_mem_bottom) / (nTotal + nIdle + 1)));\n-                checks_iterator = check_mem_bottom;\n-                std::advance(check_mem_bottom, nNow);\n-                // Check whether we need to do work at all\n+            } else {\n+                // We compute using bottom_cache (not bottom_cache + 1 as above) because it is 0-indexed\n+                T * pT = check_mem + bottom_cache;\n+                // Check whether we need to do work at all (can be read outside\n+                // of lock because it's fine if a worker executes checks\n+                // anyways)\n                 fOk = fAllOk;\n-            }\n-            // execute work\n-            for (unsigned int i = 0; i < nNow && fOk; i++) {\n-                fOk = (*checks_iterator)();\n+                // execute work\n+                fOk &= fOk && (*pT)();\n+                // We swap in a default constructed value onto pT before freeing\n+                // so that we don't accidentally double free when check_mem is\n+                // freed. We don't strictly need to free here, but it's good\n+                // practice in case T uses a lot of memory.\n                 auto t = T();\n-                checks_iterator->swap(t);\n-                std::advance(checks_iterator, 1);\n+                pT->swap(t);\n+                // Can't reveal result until after swapped, otherwise",
      "path": "src/checkqueue.h",
      "position": null,
      "original_position": 169,
      "commit_id": "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "original_commit_id": "6e24aa818be4b494fc1809a7ca3ee568e253deb6",
      "in_reply_to_id": 105046758,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Its probably better to not have quick abort and have less between-thread contention, no?",
      "created_at": "2017-03-09T17:26:29Z",
      "updated_at": "2017-03-27T17:41:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105221818",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105221818"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105235482",
      "pull_request_review_id": 26105509,
      "id": 105235482,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNTIzNTQ4Mg==",
      "diff_hunk": "@@ -30,103 +30,112 @@ template <typename T>\n class CCheckQueue\n {\n private:\n-    //! Mutex to protect the inner state\n+    //! Mutex to ensure that sleeping threads are woken.\n     boost::mutex mutex;\n \n     //! Worker threads block on this when out of work\n     boost::condition_variable condWorker;\n \n-    //! Master thread blocks on this when out of work\n-    boost::condition_variable condMaster;\n-\n-    //! The queue of elements to be processed.\n-    //! As the order of booleans doesn't matter, it is used as a LIFO (stack)\n-\n-    //! The number of workers (including the master) that are idle.\n-    int nIdle;\n-\n-    //! The total number of workers (including the master).\n-    int nTotal;\n-\n     //! The temporary evaluation result.\n-    bool fAllOk;\n+    std::atomic<uint8_t> fAllOk;\n \n     /**\n-     * Number of verifications that haven't completed yet.\n-     * This includes elements that are no longer queued, but still in the\n-     * worker's own batches.\n+     * Number of verification threads that aren't in stand-by. When a thread is\n+     * awake it may have a job that will return false, but is yet to report the\n+     * result through fAllOk.\n      */\n-    unsigned int nTodo;\n+    std::atomic<unsigned int> nAwake;\n+\n+    /** If there is presently a master process either in the queue or adding jobs */\n+    std::atomic<bool> fMasterPresent;\n \n     //! Whether we're shutting down.\n     bool fQuit;\n \n     //! The maximum number of elements to be processed in one batch\n     unsigned int nBatchSize;\n \n+    //! A pointer to contiguous memory that contains all checks\n+    T* check_mem {nullptr};\n+\n+    /** The begin and end offsets into check_mem. 128 bytes of padding is\n+     * inserted before and after check_mem_top to eliminate false sharing*/\n+    std::atomic<uint32_t> check_mem_bot {0};\n+    unsigned char _padding[128];\n+    std::atomic<uint32_t> check_mem_top {0};\n+    unsigned char _padding2[128];\n+\n     /** Internal function that does bulk of the verification work. */\n     bool Loop(bool fMaster = false)\n     {\n-        boost::condition_variable& cond = fMaster ? condMaster : condWorker;\n-        typename std::vector<T>::iterator checks_iterator;\n-        unsigned int nNow = 0;\n-        bool fOk = true;\n-        do {\n+\n+        uint8_t fOk = 1;\n+        // first iteration, only count non-master threads\n+        if (!fMaster)\n+            ++nAwake;\n+        for (;;) {\n+            uint32_t top_cache = check_mem_top;\n+            uint32_t bottom_cache = check_mem_bot;\n+            // Try to increment bottom_cache by 1 if our version of bottom_cache\n+            // indicates that there is work to be done.\n+            // E.g., if bottom_cache = top_cache, don't attempt to exchange.\n+            //       if  bottom_cache < top_cache, then do attempt to exchange \n+            //\n+            // compare_exchange_weak, on failure, updates bottom_cache to latest\n+            while (top_cache > bottom_cache && \n+                    !check_mem_bot.compare_exchange_weak( bottom_cache, bottom_cache+1));\n+            // If our loop terminated because of no_work_left...\n+            if (top_cache <= bottom_cache)\n             {\n-                boost::unique_lock<boost::mutex> lock(mutex);\n-                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n-                if (nNow) {\n-                    fAllOk &= fOk;\n-                    nTodo -= nNow;\n-                    if (nTodo == 0 && !fMaster)\n-                        // We processed the last element; inform the master it can exit and return the result\n-                        condMaster.notify_one();\n-                } else {\n-                    // first iteration\n-                    nTotal++;\n-                }\n-                // logically, the do loop starts here\n-                while (check_mem_top == check_mem_bottom) { // while (empty)\n-                    if ((fMaster || fQuit) && nTodo == 0) {\n-                        nTotal--;\n-                        bool fRet = fAllOk;\n-                        // reset the status for new work later\n-                        if (fMaster)\n-                            fAllOk = true;\n-                        // return the current status\n-                        return fRet;\n+                if (fMaster) {\n+                    fMasterPresent = false;\n+                    // There's no harm to the master holding the lock\n+                    // at this point because all the jobs are taken.\n+                    // so busy spin until no one else is awake\n+                    while (nAwake) {}\n+                    bool fRet = fAllOk;\n+                    // reset the status for new work later\n+                    fAllOk = 1;\n+                    // return the current status\n+                    return fRet;\n+                } else  if (!fMasterPresent) { // Read once outside the lock and once inside\n+                    --nAwake; \n+                    // Unfortunately we need this lock for this to be safe\n+                    // We hold it for the min time possible\n+                    {\n+                        boost::unique_lock<boost::mutex> lock(mutex);\n+                        condWorker.wait(lock, [&]{ return fMasterPresent.load();});\n                     }\n-                    nIdle++;\n-                    cond.wait(lock); // wait\n-                    nIdle--;\n+                    ++nAwake;\n                 }\n-                // Decide how many work units to process now.\n-                // * Do not try to do everything at once, but aim for increasingly smaller batches so\n-                //   all workers finish approximately simultaneously.\n-                // * Try to account for idle jobs which will instantly start helping.\n-                // * Don't do batches smaller than 1 (duh), or larger than nBatchSize.\n-                nNow = std::max(1U, std::min(nBatchSize, (unsigned int)(check_mem_top - check_mem_bottom) / (nTotal + nIdle + 1)));\n-                checks_iterator = check_mem_bottom;\n-                std::advance(check_mem_bottom, nNow);\n-                // Check whether we need to do work at all\n+            } else {\n+                // We compute using bottom_cache (not bottom_cache + 1 as above) because it is 0-indexed\n+                T * pT = check_mem + bottom_cache;\n+                // Check whether we need to do work at all (can be read outside\n+                // of lock because it's fine if a worker executes checks\n+                // anyways)\n                 fOk = fAllOk;\n-            }\n-            // execute work\n-            for (unsigned int i = 0; i < nNow && fOk; i++) {\n-                fOk = (*checks_iterator)();\n+                // execute work\n+                fOk &= fOk && (*pT)();\n+                // We swap in a default constructed value onto pT before freeing\n+                // so that we don't accidentally double free when check_mem is\n+                // freed. We don't strictly need to free here, but it's good\n+                // practice in case T uses a lot of memory.\n                 auto t = T();\n-                checks_iterator->swap(t);\n-                std::advance(checks_iterator, 1);\n+                pT->swap(t);\n+                // Can't reveal result until after swapped, otherwise",
      "path": "src/checkqueue.h",
      "position": null,
      "original_position": 169,
      "commit_id": "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "original_commit_id": "6e24aa818be4b494fc1809a7ca3ee568e253deb6",
      "in_reply_to_id": 105046758,
      "user": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think the solution i came up with is pretty trivial (I'll push it later today).\r\n\r\n```c++\r\nfOk = fAllOk.load(std::memory_order_relaxed);\r\nif (fOk) {\r\n    T t();\r\n    pT->swap(t);\r\n} else {\r\n    fAllOk.store(false, std::memory_order_relaxed);\r\n    fMasterPresent = false;\r\n    // try to consume all values as quickly as possible\r\n    while (top_cache > bottom_cache &&\r\n                    !check_mem_bot.compare_exchange_weak( bottom_cache, top_cache)) {\r\n            top_cache = check_mem_top.load();\r\n    }\r\n}\r\n```\r\n\r\nEspecially since now, fAllOk is never written really now.\r\n\r\n",
      "created_at": "2017-03-09T18:27:07Z",
      "updated_at": "2017-03-27T17:41:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105235482",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105235482"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105258806",
      "pull_request_review_id": 26130203,
      "id": 105258806,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwNTI1ODgwNg==",
      "diff_hunk": "@@ -30,103 +30,112 @@ template <typename T>\n class CCheckQueue\n {\n private:\n-    //! Mutex to protect the inner state\n+    //! Mutex to ensure that sleeping threads are woken.\n     boost::mutex mutex;\n \n     //! Worker threads block on this when out of work\n     boost::condition_variable condWorker;\n \n-    //! Master thread blocks on this when out of work\n-    boost::condition_variable condMaster;\n-\n-    //! The queue of elements to be processed.\n-    //! As the order of booleans doesn't matter, it is used as a LIFO (stack)\n-\n-    //! The number of workers (including the master) that are idle.\n-    int nIdle;\n-\n-    //! The total number of workers (including the master).\n-    int nTotal;\n-\n     //! The temporary evaluation result.\n-    bool fAllOk;\n+    std::atomic<uint8_t> fAllOk;\n \n     /**\n-     * Number of verifications that haven't completed yet.\n-     * This includes elements that are no longer queued, but still in the\n-     * worker's own batches.\n+     * Number of verification threads that aren't in stand-by. When a thread is\n+     * awake it may have a job that will return false, but is yet to report the\n+     * result through fAllOk.\n      */\n-    unsigned int nTodo;\n+    std::atomic<unsigned int> nAwake;\n+\n+    /** If there is presently a master process either in the queue or adding jobs */\n+    std::atomic<bool> fMasterPresent;\n \n     //! Whether we're shutting down.\n     bool fQuit;\n \n     //! The maximum number of elements to be processed in one batch\n     unsigned int nBatchSize;\n \n+    //! A pointer to contiguous memory that contains all checks\n+    T* check_mem {nullptr};\n+\n+    /** The begin and end offsets into check_mem. 128 bytes of padding is\n+     * inserted before and after check_mem_top to eliminate false sharing*/\n+    std::atomic<uint32_t> check_mem_bot {0};\n+    unsigned char _padding[128];\n+    std::atomic<uint32_t> check_mem_top {0};\n+    unsigned char _padding2[128];\n+\n     /** Internal function that does bulk of the verification work. */\n     bool Loop(bool fMaster = false)\n     {\n-        boost::condition_variable& cond = fMaster ? condMaster : condWorker;\n-        typename std::vector<T>::iterator checks_iterator;\n-        unsigned int nNow = 0;\n-        bool fOk = true;\n-        do {\n+\n+        uint8_t fOk = 1;\n+        // first iteration, only count non-master threads\n+        if (!fMaster)\n+            ++nAwake;\n+        for (;;) {\n+            uint32_t top_cache = check_mem_top;\n+            uint32_t bottom_cache = check_mem_bot;\n+            // Try to increment bottom_cache by 1 if our version of bottom_cache\n+            // indicates that there is work to be done.\n+            // E.g., if bottom_cache = top_cache, don't attempt to exchange.\n+            //       if  bottom_cache < top_cache, then do attempt to exchange \n+            //\n+            // compare_exchange_weak, on failure, updates bottom_cache to latest\n+            while (top_cache > bottom_cache && \n+                    !check_mem_bot.compare_exchange_weak( bottom_cache, bottom_cache+1));\n+            // If our loop terminated because of no_work_left...\n+            if (top_cache <= bottom_cache)\n             {\n-                boost::unique_lock<boost::mutex> lock(mutex);\n-                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n-                if (nNow) {\n-                    fAllOk &= fOk;\n-                    nTodo -= nNow;\n-                    if (nTodo == 0 && !fMaster)\n-                        // We processed the last element; inform the master it can exit and return the result\n-                        condMaster.notify_one();\n-                } else {\n-                    // first iteration\n-                    nTotal++;\n-                }\n-                // logically, the do loop starts here\n-                while (check_mem_top == check_mem_bottom) { // while (empty)\n-                    if ((fMaster || fQuit) && nTodo == 0) {\n-                        nTotal--;\n-                        bool fRet = fAllOk;\n-                        // reset the status for new work later\n-                        if (fMaster)\n-                            fAllOk = true;\n-                        // return the current status\n-                        return fRet;\n+                if (fMaster) {\n+                    fMasterPresent = false;\n+                    // There's no harm to the master holding the lock\n+                    // at this point because all the jobs are taken.\n+                    // so busy spin until no one else is awake\n+                    while (nAwake) {}\n+                    bool fRet = fAllOk;\n+                    // reset the status for new work later\n+                    fAllOk = 1;\n+                    // return the current status\n+                    return fRet;\n+                } else  if (!fMasterPresent) { // Read once outside the lock and once inside\n+                    --nAwake; \n+                    // Unfortunately we need this lock for this to be safe\n+                    // We hold it for the min time possible\n+                    {\n+                        boost::unique_lock<boost::mutex> lock(mutex);\n+                        condWorker.wait(lock, [&]{ return fMasterPresent.load();});\n                     }\n-                    nIdle++;\n-                    cond.wait(lock); // wait\n-                    nIdle--;\n+                    ++nAwake;\n                 }\n-                // Decide how many work units to process now.\n-                // * Do not try to do everything at once, but aim for increasingly smaller batches so\n-                //   all workers finish approximately simultaneously.\n-                // * Try to account for idle jobs which will instantly start helping.\n-                // * Don't do batches smaller than 1 (duh), or larger than nBatchSize.\n-                nNow = std::max(1U, std::min(nBatchSize, (unsigned int)(check_mem_top - check_mem_bottom) / (nTotal + nIdle + 1)));\n-                checks_iterator = check_mem_bottom;\n-                std::advance(check_mem_bottom, nNow);\n-                // Check whether we need to do work at all\n+            } else {\n+                // We compute using bottom_cache (not bottom_cache + 1 as above) because it is 0-indexed\n+                T * pT = check_mem + bottom_cache;\n+                // Check whether we need to do work at all (can be read outside\n+                // of lock because it's fine if a worker executes checks\n+                // anyways)\n                 fOk = fAllOk;\n-            }\n-            // execute work\n-            for (unsigned int i = 0; i < nNow && fOk; i++) {\n-                fOk = (*checks_iterator)();\n+                // execute work\n+                fOk &= fOk && (*pT)();\n+                // We swap in a default constructed value onto pT before freeing\n+                // so that we don't accidentally double free when check_mem is\n+                // freed. We don't strictly need to free here, but it's good\n+                // practice in case T uses a lot of memory.\n                 auto t = T();\n-                checks_iterator->swap(t);\n-                std::advance(checks_iterator, 1);\n+                pT->swap(t);\n+                // Can't reveal result until after swapped, otherwise",
      "path": "src/checkqueue.h",
      "position": null,
      "original_position": 169,
      "commit_id": "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "original_commit_id": "6e24aa818be4b494fc1809a7ca3ee568e253deb6",
      "in_reply_to_id": 105046758,
      "user": {
        "login": "TheBlueMatt",
        "id": 649246,
        "node_id": "MDQ6VXNlcjY0OTI0Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/TheBlueMatt",
        "html_url": "https://github.com/TheBlueMatt",
        "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
        "following_url": "https://api.github.com/users/TheBlueMatt/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/TheBlueMatt/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/TheBlueMatt/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
        "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
        "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
        "events_url": "https://api.github.com/users/TheBlueMatt/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Looks like too just complexity? Just dont bother exiting early, we can take a performance hit of very little on an invalid block, I think. Just dont bother writing to fAllOk if fOk?",
      "created_at": "2017-03-09T20:07:32Z",
      "updated_at": "2017-03-27T17:41:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r105258806",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/105258806"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108241184",
      "pull_request_review_id": 29260495,
      "id": 108241184,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODI0MTE4NA==",
      "diff_hunk": "@@ -0,0 +1,442 @@\n+// Copyright (c) 2012-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"util.h\"\n+#include \"utiltime.h\"\n+#include \"validation.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+#include \"checkqueue.h\"\n+#include <boost/test/unit_test.hpp>\n+#include <boost/thread.hpp>\n+#include <atomic>\n+#include <thread>\n+#include <vector>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <unordered_set>\n+#include <memory>\n+#include \"random.h\"\n+\n+// BasicTestingSetup not sufficient because nScriptCheckThreads is not set\n+// otherwise.\n+BOOST_FIXTURE_TEST_SUITE(checkqueue_tests, TestingSetup)\n+\n+static const int QUEUE_BATCH_SIZE = 128;\n+\n+struct FakeCheck {\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    void swap(FakeCheck& x){};\n+};\n+\n+struct FakeCheckCheckCompletion {\n+    static std::atomic<size_t> n_calls;\n+    bool operator()()\n+    {\n+        ++n_calls;\n+        return true;\n+    }\n+    void swap(FakeCheckCheckCompletion& x){};\n+};\n+\n+struct FailingCheck {\n+    bool fails;\n+    FailingCheck(bool fails) : fails(fails){};\n+    FailingCheck() : fails(true){};\n+    bool operator()()\n+    {\n+        return !fails;\n+    }\n+    void swap(FailingCheck& x)\n+    {\n+        std::swap(fails, x.fails);\n+    };\n+};\n+\n+struct UniqueCheck {\n+    static std::mutex m;\n+    static std::unordered_multiset<size_t> results;\n+    size_t check_id;\n+    UniqueCheck(size_t check_id_in) : check_id(check_id_in){};\n+    UniqueCheck() : check_id(0){};\n+    bool operator()()\n+    {\n+        std::lock_guard<std::mutex> l(m);\n+        results.insert(check_id);\n+        return true;\n+    }\n+    void swap(UniqueCheck& x) { std::swap(x.check_id, check_id); };\n+};\n+\n+\n+struct MemoryCheck {\n+    static std::atomic<size_t> fake_allocated_memory;\n+    bool b {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    MemoryCheck(){};\n+    MemoryCheck(const MemoryCheck& x)\n+    {\n+        // We have to do this to make sure that destructor calls are paired\n+        //\n+        // Really, copy constructor should be deletable, but CCheckQueue breaks\n+        // if it is deleted because of internal push_back.\n+        fake_allocated_memory += b;\n+    };\n+    MemoryCheck(bool b_) : b(b_)\n+    {\n+        fake_allocated_memory += b;\n+    };\n+    ~MemoryCheck(){\n+        fake_allocated_memory -= b;\n+    \n+    };\n+    void swap(MemoryCheck& x) { std::swap(b, x.b); };\n+};\n+\n+struct FrozenCleanupCheck {\n+    static std::atomic<uint64_t> nFrozen;\n+    static std::condition_variable cv;\n+    static std::mutex m;\n+    // Freezing can't be the default initialized behavior given how the queue\n+    // swaps in default initialized Checks.\n+    bool should_freeze {false};\n+    bool operator()()\n+    {\n+        return true;\n+    }\n+    FrozenCleanupCheck() {}\n+    ~FrozenCleanupCheck()\n+    {\n+        if (should_freeze) {\n+            std::unique_lock<std::mutex> l(m);\n+            nFrozen = 1;\n+            cv.notify_one();\n+            cv.wait(l, []{ return nFrozen == 0;});\n+        }\n+    }\n+    void swap(FrozenCleanupCheck& x){std::swap(should_freeze, x.should_freeze);};\n+};\n+\n+// Static Allocations\n+std::mutex FrozenCleanupCheck::m{};\n+std::atomic<uint64_t> FrozenCleanupCheck::nFrozen{0};\n+std::condition_variable FrozenCleanupCheck::cv{};\n+std::mutex UniqueCheck::m;\n+std::unordered_multiset<size_t> UniqueCheck::results;\n+std::atomic<size_t> FakeCheckCheckCompletion::n_calls{0};\n+std::atomic<size_t> MemoryCheck::fake_allocated_memory{0};\n+\n+// Queue Typedefs\n+typedef CCheckQueue<FakeCheckCheckCompletion> Correct_Queue;\n+typedef CCheckQueue<FakeCheck> Standard_Queue;\n+typedef CCheckQueue<FailingCheck> Failing_Queue;\n+typedef CCheckQueue<UniqueCheck> Unique_Queue;\n+typedef CCheckQueue<MemoryCheck> Memory_Queue;\n+typedef CCheckQueue<FrozenCleanupCheck> FrozenCleanup_Queue;\n+\n+\n+/** This test case checks that the CCheckQueue works properly\n+ * with each specified size_t Checks pushed.\n+ */\n+void Correct_Queue_range(std::vector<size_t> range)\n+{\n+    auto small_queue = std::unique_ptr<Correct_Queue>(new Correct_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{small_queue->Thread();});\n+    }\n+    // Make vChecks here to save on malloc (this test can be slow...)\n+    std::vector<FakeCheckCheckCompletion> vChecks;\n+    for (auto i : range) {\n+        size_t total = i;\n+        FakeCheckCheckCompletion::n_calls = 0;\n+        CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n+        while (total) {\n+            vChecks.resize(std::min(total, (size_t) GetRand(10)));\n+            total -= vChecks.size();\n+            control.Add(vChecks);\n+        }\n+        BOOST_REQUIRE(control.Wait());\n+        if (FakeCheckCheckCompletion::n_calls != i) {\n+            BOOST_REQUIRE_EQUAL(FakeCheckCheckCompletion::n_calls, i);\n+            BOOST_TEST_MESSAGE(\"Failure on trial \" << i << \" expected, got \" << FakeCheckCheckCompletion::n_calls);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+\n+/** Test that 0 checks is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Zero)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)0);\n+    Correct_Queue_range(range);\n+}\n+/** Test that 1 check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_One)\n+{\n+    std::vector<size_t> range;\n+    range.push_back((size_t)1);\n+    Correct_Queue_range(range);\n+}\n+/** Test that MAX check is correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Max)\n+{\n+    std::vector<size_t> range;\n+    range.push_back(100000);\n+    Correct_Queue_range(range);\n+}\n+/** Test that random numbers of checks are correct\n+ */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n+{\n+    std::vector<size_t> range;\n+    range.reserve(100000/1000);\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+        range.push_back(i);\n+    Correct_Queue_range(range);\n+}\n+\n+\n+/** Test that failing checks are caught */\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (size_t i = 0; i < 1001; ++i) {\n+        CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+        size_t remaining = i;\n+        while (remaining) {\n+            size_t r = GetRand(10);\n+\n+            std::vector<FailingCheck> vChecks;\n+            vChecks.reserve(r);\n+            for (size_t k = 0; k < r && remaining; k++, remaining--)\n+                vChecks.emplace_back(remaining == 1);\n+            control.Add(vChecks);\n+        }\n+        bool success = control.Wait();\n+        if (i > 0) {\n+            BOOST_REQUIRE(!success);\n+        } else if (i == 0) {\n+            BOOST_REQUIRE(success);\n+        }\n+    }\n+    tg.interrupt_all();\n+    tg.join_all();\n+}\n+// Test that a block validation which fails does not interfere with\n+// future blocks, ie, the bad state is cleared.\n+BOOST_AUTO_TEST_CASE(test_CheckQueue_Recovers_From_Failure)\n+{\n+    auto fail_queue = std::unique_ptr<Failing_Queue>(new Failing_Queue {QUEUE_BATCH_SIZE});\n+    boost::thread_group tg;\n+    for (auto x = 0; x < nScriptCheckThreads; ++x) {\n+       tg.create_thread([&]{fail_queue->Thread();});\n+    }\n+\n+    for (auto times = 0; times < 10; ++times) {\n+        for (bool end_fails : {true, false}) {\n+            CCheckQueueControl<FailingCheck> control(fail_queue.get());\n+            {\n+                std::vector<FailingCheck> vChecks;\n+                vChecks.resize(100, false);\n+                vChecks[99] = end_fails;\n+                control.Add(vChecks);\n+            }\n+            bool r =control.Wait();\n+            BOOST_REQUIRE(r || end_fails);",
      "path": "src/test/checkqueue_tests.cpp",
      "position": null,
      "original_position": 265,
      "commit_id": "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "original_commit_id": "08e4e1ea89427a2594415d0b37011692a5109c39",
      "in_reply_to_id": 105031924,
      "user": {
        "login": "JeremyRubin",
        "id": 886523,
        "node_id": "MDQ6VXNlcjg4NjUyMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/JeremyRubin",
        "html_url": "https://github.com/JeremyRubin",
        "followers_url": "https://api.github.com/users/JeremyRubin/followers",
        "following_url": "https://api.github.com/users/JeremyRubin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/JeremyRubin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/JeremyRubin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
        "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
        "repos_url": "https://api.github.com/users/JeremyRubin/repos",
        "events_url": "https://api.github.com/users/JeremyRubin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yes.",
      "created_at": "2017-03-27T18:15:36Z",
      "updated_at": "2017-12-30T11:11:01Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r108241184",
      "author_association": "CONTRIBUTOR",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108241184"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": null,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108277493",
      "pull_request_review_id": 29299191,
      "id": 108277493,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDEwODI3NzQ5Mw==",
      "diff_hunk": "@@ -30,103 +30,112 @@ template <typename T>\n class CCheckQueue\n {\n private:\n-    //! Mutex to protect the inner state\n+    //! Mutex to ensure that sleeping threads are woken.\n     boost::mutex mutex;\n \n     //! Worker threads block on this when out of work\n     boost::condition_variable condWorker;\n \n-    //! Master thread blocks on this when out of work\n-    boost::condition_variable condMaster;\n-\n-    //! The queue of elements to be processed.\n-    //! As the order of booleans doesn't matter, it is used as a LIFO (stack)\n-\n-    //! The number of workers (including the master) that are idle.\n-    int nIdle;\n-\n-    //! The total number of workers (including the master).\n-    int nTotal;\n-\n     //! The temporary evaluation result.\n-    bool fAllOk;\n+    std::atomic<uint8_t> fAllOk;\n \n     /**\n-     * Number of verifications that haven't completed yet.\n-     * This includes elements that are no longer queued, but still in the\n-     * worker's own batches.\n+     * Number of verification threads that aren't in stand-by. When a thread is\n+     * awake it may have a job that will return false, but is yet to report the\n+     * result through fAllOk.\n      */\n-    unsigned int nTodo;\n+    std::atomic<unsigned int> nAwake;\n+\n+    /** If there is presently a master process either in the queue or adding jobs */\n+    std::atomic<bool> fMasterPresent;\n \n     //! Whether we're shutting down.\n     bool fQuit;\n \n     //! The maximum number of elements to be processed in one batch\n     unsigned int nBatchSize;\n \n+    //! A pointer to contiguous memory that contains all checks\n+    T* check_mem {nullptr};\n+\n+    /** The begin and end offsets into check_mem. 128 bytes of padding is\n+     * inserted before and after check_mem_top to eliminate false sharing*/\n+    std::atomic<uint32_t> check_mem_bot {0};\n+    unsigned char _padding[128];\n+    std::atomic<uint32_t> check_mem_top {0};\n+    unsigned char _padding2[128];\n+\n     /** Internal function that does bulk of the verification work. */\n     bool Loop(bool fMaster = false)\n     {\n-        boost::condition_variable& cond = fMaster ? condMaster : condWorker;\n-        typename std::vector<T>::iterator checks_iterator;\n-        unsigned int nNow = 0;\n-        bool fOk = true;\n-        do {\n+\n+        uint8_t fOk = 1;\n+        // first iteration, only count non-master threads\n+        if (!fMaster)\n+            ++nAwake;\n+        for (;;) {\n+            uint32_t top_cache = check_mem_top;\n+            uint32_t bottom_cache = check_mem_bot;\n+            // Try to increment bottom_cache by 1 if our version of bottom_cache\n+            // indicates that there is work to be done.\n+            // E.g., if bottom_cache = top_cache, don't attempt to exchange.\n+            //       if  bottom_cache < top_cache, then do attempt to exchange \n+            //\n+            // compare_exchange_weak, on failure, updates bottom_cache to latest\n+            while (top_cache > bottom_cache && \n+                    !check_mem_bot.compare_exchange_weak( bottom_cache, bottom_cache+1));\n+            // If our loop terminated because of no_work_left...\n+            if (top_cache <= bottom_cache)\n             {\n-                boost::unique_lock<boost::mutex> lock(mutex);\n-                // first do the clean-up of the previous loop run (allowing us to do it in the same critsect)\n-                if (nNow) {\n-                    fAllOk &= fOk;\n-                    nTodo -= nNow;\n-                    if (nTodo == 0 && !fMaster)\n-                        // We processed the last element; inform the master it can exit and return the result\n-                        condMaster.notify_one();\n-                } else {\n-                    // first iteration\n-                    nTotal++;\n-                }\n-                // logically, the do loop starts here\n-                while (check_mem_top == check_mem_bottom) { // while (empty)\n-                    if ((fMaster || fQuit) && nTodo == 0) {\n-                        nTotal--;\n-                        bool fRet = fAllOk;\n-                        // reset the status for new work later\n-                        if (fMaster)\n-                            fAllOk = true;\n-                        // return the current status\n-                        return fRet;\n+                if (fMaster) {\n+                    fMasterPresent = false;\n+                    // There's no harm to the master holding the lock\n+                    // at this point because all the jobs are taken.\n+                    // so busy spin until no one else is awake\n+                    while (nAwake) {}\n+                    bool fRet = fAllOk;\n+                    // reset the status for new work later\n+                    fAllOk = 1;\n+                    // return the current status\n+                    return fRet;\n+                } else  if (!fMasterPresent) { // Read once outside the lock and once inside\n+                    --nAwake; \n+                    // Unfortunately we need this lock for this to be safe\n+                    // We hold it for the min time possible\n+                    {\n+                        boost::unique_lock<boost::mutex> lock(mutex);\n+                        condWorker.wait(lock, [&]{ return fMasterPresent.load();});\n                     }\n-                    nIdle++;\n-                    cond.wait(lock); // wait\n-                    nIdle--;\n+                    ++nAwake;\n                 }\n-                // Decide how many work units to process now.\n-                // * Do not try to do everything at once, but aim for increasingly smaller batches so\n-                //   all workers finish approximately simultaneously.\n-                // * Try to account for idle jobs which will instantly start helping.\n-                // * Don't do batches smaller than 1 (duh), or larger than nBatchSize.\n-                nNow = std::max(1U, std::min(nBatchSize, (unsigned int)(check_mem_top - check_mem_bottom) / (nTotal + nIdle + 1)));\n-                checks_iterator = check_mem_bottom;\n-                std::advance(check_mem_bottom, nNow);\n-                // Check whether we need to do work at all\n+            } else {\n+                // We compute using bottom_cache (not bottom_cache + 1 as above) because it is 0-indexed\n+                T * pT = check_mem + bottom_cache;\n+                // Check whether we need to do work at all (can be read outside\n+                // of lock because it's fine if a worker executes checks\n+                // anyways)\n                 fOk = fAllOk;\n-            }\n-            // execute work\n-            for (unsigned int i = 0; i < nNow && fOk; i++) {\n-                fOk = (*checks_iterator)();\n+                // execute work\n+                fOk &= fOk && (*pT)();",
      "path": "src/checkqueue.h",
      "position": null,
      "original_position": 160,
      "commit_id": "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "original_commit_id": "39397bb40cc0ead65a131492376d6a219c99c8d2",
      "in_reply_to_id": null,
      "user": {
        "login": "theuni",
        "id": 417043,
        "node_id": "MDQ6VXNlcjQxNzA0Mw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theuni",
        "html_url": "https://github.com/theuni",
        "followers_url": "https://api.github.com/users/theuni/followers",
        "following_url": "https://api.github.com/users/theuni/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theuni/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theuni/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
        "organizations_url": "https://api.github.com/users/theuni/orgs",
        "repos_url": "https://api.github.com/users/theuni/repos",
        "events_url": "https://api.github.com/users/theuni/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theuni/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Why not:\r\n```\r\nfOk &= fOk && T(std::move(*pT))()\r\n```\r\nand do away with all of the swap business?",
      "created_at": "2017-03-27T20:54:16Z",
      "updated_at": "2017-03-27T20:54:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/9938#discussion_r108277493",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/108277493"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/9938"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 119,
      "side": "RIGHT"
    }
  ]
}