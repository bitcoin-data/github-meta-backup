{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
    "id": 1080948690,
    "node_id": "PR_kwDOABII585AbffS",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/26283",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/26283.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/26283.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26283",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26283/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/00df0aefff938e849bdab5278d6658d5c9d5d064",
    "number": 26283,
    "state": "open",
    "locked": false,
    "maintainer_can_modify": true,
    "title": "p2p: Fill reconciliation sets and request reconciliation (Erlay)",
    "user": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "This is a part of the Erlay project:\r\n- [parent PR](https://github.com/bitcoin/bitcoin/pull/21515)\r\n- [associated BIP-330](https://github.com/bitcoin/bips/pull/1376). **Note this is not what's in the bitcoin/bips repo, but an updated version.**\r\n- [previous PR](https://github.com/bitcoin/bitcoin/pull/23443)\r\n\r\n-------\r\n\r\nFirst, this PR enables keeping track of per-peer reconciliation sets, containing those transactions which we intend to exchange efficiently. The remaining transactions are announced via flooding, as usual. \r\nSecond, this PR enables periodically initiating a reconciliation round via a new p2p message.",
    "labels": [
      {
        "id": 98298007,
        "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
        "name": "P2P",
        "color": "006b75",
        "default": false
      },
      {
        "id": 955867938,
        "node_id": "MDU6TGFiZWw5NTU4Njc5Mzg=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Needs%20rebase",
        "name": "Needs rebase",
        "description": "",
        "color": "cccccc",
        "default": false
      }
    ],
    "created_at": "2022-10-08T07:29:52Z",
    "updated_at": "2023-05-30T18:55:22Z",
    "mergeable": false,
    "mergeable_state": "dirty",
    "merge_commit_sha": "2560d59e01cb92de001e4858ab2929f848df9016",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "rebaseable": false,
    "head": {
      "label": "naumenkogs:2022-10-erlay2",
      "ref": "2022-10-erlay2",
      "sha": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 115054139,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTUwNTQxMzk=",
        "name": "bitcoin",
        "full_name": "naumenkogs/bitcoin",
        "owner": {
          "login": "naumenkogs",
          "id": 7975071,
          "node_id": "MDQ6VXNlcjc5NzUwNzE=",
          "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/naumenkogs",
          "html_url": "https://github.com/naumenkogs",
          "followers_url": "https://api.github.com/users/naumenkogs/followers",
          "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
          "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
          "repos_url": "https://api.github.com/users/naumenkogs/repos",
          "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/naumenkogs/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": true,
        "url": "https://api.github.com/repos/naumenkogs/bitcoin",
        "archive_url": "https://api.github.com/repos/naumenkogs/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/naumenkogs/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/naumenkogs/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/naumenkogs/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/naumenkogs/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/naumenkogs/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/naumenkogs/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/naumenkogs/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/naumenkogs/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/naumenkogs/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/naumenkogs/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/naumenkogs/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/naumenkogs/bitcoin/events",
        "forks_url": "https://api.github.com/repos/naumenkogs/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/naumenkogs/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/naumenkogs/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/naumenkogs/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/naumenkogs/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/naumenkogs/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/naumenkogs/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/naumenkogs/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/naumenkogs/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/naumenkogs/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/naumenkogs/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/naumenkogs/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/naumenkogs/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/naumenkogs/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/naumenkogs/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/naumenkogs/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:naumenkogs/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/naumenkogs/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/naumenkogs/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/naumenkogs/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/naumenkogs/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/naumenkogs/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/naumenkogs/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/naumenkogs/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/naumenkogs/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/naumenkogs/bitcoin/hooks",
        "svn_url": "https://github.com/naumenkogs/bitcoin",
        "homepage": "https://bitcoin.org/en/download",
        "language": "C++",
        "forks_count": 2,
        "stargazers_count": 1,
        "watchers_count": 1,
        "size": 213338,
        "default_branch": "master",
        "open_issues_count": 1,
        "is_template": false,
        "topics": [],
        "has_issues": false,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-02-23T10:57:41Z",
        "created_at": "2017-12-21T22:52:17Z",
        "updated_at": "2021-03-02T13:21:27Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "32f9ce0f52b7bb211de02f2c6ec9ecc65a625b79",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 34324,
        "stargazers_count": 69818,
        "watchers_count": 69818,
        "size": 233879,
        "default_branch": "master",
        "open_issues_count": 627,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-06-07T07:15:46Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2023-06-07T06:49:43Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 721,
    "deletions": 13,
    "changed_files": 11,
    "commits": 8,
    "review_comments": 111,
    "comments": 4
  },
  "events": [
    {
      "event": "convert_to_draft",
      "id": 7547617514,
      "node_id": "CTDE_lADOABII585TjqCFzwAAAAHB34Dq",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7547617514",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-08T07:30:00Z"
    },
    {
      "event": "commented",
      "id": 1272254249,
      "node_id": "IC_kwDOABII585L1Q8p",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1272254249",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-08T07:33:48Z",
      "updated_at": "2022-10-28T09:07:02Z",
      "author_association": "MEMBER",
      "body": "Marking this draft until:\r\n1. ~~[Previous PR is merged](https://github.com/bitcoin/bitcoin/pull/23443)~~ [Follow-up is merged](https://github.com/bitcoin/bitcoin/pull/26359)\r\n2. There is one in-code TODO I have to resolve (it is minor, but it has to be improved)\r\n3. I add unit and functional tests for these features.\r\n\r\nAnother task is to sync [parent PR](https://github.com/bitcoin/bitcoin/pull/21515) with this version. I have a local branch that compiles, but tests of the full Erlay there needs a little care. If you want to see how this PR works in the broader context, the parent should be good enough to get it. Otherwise, I intend to update it soon.",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#issuecomment-1272254249",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26283"
    },
    {
      "event": "labeled",
      "id": 7547807873,
      "node_id": "LE_lADOABII585TjqCFzwAAAAHB4miB",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7547807873",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-08T10:16:28Z",
      "label": {
        "name": "P2P",
        "color": "006b75"
      }
    },
    {
      "event": "commented",
      "id": 1272351013,
      "node_id": "IC_kwDOABII585L1okl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1272351013",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-08T16:15:15Z",
      "updated_at": "2023-03-24T06:37:44Z",
      "author_association": "MEMBER",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#26621](https://github.com/bitcoin/bitcoin/pull/26621) (refactor: Continue moving application data from CNode to Peer by dergoegge)\n* [#26140](https://github.com/bitcoin/bitcoin/pull/26140) (refactor: Move CNodeState members guarded by g_msgproc_mutex to Peer by dergoegge)\n* [#23233](https://github.com/bitcoin/bitcoin/pull/23233) (BIP324: Add encrypted p2p transport {de}serializer by dhruv)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#issuecomment-1272351013",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26283"
    },
    {
      "event": "labeled",
      "id": 7582950069,
      "node_id": "LE_lADOABII585TjqCFzwAAAAHD-qK1",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7582950069",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-13T16:06:09Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 1146311466,
      "node_id": "PRR_kwDOABII585EU1Mq",
      "url": null,
      "actor": null,
      "commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Just few comments as a first parse on the post-#23443 commits.",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1146311466",
      "submitted_at": "2022-10-18T20:01:20Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "reviewed",
      "id": 1156088702,
      "node_id": "PRR_kwDOABII585E6IN-",
      "url": null,
      "actor": null,
      "commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "First code-review parse, left some minor comments.",
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1156088702",
      "submitted_at": "2022-10-26T09:24:58Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7740408825,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHNXUP5",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7740408825",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-04T12:44:19Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7740556003,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHNX4Lj",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7740556003",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-04T13:05:22Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7740684079,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHNYXcv",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7740684079",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-04T13:21:48Z"
    },
    {
      "event": "unlabeled",
      "id": 7741143892,
      "node_id": "UNLE_lADOABII585TjqCFzwAAAAHNaHtU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7741143892",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-04T14:17:25Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "labeled",
      "id": 7742287057,
      "node_id": "LE_lADOABII585TjqCFzwAAAAHNeezR",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7742287057",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-04T16:29:57Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7762678458,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHOsRK6",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7762678458",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-08T13:16:16Z"
    },
    {
      "event": "unlabeled",
      "id": 7763186057,
      "node_id": "UNLE_lADOABII585TjqCFzwAAAAHOuNGJ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7763186057",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-08T14:09:11Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7781724122,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHP06_a",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7781724122",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-10T10:19:42Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7781872176,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHP1fIw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7781872176",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-10T10:37:38Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7782660720,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHP4fpw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7782660720",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-10T12:14:18Z"
    },
    {
      "event": "reviewed",
      "id": 1177296531,
      "node_id": "PRR_kwDOABII585GLB6T",
      "url": null,
      "actor": null,
      "commit_id": "913c2cbcea58696237760c51f55acee9d91eb186",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1177296531",
      "submitted_at": "2022-11-11T12:51:42Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "labeled",
      "id": 7921414509,
      "node_id": "LE_lADOABII585TjqCFzwAAAAHYJzFt",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7921414509",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-30T12:05:54Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7921654308,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHYKtok",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7921654308",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-30T12:36:12Z"
    },
    {
      "event": "ready_for_review",
      "id": 7921848447,
      "node_id": "RFRE_lADOABII585TjqCFzwAAAAHYLdB_",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7921848447",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-30T13:00:36Z"
    },
    {
      "event": "unlabeled",
      "id": 7922468578,
      "node_id": "UNLE_lADOABII585TjqCFzwAAAAHYN0bi",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7922468578",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-11-30T14:11:00Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "reviewed",
      "id": 1199573032,
      "node_id": "PRR_kwDOABII585HgAgo",
      "url": null,
      "actor": null,
      "commit_id": "63d103dcb4defeb7192179f2f5867fe964d28cb9",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Some comments on the first commits.",
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1199573032",
      "submitted_at": "2022-11-30T15:56:56Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7931380629,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHYv0OV",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7931380629",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-01T12:28:34Z"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDkzYzA2NjViYjc4NmFlZTQyYjg2ZTk0MGQ2YWRjMGRmNjZiZTIzYzI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/93c0665bb786aee42b86e940d6adc0df66be23c2",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/93c0665bb786aee42b86e940d6adc0df66be23c2",
      "tree": {
        "sha": "f66511f5fb3f1e90c4aea10d91d20df4ce913498",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f66511f5fb3f1e90c4aea10d91d20df4ce913498"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bcee94d1078ccb7812dc12bfcb0c9d9a799a6d3b",
          "sha": "bcee94d1078ccb7812dc12bfcb0c9d9a799a6d3b",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/bcee94d1078ccb7812dc12bfcb0c9d9a799a6d3b"
        }
      ],
      "message": "refactor: Add a pre-mutexed version of IsPeerRegistered\n\nThe pre-mutexed version is useful for external calls, while\nthe regular version will be used internally.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2022-12-01T12:28:58Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2022-12-01T12:12:03Z"
      },
      "sha": "93c0665bb786aee42b86e940d6adc0df66be23c2"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7931388755,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHYv2NT",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7931388755",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-01T12:29:31Z"
    },
    {
      "event": "reviewed",
      "id": 1202785461,
      "node_id": "PRR_kwDOABII585HsQy1",
      "url": null,
      "actor": null,
      "commit_id": "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1202785461",
      "submitted_at": "2022-12-02T18:54:20Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "reviewed",
      "id": 1202979648,
      "node_id": "PRR_kwDOABII585HtANA",
      "url": null,
      "actor": null,
      "commit_id": "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Some comments on the first 3 commits.",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1202979648",
      "submitted_at": "2022-12-02T23:48:35Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 7952654996,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHaA-KU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7952654996",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-05T09:16:23Z"
    },
    {
      "event": "reviewed",
      "id": 1206848088,
      "node_id": "PRR_kwDOABII585H7wpY",
      "url": null,
      "actor": null,
      "commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1206848088",
      "submitted_at": "2022-12-06T16:17:37Z",
      "state": "CHANGES_REQUESTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "reviewed",
      "id": 1207285454,
      "node_id": "PRR_kwDOABII585H9bbO",
      "url": null,
      "actor": null,
      "commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1207285454",
      "submitted_at": "2022-12-06T23:44:32Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "reviewed",
      "id": 1208726536,
      "node_id": "PRR_kwDOABII585IC7QI",
      "url": null,
      "actor": null,
      "commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "I've drafted up a fuzz target for the `TxReconciliationTracker` here: https://github.com/dergoegge/bitcoin/commits/2022-10-erlay2\r\n\r\nI think having a fuzz target is worth while, now that there is quite a bit more going on besides registering/forgetting peers. I am happy to PR that separately after this is merged.\r\n\r\nSome suggestions inline after working on that target:",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1208726536",
      "submitted_at": "2022-12-07T16:28:48Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "reviewed",
      "id": 1208638733,
      "node_id": "PRR_kwDOABII585ICl0N",
      "url": null,
      "actor": null,
      "commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1208638733",
      "submitted_at": "2022-12-07T16:31:16Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "reviewed",
      "id": 1208800680,
      "node_id": "PRR_kwDOABII585IDNWo",
      "url": null,
      "actor": null,
      "commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1208800680",
      "submitted_at": "2022-12-07T17:02:18Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8068655484,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHg7el8",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8068655484",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-19T11:42:39Z"
    },
    {
      "event": "reviewed",
      "id": 1223170187,
      "node_id": "PRR_kwDOABII585I6BiL",
      "url": null,
      "actor": null,
      "commit_id": "15006207099882aa73c18738e5013bf0c313be93",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "Left some comments. Is it possible to add some unit tests for the `ShouldFloodTo` function?",
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1223170187",
      "submitted_at": "2022-12-19T18:36:05Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "commented",
      "id": 1359001649,
      "node_id": "IC_kwDOABII585RALgx",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1359001649",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-20T08:32:30Z",
      "updated_at": "2022-12-20T08:32:30Z",
      "author_association": "MEMBER",
      "body": "@aureleoules fixed all you pointed out. Note that the last two commits are WIP, as I'm looking for a confirmation that those two are indeed an improvement. If yes, then I will squash them with the earlier commits, add tests, etc.\r\nYou could state your opinion about them too (each commit separately) :).",
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#issuecomment-1359001649",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26283"
    },
    {
      "event": "mentioned",
      "id": 8076134704,
      "node_id": "MEE_lADOABII585TjqCFzwAAAAHhYAkw",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8076134704",
      "actor": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-20T08:32:31Z"
    },
    {
      "event": "subscribed",
      "id": 8076134710,
      "node_id": "SE_lADOABII585TjqCFzwAAAAHhYAk2",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8076134710",
      "actor": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-20T08:32:31Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8076142642,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAHhYCgy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8076142642",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-12-20T08:33:33Z"
    },
    {
      "event": "reviewed",
      "id": 1302212068,
      "node_id": "PRR_kwDOABII585Nni3k",
      "url": null,
      "actor": null,
      "commit_id": "986b02ce31cc22ec6f92ec190687afe6725711b8",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "> Curious, what we care about a low transaction relay latency ? Like I would say lower latency > makes it a) harder to observe original transaction broadcast by deanonymization attacker\r\n> b) disincentive transaction issuers front-running the standard tx-relay rules to place their\r\n> transactions first in the mempools in case of congestion and c) for instant/0confs flows\r\n> improve UX, do we have more properties ?\r\n\r\nYeah low-transaction relay latency is still to reconsider in light of all the timevalue DoS that you might have as a Lightning node running on top of Bitcoin Core. Implications with things like https://github.com/bitcoin/bitcoin/pull/21224.",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1302212068",
      "submitted_at": "2023-02-16T20:13:45Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8562593448,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAH-Xs6o",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8562593448",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-20T14:57:55Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8568371560,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAH-tvlo",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8568371560",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T08:52:55Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8568840098,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAH-vh-i",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8568840098",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T09:36:12Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8569430617,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAH-xyJZ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8569430617",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T10:33:05Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8569653246,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAH-yof-",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8569653246",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T10:58:05Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8569846011,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAH-zXj7",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8569846011",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T11:18:55Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8570141448,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAH-0fsI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8570141448",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-21T11:56:50Z"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8579856066,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAH_ZjbC",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8579856066",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-22T11:09:42Z"
    },
    {
      "event": "reviewed",
      "id": 1309970444,
      "node_id": "PRR_kwDOABII585OFJAM",
      "url": null,
      "actor": null,
      "commit_id": "37a471c986af620f9547d27a466250ed1988c846",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1309970444",
      "submitted_at": "2023-02-22T19:55:29Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGNkNDVjOTI0NzUwNTZhMmMxZmMwYzhjNWY5ODE0YmVlM2ExMzlkOTQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cd45c92475056a2c1fc0c8c5f9814bee3a139d94",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/cd45c92475056a2c1fc0c8c5f9814bee3a139d94",
      "tree": {
        "sha": "aae6f220db8b8f972ce2ab932d56ffcbfbf9402a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/aae6f220db8b8f972ce2ab932d56ffcbfbf9402a"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/93c0665bb786aee42b86e940d6adc0df66be23c2",
          "sha": "93c0665bb786aee42b86e940d6adc0df66be23c2",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/93c0665bb786aee42b86e940d6adc0df66be23c2"
        }
      ],
      "message": "p2p: Functions to add/remove wtxids to tx reconciliation sets\n\nThey will be used later on.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-02-23T10:38:06Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2022-10-08T06:25:01Z"
      },
      "sha": "cd45c92475056a2c1fc0c8c5f9814bee3a139d94"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGRjZGU1MzdiNWJjMGUyZGQyNzI1MjhlM2E3NzBhNzY4Y2E4MDQ5NTU",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dcde537b5bc0e2dd272528e3a770a768ca804955",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/dcde537b5bc0e2dd272528e3a770a768ca804955",
      "tree": {
        "sha": "305041573ce6498c822bf477a9cb5fd136b43325",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/305041573ce6498c822bf477a9cb5fd136b43325"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cd45c92475056a2c1fc0c8c5f9814bee3a139d94",
          "sha": "cd45c92475056a2c1fc0c8c5f9814bee3a139d94",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/cd45c92475056a2c1fc0c8c5f9814bee3a139d94"
        }
      ],
      "message": "p2p: Add transactions to reconciliation sets\n\nTransactions eligible for reconciliation are added to the\nreconciliation sets. For the remaining txs, low-fanout is used.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-02-23T10:49:20Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-06-23T16:01:53Z"
      },
      "sha": "dcde537b5bc0e2dd272528e3a770a768ca804955"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGZlNWM4NGYzNDNjNTQ4MTg4OWNlYjY4N2NiZmRjZDBmOWJlOTViNmM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fe5c84f343c5481889ceb687cbfdcd0f9be95b6c",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/fe5c84f343c5481889ceb687cbfdcd0f9be95b6c",
      "tree": {
        "sha": "396c904621f874b04f5fe38d13b79188f01b3efd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/396c904621f874b04f5fe38d13b79188f01b3efd"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/dcde537b5bc0e2dd272528e3a770a768ca804955",
          "sha": "dcde537b5bc0e2dd272528e3a770a768ca804955",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/dcde537b5bc0e2dd272528e3a770a768ca804955"
        }
      ],
      "message": "p2p: Introduce reconciliation-fanout tx broadcast interval\n\nFor a subset of reconciling peers we announce transactions\nvia low fanout. We need to set lower intervals for that to\nachieve lower relay latency.\n\nNote that for privacy reasons the ratio between inbound and outbound\ndelays matter much more than the actual delays. That ratio is preserved\nhere, so it is not a privacy degradation.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-02-23T10:50:44Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-16T19:33:05Z"
      },
      "sha": "fe5c84f343c5481889ceb687cbfdcd0f9be95b6c"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDA1MmMxZThjNmMzNTg5ZTZiNDg0NmMxMjhkMzEzYTJlMjI0MTA3NTI",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/052c1e8c6c3589e6b4846c128d313a2e22410752",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/052c1e8c6c3589e6b4846c128d313a2e22410752",
      "tree": {
        "sha": "c828463230f698b8434cab41308329a4826dbf6b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c828463230f698b8434cab41308329a4826dbf6b"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fe5c84f343c5481889ceb687cbfdcd0f9be95b6c",
          "sha": "fe5c84f343c5481889ceb687cbfdcd0f9be95b6c",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/fe5c84f343c5481889ceb687cbfdcd0f9be95b6c"
        }
      ],
      "message": "p2p: Add peers to reconciliation queue on negotiation\n\nWhen we're finalizing negotiation, we should add the peers\nfor which we will initiate reconciliations to the queue.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-02-23T10:50:45Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-20T12:12:24Z"
      },
      "sha": "052c1e8c6c3589e6b4846c128d313a2e22410752"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKGEzNGQ1NTk5MjJlZDJmZTY3NjRjNjJjYmUxMTVkMTBiZmM0YWUzMTk",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a34d559922ed2fe6764c62cbe115d10bfc4ae319",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/a34d559922ed2fe6764c62cbe115d10bfc4ae319",
      "tree": {
        "sha": "fc0359da5e60e22ea44e085a3bad02cd4c3c55a1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fc0359da5e60e22ea44e085a3bad02cd4c3c55a1"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/052c1e8c6c3589e6b4846c128d313a2e22410752",
          "sha": "052c1e8c6c3589e6b4846c128d313a2e22410752",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/052c1e8c6c3589e6b4846c128d313a2e22410752"
        }
      ],
      "message": "p2p: Track reconciliation requests schedule\n\nWe initiate reconciliation by looking at the queue periodically\nwith equal intervals between peers to achieve efficiency.\n\nThis will be later used to see whether it's time to initiate.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-02-23T10:50:45Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-23T10:26:17Z"
      },
      "sha": "a34d559922ed2fe6764c62cbe115d10bfc4ae319"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDMwYzM5YzEzMTZhN2I1YzE5MTQ2NTRmMmExNDg3MzA5YjZlNTUwYWM",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/30c39c1316a7b5c1914654f2a1487309b6e550ac",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/30c39c1316a7b5c1914654f2a1487309b6e550ac",
      "tree": {
        "sha": "e030737691b93e18b6b918f5403abe55a46cae96",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e030737691b93e18b6b918f5403abe55a46cae96"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a34d559922ed2fe6764c62cbe115d10bfc4ae319",
          "sha": "a34d559922ed2fe6764c62cbe115d10bfc4ae319",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/a34d559922ed2fe6764c62cbe115d10bfc4ae319"
        }
      ],
      "message": "p2p: Initiate reconciliation round\n\nWhen the time comes for the peer, we send a\nreconciliation request with the parameters which\nwill help the peer to construct a (hopefully) sufficient\nreconciliation sketch for us. We will then use that\nsketch to find missing transactions.",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-02-23T10:56:39Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2021-03-23T10:27:32Z"
      },
      "sha": "30c39c1316a7b5c1914654f2a1487309b6e550ac"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "C_kwDOABII59oAKDAwZGYwYWVmZmY5MzhlODQ5YmRhYjUyNzhkNjY1OGQ1YzlkNWQwNjQ",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/00df0aefff938e849bdab5278d6658d5c9d5d064",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/00df0aefff938e849bdab5278d6658d5c9d5d064",
      "tree": {
        "sha": "89a21a4693a601a1b670f17e33b5bc89f0255a13",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/89a21a4693a601a1b670f17e33b5bc89f0255a13"
      },
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "payload": null,
        "signature": null
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/30c39c1316a7b5c1914654f2a1487309b6e550ac",
          "sha": "30c39c1316a7b5c1914654f2a1487309b6e550ac",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/30c39c1316a7b5c1914654f2a1487309b6e550ac"
        }
      ],
      "message": "test: functional test for reqtxrcncl",
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2023-02-23T10:56:40Z"
      },
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2022-11-10T10:18:45Z"
      },
      "sha": "00df0aefff938e849bdab5278d6658d5c9d5d064"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 8590289302,
      "node_id": "HRFPE_lADOABII585TjqCFzwAAAAIABWmW",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8590289302",
      "actor": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-02-23T10:58:19Z"
    },
    {
      "event": "reviewed",
      "id": 1339558296,
      "node_id": "PRR_kwDOABII585P2AmY",
      "url": null,
      "actor": null,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1339558296",
      "submitted_at": "2023-03-14T15:31:27Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "reviewed",
      "id": 1342448815,
      "node_id": "PRR_kwDOABII585QBCSv",
      "url": null,
      "actor": null,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "I found the algorithm to pick fanout peers in commit \"p2p: Initiate reconciliation round\" rather hard to understand.\r\nIt would be helpful to have more documentation in this part of the code and the function descriptions of (`ShouldFanoutTo()` and `GetFanoutTargets()`), especially since this is not covered in the BIP.",
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1342448815",
      "submitted_at": "2023-03-16T15:49:51Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "reviewed",
      "id": 1344306348,
      "node_id": "PRR_kwDOABII585QIHys",
      "url": null,
      "actor": null,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1344306348",
      "submitted_at": "2023-03-16T17:34:08Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "reviewed",
      "id": 1363161761,
      "node_id": "PRR_kwDOABII585RQDKh",
      "url": null,
      "actor": null,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "",
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1363161761",
      "submitted_at": "2023-03-29T13:59:05Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "labeled",
      "id": 8889740944,
      "node_id": "LE_lADOABII585TjqCFzwAAAAIR3q6Q",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/8889740944",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-30T16:43:16Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 1490610285,
      "node_id": "IC_kwDOABII585Y2Oht",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1490610285",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2023-03-30T16:43:17Z",
      "updated_at": "2023-03-30T16:43:17Z",
      "author_association": "MEMBER",
      "body": "<!--cf906140f33d8803c4a75a2196329ecb-->\n🐙 This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#issuecomment-1490610285",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/26283"
    },
    {
      "event": "reviewed",
      "id": 1451435060,
      "node_id": "PRR_kwDOABII585WgyQ0",
      "url": null,
      "actor": null,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1451435060",
      "submitted_at": "2023-05-30T17:12:07Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    },
    {
      "event": "reviewed",
      "id": 1451623963,
      "node_id": "PRR_kwDOABII585WhgYb",
      "url": null,
      "actor": null,
      "commit_id": "30c39c1316a7b5c1914654f2a1487309b6e550ac",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#pullrequestreview-1451623963",
      "submitted_at": "2023-05-30T18:55:21Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998568613",
      "pull_request_review_id": 1146311466,
      "id": 998568613,
      "node_id": "PRRC_kwDOABII5847hPKl",
      "diff_hunk": "@@ -5576,8 +5701,94 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            bool flood_target = m_txreconciliation->ShouldFloodTo(wtxid, pto->GetId());\n+\n+                            // Special treatment for unconfirmed transactions with unconfirmed\n+                            // parents.\n+                            LOCK(m_mempool.cs);\n+                            auto txiter = m_mempool.GetIter(txinfo.tx->GetHash());\n+                            assert(txiter);\n+                            const CTxMemPoolEntry::Parents& parents = (*txiter)->GetMemPoolParentsConst();\n+                            for (const CTxMemPoolEntry& parent : parents) {\n+                                // Two situations are possible here:\n+                                // 1. The parent was fully relayed to the peer earlier.\n+                                // 2. The parent is set for reconciliation and the child is not\n+                                //    in the mempool yet. The child arrives to the mempool and is\n+                                //    flooded. The peer receives the child earlier than the parent.\n+                                // We can differentiate between the two by looking at the recon\n+                                // set: if the set (or the snapshot) contains the parent, the parent\n+                                // is being reconciled (case 2). Then, we add the child to the\n+                                // reconciliation set, so that it doesn't arrive earlier than the\n+                                // parent.\n+                                // If it's the case 1, we proceed as usual by looking at the\n+                                // child's wtxid.\n+                                const uint256 parent_wtxid = parent.GetTx().GetWitnessHash();\n+                                if (m_txreconciliation->CurrentlyReconcilingTx(pto->GetId(), parent_wtxid) ||\n+                                    std::find(txs_to_reconcile.begin(), txs_to_reconcile.end(), parent_wtxid) != txs_to_reconcile.end()) {\n+                                    // Currently reconciling parent tx.\n+                                    // We have the following options to do:\n+                                    // 1. Flood parent+child.\n+                                    // 2. Reconcile parent+child.\n+                                    // 3. Flood parent, reconcile child.\n+                                    // We choose (2) because it has the easiest implementation.\n+                                    // The latency impact is not that bad:\n+                                    // 1. If the parent is in the reocnciliation set, the two",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 297,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "s/reocnciliation set/reconciliation set/g",
      "created_at": "2022-10-18T18:17:12Z",
      "updated_at": "2022-10-18T20:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998568613",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998568613"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5744,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998588937",
      "pull_request_review_id": 1146311466,
      "id": 998588937,
      "node_id": "PRRC_kwDOABII5847hUIJ",
      "diff_hunk": "@@ -5576,8 +5701,94 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            bool flood_target = m_txreconciliation->ShouldFloodTo(wtxid, pto->GetId());\n+\n+                            // Special treatment for unconfirmed transactions with unconfirmed\n+                            // parents.\n+                            LOCK(m_mempool.cs);\n+                            auto txiter = m_mempool.GetIter(txinfo.tx->GetHash());\n+                            assert(txiter);\n+                            const CTxMemPoolEntry::Parents& parents = (*txiter)->GetMemPoolParentsConst();\n+                            for (const CTxMemPoolEntry& parent : parents) {\n+                                // Two situations are possible here:\n+                                // 1. The parent was fully relayed to the peer earlier.\n+                                // 2. The parent is set for reconciliation and the child is not\n+                                //    in the mempool yet. The child arrives to the mempool and is\n+                                //    flooded. The peer receives the child earlier than the parent.\n+                                // We can differentiate between the two by looking at the recon\n+                                // set: if the set (or the snapshot) contains the parent, the parent\n+                                // is being reconciled (case 2). Then, we add the child to the\n+                                // reconciliation set, so that it doesn't arrive earlier than the\n+                                // parent.\n+                                // If it's the case 1, we proceed as usual by looking at the\n+                                // child's wtxid.\n+                                const uint256 parent_wtxid = parent.GetTx().GetWitnessHash();\n+                                if (m_txreconciliation->CurrentlyReconcilingTx(pto->GetId(), parent_wtxid) ||\n+                                    std::find(txs_to_reconcile.begin(), txs_to_reconcile.end(), parent_wtxid) != txs_to_reconcile.end()) {\n+                                    // Currently reconciling parent tx.\n+                                    // We have the following options to do:\n+                                    // 1. Flood parent+child.\n+                                    // 2. Reconcile parent+child.\n+                                    // 3. Flood parent, reconcile child.\n+                                    // We choose (2) because it has the easiest implementation.\n+                                    // The latency impact is not that bad:\n+                                    // 1. If the parent is in the reocnciliation set, the two\n+                                    // transactions will be relayed at the same time. There is\n+                                    // no point relaying the child faster anyway.\n+                                    // 2. If the parent is in the snapshot, the child will\n+                                    // be reconcilied within the next batch. This would\n+                                    // introduce extra latency (even if by wtxid the child\n+                                    // should have been flooded over this link), but this will\n+                                    // be compensated later: if the delay is non-trivial,\n+                                    // for the next nodes this condition won't be triggered (\n+                                    // parent won't be in the reconciliation set).\n+                                    //\n+                                    // In case of the multiple unconfirmed parents, we will\n+                                    // reconcile if at least one of the parents is being\n+                                    // reconciled.\n+                                    //\n+                                    // Note, the transaction still could be flooded if the\n+                                    // reconciliation set is full (see check below). This\n+                                    // is not the general case and is likely caused by the\n+                                    // issues with the peer, and then we're not responsible\n+                                    // that the package can't pass mempool limitations.\n+                                    flood_target = false;\n+                                    break;\n+                                }\n+                            }\n+\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via fan-out.\n+                            const size_t recon_set_size = m_txreconciliation->GetPeerSetSize(pto->GetId());\n+                            if (!flood_target && txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 334,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could be `<=` as `MAX_PEER_TX_ANNOUNCEMENTS` should be the maximum number of elements/transactions we announce to our peers. Note, while only strictly inferior transaction requests are considered L1409 in `net_processing.cpp`, this is different for the processing of `NOTFOUND`, L4793, still in `net_processing.cpp`.",
      "created_at": "2022-10-18T18:41:23Z",
      "updated_at": "2022-10-18T20:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998588937",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998588937"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5781,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998598182",
      "pull_request_review_id": 1146311466,
      "id": 998598182,
      "node_id": "PRRC_kwDOABII5847hWYm",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXRECONCILIATION_H\n+#define BITCOIN_NODE_TXRECONCILIATION_H\n+\n+#include <net.h>\n+#include <sync.h>\n+\n+#include <memory>\n+#include <tuple>\n+\n+/** Whether transaction reconciliation protocol should be enabled by default. */\n+static constexpr bool DEFAULT_TXRECONCILIATION_ENABLE{false};\n+/** Supported transaction reconciliation protocol version */\n+static constexpr uint32_t TXRECONCILIATION_VERSION{1};\n+\n+enum ReconciliationRegisterResult {\n+    NOT_FOUND = 0,\n+    SUCCESS = 1,\n+    PROTOCOL_VIOLATION = 2,\n+};\n+\n+/**\n+ * Transaction reconciliation is a way for nodes to efficiently announce transactions.\n+ * This object keeps track of all txreconciliation-related communications with the peers.\n+ * The high-level protocol is:\n+ * 0.  Txreconciliation protocol handshake.\n+ * 1.  Once we receive a new transaction, add it to the set instead of announcing immediately.\n+ * 2.  At regular intervals, a txreconciliation initiator requests a sketch from a peer, where a\n+ *     sketch is a compressed representation of short form IDs of the transactions in their set.\n+ * 3.  Once the initiator received a sketch from the peer, the initiator computes a local sketch,\n+ *     and combines the two sketches to attempt finding the difference in *sets*.\n+ * 4a. If the difference was not larger than estimated, see SUCCESS below.\n+ * 4b. If the difference was larger than estimated, initial txreconciliation fails. The initiator\n+ *     requests a larger sketch via an extension round (allowed only once).\n+ *     - If extension succeeds (a larger sketch is sufficient), see SUCCESS below.\n+ *     - If extension fails (a larger sketch is insufficient), see FAILURE below.\n+ *\n+ * SUCCESS. The initiator knows full symmetrical difference and can request what the initiator is\n+ *          missing and announce to the peer what the peer is missing.\n+ *\n+ * FAILURE. The initiator notifies the peer about the failure and announces all transactions from\n+ *          the corresponding set. Once the peer received the failure notification, the peer\n+ *          announces all transactions from their set.\n+\n+ * This is a modification of the Erlay protocol (https://arxiv.org/abs/1905.10518) with two\n+ * changes (sketch extensions instead of bisections, and an extra INV exchange round), both\n+ * are motivated in BIP-330.\n+ */\n+class TxReconciliationTracker\n+{\n+private:\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    explicit TxReconciliationTracker(uint32_t recon_version);\n+    ~TxReconciliationTracker();\n+\n+    /**\n+     * Step 0. Generates initial part of the state (salt) required to reconcile txs with the peer.\n+     * The salt is used for short ID computation required for txreconciliation.\n+     * The function returns the salt.\n+     * A peer can't participate in future txreconciliations without this call.\n+     * This function must be called only once per peer.\n+     */\n+    uint64_t PreRegisterPeer(NodeId peer_id);\n+\n+    /**\n+     * Step 0. Once the peer agreed to reconcile txs with us, generate the state required to track\n+     * ongoing reconciliations. Must be called only after pre-registering the peer and only once.\n+     */\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version, uint64_t remote_salt);\n+\n+    /**\n+     * Step 1. Add new transactions we want to announce to the peer to the local reconciliation set\n+     * of the peer, so that those transactions will be reconciled later.\n+     */\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile);\n+\n+    /**\n+     * Before Step 2, we might want to remove a wtxid from the reconciliation set, for example if\n+     * the peer just announced the transaction to us.\n+     */\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove);\n+\n+    /**\n+     * Step 2. If a it's time to request a reconciliation from the peer, this function will return\n+     * the details of our local state, which should be communicated to the peer so that they better\n+     * know what we need:\n+     * - size of our reconciliation set for the peer\n+     * - our q-coefficient with the peer, formatted to be transmitted as integer value\n+     * If the peer was not previously registered for reconciliations, returns nullopt.\n+     */\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id);\n+\n+    /**\n+     * Returns the size of the reconciliation set we have locally for the given peer.\n+     * If the peer was not previously registered for reconciliations, returns nullopt.\n+     */\n+    size_t GetPeerSetSize(NodeId peer_id) const;\n+\n+    /**\n+     * Attempts to forget txreconciliation-related state of the peer (if we previously stored any).\n+     * After this, we won't be able to reconcile transactions with the peer.\n+     */\n+    void ForgetPeer(NodeId peer_id);\n+\n+    /**\n+     * Check if a peer is registered to reconcile transactions with us.\n+     */\n+    bool IsPeerRegistered(NodeId peer_id) const;\n+\n+    /**\n+     * Returns whether for the given call the peer is chosen as a low-fanout destination.\n+     */\n+    bool ShouldFloodTo(uint256 wtxid, NodeId peer_id) const;\n+\n+    /**\n+     * Check whether a particular transaction is being currently reconciled with a given peer.\n+     */\n+    bool CurrentlyReconcilingTx(NodeId peer_id, const uint256 wtxid) const;",
      "path": "src/node/txreconciliation.h",
      "position": null,
      "original_position": 125,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could be called `IsAlreadyInPeerSet` or something more speaking than transaction is already in peer local set but not announced yet. ",
      "created_at": "2022-10-18T18:52:19Z",
      "updated_at": "2022-10-18T20:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998598182",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998598182"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 125,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998610903",
      "pull_request_review_id": 1146311466,
      "id": 998610903,
      "node_id": "PRRC_kwDOABII5847hZfX",
      "diff_hunk": "@@ -5611,11 +5822,31 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             tx_relay->m_tx_inventory_known_filter.insert(txid);\n                         }\n                     }\n+\n+                    // Populating local reconciliation set.\n+                    if (txs_to_reconcile.size() != 0) {\n+                        m_txreconciliation->AddToReconSet(pto->GetId(), txs_to_reconcile);\n+                    }\n                 }\n         }\n         if (!vInv.empty())\n             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n+        //\n+        // Message: reconciliation request\n+        //\n+        {\n+            if (!m_chainman.ActiveChainstate().IsInitialBlockDownload()) {",
      "path": "src/net_processing.cpp",
      "position": 173,
      "original_position": 366,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Note, current inv-based transaction announcement (L5812) isn't gated on IBD being over though I agree it makes sense to save bandwidth as the node is unlikely to be able to validate most of the transactions received for inaccuracy of its local UTXO set. ",
      "created_at": "2022-10-18T19:07:34Z",
      "updated_at": "2022-10-18T20:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998610903",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998610903"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 5802,
      "original_line": 5802,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998613472",
      "pull_request_review_id": 1146311466,
      "id": 998613472,
      "node_id": "PRRC_kwDOABII5847haHg",
      "diff_hunk": "@@ -0,0 +1,128 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXRECONCILIATION_H\n+#define BITCOIN_NODE_TXRECONCILIATION_H\n+\n+#include <net.h>\n+#include <sync.h>\n+\n+#include <memory>\n+#include <tuple>\n+\n+/** Whether transaction reconciliation protocol should be enabled by default. */\n+static constexpr bool DEFAULT_TXRECONCILIATION_ENABLE{false};\n+/** Supported transaction reconciliation protocol version */\n+static constexpr uint32_t TXRECONCILIATION_VERSION{1};\n+\n+enum ReconciliationRegisterResult {\n+    NOT_FOUND = 0,\n+    SUCCESS = 1,\n+    PROTOCOL_VIOLATION = 2,\n+};\n+\n+/**\n+ * Transaction reconciliation is a way for nodes to efficiently announce transactions.\n+ * This object keeps track of all txreconciliation-related communications with the peers.\n+ * The high-level protocol is:\n+ * 0.  Txreconciliation protocol handshake.\n+ * 1.  Once we receive a new transaction, add it to the set instead of announcing immediately.\n+ * 2.  At regular intervals, a txreconciliation initiator requests a sketch from a peer, where a\n+ *     sketch is a compressed representation of short form IDs of the transactions in their set.\n+ * 3.  Once the initiator received a sketch from the peer, the initiator computes a local sketch,\n+ *     and combines the two sketches to attempt finding the difference in *sets*.\n+ * 4a. If the difference was not larger than estimated, see SUCCESS below.\n+ * 4b. If the difference was larger than estimated, initial txreconciliation fails. The initiator\n+ *     requests a larger sketch via an extension round (allowed only once).\n+ *     - If extension succeeds (a larger sketch is sufficient), see SUCCESS below.\n+ *     - If extension fails (a larger sketch is insufficient), see FAILURE below.\n+ *\n+ * SUCCESS. The initiator knows full symmetrical difference and can request what the initiator is\n+ *          missing and announce to the peer what the peer is missing.\n+ *\n+ * FAILURE. The initiator notifies the peer about the failure and announces all transactions from\n+ *          the corresponding set. Once the peer received the failure notification, the peer\n+ *          announces all transactions from their set.\n+\n+ * This is a modification of the Erlay protocol (https://arxiv.org/abs/1905.10518) with two\n+ * changes (sketch extensions instead of bisections, and an extra INV exchange round), both\n+ * are motivated in BIP-330.\n+ */\n+class TxReconciliationTracker\n+{\n+private:\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    explicit TxReconciliationTracker(uint32_t recon_version);\n+    ~TxReconciliationTracker();\n+\n+    /**\n+     * Step 0. Generates initial part of the state (salt) required to reconcile txs with the peer.\n+     * The salt is used for short ID computation required for txreconciliation.\n+     * The function returns the salt.\n+     * A peer can't participate in future txreconciliations without this call.\n+     * This function must be called only once per peer.\n+     */\n+    uint64_t PreRegisterPeer(NodeId peer_id);\n+\n+    /**\n+     * Step 0. Once the peer agreed to reconcile txs with us, generate the state required to track\n+     * ongoing reconciliations. Must be called only after pre-registering the peer and only once.\n+     */\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version, uint64_t remote_salt);\n+\n+    /**\n+     * Step 1. Add new transactions we want to announce to the peer to the local reconciliation set\n+     * of the peer, so that those transactions will be reconciled later.\n+     */\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile);\n+\n+    /**\n+     * Before Step 2, we might want to remove a wtxid from the reconciliation set, for example if\n+     * the peer just announced the transaction to us.\n+     */\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove);\n+\n+    /**\n+     * Step 2. If a it's time to request a reconciliation from the peer, this function will return",
      "path": "src/node/txreconciliation.h",
      "position": null,
      "original_position": 91,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "s/if a it's time/if it's time/g",
      "created_at": "2022-10-18T19:10:45Z",
      "updated_at": "2022-10-18T20:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998613472",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998613472"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 91,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998619645",
      "pull_request_review_id": 1146311466,
      "id": 998619645,
      "node_id": "PRRC_kwDOABII5847hbn9",
      "diff_hunk": "@@ -5611,11 +5822,31 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             tx_relay->m_tx_inventory_known_filter.insert(txid);\n                         }\n                     }\n+\n+                    // Populating local reconciliation set.\n+                    if (txs_to_reconcile.size() != 0) {\n+                        m_txreconciliation->AddToReconSet(pto->GetId(), txs_to_reconcile);\n+                    }\n                 }\n         }\n         if (!vInv.empty())\n             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n+        //\n+        // Message: reconciliation request\n+        //\n+        {\n+            if (!m_chainman.ActiveChainstate().IsInitialBlockDownload()) {\n+                if (m_txreconciliation && m_txreconciliation->IsPeerRegistered(pto->GetId())) {\n+                    auto reconciliation_request_data = m_txreconciliation->MaybeRequestReconciliation(pto->GetId());",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 368,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`reconciliation_request_data` could be called `reconciliation_request_parameters` to dissociate clearly we're sending reconciliation config info and not the set itself.",
      "created_at": "2022-10-18T19:18:32Z",
      "updated_at": "2022-10-18T20:01:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998619645",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998619645"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5841,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998628718",
      "pull_request_review_id": 1146311466,
      "id": 998628718,
      "node_id": "PRRC_kwDOABII5847hd1u",
      "diff_hunk": "@@ -143,17 +146,22 @@ static constexpr auto AVG_ADDRESS_BROADCAST_INTERVAL{30s};\n /** Delay between rotating the peers we relay a particular address to */\n static constexpr auto ROTATE_ADDR_RELAY_DEST_INTERVAL{24h};\n /** Average delay between trickled inventory transmissions for inbound peers.\n- *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this. */\n+ *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this.\n+ *  For reconciliation peers the delay is different. */\n static constexpr auto INBOUND_INVENTORY_BROADCAST_INTERVAL{5s};\n+static constexpr auto INBOUND_INVENTORY_BROADCAST_INTERVAL_RECON{2s};\n /** Average delay between trickled inventory transmissions for outbound peers.\n  *  Use a smaller delay as there is less privacy concern for them.\n- *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this. */\n+ *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this.\n+ *  For reconciliation peers the delay is different. */\n static constexpr auto OUTBOUND_INVENTORY_BROADCAST_INTERVAL{2s};\n+static constexpr auto OUTBOUND_INVENTORY_BROADCAST_INTERVAL_RECON{1s};\n /** Maximum rate of inventory items to send per second.\n  *  Limits the impact of low-fee transaction floods. */\n static constexpr unsigned int INVENTORY_BROADCAST_PER_SECOND = 7;\n /** Maximum number of inventory items to send per transmission. */\n-static constexpr unsigned int INVENTORY_BROADCAST_MAX = INVENTORY_BROADCAST_PER_SECOND * count_seconds(INBOUND_INVENTORY_BROADCAST_INTERVAL);\n+static constexpr unsigned int INVENTORY_BROADCAST_MAX = INVENTORY_BROADCAST_PER_SECOND *\n+    count_seconds(std::max(INBOUND_INVENTORY_BROADCAST_INTERVAL, INBOUND_INVENTORY_BROADCAST_INTERVAL_RECON));",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 41,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not sure what you aimed to achieve here with the `std::max` between `INBOUND_INVENTORY_BROADCAST_INTERVAL` and `INBOUND_INVENTORY_BROADCAST_INTERVAL_RECON` as the former is always superior to the latter. Maybe could be rather a `static_assert` to enforce the order at compilation time in case of future changes.  ",
      "created_at": "2022-10-18T19:29:51Z",
      "updated_at": "2022-10-18T20:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998628718",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998628718"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 164,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998629668",
      "pull_request_review_id": 1146311466,
      "id": 998629668,
      "node_id": "PRRC_kwDOABII5847heEk",
      "diff_hunk": "@@ -5488,12 +5589,35 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                 LOCK(tx_relay->m_tx_inventory_mutex);\n                 // Check whether periodic sends should happen\n                 bool fSendTrickle = pto->HasPermission(NetPermissionFlags::NoBan);\n+                const bool supports_recon = m_txreconciliation && m_txreconciliation->IsPeerRegistered(pto->GetId());\n+\n                 if (tx_relay->m_next_inv_send_time < current_time) {\n                     fSendTrickle = true;\n                     if (pto->IsInboundConn()) {\n-                        tx_relay->m_next_inv_send_time = NextInvToInbounds(current_time, INBOUND_INVENTORY_BROADCAST_INTERVAL);\n+                        if (supports_recon) {\n+                            // Use shorter intervals for reconciliation peers because we use\n+                            // low-fanout, and 1) we need to make faster; 2) we won't get much",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 217,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If you can develop the comment here why \"we need to make faster\" or point towards another code comment or BIP section where it's explained.",
      "created_at": "2022-10-18T19:31:04Z",
      "updated_at": "2022-10-18T20:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998629668",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998629668"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5599,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998633914",
      "pull_request_review_id": 1146311466,
      "id": 998633914,
      "node_id": "PRRC_kwDOABII5847hfG6",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 25,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could add comment if the rational behind those values selection is specified in the BIP, paper or other research.",
      "created_at": "2022-10-18T19:36:25Z",
      "updated_at": "2022-10-18T20:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998633914",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998633914"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 25,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998640600",
      "pull_request_review_id": 1146311466,
      "id": 998640600,
      "node_id": "PRRC_kwDOABII5847hgvY",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.",
      "path": "src/node/txreconciliation.cpp",
      "position": 33,
      "original_position": 36,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Curious, what we care about a low transaction relay latency ? Like I would say lower latency makes it a) harder to observe original transaction broadcast by deanonymization attacker b) disincentive transaction issuers front-running the standard tx-relay rules to place their transactions first in the mempools in case of congestion and c) for instant/0confs flows improve UX, do we have more properties ?",
      "created_at": "2022-10-18T19:44:50Z",
      "updated_at": "2022-10-18T20:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998640600",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998640600"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 39,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998653688",
      "pull_request_review_id": 1146311466,
      "id": 998653688,
      "node_id": "PRRC_kwDOABII5847hj74",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.",
      "path": "src/node/txreconciliation.cpp",
      "position": 95,
      "original_position": 136,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\"which are unlikely to game this timer in a serious way\", though is there a timeout in the rest of the patchset to evict lazy/buggy outbound peers which would stuck the reconciliation, making us stale on `Phase::INIT_REQUESTED` and which would prevent `MaybeRequestReconciliation()` to move forward due to the check L258 ?",
      "created_at": "2022-10-18T20:00:37Z",
      "updated_at": "2022-10-18T20:01:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998653688",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998653688"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 139,
      "original_line": 139,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005384672",
      "pull_request_review_id": 1156088702,
      "id": 1005384672,
      "node_id": "PRRC_kwDOABII58477PPg",
      "diff_hunk": "@@ -5611,11 +5822,31 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             tx_relay->m_tx_inventory_known_filter.insert(txid);\n                         }\n                     }\n+\n+                    // Populating local reconciliation set.\n+                    if (txs_to_reconcile.size() != 0) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 354,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "1d9b1f7d4bbf5ca5a8f43180b994b7b2fc03447f\r\n```suggestion\r\n                    if (!txs_to_reconcile.empty()) {\r\n```",
      "created_at": "2022-10-26T08:36:31Z",
      "updated_at": "2022-10-26T09:24:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005384672",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005384672"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5827,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005385195",
      "pull_request_review_id": 1156088702,
      "id": 1005385195,
      "node_id": "PRRC_kwDOABII58477PXr",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 43,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "5070c97459282346cdcff7af08914c702462fe0d\r\n```suggestion\r\nenum class Phase {\r\n```",
      "created_at": "2022-10-26T08:36:58Z",
      "updated_at": "2022-10-26T09:24:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005385195",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005385195"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 43,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005386331",
      "pull_request_review_id": 1156088702,
      "id": 1005386331,
      "node_id": "PRRC_kwDOABII58477Ppb",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.\n+        size_t we_initiate_to_count = std::count_if(m_states.begin(), m_states.end(),\n+            [](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 139,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "7cffb4cc0211b0494a7563d9a80a67633fa61255\r\n```suggestion\r\n                const auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);\r\n```",
      "created_at": "2022-10-26T08:38:01Z",
      "updated_at": "2022-10-26T09:24:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005386331",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005386331"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 139,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005387197",
      "pull_request_review_id": 1156088702,
      "id": 1005387197,
      "node_id": "PRRC_kwDOABII58477P29",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.\n+        size_t we_initiate_to_count = std::count_if(m_states.begin(), m_states.end(),\n+            [](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);\n+                if (cur_state) return cur_state->m_we_initiate;\n+                return false;\n+            });\n+        m_next_recon_request = now + (RECON_REQUEST_INTERVAL / we_initiate_to_count);\n+    }\n+\n+    public:\n+    explicit Impl(uint32_t recon_version) : m_recon_version(recon_version) {}\n+\n+    uint64_t PreRegisterPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        // We do not support txreconciliation salt/version updates.\n+        assert(m_states.find(peer_id) == m_states.end());\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Pre-register peer=%d\\n\", peer_id);\n+        const uint64_t local_salt{GetRand(UINT64_MAX)};\n+\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        Assert(m_states.emplace(peer_id, local_salt).second);\n+        return local_salt;\n+    }\n+\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return PROTOCOL_VIOLATION;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Register peer=%d with the following params: \" /* Continued */\n+                                                                    \"we_initiate=%i, they_initiate=%i.\\n\",\n+                      peer_id, we_initiate, they_initiate);\n+\n+        const uint256 full_salt{ComputeSalt(*local_salt, remote_salt)};\n+        recon_state->second = TxReconciliationState(we_initiate, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        return SUCCESS;\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_queue.size() > 0) {",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 249,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        if (!m_queue.empty()) {\r\n```",
      "created_at": "2022-10-26T08:38:49Z",
      "updated_at": "2022-10-26T09:24:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005387197",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005387197"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 249,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005388347",
      "pull_request_review_id": 1156088702,
      "id": 1005388347,
      "node_id": "PRRC_kwDOABII58477QI7",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.\n+        size_t we_initiate_to_count = std::count_if(m_states.begin(), m_states.end(),\n+            [](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);\n+                if (cur_state) return cur_state->m_we_initiate;\n+                return false;\n+            });\n+        m_next_recon_request = now + (RECON_REQUEST_INTERVAL / we_initiate_to_count);\n+    }\n+\n+    public:\n+    explicit Impl(uint32_t recon_version) : m_recon_version(recon_version) {}\n+\n+    uint64_t PreRegisterPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        // We do not support txreconciliation salt/version updates.\n+        assert(m_states.find(peer_id) == m_states.end());\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Pre-register peer=%d\\n\", peer_id);\n+        const uint64_t local_salt{GetRand(UINT64_MAX)};\n+\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        Assert(m_states.emplace(peer_id, local_salt).second);\n+        return local_salt;\n+    }\n+\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return PROTOCOL_VIOLATION;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Register peer=%d with the following params: \" /* Continued */\n+                                                                    \"we_initiate=%i, they_initiate=%i.\\n\",\n+                      peer_id, we_initiate, they_initiate);\n+\n+        const uint256 full_salt{ComputeSalt(*local_salt, remote_salt)};\n+        recon_state->second = TxReconciliationState(we_initiate, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        return SUCCESS;\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_queue.size() > 0) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+                recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state.m_local_set.size();\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                    \"local_set_size=%i\\n\", peer_id, local_set_size);\n+\n+                // In future, RECON_Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, RECON_Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n+    void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n+            LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n+        }\n+    }\n+\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        return (recon_state != m_states.end() &&\n+                std::holds_alternative<TxReconciliationState>(recon_state->second));\n+    }\n+\n+    bool ShouldFloodTo(uint256 wtxid, NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 305,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "4cb08ebcd6190535bc2300e35557dd8b730b8951\r\n```suggestion\r\n    bool ShouldFloodTo(const uint256& wtxid, NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\r\n```",
      "created_at": "2022-10-26T08:39:49Z",
      "updated_at": "2022-10-26T09:24:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005388347",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005388347"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 305,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005389029",
      "pull_request_review_id": 1156088702,
      "id": 1005389029,
      "node_id": "PRRC_kwDOABII58477QTl",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.\n+        size_t we_initiate_to_count = std::count_if(m_states.begin(), m_states.end(),\n+            [](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);\n+                if (cur_state) return cur_state->m_we_initiate;\n+                return false;\n+            });\n+        m_next_recon_request = now + (RECON_REQUEST_INTERVAL / we_initiate_to_count);\n+    }\n+\n+    public:\n+    explicit Impl(uint32_t recon_version) : m_recon_version(recon_version) {}\n+\n+    uint64_t PreRegisterPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        // We do not support txreconciliation salt/version updates.\n+        assert(m_states.find(peer_id) == m_states.end());\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Pre-register peer=%d\\n\", peer_id);\n+        const uint64_t local_salt{GetRand(UINT64_MAX)};\n+\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        Assert(m_states.emplace(peer_id, local_salt).second);\n+        return local_salt;\n+    }\n+\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return PROTOCOL_VIOLATION;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Register peer=%d with the following params: \" /* Continued */\n+                                                                    \"we_initiate=%i, they_initiate=%i.\\n\",\n+                      peer_id, we_initiate, they_initiate);\n+\n+        const uint256 full_salt{ComputeSalt(*local_salt, remote_salt)};\n+        recon_state->second = TxReconciliationState(we_initiate, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        return SUCCESS;\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_queue.size() > 0) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+                recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state.m_local_set.size();\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                    \"local_set_size=%i\\n\", peer_id, local_set_size);\n+\n+                // In future, RECON_Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, RECON_Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n+    void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n+            LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n+        }\n+    }\n+\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        return (recon_state != m_states.end() &&\n+                std::holds_alternative<TxReconciliationState>(recon_state->second));\n+    }\n+\n+    bool ShouldFloodTo(uint256 wtxid, NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the similar reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+            [&eligible_peers, we_initiate](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                const auto cur_state = std::get<TxReconciliationState>(indexed_state.second);",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 320,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "4cb08ebcd6190535bc2300e35557dd8b730b8951\r\n```suggestion\r\n                const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\r\n```",
      "created_at": "2022-10-26T08:40:23Z",
      "updated_at": "2022-10-26T09:24:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005389029",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005389029"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 320,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005389951",
      "pull_request_review_id": 1156088702,
      "id": 1005389951,
      "node_id": "PRRC_kwDOABII58477Qh_",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.\n+        size_t we_initiate_to_count = std::count_if(m_states.begin(), m_states.end(),\n+            [](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);\n+                if (cur_state) return cur_state->m_we_initiate;\n+                return false;\n+            });\n+        m_next_recon_request = now + (RECON_REQUEST_INTERVAL / we_initiate_to_count);\n+    }\n+\n+    public:\n+    explicit Impl(uint32_t recon_version) : m_recon_version(recon_version) {}\n+\n+    uint64_t PreRegisterPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        // We do not support txreconciliation salt/version updates.\n+        assert(m_states.find(peer_id) == m_states.end());\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Pre-register peer=%d\\n\", peer_id);\n+        const uint64_t local_salt{GetRand(UINT64_MAX)};\n+\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        Assert(m_states.emplace(peer_id, local_salt).second);\n+        return local_salt;\n+    }\n+\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return PROTOCOL_VIOLATION;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Register peer=%d with the following params: \" /* Continued */\n+                                                                    \"we_initiate=%i, they_initiate=%i.\\n\",\n+                      peer_id, we_initiate, they_initiate);\n+\n+        const uint256 full_salt{ComputeSalt(*local_salt, remote_salt)};\n+        recon_state->second = TxReconciliationState(we_initiate, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        return SUCCESS;\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_queue.size() > 0) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+                recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state.m_local_set.size();\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                    \"local_set_size=%i\\n\", peer_id, local_set_size);\n+\n+                // In future, RECON_Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, RECON_Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n+    void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n+            LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n+        }\n+    }\n+\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        return (recon_state != m_states.end() &&\n+                std::holds_alternative<TxReconciliationState>(recon_state->second));\n+    }\n+\n+    bool ShouldFloodTo(uint256 wtxid, NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the similar reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+            [&eligible_peers, we_initiate](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 319,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "4cb08ebcd6190535bc2300e35557dd8b730b8951\r\n```suggestion\r\n            [&eligible_peers, we_initiate](auto indexed_state) {\r\n```",
      "created_at": "2022-10-26T08:41:20Z",
      "updated_at": "2022-10-26T09:24:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005389951",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005389951"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 319,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005390504",
      "pull_request_review_id": 1156088702,
      "id": 1005390504,
      "node_id": "PRRC_kwDOABII58477Qqo",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.\n+        size_t we_initiate_to_count = std::count_if(m_states.begin(), m_states.end(),\n+            [](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);\n+                if (cur_state) return cur_state->m_we_initiate;\n+                return false;\n+            });\n+        m_next_recon_request = now + (RECON_REQUEST_INTERVAL / we_initiate_to_count);\n+    }\n+\n+    public:\n+    explicit Impl(uint32_t recon_version) : m_recon_version(recon_version) {}\n+\n+    uint64_t PreRegisterPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        // We do not support txreconciliation salt/version updates.\n+        assert(m_states.find(peer_id) == m_states.end());\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Pre-register peer=%d\\n\", peer_id);\n+        const uint64_t local_salt{GetRand(UINT64_MAX)};\n+\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        Assert(m_states.emplace(peer_id, local_salt).second);\n+        return local_salt;\n+    }\n+\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return PROTOCOL_VIOLATION;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Register peer=%d with the following params: \" /* Continued */\n+                                                                    \"we_initiate=%i, they_initiate=%i.\\n\",\n+                      peer_id, we_initiate, they_initiate);\n+\n+        const uint256 full_salt{ComputeSalt(*local_salt, remote_salt)};\n+        recon_state->second = TxReconciliationState(we_initiate, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        return SUCCESS;\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_queue.size() > 0) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+                recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state.m_local_set.size();\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                    \"local_set_size=%i\\n\", peer_id, local_set_size);\n+\n+                // In future, RECON_Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, RECON_Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n+    void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n+            LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n+        }\n+    }\n+\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        return (recon_state != m_states.end() &&\n+                std::holds_alternative<TxReconciliationState>(recon_state->second));\n+    }\n+\n+    bool ShouldFloodTo(uint256 wtxid, NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the similar reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+            [&eligible_peers, we_initiate](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                const auto cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+            }\n+        );\n+\n+        // TODO: there should be a cleaner way to do this.\n+        size_t flood_index_modulo;\n+        if (we_initiate) {\n+            flood_index_modulo = 1.0 / OUTBOUND_FANOUT_DESTINATIONS_FRACTION;\n+        } else {\n+            flood_index_modulo = 1.0 / INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+        }\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        assert(it != eligible_peers.end());\n+\n+        const size_t peer_index = it - eligible_peers.begin();\n+        return txidHasher(wtxid) % flood_index_modulo == peer_index % flood_index_modulo;\n+    }\n+\n+    bool CurrentlyReconcilingTx(NodeId peer_id, const uint256 wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 340,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "1d9b1f7d4bbf5ca5a8f43180b994b7b2fc03447f: there are other instances where wtxid is not passed by ref\r\n```suggestion\r\n    bool CurrentlyReconcilingTx(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\r\n```",
      "created_at": "2022-10-26T08:41:50Z",
      "updated_at": "2022-10-26T09:24:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005390504",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005390504"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 340,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005414595",
      "pull_request_review_id": 1156088702,
      "id": 1005414595,
      "node_id": "PRRC_kwDOABII58477WjD",
      "diff_hunk": "@@ -55,6 +93,50 @@ class TxReconciliationTracker::Impl\n         return local_salt;\n     }\n \n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 100,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "c60235bacceecbe7f83bb70f761a0adb3e5bf65b",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c60235bacceecbe7f83bb70f761a0adb3e5bf65b\r\nnit but I think it's easier to read\r\n```suggestion\r\n        assert(!they_initiate || !we_initiate));\r\n```",
      "created_at": "2022-10-26T09:02:41Z",
      "updated_at": "2022-10-26T09:24:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005414595",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005414595"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005415156",
      "pull_request_review_id": 1156088702,
      "id": 1005415156,
      "node_id": "PRRC_kwDOABII58477Wr0",
      "diff_hunk": "@@ -55,6 +93,50 @@ class TxReconciliationTracker::Impl\n         return local_salt;\n     }\n \n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return PROTOCOL_VIOLATION;",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 103,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "c60235bacceecbe7f83bb70f761a0adb3e5bf65b",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "c60235bacceecbe7f83bb70f761a0adb3e5bf65b\r\nnit but I think it's easier to read\r\n```suggestion\r\n        if (!they_initiate && !we_initiate) return PROTOCOL_VIOLATION;\r\n```",
      "created_at": "2022-10-26T09:03:01Z",
      "updated_at": "2022-10-26T09:24:58Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005415156",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005415156"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 129,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013791316",
      "pull_request_review_id": 1168195546,
      "id": 1013791316,
      "node_id": "PRRC_kwDOABII5848bTpU",
      "diff_hunk": "@@ -5576,8 +5701,94 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            bool flood_target = m_txreconciliation->ShouldFloodTo(wtxid, pto->GetId());\n+\n+                            // Special treatment for unconfirmed transactions with unconfirmed\n+                            // parents.\n+                            LOCK(m_mempool.cs);\n+                            auto txiter = m_mempool.GetIter(txinfo.tx->GetHash());\n+                            assert(txiter);\n+                            const CTxMemPoolEntry::Parents& parents = (*txiter)->GetMemPoolParentsConst();\n+                            for (const CTxMemPoolEntry& parent : parents) {\n+                                // Two situations are possible here:\n+                                // 1. The parent was fully relayed to the peer earlier.\n+                                // 2. The parent is set for reconciliation and the child is not\n+                                //    in the mempool yet. The child arrives to the mempool and is\n+                                //    flooded. The peer receives the child earlier than the parent.\n+                                // We can differentiate between the two by looking at the recon\n+                                // set: if the set (or the snapshot) contains the parent, the parent\n+                                // is being reconciled (case 2). Then, we add the child to the\n+                                // reconciliation set, so that it doesn't arrive earlier than the\n+                                // parent.\n+                                // If it's the case 1, we proceed as usual by looking at the\n+                                // child's wtxid.\n+                                const uint256 parent_wtxid = parent.GetTx().GetWitnessHash();\n+                                if (m_txreconciliation->CurrentlyReconcilingTx(pto->GetId(), parent_wtxid) ||\n+                                    std::find(txs_to_reconcile.begin(), txs_to_reconcile.end(), parent_wtxid) != txs_to_reconcile.end()) {\n+                                    // Currently reconciling parent tx.\n+                                    // We have the following options to do:\n+                                    // 1. Flood parent+child.\n+                                    // 2. Reconcile parent+child.\n+                                    // 3. Flood parent, reconcile child.\n+                                    // We choose (2) because it has the easiest implementation.\n+                                    // The latency impact is not that bad:\n+                                    // 1. If the parent is in the reocnciliation set, the two\n+                                    // transactions will be relayed at the same time. There is\n+                                    // no point relaying the child faster anyway.\n+                                    // 2. If the parent is in the snapshot, the child will\n+                                    // be reconcilied within the next batch. This would\n+                                    // introduce extra latency (even if by wtxid the child\n+                                    // should have been flooded over this link), but this will\n+                                    // be compensated later: if the delay is non-trivial,\n+                                    // for the next nodes this condition won't be triggered (\n+                                    // parent won't be in the reconciliation set).\n+                                    //\n+                                    // In case of the multiple unconfirmed parents, we will\n+                                    // reconcile if at least one of the parents is being\n+                                    // reconciled.\n+                                    //\n+                                    // Note, the transaction still could be flooded if the\n+                                    // reconciliation set is full (see check below). This\n+                                    // is not the general case and is likely caused by the\n+                                    // issues with the peer, and then we're not responsible\n+                                    // that the package can't pass mempool limitations.\n+                                    flood_target = false;\n+                                    break;\n+                                }\n+                            }\n+\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via fan-out.\n+                            const size_t recon_set_size = m_txreconciliation->GetPeerSetSize(pto->GetId());\n+                            if (!flood_target && txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 334,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": 998588937,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Applied `<=`, but I don't get the second sentence :(",
      "created_at": "2022-11-04T09:26:34Z",
      "updated_at": "2022-11-04T09:26:34Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1013791316",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013791316"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5781,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013848477",
      "pull_request_review_id": 1168276941,
      "id": 1013848477,
      "node_id": "PRRC_kwDOABII5848bhmd",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.",
      "path": "src/node/txreconciliation.cpp",
      "position": 33,
      "original_position": 36,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": 998640600,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I thought it's kinda obvious for 0conf experience, yes. Not even accepting payment, but at least seeing it in the network... Not sure what to include in the codebase.",
      "created_at": "2022-11-04T10:26:35Z",
      "updated_at": "2022-11-04T10:26:36Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1013848477",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013848477"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 39,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013850793",
      "pull_request_review_id": 1168280370,
      "id": 1013850793,
      "node_id": "PRRC_kwDOABII5848biKp",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.",
      "path": "src/node/txreconciliation.cpp",
      "position": 95,
      "original_position": 136,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": 998653688,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think `Phase::INIT_REQUESTED` is somehow related to being stuck... if one peer stays in that state, it doesn't prevent us from requesting recon from other peers. Only will delay by `m_next_recon_request` once?",
      "created_at": "2022-11-04T10:29:12Z",
      "updated_at": "2022-11-04T10:29:12Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1013850793",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013850793"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 139,
      "original_line": 139,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013981776",
      "pull_request_review_id": 1168466518,
      "id": 1013981776,
      "node_id": "PRRC_kwDOABII5848cCJQ",
      "diff_hunk": "@@ -55,6 +93,50 @@ class TxReconciliationTracker::Impl\n         return local_salt;\n     }\n \n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 100,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "c60235bacceecbe7f83bb70f761a0adb3e5bf65b",
      "in_reply_to_id": 1005414595,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not sure it's any better",
      "created_at": "2022-11-04T12:46:02Z",
      "updated_at": "2022-11-04T12:46:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1013981776",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013981776"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 126,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1020190507",
      "pull_request_review_id": 1177296531,
      "id": 1020190507,
      "node_id": "PRRC_kwDOABII5848zt8r",
      "diff_hunk": "@@ -154,6 +297,77 @@ class TxReconciliationTracker::Impl\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = floor(flood_targets);\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:\n+        // 1. Every transaction should be assigned to *some* peer, at least assuming a static list\n+        // of peers. For this function that means no randomness.\n+        // 2. The choice doesn't leak the internal order of peers (m_states) to the external\n+        // observer. This is achieved by hashing the txid.\n+        //\n+        // Say, we have 2.4 targets out of 20 inbound peers, the wtixd hash is 217, and our peer_id\n+        // holds peer_position in the list of inbound peers.\n+        // We will compute 217 % 20 = 17, as if it was a \"starting_point\", from which we see if\n+        // the target is within a range of 2.4. It's impossible for the range to exceed\n+        // the bounds because of how we computed them in the first place.\n+        // For that, we need to check the following:\n+        // 1. If 17 <= peer_position < 19, return true.\n+        // 2. If peer_position = 19, roll the dice with the remaining probability (0.4).\n+        // 3. Otherwise, return false.\n+        const size_t starting_point = txidHasher(wtxid) % eligible_peers.size();\n+        if (starting_point <= peer_position && peer_position < starting_point + round_down_flood_targets) {\n+            return true;\n+        } else if (peer_position == starting_point + round_down_flood_targets) {\n+            return rand() < (flood_targets - round_down_flood_targets) * RAND_MAX;",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 341,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "913c2cbcea58696237760c51f55acee9d91eb186",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Using PRNGs is usually discouraged, is this safe here?",
      "created_at": "2022-11-11T12:48:21Z",
      "updated_at": "2022-11-11T12:51:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1020190507",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1020190507"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 360,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1020204771",
      "pull_request_review_id": 1177318100,
      "id": 1020204771,
      "node_id": "PRRC_kwDOABII5848zxbj",
      "diff_hunk": "@@ -154,6 +297,77 @@ class TxReconciliationTracker::Impl\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = floor(flood_targets);\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:\n+        // 1. Every transaction should be assigned to *some* peer, at least assuming a static list\n+        // of peers. For this function that means no randomness.\n+        // 2. The choice doesn't leak the internal order of peers (m_states) to the external\n+        // observer. This is achieved by hashing the txid.\n+        //\n+        // Say, we have 2.4 targets out of 20 inbound peers, the wtixd hash is 217, and our peer_id\n+        // holds peer_position in the list of inbound peers.\n+        // We will compute 217 % 20 = 17, as if it was a \"starting_point\", from which we see if\n+        // the target is within a range of 2.4. It's impossible for the range to exceed\n+        // the bounds because of how we computed them in the first place.\n+        // For that, we need to check the following:\n+        // 1. If 17 <= peer_position < 19, return true.\n+        // 2. If peer_position = 19, roll the dice with the remaining probability (0.4).\n+        // 3. Otherwise, return false.\n+        const size_t starting_point = txidHasher(wtxid) % eligible_peers.size();\n+        if (starting_point <= peer_position && peer_position < starting_point + round_down_flood_targets) {\n+            return true;\n+        } else if (peer_position == starting_point + round_down_flood_targets) {\n+            return rand() < (flood_targets - round_down_flood_targets) * RAND_MAX;",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 341,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "913c2cbcea58696237760c51f55acee9d91eb186",
      "in_reply_to_id": 1020190507,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think so — since txidHasher is salted, the peer would have no control of it, and thus can't exploit this rand. But I'll keep this comment in case someone has an objection, just in case.",
      "created_at": "2022-11-11T13:08:41Z",
      "updated_at": "2022-11-11T13:08:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1020204771",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1020204771"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 360,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036137603",
      "pull_request_review_id": 1199573032,
      "id": 1036137603,
      "node_id": "PRRC_kwDOABII5849wjSD",
      "diff_hunk": "@@ -124,6 +132,35 @@ class TxReconciliationTracker::Impl\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 23,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "624e0988058e90537e1d1066a9c4528e4f1eecd1",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This will lock `m_txreconciliation_mutex` inside `IsPeerRegistered()`, check the state, and unlock again. On the next line we will then lock it again, and get a reference to the actual state. I don't think that's what we want:\r\n\r\n* It doesn't guarantee that the state didn't change in between the unlocking in `IsPeerRegistered` and getting the state two lines below, so the assertion doesn't actually prevent race conditions.\r\n* It's inefficient to lock and unlock twice.\r\n\r\nYou should check the `TxReconciliationState` within the same critical section as using it (perhaps by making `IsPeerRegistered` require `m_txreconciliation_mutex` being held?).",
      "created_at": "2022-11-30T15:45:13Z",
      "updated_at": "2022-11-30T15:56:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036137603",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036137603"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 139,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036138757",
      "pull_request_review_id": 1199573032,
      "id": 1036138757,
      "node_id": "PRRC_kwDOABII5849wjkF",
      "diff_hunk": "@@ -124,6 +132,35 @@ class TxReconciliationTracker::Impl\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 41,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "624e0988058e90537e1d1066a9c4528e4f1eecd1",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Same thing here: check the state within the same critical section as using it.",
      "created_at": "2022-11-30T15:46:15Z",
      "updated_at": "2022-11-30T15:56:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036138757",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036138757"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 157,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036140210",
      "pull_request_review_id": 1199573032,
      "id": 1036140210,
      "node_id": "PRRC_kwDOABII5849wj6y",
      "diff_hunk": "@@ -124,6 +132,35 @@ class TxReconciliationTracker::Impl\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 29,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "624e0988058e90537e1d1066a9c4528e4f1eecd1",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Shorter: `added += recon_state.m_local_set.insert(wtxid).second;`.",
      "created_at": "2022-11-30T15:47:27Z",
      "updated_at": "2022-11-30T15:56:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036140210",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036140210"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 145,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036141026",
      "pull_request_review_id": 1199573032,
      "id": 1036141026,
      "node_id": "PRRC_kwDOABII5849wkHi",
      "diff_hunk": "@@ -124,6 +132,35 @@ class TxReconciliationTracker::Impl\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 28,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "624e0988058e90537e1d1066a9c4528e4f1eecd1",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Style nit (feel free to ignore, it's not in the style guide, but I don't think we use anything like this anywhere): space before `:`.",
      "created_at": "2022-11-30T15:48:05Z",
      "updated_at": "2022-11-30T15:56:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036141026",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036141026"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 217,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036143555",
      "pull_request_review_id": 1199573032,
      "id": 1036143555,
      "node_id": "PRRC_kwDOABII5849wkvD",
      "diff_hunk": "@@ -154,6 +297,77 @@ class TxReconciliationTracker::Impl\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = floor(flood_targets);\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:\n+        // 1. Every transaction should be assigned to *some* peer, at least assuming a static list\n+        // of peers. For this function that means no randomness.\n+        // 2. The choice doesn't leak the internal order of peers (m_states) to the external\n+        // observer. This is achieved by hashing the txid.\n+        //\n+        // Say, we have 2.4 targets out of 20 inbound peers, the wtixd hash is 217, and our peer_id\n+        // holds peer_position in the list of inbound peers.\n+        // We will compute 217 % 20 = 17, as if it was a \"starting_point\", from which we see if\n+        // the target is within a range of 2.4. It's impossible for the range to exceed\n+        // the bounds because of how we computed them in the first place.\n+        // For that, we need to check the following:\n+        // 1. If 17 <= peer_position < 19, return true.\n+        // 2. If peer_position = 19, roll the dice with the remaining probability (0.4).\n+        // 3. Otherwise, return false.\n+        const size_t starting_point = txidHasher(wtxid) % eligible_peers.size();\n+        if (starting_point <= peer_position && peer_position < starting_point + round_down_flood_targets) {\n+            return true;\n+        } else if (peer_position == starting_point + round_down_flood_targets) {\n+            return rand() < (flood_targets - round_down_flood_targets) * RAND_MAX;",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 341,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "913c2cbcea58696237760c51f55acee9d91eb186",
      "in_reply_to_id": 1020190507,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You should really use our own PRNG (`FastRandomContext`), not the standard library built-in one which has no guarantees about its quality or performance. If you really can't use FastRandomContext for some reason, use C++ RNG functions, not C ones (`rand()` is not thread-safe, in addition to possibly being poor quality).",
      "created_at": "2022-11-30T15:50:07Z",
      "updated_at": "2022-11-30T15:58:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036143555",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036143555"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 360,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036145460",
      "pull_request_review_id": 1199573032,
      "id": 1036145460,
      "node_id": "PRRC_kwDOABII5849wlM0",
      "diff_hunk": "@@ -178,6 +198,69 @@ class TxReconciliationTracker::Impl\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 53,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "51f1c190762e9283d91297a82704e0d90fe0a8fb",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This creates a copy of the `TxReconciliationState`. Sure you don't want to get a reference here?",
      "created_at": "2022-11-30T15:51:40Z",
      "updated_at": "2022-11-30T15:56:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036145460",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036145460"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 207,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036146412",
      "pull_request_review_id": 1199573032,
      "id": 1036146412,
      "node_id": "PRRC_kwDOABII5849wlbs",
      "diff_hunk": "@@ -72,6 +86,12 @@ class TxReconciliationTracker::Impl\n private:\n     mutable Mutex m_txreconciliation_mutex;\n \n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 38,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "51f1c190762e9283d91297a82704e0d90fe0a8fb",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Style: `m_txid_hasher`.",
      "created_at": "2022-11-30T15:52:15Z",
      "updated_at": "2022-11-30T15:56:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036146412",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036146412"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 93,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036149162",
      "pull_request_review_id": 1199573032,
      "id": 1036149162,
      "node_id": "PRRC_kwDOABII5849wmGq",
      "diff_hunk": "@@ -178,6 +198,69 @@ class TxReconciliationTracker::Impl\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = floor(flood_targets);",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 81,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "51f1c190762e9283d91297a82704e0d90fe0a8fb",
      "in_reply_to_id": null,
      "user": {
        "login": "sipa",
        "id": 548488,
        "node_id": "MDQ6VXNlcjU0ODQ4OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sipa",
        "html_url": "https://github.com/sipa",
        "followers_url": "https://api.github.com/users/sipa/followers",
        "following_url": "https://api.github.com/users/sipa/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sipa/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sipa/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
        "organizations_url": "https://api.github.com/users/sipa/orgs",
        "repos_url": "https://api.github.com/users/sipa/repos",
        "events_url": "https://api.github.com/users/sipa/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sipa/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "No need for `floor()` here. Casting a floating-point type to integer type will automatically round down.",
      "created_at": "2022-11-30T15:54:20Z",
      "updated_at": "2022-11-30T15:56:56Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1036149162",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036149162"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 235,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038334384",
      "pull_request_review_id": 1202785461,
      "id": 1038334384,
      "node_id": "PRRC_kwDOABII584947mw",
      "diff_hunk": "@@ -264,6 +264,11 @@ extern const char* WTXIDRELAY;\n  * txreconciliation, as described by BIP 330.\n  */\n extern const char* SENDTXRCNCL;\n+/**\n+ * Contains a 4-byte local reconciliation set size and 4-byte q-coefficient.",
      "path": "src/protocol.h",
      "position": null,
      "original_position": 5,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The comment could be descriptive of actually what is contains and which protocol phase it's triggering (as other p2p messages coments). From the BIP:  \"The reqrecon message initiates a reconciliation round\" ",
      "created_at": "2022-12-02T16:49:28Z",
      "updated_at": "2022-12-02T18:54:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038334384",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038334384"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 268,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038404614",
      "pull_request_review_id": 1202785461,
      "id": 1038404614,
      "node_id": "PRRC_kwDOABII58495MwG",
      "diff_hunk": "@@ -121,26 +201,181 @@ class TxReconciliationTracker::Impl\n \n         const uint256 full_salt{ComputeSalt(local_salt, remote_salt)};\n         recon_state->second = TxReconciliationState(!is_peer_inbound, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        m_queue.push_back(peer_id);\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (!m_queue.empty()) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+                recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state.m_local_set.size();\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                                     \"local_set_size=%i\\n\",\n+                         peer_id, local_set_size);\n+\n+                // In future, Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n     void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n     {\n         AssertLockNotHeld(m_txreconciliation_mutex);\n         LOCK(m_txreconciliation_mutex);\n         if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n             LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n         }\n     }\n \n-    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n     {\n-        AssertLockNotHeld(m_txreconciliation_mutex);\n-        LOCK(m_txreconciliation_mutex);\n+        AssertLockHeld(m_txreconciliation_mutex);\n         auto recon_state = m_states.find(peer_id);\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool IsPeerRegisteredExternal(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        return IsPeerRegistered(peer_id);\n+    }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 234,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If you can use the same wording than the BIP here \"The initiator of the P2P connection assumes the role of reconciliation initiator\" otherwise it's obscure how the initiator/responder overlaps with connection direction.",
      "created_at": "2022-12-02T18:17:56Z",
      "updated_at": "2022-12-02T18:54:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038404614",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038404614"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 314,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038421101",
      "pull_request_review_id": 1202785461,
      "id": 1038421101,
      "node_id": "PRRC_kwDOABII58495Qxt",
      "diff_hunk": "@@ -53,6 +90,17 @@ class TxReconciliationState\n      */\n     uint64_t m_k0, m_k1;\n \n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)",
      "path": "src/node/txreconciliation.cpp",
      "position": 52,
      "original_position": 58,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Have you considered to enforce policy checks like feefilter at `REQTXRCNCL` sending instead of at reconciliation set fulfilling in INV sending ?\r\n\r\nDue to `RECON_REQUEST_INTERVAL`, I think some transactions could become stalled, wasting bandwidth in case of fast-paced mempool congestion change (not to exclude when we see few transactions issuers on the network provoking spikes by themselves). Though if correct, more likely a marginal performance improvement better left for follow-up. ",
      "created_at": "2022-12-02T18:33:42Z",
      "updated_at": "2022-12-02T18:54:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038421101",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038421101"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038424477",
      "pull_request_review_id": 1202785461,
      "id": 1038424477,
      "node_id": "PRRC_kwDOABII58495Rmd",
      "diff_hunk": "@@ -121,26 +201,181 @@ class TxReconciliationTracker::Impl\n \n         const uint256 full_salt{ComputeSalt(local_salt, remote_salt)};\n         recon_state->second = TxReconciliationState(!is_peer_inbound, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        m_queue.push_back(peer_id);\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 138,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can update this logger and few other to `BCLog::TXRECONCILIATION`",
      "created_at": "2022-12-02T18:38:27Z",
      "updated_at": "2022-12-02T18:54:20Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038424477",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038424477"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 221,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038465392",
      "pull_request_review_id": 1202979648,
      "id": 1038465392,
      "node_id": "PRRC_kwDOABII58495blw",
      "diff_hunk": "@@ -124,6 +132,33 @@ class TxReconciliationTracker::Impl\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 43,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "99acf14cf4aa66167f826de6b1d6044c5cc3dc85",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If adding is logged, maybe also log removal similarly?",
      "created_at": "2022-12-02T19:34:22Z",
      "updated_at": "2022-12-02T23:48:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038465392",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038465392"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 233,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038564473",
      "pull_request_review_id": 1202979648,
      "id": 1038564473,
      "node_id": "PRRC_kwDOABII58495zx5",
      "diff_hunk": "@@ -182,6 +202,70 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 78,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "89beb9043ec8a32311c3e99af2f230553a3f448e",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Using `==` to compare floating-point numbers seems not ideal due to precision issues, but it seems like we can never hit the return here anyway since we assert that `eligible_peers.size() > 0` above, so maybe the entire line could be deleted or be an assert?",
      "created_at": "2022-12-02T21:42:31Z",
      "updated_at": "2022-12-02T23:48:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038564473",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038564473"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 236,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038589117",
      "pull_request_review_id": 1202979648,
      "id": 1038589117,
      "node_id": "PRRC_kwDOABII584955y9",
      "diff_hunk": "@@ -182,6 +202,70 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = flood_targets;\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:\n+        // 1. Every transaction should be assigned to *some* peer, at least assuming a static list\n+        // of peers. For this function that means no randomness.",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 88,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "89beb9043ec8a32311c3e99af2f230553a3f448e",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "since you later use `insecure_rand.randrange`, \"no randomness\" seems a bit misleading.",
      "created_at": "2022-12-02T22:05:42Z",
      "updated_at": "2022-12-02T23:48:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038589117",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038589117"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 246,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038591870",
      "pull_request_review_id": 1202979648,
      "id": 1038591870,
      "node_id": "PRRC_kwDOABII584956d-",
      "diff_hunk": "@@ -182,6 +202,70 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = flood_targets;\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:\n+        // 1. Every transaction should be assigned to *some* peer, at least assuming a static list\n+        // of peers. For this function that means no randomness.\n+        // 2. The choice doesn't leak the internal order of peers (m_states) to the external\n+        // observer. This is achieved by hashing the txid.",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 90,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "89beb9043ec8a32311c3e99af2f230553a3f448e",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "nit: wtxid",
      "created_at": "2022-12-02T22:09:57Z",
      "updated_at": "2022-12-02T23:48:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038591870",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038591870"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 248,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038600759",
      "pull_request_review_id": 1202979648,
      "id": 1038600759,
      "node_id": "PRRC_kwDOABII584958o3",
      "diff_hunk": "@@ -182,6 +202,70 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = flood_targets;\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 86,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "89beb9043ec8a32311c3e99af2f230553a3f448e",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't think I understand this algorithm yet. Say we have 20 inbound peers (0...19), as in the example. What if the starting point is 19 because of the hash of the wtxid? Then we'd only flood the tx to peer 19, but not to peer 0 (because the algorithm doesn't wrap around) - so we'd flood it to 1 target out of 20, not meeting the goal of flooding to 2.4 targets even ignoring the fraction - is that intended?",
      "created_at": "2022-12-02T22:29:22Z",
      "updated_at": "2022-12-02T23:48:35Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1038600759",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1038600759"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 342,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039262264",
      "pull_request_review_id": 1204047515,
      "id": 1039262264,
      "node_id": "PRRC_kwDOABII58498eI4",
      "diff_hunk": "@@ -121,26 +201,181 @@ class TxReconciliationTracker::Impl\n \n         const uint256 full_salt{ComputeSalt(local_salt, remote_salt)};\n         recon_state->second = TxReconciliationState(!is_peer_inbound, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        m_queue.push_back(peer_id);\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (!m_queue.empty()) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+                recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state.m_local_set.size();\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                                     \"local_set_size=%i\\n\",\n+                         peer_id, local_set_size);\n+\n+                // In future, Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n     void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n     {\n         AssertLockNotHeld(m_txreconciliation_mutex);\n         LOCK(m_txreconciliation_mutex);\n         if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n             LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n         }\n     }\n \n-    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n     {\n-        AssertLockNotHeld(m_txreconciliation_mutex);\n-        LOCK(m_txreconciliation_mutex);\n+        AssertLockHeld(m_txreconciliation_mutex);\n         auto recon_state = m_states.find(peer_id);\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool IsPeerRegisteredExternal(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        return IsPeerRegistered(peer_id);\n+    }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 234,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "in_reply_to_id": 1038404614,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This comment was outdated, i think it's not needed here at all... deleting for now.",
      "created_at": "2022-12-05T07:55:53Z",
      "updated_at": "2022-12-05T07:55:54Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1039262264",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039262264"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 314,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039265857",
      "pull_request_review_id": 1204052484,
      "id": 1039265857,
      "node_id": "PRRC_kwDOABII58498fBB",
      "diff_hunk": "@@ -53,6 +90,17 @@ class TxReconciliationState\n      */\n     uint64_t m_k0, m_k1;\n \n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)",
      "path": "src/node/txreconciliation.cpp",
      "position": 52,
      "original_position": 58,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "in_reply_to_id": 1038421101,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This would largely complicate the code I think.... Policy check stuff should be moved out of `net_processing.cpp`.\r\nYeah, I see your concern (although I tested Erlay in mainnet and it was ok), let's see if other reviewers think it's needed now.",
      "created_at": "2022-12-05T08:00:28Z",
      "updated_at": "2022-12-05T08:00:28Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1039265857",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039265857"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039272601",
      "pull_request_review_id": 1204063482,
      "id": 1039272601,
      "node_id": "PRRC_kwDOABII58498gqZ",
      "diff_hunk": "@@ -124,6 +132,33 @@ class TxReconciliationTracker::Impl\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 43,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "99acf14cf4aa66167f826de6b1d6044c5cc3dc85",
      "in_reply_to_id": 1038465392,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "The removal is currently per-tx (not batched), so it would make the logs really annoying... Which raises another question: should I refactor it to make it batched where possible (on hearing INV batch from the given peer)?",
      "created_at": "2022-12-05T08:09:50Z",
      "updated_at": "2022-12-05T08:09:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1039272601",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039272601"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 233,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039308165",
      "pull_request_review_id": 1204115844,
      "id": 1039308165,
      "node_id": "PRRC_kwDOABII58498pWF",
      "diff_hunk": "@@ -182,6 +202,70 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = flood_targets;\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 86,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "89beb9043ec8a32311c3e99af2f230553a3f448e",
      "in_reply_to_id": 1038600759,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "You are right, it is broken. At least it was documented well enough you found the issue :)\r\n",
      "created_at": "2022-12-05T08:47:43Z",
      "updated_at": "2022-12-05T08:47:43Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1039308165",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1039308165"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 342,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041146278",
      "pull_request_review_id": 1206848088,
      "id": 1041146278,
      "node_id": "PRRC_kwDOABII584-DqGm",
      "diff_hunk": "@@ -121,26 +201,184 @@ class TxReconciliationTracker::Impl\n \n         const uint256 full_salt{ComputeSalt(local_salt, remote_salt)};\n         recon_state->second = TxReconciliationState(!is_peer_inbound, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        m_queue.push_back(peer_id);\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid : txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;\n+        }\n+\n+        LogPrint(BCLog::TXRECONCILIATION, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+                                          \"Now the set contains %i transactions.\\n\",\n+                 added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 147,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I would suggest not to have an assert here. Generally (imo) we should only add asserts when crashing the node is better than continuing. In this case simply adding a `if(!IsPeerRegistered()) return;` is better than crashing if the user of the API makes a mistake. You would be treating non-existence of the peer the same as the peer having an empty set (i.e. nothing is removed as it didn't exist in the first place).\r\n\r\nAdditionally, the way you are using this API right now is not generally safe.\r\n```c++\r\nif (m_txreconciliation && m_txreconciliation->IsPeerRegistered(pfrom.GetId())) {\r\n    m_txreconciliation->TryRemovingFromSet(pfrom.GetId(), wtxid);\r\n}\r\n```\r\n\r\nThe peer could be de-registered from the tracker in between the `IsPeerRegistered` and `TryRemovingFromSet` calls causing the node to crash for no good reason. This is only safe right now because `cs_main` is held here as well as when a peer is forgotten from the tracker. Since the tracker has its own mutex it should not rely on another mutex such as `cs_main`.",
      "created_at": "2022-12-06T15:48:37Z",
      "updated_at": "2022-12-06T16:17:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041146278",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041146278"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 230,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041165539",
      "pull_request_review_id": 1206848088,
      "id": 1041165539,
      "node_id": "PRRC_kwDOABII584-Duzj",
      "diff_hunk": "@@ -5668,8 +5714,94 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 120,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think it would make sense to move this block to its own function. This entire block for the tx announcement logic in SendMessages is already quite big.\r\n\r\nMaybe this can even move to the tracker?",
      "created_at": "2022-12-06T16:04:46Z",
      "updated_at": "2022-12-06T16:17:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041165539",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041165539"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5735,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041171241",
      "pull_request_review_id": 1206848088,
      "id": 1041171241,
      "node_id": "PRRC_kwDOABII584-DwMp",
      "diff_hunk": "@@ -121,26 +201,184 @@ class TxReconciliationTracker::Impl\n \n         const uint256 full_salt{ComputeSalt(local_salt, remote_salt)};\n         recon_state->second = TxReconciliationState(!is_peer_inbound, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        m_queue.push_back(peer_id);\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 130,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Same thing here about the assert.",
      "created_at": "2022-12-06T16:09:35Z",
      "updated_at": "2022-12-06T16:17:37Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041171241",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041171241"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 213,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041434849",
      "pull_request_review_id": 1207285454,
      "id": 1041434849,
      "node_id": "PRRC_kwDOABII584-Ewjh",
      "diff_hunk": "@@ -183,6 +203,72 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        std::vector<NodeId> eligible_peers;\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+        }\n+\n+        const size_t round_down_flood_targets = flood_targets;\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:\n+        // 1. Every transaction should be assigned to *some* peer.\n+        // 2. The choice doesn't leak the internal order of peers (m_states) to the external",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 84,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "ffbb2b814e82284c7c77c5a5b23058cbc7c0149c",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "One more conceptual question for the flooding algorithm:\r\nDoesn't this still leak internal order by flooding preferentially to adjacent nodes in `eligible_peers` if `flood_targets > 1`?\r\n\r\nWould it be a simpler alternative to have a deterministic randomizer that takes the wtxid, and then pick `flood_targets` random peers (and pick a last one only with an appropiate probability if `flood_targets` is not an integer), in the same way that way `PeerManagerImpl::RelayAddress()` picks 2 peers for addr relay? (but without the 24h reset happening there)",
      "created_at": "2022-12-06T20:38:07Z",
      "updated_at": "2022-12-06T23:44:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041434849",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041434849"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 243,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041516794",
      "pull_request_review_id": 1207285454,
      "id": 1041516794,
      "node_id": "PRRC_kwDOABII584-FEj6",
      "diff_hunk": "@@ -5678,7 +5678,11 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 8,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "869c6824235ff2af09d24b13cfab9a6cabd52b00",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Trying to understand commit 869c6824235ff2af09d24b13cfab9a6cabd52b00: \"It's possible that a parent will be scheduled to relay same time as child, but a child arrives earlier. \"\r\nIs this only possible with reconciliation? The previous commit tries to make sure that the child is also scheduled for recon, if the parent was - so can it only happen in the case where the recon set is at max capacity?\r\n\r\nAlso, since now twice as many entries will be saved in `m_recently_announced_invs`, does it need a larger capacity?",
      "created_at": "2022-12-06T22:16:45Z",
      "updated_at": "2022-12-06T23:44:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041516794",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041516794"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5731,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041544419",
      "pull_request_review_id": 1207285454,
      "id": 1041544419,
      "node_id": "PRRC_kwDOABII584-FLTj",
      "diff_hunk": "@@ -147,12 +147,29 @@ static constexpr auto AVG_ADDRESS_BROADCAST_INTERVAL{30s};\n /** Delay between rotating the peers we relay a particular address to */\n static constexpr auto ROTATE_ADDR_RELAY_DEST_INTERVAL{24h};\n /** Average delay between trickled inventory transmissions for inbound peers.\n- *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this. */\n+ *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this.\n+ *  For reconciliation peers the delay is chosen according the following\n+ *  considerations:\n+ *  1. Reconciliation. When the transaction is reconciled, this delay is applied to adding to\n+ *     reconciliation sets, not actual reconciliation (less frequent). That should happen rather\n+ *     fast, so that sets are in sync and reconciliation is efficient. At the same time, not too\n+ *     fast to avoid privacy leaks (e.g., infer connections via set probing).\n+ *  2. Low-fanout. In rare cases when the reconciling peer is chosen for low-fanout\n+ *     flooding, it will apply to the actual broadcast. Then, regular trickle considerations apply,\n+ *     but since this is a rare occasion, the following risks are much lower:\n+ *     2a) announcing both ways simultaneously (inefficiency);\n+ *     2b) inference based on the announced transactions (privacy leak).\n+ *     That's why it's ok to make this delay low as well, and lower delay is generally good to\n+ *     facilitate good transaction relay speed when slow reconciliations prevail. */\n static constexpr auto INBOUND_INVENTORY_BROADCAST_INTERVAL{5s};\n+static constexpr auto INBOUND_INVENTORY_BROADCAST_INTERVAL_RECON{2s};",
      "path": "src/net_processing.cpp",
      "position": 20,
      "original_position": 20,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "9f64cfe63e3b833e0f9faf17004cf51c4c925aec",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Commit 9f64cfe63e3b833e0f9faf17004cf51c4c925aec:\r\n\"Note that for privacy reasons the ratio between inbound and outbound\r\ndelays matter much more than the actual delays. That ratio is preserved\r\nhere, so it is not a privacy degradation.\"\r\nThe ratio is not exactly preserved, the old one was 5s/2s, now it's 2s/1s.",
      "created_at": "2022-12-06T22:45:45Z",
      "updated_at": "2022-12-06T23:44:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041544419",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041544419"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 163,
      "original_line": 163,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041586275",
      "pull_request_review_id": 1207285454,
      "id": 1041586275,
      "node_id": "PRRC_kwDOABII584-FVhj",
      "diff_hunk": "@@ -216,6 +233,43 @@ class TxReconciliationTracker::Impl\n         recon_state.m_local_set.erase(wtxid_to_remove);\n     }\n \n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (!m_queue.empty()) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 56,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "ef5a0457ae3d473fad3c79e169373bb8f9ef2c8c",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think it might be possible for a peer to abuse this logic and prevent us from reconciling with other peers: If an attacker sends a `SENDTXRCNCL` but stalls the `VERACK`, they would be registered and added to `m_queue` - but `SendMessages()` will never get to the part where `REQTXRCNCL` is sent for this peer because we abort early [here](https://github.com/bitcoin/bitcoin/blob/0596aa40f77a630d8a21035856fa5fd6838b292e/src/net_processing.cpp#L5367) before hanshake completion. Therefore, once that peer is in the front of the queue, it won't get cleared and prevents us from reconciling with other peers while connected (up to `DEFAULT_PEER_CONNECT_TIMEOUT = 60` seconds).",
      "created_at": "2022-12-06T23:40:07Z",
      "updated_at": "2022-12-06T23:44:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1041586275",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1041586275"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 250,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042310934",
      "pull_request_review_id": 1208575387,
      "id": 1042310934,
      "node_id": "PRRC_kwDOABII584-IGcW",
      "diff_hunk": "@@ -53,6 +90,17 @@ class TxReconciliationState\n      */\n     uint64_t m_k0, m_k1;\n \n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)",
      "path": "src/node/txreconciliation.cpp",
      "position": 52,
      "original_position": 58,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "in_reply_to_id": 1038421101,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "To clarify, we're considering the scenario in which our peer's fee filter changes between adding tx to `txs_to_reconcile` and sending the `inv` after reconciliation? Given that `RECON_REQUEST_INTERVAL` is 8sec and `AVG_FEEFILTER_BROADCAST_INTERVAL` is 10min, I don't think this is too much of a concern (at least for this PR)?",
      "created_at": "2022-12-07T14:58:09Z",
      "updated_at": "2022-12-07T14:58:42Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042310934",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042310934"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042366525",
      "pull_request_review_id": 1208638733,
      "id": 1042366525,
      "node_id": "PRRC_kwDOABII584-IUA9",
      "diff_hunk": "@@ -5668,8 +5714,94 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 120,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": 1041165539,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Agree, though it wouldn't make sense to have txreconciliation module depend on mempool. Would probably recommend grabbing the txiter ahead of time and passing in the parent wtxids.",
      "created_at": "2022-12-07T15:39:47Z",
      "updated_at": "2022-12-07T16:31:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042366525",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042366525"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5735,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042385456",
      "pull_request_review_id": 1208638733,
      "id": 1042385456,
      "node_id": "PRRC_kwDOABII584-IYow",
      "diff_hunk": "@@ -17,6 +19,41 @@ namespace {\n const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n \n+/**\n+ * Announce transactions via full wtxid to a limited number of inbound and outbound peers.\n+ * Justification for these values are provided here:\n+ * https://github.com/naumenkogs/txrelaysim/issues/7#issuecomment-902165806 */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS = 1;\n+/**\n+ * If there's a chance a transaction is not streamlined along the first couple hops, it would take\n+ *  very long to relay.\n+ */\n+static_assert(OUTBOUND_FANOUT_DESTINATIONS >= 1);",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 25,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "in ffbb2b814e82284c7c77c5a5b23058cbc7c0149c:\r\n\r\nBased on this, is the \"The requirements to this algorithm is the following: 1. Every transaction should be assigned to *some* peer.\" a hard requirement? If so, it seems the logic in f0685a1781 net_processing if recon parent -> recon child seems to break this, since you might have chosen just 1 peer to flood the child to, but then switch to recon because you're reconing the parent with that peer. It doesn't seem like `ShouldFloodTo` uses any state about whether we've chosen other peers for flooding, so we might end up not flooding the tx to anybody? Am I missing something / is this okay?",
      "created_at": "2022-12-07T15:54:24Z",
      "updated_at": "2022-12-07T16:31:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042385456",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042385456"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 32,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042412529",
      "pull_request_review_id": 1208638733,
      "id": 1042412529,
      "node_id": "PRRC_kwDOABII584-IfPx",
      "diff_hunk": "@@ -5703,11 +5835,28 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             tx_relay->m_tx_inventory_known_filter.insert(txid);\n                         }\n                     }\n+\n+                    if (!txs_to_reconcile.empty()) {\n+                        m_txreconciliation->AddToSet(pto->GetId(), txs_to_reconcile);\n+                    }\n                 }\n         }\n         if (!vInv.empty())\n             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n+        //\n+        // Message: reconciliation request\n+        //\n+        {\n+            if (!m_chainman.ActiveChainstate().IsInitialBlockDownload() && m_txreconciliation) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 220,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": null,
      "user": {
        "login": "glozow",
        "id": 25183001,
        "node_id": "MDQ6VXNlcjI1MTgzMDAx",
        "avatar_url": "https://avatars.githubusercontent.com/u/25183001?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/glozow",
        "html_url": "https://github.com/glozow",
        "followers_url": "https://api.github.com/users/glozow/followers",
        "following_url": "https://api.github.com/users/glozow/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/glozow/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/glozow/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/glozow/subscriptions",
        "organizations_url": "https://api.github.com/users/glozow/orgs",
        "repos_url": "https://api.github.com/users/glozow/repos",
        "events_url": "https://api.github.com/users/glozow/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/glozow/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "IIUC with this PR we'll request reconciliation with each other but since no `NetMsgType::REQTXRCNCL` handling is added, we ignore the request. That's fine, but should we also have the logic for falling back to flooding the wtxids in the reconciliation set when it gets full / after a timeout?",
      "created_at": "2022-12-07T16:16:45Z",
      "updated_at": "2022-12-07T16:31:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042412529",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042412529"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5851,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042413082",
      "pull_request_review_id": 1208726536,
      "id": 1042413082,
      "node_id": "PRRC_kwDOABII584-IfYa",
      "diff_hunk": "@@ -76,6 +76,35 @@ class TxReconciliationTracker\n     ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound,\n                                               uint32_t peer_recon_version, uint64_t remote_salt);\n \n+    /**\n+     * Step 1. Add new transactions we want to announce to the peer to the local reconciliation set\n+     * of the peer, so that those transactions will be reconciled later.\n+     * The caller *must* check that the peer is registered for reconciliations.\n+     */\n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile);",
      "path": "src/node/txreconciliation.h",
      "position": null,
      "original_position": 9,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It would be useful if this returned the number of added wtxids.",
      "created_at": "2022-12-07T16:17:17Z",
      "updated_at": "2022-12-07T16:28:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042413082",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042413082"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 84,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042413751",
      "pull_request_review_id": 1208726536,
      "id": 1042413751,
      "node_id": "PRRC_kwDOABII584-Ifi3",
      "diff_hunk": "@@ -76,6 +76,35 @@ class TxReconciliationTracker\n     ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound,\n                                               uint32_t peer_recon_version, uint64_t remote_salt);\n \n+    /**\n+     * Step 1. Add new transactions we want to announce to the peer to the local reconciliation set\n+     * of the peer, so that those transactions will be reconciled later.\n+     * The caller *must* check that the peer is registered for reconciliations.\n+     */\n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile);\n+\n+    /**\n+     * Before Step 2, we might want to remove a wtxid from the reconciliation set, for example if\n+     * the peer just announced the transaction to us.\n+     * The caller *must* check that the peer is registered for reconciliations.\n+     */\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove);",
      "path": "src/node/txreconciliation.h",
      "position": null,
      "original_position": 16,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "It would be useful if this returned whether or not the wtxid was removed.",
      "created_at": "2022-12-07T16:17:50Z",
      "updated_at": "2022-12-07T16:28:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042413751",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042413751"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 91,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042417507",
      "pull_request_review_id": 1208726536,
      "id": 1042417507,
      "node_id": "PRRC_kwDOABII584-Igdj",
      "diff_hunk": "@@ -76,6 +76,35 @@ class TxReconciliationTracker\n     ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound,\n                                               uint32_t peer_recon_version, uint64_t remote_salt);\n \n+    /**\n+     * Step 1. Add new transactions we want to announce to the peer to the local reconciliation set\n+     * of the peer, so that those transactions will be reconciled later.\n+     * The caller *must* check that the peer is registered for reconciliations.\n+     */\n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile);\n+\n+    /**\n+     * Before Step 2, we might want to remove a wtxid from the reconciliation set, for example if\n+     * the peer just announced the transaction to us.\n+     * The caller *must* check that the peer is registered for reconciliations.\n+     */\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove);\n+\n+    /**\n+     * Step 2. If it's time to request a reconciliation from the peer, this function will return\n+     * the details of our local state, which should be communicated to the peer so that they better\n+     * know what we need:\n+     * - size of our reconciliation set for the peer\n+     * - our q-coefficient with the peer, formatted to be transmitted as integer value\n+     * If the peer was not previously registered for reconciliations, returns nullopt.\n+     */\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id);",
      "path": "src/node/txreconciliation.h",
      "position": null,
      "original_position": 26,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "\r\n```suggestion\r\n    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id, std::chrono::microsecond now);\r\n```\r\n\r\nPassing in the time here would be nice for testing. \r\n* We only have one global mock time currently (globals are always a bit annoying when writing unit/fuzz tests, as you have to reset state after each test)\r\n* The current global mock time is only accurate in intervals of seconds",
      "created_at": "2022-12-07T16:21:06Z",
      "updated_at": "2022-12-07T16:28:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042417507",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042417507"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042420561",
      "pull_request_review_id": 1208726536,
      "id": 1042420561,
      "node_id": "PRRC_kwDOABII584-IhNR",
      "diff_hunk": "@@ -5668,8 +5714,94 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 120,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": 1041165539,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Adding to this:\r\n\r\nAfaict it's impossible for our fuzzers to exercise this code at the moment. Encapsulating this logic within the TxReconciliationTracker would make that possible.",
      "created_at": "2022-12-07T16:23:45Z",
      "updated_at": "2022-12-07T16:28:49Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042420561",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042420561"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5735,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042464406",
      "pull_request_review_id": 1208800680,
      "id": 1042464406,
      "node_id": "PRRC_kwDOABII584-Ir6W",
      "diff_hunk": "@@ -121,26 +201,184 @@ class TxReconciliationTracker::Impl\n \n         const uint256 full_salt{ComputeSalt(local_salt, remote_salt)};\n         recon_state->second = TxReconciliationState(!is_peer_inbound, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        m_queue.push_back(peer_id);\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid : txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;\n+        }\n+\n+        LogPrint(BCLog::TXRECONCILIATION, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+                                          \"Now the set contains %i transactions.\\n\",\n+                 added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (!m_queue.empty()) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+                recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state.m_local_set.size();\n+\n+                LogPrint(BCLog::TXRECONCILIATION, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                                                  \"local_set_size=%i\\n\",\n+                         peer_id, local_set_size);\n+\n+                // In future, Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n     void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n     {\n         AssertLockNotHeld(m_txreconciliation_mutex);\n         LOCK(m_txreconciliation_mutex);\n         if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n             LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n         }\n     }\n \n-    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n     {\n-        AssertLockNotHeld(m_txreconciliation_mutex);\n-        LOCK(m_txreconciliation_mutex);\n+        AssertLockHeld(m_txreconciliation_mutex);\n         auto recon_state = m_states.find(peer_id);\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool IsPeerRegisteredExternal(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        return IsPeerRegistered(peer_id);\n+    }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        std::vector<NodeId> eligible_peers;\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 240,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This throws a `std::bad_variant_access` for peers that aren't fully registered yet (found by the fuzzer).\r\n\r\nMaybe create an internal helper method that only iterates through all fully registered peers/states to avoid this entirely?",
      "created_at": "2022-12-07T17:02:17Z",
      "updated_at": "2022-12-07T17:02:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042464406",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1042464406"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 320,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1044199932",
      "pull_request_review_id": 1211290010,
      "id": 1044199932,
      "node_id": "PRRC_kwDOABII584-PTn8",
      "diff_hunk": "@@ -53,6 +90,17 @@ class TxReconciliationState\n      */\n     uint64_t m_k0, m_k1;\n \n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)",
      "path": "src/node/txreconciliation.cpp",
      "position": 52,
      "original_position": 58,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "54777ce347a45fecbf77125d14c3099fffbfa7d4",
      "in_reply_to_id": 1038421101,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I thought this could happen even without explicit fee filter changes, but rather the following:\r\n1. A transaction marginally passed the given fee filter.\r\n2. In 8 seconds when it's time to send, it doesn't pass the filter, but is sent anyway.",
      "created_at": "2022-12-09T08:26:21Z",
      "updated_at": "2022-12-09T08:26:22Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1044199932",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1044199932"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 88,
      "original_line": 88,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1044229932",
      "pull_request_review_id": 1211334700,
      "id": 1044229932,
      "node_id": "PRRC_kwDOABII584-Pa8s",
      "diff_hunk": "@@ -183,6 +203,72 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        std::vector<NodeId> eligible_peers;\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+        }\n+\n+        const size_t round_down_flood_targets = flood_targets;\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:\n+        // 1. Every transaction should be assigned to *some* peer.\n+        // 2. The choice doesn't leak the internal order of peers (m_states) to the external",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 84,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "ffbb2b814e82284c7c77c5a5b23058cbc7c0149c",
      "in_reply_to_id": 1041434849,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> Doesn't this still leak internal order by flooding preferentially to adjacent nodes in eligible_peers if flood_targets > 1?\r\n\r\nGood point. Yes. I should think about the fix.\r\n\r\n>Would it be a simpler alternative to have a deterministic randomizer that takes the wtxid, and then pick flood_targets random peers (and pick a last one only with an appropiate probability if flood_targets is not an integer), in the same way that way PeerManagerImpl::RelayAddress() picks 2 peers for addr relay? (but without the 24h reset happening there)\r\n\r\nI'll try.",
      "created_at": "2022-12-09T09:04:17Z",
      "updated_at": "2022-12-09T09:04:18Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1044229932",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1044229932"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 243,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1045740922",
      "pull_request_review_id": 1213394979,
      "id": 1045740922,
      "node_id": "PRRC_kwDOABII584-VL16",
      "diff_hunk": "@@ -5703,11 +5835,28 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             tx_relay->m_tx_inventory_known_filter.insert(txid);\n                         }\n                     }\n+\n+                    if (!txs_to_reconcile.empty()) {\n+                        m_txreconciliation->AddToSet(pto->GetId(), txs_to_reconcile);\n+                    }\n                 }\n         }\n         if (!vInv.empty())\n             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n+        //\n+        // Message: reconciliation request\n+        //\n+        {\n+            if (!m_chainman.ActiveChainstate().IsInitialBlockDownload() && m_txreconciliation) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 220,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": 1042412529,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "We're talking about someone enabling the `-txreconciliation=1` CLI flag... Why do you think this would be useful for such tester?",
      "created_at": "2022-12-12T12:04:33Z",
      "updated_at": "2022-12-12T12:04:33Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1045740922",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1045740922"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5851,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1045802684",
      "pull_request_review_id": 1213502717,
      "id": 1045802684,
      "node_id": "PRRC_kwDOABII584-Va68",
      "diff_hunk": "@@ -216,6 +233,43 @@ class TxReconciliationTracker::Impl\n         recon_state.m_local_set.erase(wtxid_to_remove);\n     }\n \n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (!m_queue.empty()) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 56,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "ef5a0457ae3d473fad3c79e169373bb8f9ef2c8c",
      "in_reply_to_id": 1041586275,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I don't see that yet. No matter what happens to this peer, it will be moved to the end of the queue, and the next peer will be requested in couple seconds.",
      "created_at": "2022-12-12T13:02:55Z",
      "updated_at": "2022-12-12T13:02:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1045802684",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1045802684"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 250,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1045978253",
      "pull_request_review_id": 1213803271,
      "id": 1045978253,
      "node_id": "PRRC_kwDOABII584-WFyN",
      "diff_hunk": "@@ -216,6 +233,43 @@ class TxReconciliationTracker::Impl\n         recon_state.m_local_set.erase(wtxid_to_remove);\n     }\n \n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (!m_queue.empty()) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 56,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "ef5a0457ae3d473fad3c79e169373bb8f9ef2c8c",
      "in_reply_to_id": 1041586275,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "> I don't see that yet. No matter what happens to this peer, it will be moved to the end of the queue, and the next peer will be requested in couple seconds.\r\n\r\nI was thinking of the following:\r\n1.) Peer X gets connected, sends `SENDTXRCNCL`, RegisterPeer puts it into the back of the queue.\r\n2.) X doesn't send `VERACK`\r\n3.) We do regular reconciliation requests with all other peers of the queue, so now X is in the front of it\r\n4.) Since X is not succesfully connected, `SendMessages` aborts early and we don't reach the code where `REQTXRCNCL` is processed\r\n5.) X won't be removed from the front of the queue,  and we don't request reconciliations from any other peer because of that.\r\n\r\n\r\n",
      "created_at": "2022-12-12T15:32:01Z",
      "updated_at": "2022-12-12T15:32:38Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1045978253",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1045978253"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 250,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1045980252",
      "pull_request_review_id": 1213806803,
      "id": 1045980252,
      "node_id": "PRRC_kwDOABII584-WGRc",
      "diff_hunk": "@@ -216,6 +233,43 @@ class TxReconciliationTracker::Impl\n         recon_state.m_local_set.erase(wtxid_to_remove);\n     }\n \n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (!m_queue.empty()) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 56,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "ef5a0457ae3d473fad3c79e169373bb8f9ef2c8c",
      "in_reply_to_id": 1041586275,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "ahhh good point, should be addressed indeed.",
      "created_at": "2022-12-12T15:33:43Z",
      "updated_at": "2022-12-12T15:33:44Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1045980252",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1045980252"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 250,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1046946611",
      "pull_request_review_id": 1215173615,
      "id": 1046946611,
      "node_id": "PRRC_kwDOABII584-ZyMz",
      "diff_hunk": "@@ -216,6 +233,43 @@ class TxReconciliationTracker::Impl\n         recon_state.m_local_set.erase(wtxid_to_remove);\n     }\n \n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (!m_queue.empty()) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 56,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "ef5a0457ae3d473fad3c79e169373bb8f9ef2c8c",
      "in_reply_to_id": 1041586275,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "This is a dangerous piece of code... This could also happen if the peer enters IBD again or something.",
      "created_at": "2022-12-13T10:24:05Z",
      "updated_at": "2022-12-13T10:24:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1046946611",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1046946611"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 250,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1047291134",
      "pull_request_review_id": 1215685753,
      "id": 1047291134,
      "node_id": "PRRC_kwDOABII584-bGT-",
      "diff_hunk": "@@ -216,6 +233,43 @@ class TxReconciliationTracker::Impl\n         recon_state.m_local_set.erase(wtxid_to_remove);\n     }\n \n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (!m_queue.empty()) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 56,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "ef5a0457ae3d473fad3c79e169373bb8f9ef2c8c",
      "in_reply_to_id": 1041586275,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Yeah - just to bring this alternative up, if we uncoupled peers and had every peer on its separate timer (instead of a queue), would that lead to major efficiency losses?",
      "created_at": "2022-12-13T15:13:17Z",
      "updated_at": "2022-12-13T15:13:17Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1047291134",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1047291134"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 250,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1047538690",
      "pull_request_review_id": 1216141754,
      "id": 1047538690,
      "node_id": "PRRC_kwDOABII584-cCwC",
      "diff_hunk": "@@ -216,6 +233,43 @@ class TxReconciliationTracker::Impl\n         recon_state.m_local_set.erase(wtxid_to_remove);\n     }\n \n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (!m_queue.empty()) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 56,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "ef5a0457ae3d473fad3c79e169373bb8f9ef2c8c",
      "in_reply_to_id": 1041586275,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I started with having two separate calls — one for queue management, the other for sending REQTXRCNCL.\r\nI'll submit that shortly. Then I'll think about your idea.",
      "created_at": "2022-12-13T18:04:24Z",
      "updated_at": "2022-12-13T18:04:25Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1047538690",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1047538690"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 250,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1051969326",
      "pull_request_review_id": 1222540790,
      "id": 1051969326,
      "node_id": "PRRC_kwDOABII584-s8cu",
      "diff_hunk": "@@ -5678,7 +5678,11 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 8,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "869c6824235ff2af09d24b13cfab9a6cabd52b00",
      "in_reply_to_id": 1041516794,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ">Is this only possible with reconciliation? \r\n\r\nYes I think so\r\n\r\n>so can it only happen in the case where the recon set is at max capacity?\r\n\r\nNot only that. The order is lost when set difference is decoded. The decoding party only knows wtxids and will request them in random order, via a regular INV. The ordering could be handled on the responder side, but I'm afraid it would be hard and messy. I can try though.\r\n\r\nThe logic in the last commit is not super-reliable either, so I think it's better to have belt-and-suspenders like this.\r\n\r\nUnless they break something else of course.\r\n\r\n>Also, since now twice as many entries will be saved in m_recently_announced_invs, does it need a larger capacity?\r\n\r\ngood point.\r\n",
      "created_at": "2022-12-19T09:18:01Z",
      "updated_at": "2022-12-19T09:18:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1051969326",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1051969326"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5731,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052002193",
      "pull_request_review_id": 1222589735,
      "id": 1052002193,
      "node_id": "PRRC_kwDOABII584-tEeR",
      "diff_hunk": "@@ -17,6 +19,41 @@ namespace {\n const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n \n+/**\n+ * Announce transactions via full wtxid to a limited number of inbound and outbound peers.\n+ * Justification for these values are provided here:\n+ * https://github.com/naumenkogs/txrelaysim/issues/7#issuecomment-902165806 */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS = 1;\n+/**\n+ * If there's a chance a transaction is not streamlined along the first couple hops, it would take\n+ *  very long to relay.\n+ */\n+static_assert(OUTBOUND_FANOUT_DESTINATIONS >= 1);",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 25,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": 1042385456,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": ">Every transaction should be assigned to some peer.\" a hard requirement?\r\n\r\nI meant to relay in *some way* (either flooded or reconciled), so that the transaction doesn't get stuck. That's it.\r\nThat resolves your question right? Fixing code comment for now.",
      "created_at": "2022-12-19T09:49:43Z",
      "updated_at": "2022-12-19T09:49:50Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1052002193",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052002193"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": 29,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 32,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052114025",
      "pull_request_review_id": 1222752080,
      "id": 1052114025,
      "node_id": "PRRC_kwDOABII584-tfxp",
      "diff_hunk": "@@ -183,6 +203,72 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        std::vector<NodeId> eligible_peers;\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+        }\n+\n+        const size_t round_down_flood_targets = flood_targets;\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:\n+        // 1. Every transaction should be assigned to *some* peer.\n+        // 2. The choice doesn't leak the internal order of peers (m_states) to the external",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 84,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "ffbb2b814e82284c7c77c5a5b23058cbc7c0149c",
      "in_reply_to_id": 1041434849,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could you review if 02e480d174e4edb1ffedb643fc454ad9b77e9001 is any better? Looking at the following commit may add some useful context 15006207099882aa73c18738e5013bf0c313be93",
      "created_at": "2022-12-19T11:46:54Z",
      "updated_at": "2022-12-19T11:46:55Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1052114025",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052114025"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 243,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052114496",
      "pull_request_review_id": 1222752746,
      "id": 1052114496,
      "node_id": "PRRC_kwDOABII584-tf5A",
      "diff_hunk": "@@ -5668,8 +5714,94 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 120,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "e480bed66158971493c2af51a72acaec582e8f01",
      "in_reply_to_id": 1041165539,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could your review 15006207099882aa73c18738e5013bf0c313be93 separately? If that's roughly what you're asked for and you are satisfied, I will squash into the original commit.",
      "created_at": "2022-12-19T11:47:29Z",
      "updated_at": "2022-12-19T11:47:30Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1052114496",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052114496"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5735,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052392630",
      "pull_request_review_id": 1223170187,
      "id": 1052392630,
      "node_id": "PRRC_kwDOABII584-ujy2",
      "diff_hunk": "@@ -5336,6 +5365,16 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n     if (!peer) return false;\n     const Consensus::Params& consensusParams = m_chainparams.GetConsensus();\n \n+    const auto current_time{GetTime<std::chrono::microseconds>()};\n+\n+    // We must look into the reconciliation queue first. Since the queue applies to all peers,\n+    // this peer might block other reconciliation if we don't make this call regularly and\n+    // unconditionally.\n+    bool reconcile = false;\n+    if (m_txreconciliation) {\n+        // reconcile = m_txreconciliation->IsPeerNextToReconcileWith(pto->GetId(), current_time);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 103,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "15006207099882aa73c18738e5013bf0c313be93",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "e894824cea7bbb835c762fc57b9523f76c51339f\r\ncommented code here",
      "created_at": "2022-12-19T16:16:07Z",
      "updated_at": "2022-12-19T18:36:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1052392630",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052392630"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5375,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052393745",
      "pull_request_review_id": 1223170187,
      "id": 1052393745,
      "node_id": "PRRC_kwDOABII584-ukER",
      "diff_hunk": "@@ -5703,11 +5788,30 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             tx_relay->m_tx_inventory_known_filter.insert(txid);\n                         }\n                     }\n+\n+                    if (!txs_to_reconcile.empty()) {\n+                        m_txreconciliation->AddToSet(pto->GetId(), txs_to_reconcile);\n+                    }\n                 }\n         }\n         if (!vInv.empty())\n             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n+        //\n+        // Message: reconciliation request\n+        //\n+        {\n+            if (!m_chainman.ActiveChainstate().IsInitialBlockDownload()) {\n+                if (reconcile) {\n+                    const auto reconciliation_request_params = m_txreconciliation->InitiateReconciliationRequest(pto->GetId());\n+                    if (reconciliation_request_params) {\n+                        const auto [local_set_size, local_q_formatted] = (*reconciliation_request_params);",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 220,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "15006207099882aa73c18738e5013bf0c313be93",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "e894824cea7bbb835c762fc57b9523f76c51339f no need for parentheses",
      "created_at": "2022-12-19T16:17:14Z",
      "updated_at": "2022-12-19T18:36:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1052393745",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052393745"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5808,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052395138",
      "pull_request_review_id": 1223170187,
      "id": 1052395138,
      "node_id": "PRRC_kwDOABII584-ukaC",
      "diff_hunk": "@@ -124,23 +204,273 @@ class TxReconciliationTracker::Impl\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddPeerToQueue(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+\n+        auto recon_state = m_states.find(peer_id);\n+\n+        if (recon_state == m_states.end()) return;\n+\n+        if (!std::holds_alternative<TxReconciliationState>(recon_state->second)) {\n+            return;\n+        }\n+\n+        m_queue.push_back(peer_id);\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Added peer=%d to the queue\\n\",\n+                      peer_id);\n+    }\n+\n+    size_t AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return 0;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid : txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;\n+        }\n+\n+        LogPrint(BCLog::TXRECONCILIATION, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+                                          \"Now the set contains %i transactions.\\n\",\n+                 added, peer_id, recon_state.m_local_set.size());\n+        return added;\n+    }\n+\n+    bool TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return false;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.erase(wtxid_to_remove) > 0;\n+    }\n+\n+    bool IsPeerNextToReconcileWith(NodeId peer_id, std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+\n+        if (!IsPeerRegistered(peer_id)) return false;\n+        if (m_queue.empty()) return false;\n+\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_next_recon_request <= now && m_queue.front() == peer_id) {\n+            Assume(recon_state.m_we_initiate);\n+            m_queue.pop_front();\n+            m_queue.push_back(peer_id);\n+\n+            // If the phase is not NONE, the peer hasn't responded to the previous reconciliation.\n+            // A laggy peer should not affect other peers.\n+            //\n+            // This doesn't prevent from a malicious peer gaming this by staying in this state\n+            // all the time somehow.\n+            if (recon_state.m_phase_init_by_us == Phase::NONE) UpdateNextReconRequest(now);\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> InitiateReconciliationRequest(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+        recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+        size_t local_set_size = recon_state.m_local_set.size();\n+\n+        LogPrint(BCLog::TXRECONCILIATION, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                                          \"local_set_size=%i\\n\",\n+                 peer_id, local_set_size);\n+\n+        // In future, Q could be recomputed after every reconciliation based on the\n+        // set differences. For now, it provides good enough results without recompute\n+        // complexity, but we communicate it here to allow backward compatibility if\n+        // the value is changed or made dynamic.\n+        return std::make_pair(local_set_size, Q * Q_PRECISION);\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n     void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n     {\n         AssertLockNotHeld(m_txreconciliation_mutex);\n         LOCK(m_txreconciliation_mutex);\n         if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n             LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n         }\n     }\n \n-    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n     {\n-        AssertLockNotHeld(m_txreconciliation_mutex);\n-        LOCK(m_txreconciliation_mutex);\n+        AssertLockHeld(m_txreconciliation_mutex);\n         auto recon_state = m_states.find(peer_id);\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool IsPeerRegisteredExternal(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        return IsPeerRegistered(peer_id);\n+    }\n+\n+    bool IsAlreadyInPeerSet(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return false;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+        return recon_state.m_local_set.count(wtxid) > 0;\n+    }\n+\n+    std::vector<NodeId> GetFloodTargets(const uint256& wtxid, CSipHasher deterministic_randomizer,\n+                                        size_t all_inbound_peers, size_t already_flooded_to_outbound) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+\n+        auto try_flood_candidate = [](CSipHasher deterministic_randomizer, std::vector<std::pair<uint64_t, NodeId>> best_peers,\n+                                      const size_t limit, const std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> candidate) {\n+            const auto& cur_state = std::get<TxReconciliationState>(candidate.second);\n+            uint64_t hash_key = std::min<uint64_t>(deterministic_randomizer.Write(cur_state.m_k0).Finalize(), 1);\n+\n+            for (size_t i = 0; i < limit; ++i) {\n+                if (hash_key > best_peers[i].first) {\n+                    std::copy(best_peers.begin() + i, best_peers.begin() + limit - 1, best_peers.begin() + i + 1);\n+                    best_peers[i] = std::make_pair(hash_key, candidate.first);\n+                    break;\n+                }\n+            }\n+        };\n+\n+        const double inbound_destinations = all_inbound_peers * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+        const size_t outbound_destinations = std::min<int>(0, OUTBOUND_FANOUT_DESTINATIONS - already_flooded_to_outbound);\n+\n+        std::vector<std::pair<uint64_t, NodeId>> best_inbound_peers(size_t(inbound_destinations) + 1, std::make_pair(0, 0));\n+        std::vector<std::pair<uint64_t, NodeId>> best_outbound_peers(outbound_destinations, std::make_pair(0, 0));\n+        ;",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 292,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "15006207099882aa73c18738e5013bf0c313be93",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "02e480d174e4edb1ffedb643fc454ad9b77e9001\r\n```suggestion\r\n```",
      "created_at": "2022-12-19T16:18:42Z",
      "updated_at": "2022-12-19T18:36:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1052395138",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052395138"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 375,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052397812",
      "pull_request_review_id": 1223170187,
      "id": 1052397812,
      "node_id": "PRRC_kwDOABII584-ulD0",
      "diff_hunk": "@@ -76,6 +76,44 @@ class TxReconciliationTracker\n     ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound,\n                                               uint32_t peer_recon_version, uint64_t remote_salt);\n \n+    /** TODO */",
      "path": "src/node/txreconciliation.h",
      "position": null,
      "original_position": 4,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "15006207099882aa73c18738e5013bf0c313be93",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "e894824cea7bbb835c762fc57b9523f76c51339f Forgotten todo?",
      "created_at": "2022-12-19T16:21:13Z",
      "updated_at": "2022-12-19T18:36:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1052397812",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052397812"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 79,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052398233",
      "pull_request_review_id": 1223170187,
      "id": 1052398233,
      "node_id": "PRRC_kwDOABII584-ulKZ",
      "diff_hunk": "@@ -124,23 +204,273 @@ class TxReconciliationTracker::Impl\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    void AddPeerToQueue(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+\n+        auto recon_state = m_states.find(peer_id);\n+\n+        if (recon_state == m_states.end()) return;\n+\n+        if (!std::holds_alternative<TxReconciliationState>(recon_state->second)) {\n+            return;\n+        }\n+\n+        m_queue.push_back(peer_id);\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Added peer=%d to the queue\\n\",\n+                      peer_id);\n+    }\n+\n+    size_t AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return 0;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid : txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;\n+        }\n+\n+        LogPrint(BCLog::TXRECONCILIATION, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+                                          \"Now the set contains %i transactions.\\n\",\n+                 added, peer_id, recon_state.m_local_set.size());\n+        return added;\n+    }\n+\n+    bool TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return false;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.erase(wtxid_to_remove) > 0;\n+    }\n+\n+    bool IsPeerNextToReconcileWith(NodeId peer_id, std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+\n+        if (!IsPeerRegistered(peer_id)) return false;\n+        if (m_queue.empty()) return false;\n+\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_next_recon_request <= now && m_queue.front() == peer_id) {\n+            Assume(recon_state.m_we_initiate);\n+            m_queue.pop_front();\n+            m_queue.push_back(peer_id);\n+\n+            // If the phase is not NONE, the peer hasn't responded to the previous reconciliation.\n+            // A laggy peer should not affect other peers.\n+            //\n+            // This doesn't prevent from a malicious peer gaming this by staying in this state\n+            // all the time somehow.\n+            if (recon_state.m_phase_init_by_us == Phase::NONE) UpdateNextReconRequest(now);\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> InitiateReconciliationRequest(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+        recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+        size_t local_set_size = recon_state.m_local_set.size();\n+\n+        LogPrint(BCLog::TXRECONCILIATION, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                                          \"local_set_size=%i\\n\",\n+                 peer_id, local_set_size);\n+\n+        // In future, Q could be recomputed after every reconciliation based on the\n+        // set differences. For now, it provides good enough results without recompute\n+        // complexity, but we communicate it here to allow backward compatibility if\n+        // the value is changed or made dynamic.\n+        return std::make_pair(local_set_size, Q * Q_PRECISION);\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n     void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n     {\n         AssertLockNotHeld(m_txreconciliation_mutex);\n         LOCK(m_txreconciliation_mutex);\n         if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n             LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n         }\n     }\n \n-    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n     {\n-        AssertLockNotHeld(m_txreconciliation_mutex);\n-        LOCK(m_txreconciliation_mutex);\n+        AssertLockHeld(m_txreconciliation_mutex);\n         auto recon_state = m_states.find(peer_id);\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool IsPeerRegisteredExternal(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        return IsPeerRegistered(peer_id);\n+    }\n+\n+    bool IsAlreadyInPeerSet(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return false;\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+        return recon_state.m_local_set.count(wtxid) > 0;\n+    }\n+\n+    std::vector<NodeId> GetFloodTargets(const uint256& wtxid, CSipHasher deterministic_randomizer,\n+                                        size_t all_inbound_peers, size_t already_flooded_to_outbound) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+\n+        auto try_flood_candidate = [](CSipHasher deterministic_randomizer, std::vector<std::pair<uint64_t, NodeId>> best_peers,\n+                                      const size_t limit, const std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> candidate) {\n+            const auto& cur_state = std::get<TxReconciliationState>(candidate.second);\n+            uint64_t hash_key = std::min<uint64_t>(deterministic_randomizer.Write(cur_state.m_k0).Finalize(), 1);\n+\n+            for (size_t i = 0; i < limit; ++i) {\n+                if (hash_key > best_peers[i].first) {\n+                    std::copy(best_peers.begin() + i, best_peers.begin() + limit - 1, best_peers.begin() + i + 1);\n+                    best_peers[i] = std::make_pair(hash_key, candidate.first);\n+                    break;\n+                }\n+            }\n+        };\n+\n+        const double inbound_destinations = all_inbound_peers * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+        const size_t outbound_destinations = std::min<int>(0, OUTBOUND_FANOUT_DESTINATIONS - already_flooded_to_outbound);\n+\n+        std::vector<std::pair<uint64_t, NodeId>> best_inbound_peers(size_t(inbound_destinations) + 1, std::make_pair(0, 0));\n+        std::vector<std::pair<uint64_t, NodeId>> best_outbound_peers(outbound_destinations, std::make_pair(0, 0));\n+        ;\n+\n+        for (auto indexed_state : m_states) {\n+            const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+            if (cur_state.m_we_initiate == true) { // corresponds to connection direction.\n+                try_flood_candidate(deterministic_randomizer, best_outbound_peers, outbound_destinations, indexed_state);\n+            } else {\n+                try_flood_candidate(deterministic_randomizer, best_inbound_peers, inbound_destinations, indexed_state);\n+            }\n+        }\n+\n+        // For inbound peers, it's possible that the last peer was added optimistically,\n+        // so we have to roll the dice now.\n+        FastRandomContext insecure_rand;\n+        if (insecure_rand.randrange(100) > (inbound_destinations - size_t(inbound_destinations)) * 100) {\n+            best_inbound_peers.pop_back();\n+        }\n+\n+\n+        best_inbound_peers.insert(best_inbound_peers.end(), best_outbound_peers.begin(), best_outbound_peers.end());\n+        std::vector<NodeId> result;\n+        std::for_each(best_inbound_peers.begin(), best_inbound_peers.end(),\n+                      [&result](auto best_peer) {\n+                          if (best_peer.first != 0) result.push_back(best_peer.second);\n+                      });\n+        return result;\n+    }\n+\n+    // For a given peer, see whether the transaction should be flooded\n+    bool ShouldFloodTo(const uint256& wtxid, const std::vector<uint256> parents_wtxids,\n+                       const std::vector<uint256> wtxids_to_reconcile, CSipHasher deterministic_randomizer, NodeId peer_id,",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 322,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "15006207099882aa73c18738e5013bf0c313be93",
      "in_reply_to_id": null,
      "user": {
        "login": "aureleoules",
        "id": 22493292,
        "node_id": "MDQ6VXNlcjIyNDkzMjky",
        "avatar_url": "https://avatars.githubusercontent.com/u/22493292?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aureleoules",
        "html_url": "https://github.com/aureleoules",
        "followers_url": "https://api.github.com/users/aureleoules/followers",
        "following_url": "https://api.github.com/users/aureleoules/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/aureleoules/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/aureleoules/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/aureleoules/subscriptions",
        "organizations_url": "https://api.github.com/users/aureleoules/orgs",
        "repos_url": "https://api.github.com/users/aureleoules/repos",
        "events_url": "https://api.github.com/users/aureleoules/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/aureleoules/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "15006207099882aa73c18738e5013bf0c313be93\r\nShould maybe pass by const ref for `parents_wtxids` and `wtxids_to_reconcile`, same for `TxReconciliationTracker::ShouldFloodTo`.",
      "created_at": "2022-12-19T16:21:40Z",
      "updated_at": "2022-12-19T18:36:06Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1052398233",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1052398233"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": 404,
      "start_side": "RIGHT",
      "line": null,
      "original_line": 405,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114818128",
      "pull_request_review_id": 1309970444,
      "id": 1114818128,
      "node_id": "PRRC_kwDOABII585CcsZQ",
      "diff_hunk": "@@ -3699,6 +3720,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 if (!fAlreadyHave && !m_chainman.ActiveChainstate().IsInitialBlockDownload()) {\n                     AddTxAnnouncement(pfrom, gtxid, current_time);\n                 }\n+                if (m_txreconciliation && m_txreconciliation->IsPeerRegistered(pfrom.GetId()) && gtxid.IsWtxid()) {\n+                    m_txreconciliation->TryRemovingFromSet(pfrom.GetId(), gtxid.GetHash());",
      "path": "src/net_processing.cpp",
      "position": 46,
      "original_position": 57,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "37a471c986af620f9547d27a466250ed1988c846",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Don't know if transaction received through BIP152's `BLOCKTXN` should be `TryRemovingFromSet()`.",
      "created_at": "2023-02-22T18:53:50Z",
      "updated_at": "2023-02-22T19:55:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1114818128",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114818128"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3722,
      "original_line": 3722,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114821225",
      "pull_request_review_id": 1309970444,
      "id": 1114821225,
      "node_id": "PRRC_kwDOABII585CctJp",
      "diff_hunk": "@@ -145,12 +147,29 @@ static constexpr auto AVG_ADDRESS_BROADCAST_INTERVAL{30s};\n /** Delay between rotating the peers we relay a particular address to */\n static constexpr auto ROTATE_ADDR_RELAY_DEST_INTERVAL{24h};\n /** Average delay between trickled inventory transmissions for inbound peers.\n- *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this. */\n+ *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this.\n+ *  For reconciliation peers the delay is chosen according the following\n+ *  considerations:\n+ *  1. Reconciliation. When the transaction is reconciled, this delay is applied to adding to\n+ *     reconciliation sets, not actual reconciliation (less frequent). That should happen rather\n+ *     fast, so that sets are in sync and reconciliation is efficient. At the same time, not too\n+ *     fast to avoid privacy leaks (e.g., infer connections via set probing).",
      "path": "src/net_processing.cpp",
      "position": 11,
      "original_position": 22,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "37a471c986af620f9547d27a466250ed1988c846",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If the \"fast\" (i.e 2s)  has been reasoned out in the bip or the paper, the section can be referenced too, I think. ",
      "created_at": "2023-02-22T18:55:52Z",
      "updated_at": "2023-02-22T19:55:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1114821225",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114821225"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 154,
      "original_line": 154,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114835166",
      "pull_request_review_id": 1309970444,
      "id": 1114835166,
      "node_id": "PRRC_kwDOABII585Ccwje",
      "diff_hunk": "@@ -76,6 +76,36 @@ class TxReconciliationTracker\n     ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound,\n                                               uint32_t peer_recon_version, uint64_t remote_salt);\n \n+    /**\n+     * Step 1. Add new transactions we want to announce to the peer to the local reconciliation set\n+     * of the peer, so that those transactions will be reconciled later.\n+     * Returns the number of added transactions (already present transactions won't be added).\n+     *\n+     * The caller *must* check that the peer is registered for reconciliations.\n+     */\n+    size_t AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile);\n+\n+    /**\n+     * Before Step 2, we might want to remove a wtxid from the reconciliation set, for example if\n+     * the peer just announced the transaction to us.\n+     * Returns whether the wtxid was removed.\n+     *\n+     * The caller *must* check that the peer is registered for reconciliations.\n+     */\n+    bool TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove);\n+\n+    bool IsPeerNextToReconcileWith(NodeId peer_id, std::chrono::microseconds now);",
      "path": "src/node/txreconciliation.h",
      "position": 26,
      "original_position": 22,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "37a471c986af620f9547d27a466250ed1988c846",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Can add a comment about what `TxReconciliationTracker::IsPeerNextToReconcileWith()` does, like assumptions on peers queue and phase we're in.",
      "created_at": "2023-02-22T19:04:02Z",
      "updated_at": "2023-02-22T19:55:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1114835166",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114835166"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 101,
      "original_line": 101,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114866248",
      "pull_request_review_id": 1309970444,
      "id": 1114866248,
      "node_id": "PRRC_kwDOABII585Cc4JI",
      "diff_hunk": "@@ -99,7 +99,9 @@ static constexpr int32_t MAX_PEER_TX_REQUEST_IN_FLIGHT = 100;\n /** Maximum number of transactions to consider for requesting, per peer. It provides a reasonable DoS limit to\n  *  per-peer memory usage spent on announcements, while covering peers continuously sending INVs at the maximum\n  *  rate (by our own policy, see INVENTORY_BROADCAST_PER_SECOND) for several minutes, while not receiving\n- *  the actual transaction (from any peer) in response to requests for them. */\n+ *  the actual transaction (from any peer) in response to requests for them.\n+ *  Also limits a maximum number of elements to store in the reconciliation set.",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 6,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "37a471c986af620f9547d27a466250ed1988c846",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Not sure this new comment still holds with the introduction of `MAX_SET_SIZE=3000`. ",
      "created_at": "2023-02-22T19:35:20Z",
      "updated_at": "2023-02-22T19:55:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1114866248",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114866248"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 103,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114877866",
      "pull_request_review_id": 1309970444,
      "id": 1114877866,
      "node_id": "PRRC_kwDOABII585Cc6-q",
      "diff_hunk": "@@ -121,26 +194,233 @@ class TxReconciliationTracker::Impl\n \n         const uint256 full_salt{ComputeSalt(local_salt, remote_salt)};\n         recon_state->second = TxReconciliationState(!is_peer_inbound, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        if (!is_peer_inbound) m_queue.push_back(peer_id);\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    size_t AddToSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        Assume(txs_to_reconcile.size() > 0);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return 0;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid : txs_to_reconcile) {\n+            added += recon_state.m_local_set.insert(wtxid).second;",
      "path": "src/node/txreconciliation.cpp",
      "position": null,
      "original_position": 128,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "37a471c986af620f9547d27a466250ed1988c846",
      "in_reply_to_id": null,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Correct the max set size (`MAX_SET_SIZE`) is enforced by `ShouldFanoutTo()` which happens before the call to `AddToSet()`, don't know if it could be more conservative with another check here. ",
      "created_at": "2023-02-22T19:47:25Z",
      "updated_at": "2023-02-22T19:55:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1114877866",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114877866"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 211,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114886751",
      "pull_request_review_id": 1310071886,
      "id": 1114886751,
      "node_id": "PRRC_kwDOABII585Cc9Jf",
      "diff_hunk": "@@ -5576,8 +5701,94 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            bool flood_target = m_txreconciliation->ShouldFloodTo(wtxid, pto->GetId());\n+\n+                            // Special treatment for unconfirmed transactions with unconfirmed\n+                            // parents.\n+                            LOCK(m_mempool.cs);\n+                            auto txiter = m_mempool.GetIter(txinfo.tx->GetHash());\n+                            assert(txiter);\n+                            const CTxMemPoolEntry::Parents& parents = (*txiter)->GetMemPoolParentsConst();\n+                            for (const CTxMemPoolEntry& parent : parents) {\n+                                // Two situations are possible here:\n+                                // 1. The parent was fully relayed to the peer earlier.\n+                                // 2. The parent is set for reconciliation and the child is not\n+                                //    in the mempool yet. The child arrives to the mempool and is\n+                                //    flooded. The peer receives the child earlier than the parent.\n+                                // We can differentiate between the two by looking at the recon\n+                                // set: if the set (or the snapshot) contains the parent, the parent\n+                                // is being reconciled (case 2). Then, we add the child to the\n+                                // reconciliation set, so that it doesn't arrive earlier than the\n+                                // parent.\n+                                // If it's the case 1, we proceed as usual by looking at the\n+                                // child's wtxid.\n+                                const uint256 parent_wtxid = parent.GetTx().GetWitnessHash();\n+                                if (m_txreconciliation->CurrentlyReconcilingTx(pto->GetId(), parent_wtxid) ||\n+                                    std::find(txs_to_reconcile.begin(), txs_to_reconcile.end(), parent_wtxid) != txs_to_reconcile.end()) {\n+                                    // Currently reconciling parent tx.\n+                                    // We have the following options to do:\n+                                    // 1. Flood parent+child.\n+                                    // 2. Reconcile parent+child.\n+                                    // 3. Flood parent, reconcile child.\n+                                    // We choose (2) because it has the easiest implementation.\n+                                    // The latency impact is not that bad:\n+                                    // 1. If the parent is in the reocnciliation set, the two\n+                                    // transactions will be relayed at the same time. There is\n+                                    // no point relaying the child faster anyway.\n+                                    // 2. If the parent is in the snapshot, the child will\n+                                    // be reconcilied within the next batch. This would\n+                                    // introduce extra latency (even if by wtxid the child\n+                                    // should have been flooded over this link), but this will\n+                                    // be compensated later: if the delay is non-trivial,\n+                                    // for the next nodes this condition won't be triggered (\n+                                    // parent won't be in the reconciliation set).\n+                                    //\n+                                    // In case of the multiple unconfirmed parents, we will\n+                                    // reconcile if at least one of the parents is being\n+                                    // reconciled.\n+                                    //\n+                                    // Note, the transaction still could be flooded if the\n+                                    // reconciliation set is full (see check below). This\n+                                    // is not the general case and is likely caused by the\n+                                    // issues with the peer, and then we're not responsible\n+                                    // that the package can't pass mempool limitations.\n+                                    flood_target = false;\n+                                    break;\n+                                }\n+                            }\n+\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via fan-out.\n+                            const size_t recon_set_size = m_txreconciliation->GetPeerSetSize(pto->GetId());\n+                            if (!flood_target && txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {",
      "path": "src/net_processing.cpp",
      "position": null,
      "original_position": 334,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": 998588937,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Well we might have some small discrepancy in old code, doesn't seem to matter here.",
      "created_at": "2023-02-22T19:56:19Z",
      "updated_at": "2023-02-22T19:56:19Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1114886751",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114886751"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": null,
      "original_line": 5781,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114888417",
      "pull_request_review_id": 1310074223,
      "id": 1114888417,
      "node_id": "PRRC_kwDOABII585Cc9jh",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.",
      "path": "src/node/txreconciliation.cpp",
      "position": 33,
      "original_position": 36,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": 998640600,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think it's accurate with the current comment of warning about less frequent reconciliations introducing high transaction relay latency. Like some trade-off between bandwidth and 0confs UX to be aware, I would say.",
      "created_at": "2023-02-22T19:58:03Z",
      "updated_at": "2023-02-22T19:58:04Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1114888417",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114888417"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 39,
      "original_line": 39,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114890070",
      "pull_request_review_id": 1310077069,
      "id": 1114890070,
      "node_id": "PRRC_kwDOABII585Cc99W",
      "diff_hunk": "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then it’s\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.",
      "path": "src/node/txreconciliation.cpp",
      "position": 95,
      "original_position": 136,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "5070c97459282346cdcff7af08914c702462fe0d",
      "in_reply_to_id": 998653688,
      "user": {
        "login": "ariard",
        "id": 23310655,
        "node_id": "MDQ6VXNlcjIzMzEwNjU1",
        "avatar_url": "https://avatars.githubusercontent.com/u/23310655?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ariard",
        "html_url": "https://github.com/ariard",
        "followers_url": "https://api.github.com/users/ariard/followers",
        "following_url": "https://api.github.com/users/ariard/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ariard/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ariard/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ariard/subscriptions",
        "organizations_url": "https://api.github.com/users/ariard/orgs",
        "repos_url": "https://api.github.com/users/ariard/repos",
        "events_url": "https://api.github.com/users/ariard/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ariard/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Gotcha, just means the malicious outbound peer will never move forward its own reconciliation. ",
      "created_at": "2023-02-22T19:59:29Z",
      "updated_at": "2023-02-22T19:59:29Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1114890070",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1114890070"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 139,
      "original_line": 139,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1115299326",
      "pull_request_review_id": 1310699173,
      "id": 1115299326,
      "node_id": "PRRC_kwDOABII585Ceh3-",
      "diff_hunk": "@@ -3699,6 +3720,9 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 if (!fAlreadyHave && !m_chainman.ActiveChainstate().IsInitialBlockDownload()) {\n                     AddTxAnnouncement(pfrom, gtxid, current_time);\n                 }\n+                if (m_txreconciliation && m_txreconciliation->IsPeerRegistered(pfrom.GetId()) && gtxid.IsWtxid()) {\n+                    m_txreconciliation->TryRemovingFromSet(pfrom.GetId(), gtxid.GetHash());",
      "path": "src/net_processing.cpp",
      "position": 46,
      "original_position": 57,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "37a471c986af620f9547d27a466250ed1988c846",
      "in_reply_to_id": 1114818128,
      "user": {
        "login": "naumenkogs",
        "id": 7975071,
        "node_id": "MDQ6VXNlcjc5NzUwNzE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/naumenkogs",
        "html_url": "https://github.com/naumenkogs",
        "followers_url": "https://api.github.com/users/naumenkogs/followers",
        "following_url": "https://api.github.com/users/naumenkogs/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/naumenkogs/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/naumenkogs/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
        "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
        "repos_url": "https://api.github.com/users/naumenkogs/repos",
        "events_url": "https://api.github.com/users/naumenkogs/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "What you described means that the peer clearly has the transaction, thus it can safely be removed from the corresponding set (\"try\" means it's ok if the tx is not there). What's the problem with that?",
      "created_at": "2023-02-23T07:04:14Z",
      "updated_at": "2023-02-23T07:04:14Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1115299326",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1115299326"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 3722,
      "original_line": 3722,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1135725988",
      "pull_request_review_id": 1339558296,
      "id": 1135725988,
      "node_id": "PRRC_kwDOABII585Dsc2k",
      "diff_hunk": "@@ -121,26 +194,204 @@ class TxReconciliationTracker::Impl\n \n         const uint256 full_salt{ComputeSalt(local_salt, remote_salt)};\n         recon_state->second = TxReconciliationState(!is_peer_inbound, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        if (!is_peer_inbound) m_queue.push_back(peer_id);\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    bool AddToSet(NodeId peer_id, const uint256& wtxid) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return false;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // Check if reconciliation set is not at capacity for two reasons:\n+        // - limit sizes of reconciliation sets and short id mappings;\n+        // - limit CPU use for sketch computations.\n+        //\n+        // Since we reconcile frequently, reaching capacity either means:\n+        // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+        // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+        // We don't care about a laggy peer (1) because we probably can't help them even if we fanout transactions.\n+        // However, exploiting (2) should not prevent us from relaying certain transactions.\n+        //\n+        // Transactions which don't make it to the set due to the limit are announced via fan-out.\n+        if (recon_state.m_local_set.size() >= MAX_SET_SIZE) return false;\n+\n+        Assume(recon_state.m_local_set.insert(wtxid).second);\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Added a transaction to the reconciliation set for peer=%d. \" /* Continued */\n+                                                                    \"Now the set contains %i transactions.\\n\",\n+                      peer_id, recon_state.m_local_set.size());\n+        return true;\n+    }\n+\n+    bool TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return false;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.erase(wtxid_to_remove) > 0;\n+    }\n+\n+    bool IsPeerNextToReconcileWith(NodeId peer_id, std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+\n+        if (!IsPeerRegistered(peer_id)) return false;\n+        if (m_queue.empty()) return false;\n+\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_next_recon_request <= now && m_queue.front() == peer_id) {\n+            Assume(recon_state.m_we_initiate);\n+            m_queue.pop_front();\n+            m_queue.push_back(peer_id);\n+\n+            // If the phase is not NONE, the peer hasn't responded to the previous reconciliation.\n+            // A laggy peer should not affect other peers.\n+            //\n+            // This doesn't prevent from a malicious peer gaming this by staying in this state\n+            // all the time somehow.\n+            if (recon_state.m_phase_init_by_us == Phase::NONE) UpdateNextReconRequest(now);\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> InitiateReconciliationRequest(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+        recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+        size_t local_set_size = recon_state.m_local_set.size();\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                                                                    \"local_set_size=%i\\n\",\n+                      peer_id, local_set_size);\n+\n+        // In future, Q could be recomputed after every reconciliation based on the\n+        // set differences. For now, it provides good enough results without recompute\n+        // complexity, but we communicate it here to allow backward compatibility if\n+        // the value is changed or made dynamic.\n+        return std::make_pair(local_set_size, Q * Q_PRECISION);\n+    }\n+\n     void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n     {\n         AssertLockNotHeld(m_txreconciliation_mutex);\n         LOCK(m_txreconciliation_mutex);\n         if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n             LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n         }\n     }\n \n-    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n     {\n-        AssertLockNotHeld(m_txreconciliation_mutex);\n-        LOCK(m_txreconciliation_mutex);\n+        AssertLockHeld(m_txreconciliation_mutex);\n         auto recon_state = m_states.find(peer_id);\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool IsPeerRegisteredExternal(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        return IsPeerRegistered(peer_id);\n+    }\n+\n+    std::vector<NodeId> GetFanoutTargets(const uint256& wtxid, CSipHasher& deterministic_randomizer,\n+                                         bool we_initiate, float limit) const EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // To handle fractional values, we add one peer optimistically and then probabilistically\n+        // drop it later.\n+        // Initiate the randomness here so that it's not influenced by the following code.\n+        double fractional_peer;\n+        const size_t targets = size_t(std::modf(limit, &fractional_peer)) + 1;\n+        const bool drop_peer_if_extra = deterministic_randomizer.Finalize() > fractional_peer * float(UINT64_MAX);\n+\n+        std::vector<std::pair<uint64_t, NodeId>> best_peers(targets, std::make_pair(0, 0));\n+\n+        auto try_fanout_candidate = [&best_peers, &deterministic_randomizer, targets](\n+                                        const std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> candidate) {\n+            const auto& cur_state = std::get<TxReconciliationState>(candidate.second);\n+            uint64_t hash_key = std::max<uint64_t>(deterministic_randomizer.Write(cur_state.m_k0).Finalize(), 1);\n+\n+            for (size_t i = 0; i < targets; ++i) {\n+                if (hash_key > best_peers[i].first) {\n+                    std::copy(best_peers.begin() + i, best_peers.begin() + targets - 1, best_peers.begin() + i + 1);\n+                    best_peers[i] = std::make_pair(hash_key, candidate.first);\n+                    break;\n+                }\n+            }\n+        };\n+\n+        for (auto indexed_state : m_states) {\n+            const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);",
      "path": "src/node/txreconciliation.cpp",
      "position": 262,
      "original_position": 262,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Same as https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1042464406",
      "created_at": "2023-03-14T15:20:01Z",
      "updated_at": "2023-03-14T15:31:27Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1135725988",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1135725988"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 342,
      "original_line": 342,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1135765960",
      "pull_request_review_id": 1339614248,
      "id": 1135765960,
      "node_id": "PRRC_kwDOABII585DsmnI",
      "diff_hunk": "@@ -121,26 +194,204 @@ class TxReconciliationTracker::Impl\n \n         const uint256 full_salt{ComputeSalt(local_salt, remote_salt)};\n         recon_state->second = TxReconciliationState(!is_peer_inbound, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        if (!is_peer_inbound) m_queue.push_back(peer_id);\n         return ReconciliationRegisterResult::SUCCESS;\n     }\n \n+    bool AddToSet(NodeId peer_id, const uint256& wtxid) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return false;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // Check if reconciliation set is not at capacity for two reasons:\n+        // - limit sizes of reconciliation sets and short id mappings;\n+        // - limit CPU use for sketch computations.\n+        //\n+        // Since we reconcile frequently, reaching capacity either means:\n+        // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+        // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+        // We don't care about a laggy peer (1) because we probably can't help them even if we fanout transactions.\n+        // However, exploiting (2) should not prevent us from relaying certain transactions.\n+        //\n+        // Transactions which don't make it to the set due to the limit are announced via fan-out.\n+        if (recon_state.m_local_set.size() >= MAX_SET_SIZE) return false;\n+\n+        Assume(recon_state.m_local_set.insert(wtxid).second);\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Added a transaction to the reconciliation set for peer=%d. \" /* Continued */\n+                                                                    \"Now the set contains %i transactions.\\n\",\n+                      peer_id, recon_state.m_local_set.size());\n+        return true;\n+    }\n+\n+    bool TryRemovingFromSet(NodeId peer_id, const uint256& wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return false;\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.erase(wtxid_to_remove) > 0;\n+    }\n+\n+    bool IsPeerNextToReconcileWith(NodeId peer_id, std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+\n+        if (!IsPeerRegistered(peer_id)) return false;\n+        if (m_queue.empty()) return false;\n+\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_next_recon_request <= now && m_queue.front() == peer_id) {\n+            Assume(recon_state.m_we_initiate);\n+            m_queue.pop_front();\n+            m_queue.push_back(peer_id);\n+\n+            // If the phase is not NONE, the peer hasn't responded to the previous reconciliation.\n+            // A laggy peer should not affect other peers.\n+            //\n+            // This doesn't prevent from a malicious peer gaming this by staying in this state\n+            // all the time somehow.\n+            if (recon_state.m_phase_init_by_us == Phase::NONE) UpdateNextReconRequest(now);\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> InitiateReconciliationRequest(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+        if (!recon_state.m_we_initiate) return std::nullopt;\n+\n+        if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+        recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+        size_t local_set_size = recon_state.m_local_set.size();\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                                                                    \"local_set_size=%i\\n\",\n+                      peer_id, local_set_size);\n+\n+        // In future, Q could be recomputed after every reconciliation based on the\n+        // set differences. For now, it provides good enough results without recompute\n+        // complexity, but we communicate it here to allow backward compatibility if\n+        // the value is changed or made dynamic.\n+        return std::make_pair(local_set_size, Q * Q_PRECISION);\n+    }\n+\n     void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n     {\n         AssertLockNotHeld(m_txreconciliation_mutex);\n         LOCK(m_txreconciliation_mutex);\n         if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n             LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n         }\n     }\n \n-    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n     {\n-        AssertLockNotHeld(m_txreconciliation_mutex);\n-        LOCK(m_txreconciliation_mutex);\n+        AssertLockHeld(m_txreconciliation_mutex);\n         auto recon_state = m_states.find(peer_id);\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool IsPeerRegisteredExternal(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        return IsPeerRegistered(peer_id);\n+    }\n+\n+    std::vector<NodeId> GetFanoutTargets(const uint256& wtxid, CSipHasher& deterministic_randomizer,\n+                                         bool we_initiate, float limit) const EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // To handle fractional values, we add one peer optimistically and then probabilistically\n+        // drop it later.\n+        // Initiate the randomness here so that it's not influenced by the following code.\n+        double fractional_peer;\n+        const size_t targets = size_t(std::modf(limit, &fractional_peer)) + 1;\n+        const bool drop_peer_if_extra = deterministic_randomizer.Finalize() > fractional_peer * float(UINT64_MAX);\n+\n+        std::vector<std::pair<uint64_t, NodeId>> best_peers(targets, std::make_pair(0, 0));\n+\n+        auto try_fanout_candidate = [&best_peers, &deterministic_randomizer, targets](\n+                                        const std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> candidate) {\n+            const auto& cur_state = std::get<TxReconciliationState>(candidate.second);\n+            uint64_t hash_key = std::max<uint64_t>(deterministic_randomizer.Write(cur_state.m_k0).Finalize(), 1);\n+\n+            for (size_t i = 0; i < targets; ++i) {\n+                if (hash_key > best_peers[i].first) {\n+                    std::copy(best_peers.begin() + i, best_peers.begin() + targets - 1, best_peers.begin() + i + 1);\n+                    best_peers[i] = std::make_pair(hash_key, candidate.first);\n+                    break;\n+                }\n+            }\n+        };\n+\n+        for (auto indexed_state : m_states) {\n+            const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);",
      "path": "src/node/txreconciliation.cpp",
      "position": 262,
      "original_position": 262,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "in_reply_to_id": 1135725988,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Could use [`std::visit`](https://en.cppreference.com/w/cpp/utility/variant/visit).",
      "created_at": "2023-03-14T15:44:09Z",
      "updated_at": "2023-03-14T15:44:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1135765960",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1135765960"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 342,
      "original_line": 342,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137786018",
      "pull_request_review_id": 1342448815,
      "id": 1137786018,
      "node_id": "PRRC_kwDOABII585D0Tyi",
      "diff_hunk": "@@ -5669,7 +5679,42 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool fanout = true;\n+                        if (reconciles_txs) {\n+                            LOCK(m_mempool.cs);\n+                            auto txiter = m_mempool.GetIter(txinfo.tx->GetHash());\n+                            assert(txiter);",
      "path": "src/net_processing.cpp",
      "position": 131,
      "original_position": 48,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "dcde537b5bc0e2dd272528e3a770a768ca804955",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "I think it might be possible that in between the spot where `txinfo` is queried, and the time we call `m_mempool.GetIter()` some other thread could remove the tx from the mempool (because no lock is held), so that this assert would be hit.",
      "created_at": "2023-03-15T21:20:43Z",
      "updated_at": "2023-03-16T15:49:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1137786018",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1137786018"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 5729,
      "original_line": 5687,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1138793203",
      "pull_request_review_id": 1342448815,
      "id": 1138793203,
      "node_id": "PRRC_kwDOABII585D4Jrz",
      "diff_hunk": "@@ -192,6 +205,87 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    std::vector<NodeId> GetFanoutTargets(const uint256& wtxid, CSipHasher& deterministic_randomizer,\n+                                         bool we_initiate, float limit) const EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // To handle fractional values, we add one peer optimistically and then probabilistically\n+        // drop it later.\n+        // Initiate the randomness here so that it's not influenced by the following code.\n+        double fractional_peer;",
      "path": "src/node/txreconciliation.cpp",
      "position": 241,
      "original_position": 47,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "dcde537b5bc0e2dd272528e3a770a768ca804955",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "Having a mix of float (`limit`) and double (`fractional_peer`) is probably not ideal.",
      "created_at": "2023-03-16T14:40:48Z",
      "updated_at": "2023-03-16T15:49:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1138793203",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1138793203"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 321,
      "original_line": 215,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1138809864",
      "pull_request_review_id": 1342448815,
      "id": 1138809864,
      "node_id": "PRRC_kwDOABII585D4NwI",
      "diff_hunk": "@@ -192,6 +205,87 @@ class TxReconciliationTracker::Impl\n         LOCK(m_txreconciliation_mutex);\n         return IsPeerRegistered(peer_id);\n     }\n+\n+    std::vector<NodeId> GetFanoutTargets(const uint256& wtxid, CSipHasher& deterministic_randomizer,",
      "path": "src/node/txreconciliation.cpp",
      "position": 235,
      "original_position": 41,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "dcde537b5bc0e2dd272528e3a770a768ca804955",
      "in_reply_to_id": null,
      "user": {
        "login": "mzumsande",
        "id": 48763452,
        "node_id": "MDQ6VXNlcjQ4NzYzNDUy",
        "avatar_url": "https://avatars.githubusercontent.com/u/48763452?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mzumsande",
        "html_url": "https://github.com/mzumsande",
        "followers_url": "https://api.github.com/users/mzumsande/followers",
        "following_url": "https://api.github.com/users/mzumsande/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/mzumsande/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/mzumsande/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/mzumsande/subscriptions",
        "organizations_url": "https://api.github.com/users/mzumsande/orgs",
        "repos_url": "https://api.github.com/users/mzumsande/repos",
        "events_url": "https://api.github.com/users/mzumsande/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/mzumsande/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`wtxid` is unused",
      "created_at": "2023-03-16T14:48:46Z",
      "updated_at": "2023-03-16T15:49:51Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1138809864",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1138809864"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 315,
      "original_line": 209,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1139046536",
      "pull_request_review_id": 1344306348,
      "id": 1139046536,
      "node_id": "PRRC_kwDOABII585D5HiI",
      "diff_hunk": "@@ -4021,6 +4043,10 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             return;\n         }\n \n+        if (m_txreconciliation && m_txreconciliation->IsPeerRegistered(pfrom.GetId())) {\n+            m_txreconciliation->TryRemovingFromSet(pfrom.GetId(), wtxid);\n+        }",
      "path": "src/net_processing.cpp",
      "position": 57,
      "original_position": 57,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n        if (m_txreconciliation) m_txreconciliation->TryRemovingFromSet(pfrom.GetId(), wtxid);\r\n```\r\n\r\nYou are already checking internally that the peer is registered.",
      "created_at": "2023-03-16T16:49:30Z",
      "updated_at": "2023-03-16T17:34:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1139046536",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1139046536"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": 4046,
      "original_start_line": 4046,
      "start_side": "RIGHT",
      "line": 4048,
      "original_line": 4048,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1139078818",
      "pull_request_review_id": 1344306348,
      "id": 1139078818,
      "node_id": "PRRC_kwDOABII585D5Pai",
      "diff_hunk": "@@ -5669,7 +5721,42 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool fanout = true;\n+                        if (reconciles_txs) {\n+                            LOCK(m_mempool.cs);\n+                            auto txiter = m_mempool.GetIter(txinfo.tx->GetHash());\n+                            assert(txiter);\n+                            if ((*txiter)->GetCountWithDescendants() > 1) {\n+                                // If a transaction has in-mempool children, always fanout it.\n+                                // Until package relay is implemented, this is needed to avoid\n+                                // breaking parent+child relay expectations in some cases.\n+                                //\n+                                // Potentially reconciling parent+child would mean that for every\n+                                // child we need to to check if any of the parents is currently\n+                                // reconciled so that the child isn't fanouted ahead. But then\n+                                // it gets tricky when reconciliation sets are full: a) the child\n+                                // can't just be added; b) removing parents from reconciliation\n+                                // sets for this one child is not good either.\n+                                fanout = true;\n+                            } else {\n+                                size_t inbounds_fanouted = 0, outbounds_fanouted = 0;\n+                                m_connman.ForEachNode([&inbounds_fanouted, &outbounds_fanouted, this](CNode* pnode) {\n+                                    inbounds_fanouted += pnode->IsInboundConn() && pnode->m_relays_txs;\n+                                    outbounds_fanouted += pnode->IsFullOutboundConn() && pnode->m_relays_txs && !m_txreconciliation->IsPeerRegistered(pnode->GetId());\n+                                });",
      "path": "src/net_processing.cpp",
      "position": 149,
      "original_position": 149,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n                                {\r\n                                    LOCK(m_peer_mutex);\r\n                                    for (auto [id, peer] : m_peer_map) {\r\n                                        const auto state{State(id)};\r\n                                        if (!state) continue;\r\n\r\n                                        if (auto tx_relay = peer->GetTxRelay()) {\r\n                                            LOCK(tx_relay->m_bloom_filter_mutex);\r\n                                            inbounds_fanouted += state->m_is_inbound && tx_relay->m_relay_txs;\r\n                                            outbounds_fanouted += !state->m_is_inbound && tx_relay->m_relay_txs && !m_txreconciliation->IsPeerRegistered(id);\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n```\r\n\r\nSee https://github.com/bitcoin/bitcoin/pull/27270",
      "created_at": "2023-03-16T17:08:36Z",
      "updated_at": "2023-03-16T17:34:09Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1139078818",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1139078818"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": 5744,
      "original_start_line": 5744,
      "start_side": "RIGHT",
      "line": 5747,
      "original_line": 5747,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151979732",
      "pull_request_review_id": 1363161761,
      "id": 1151979732,
      "node_id": "PRRC_kwDOABII585EqdDU",
      "diff_hunk": "@@ -5669,7 +5721,42 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool fanout = true;\n+                        if (reconciles_txs) {\n+                            LOCK(m_mempool.cs);\n+                            auto txiter = m_mempool.GetIter(txinfo.tx->GetHash());\n+                            assert(txiter);\n+                            if ((*txiter)->GetCountWithDescendants() > 1) {\n+                                // If a transaction has in-mempool children, always fanout it.\n+                                // Until package relay is implemented, this is needed to avoid\n+                                // breaking parent+child relay expectations in some cases.\n+                                //\n+                                // Potentially reconciling parent+child would mean that for every\n+                                // child we need to to check if any of the parents is currently\n+                                // reconciled so that the child isn't fanouted ahead. But then\n+                                // it gets tricky when reconciliation sets are full: a) the child\n+                                // can't just be added; b) removing parents from reconciliation\n+                                // sets for this one child is not good either.\n+                                fanout = true;\n+                            } else {\n+                                size_t inbounds_fanouted = 0, outbounds_fanouted = 0;\n+                                m_connman.ForEachNode([&inbounds_fanouted, &outbounds_fanouted, this](CNode* pnode) {\n+                                    inbounds_fanouted += pnode->IsInboundConn() && pnode->m_relays_txs;",
      "path": "src/net_processing.cpp",
      "position": 147,
      "original_position": 147,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "```suggestion\r\n                                    inbounds_fanouted += pnode->IsInboundConn() && pnode->m_relays_txs && !m_txreconciliation->IsPeerRegistered(pnode->GetId());\r\n```\r\nRight? because otherwise this includes erlay peers which we are not flooding to by default.",
      "created_at": "2023-03-29T13:51:53Z",
      "updated_at": "2023-03-29T13:59:32Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1151979732",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151979732"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 5745,
      "original_line": 5745,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151986544",
      "pull_request_review_id": 1363161761,
      "id": 1151986544,
      "node_id": "PRRC_kwDOABII585Eqetw",
      "diff_hunk": "@@ -5669,7 +5721,42 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n                         State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        bool fanout = true;\n+                        if (reconciles_txs) {\n+                            LOCK(m_mempool.cs);\n+                            auto txiter = m_mempool.GetIter(txinfo.tx->GetHash());\n+                            assert(txiter);\n+                            if ((*txiter)->GetCountWithDescendants() > 1) {\n+                                // If a transaction has in-mempool children, always fanout it.\n+                                // Until package relay is implemented, this is needed to avoid\n+                                // breaking parent+child relay expectations in some cases.\n+                                //\n+                                // Potentially reconciling parent+child would mean that for every\n+                                // child we need to to check if any of the parents is currently\n+                                // reconciled so that the child isn't fanouted ahead. But then\n+                                // it gets tricky when reconciliation sets are full: a) the child\n+                                // can't just be added; b) removing parents from reconciliation\n+                                // sets for this one child is not good either.\n+                                fanout = true;\n+                            } else {\n+                                size_t inbounds_fanouted = 0, outbounds_fanouted = 0;\n+                                m_connman.ForEachNode([&inbounds_fanouted, &outbounds_fanouted, this](CNode* pnode) {\n+                                    inbounds_fanouted += pnode->IsInboundConn() && pnode->m_relays_txs;\n+                                    outbounds_fanouted += pnode->IsFullOutboundConn() && pnode->m_relays_txs && !m_txreconciliation->IsPeerRegistered(pnode->GetId());\n+                                });\n+\n+                                auto fanout_randomizer = m_connman.GetDeterministicRandomizer(RANDOMIZER_ID_FANOUTTARGET);\n+                                fanout = m_txreconciliation->ShouldFanoutTo(wtxid, fanout_randomizer, pto->GetId(),\n+                                                                            std::make_pair(m_connman.GetNodeCount(ConnectionDirection::In), inbounds_fanouted),",
      "path": "src/net_processing.cpp",
      "position": 153,
      "original_position": 153,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "in_reply_to_id": null,
      "user": {
        "login": "dergoegge",
        "id": 8077169,
        "node_id": "MDQ6VXNlcjgwNzcxNjk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8077169?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dergoegge",
        "html_url": "https://github.com/dergoegge",
        "followers_url": "https://api.github.com/users/dergoegge/followers",
        "following_url": "https://api.github.com/users/dergoegge/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/dergoegge/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/dergoegge/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/dergoegge/subscriptions",
        "organizations_url": "https://api.github.com/users/dergoegge/orgs",
        "repos_url": "https://api.github.com/users/dergoegge/repos",
        "events_url": "https://api.github.com/users/dergoegge/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/dergoegge/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "`m_connman.GetNodeCount(ConnectionDirection::In)` includes all inbound connections, even ones that do want transactions relayed to them. IIUC, you want this to be \"number of all inbound peers that sent fRelay=true\" and the second member of the pair should be \"number of all non-erlay inbound peers that sent fRelay=true\"",
      "created_at": "2023-03-29T13:56:22Z",
      "updated_at": "2023-03-29T13:59:05Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1151986544",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1151986544"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 5751,
      "original_line": 5751,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1210580514",
      "pull_request_review_id": 1451435060,
      "id": 1210580514,
      "node_id": "PRRC_kwDOABII585IJ_4i",
      "diff_hunk": "@@ -0,0 +1,84 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2023 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test REQTXRCNCL message\n+\"\"\"\n+\n+import time\n+\n+from test_framework.p2p import P2PInterface\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import assert_equal\n+from test_framework.wallet import MiniWallet\n+\n+class ReqTxrcnclReceiver(P2PInterface):\n+    def __init__(self):\n+        super().__init__(support_txrcncl = True)\n+        self.reqtxrcncl_msg_received = None\n+        self.received_inv_items = 0\n+\n+    def on_inv(self, message):\n+        self.received_inv_items += len(message.inv)\n+        super().on_inv(message)\n+\n+    def on_reqtxrcncl(self, message):\n+        self.reqtxrcncl_msg_received = message\n+\n+class ReqTxRcnclTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+        self.extra_args = [['-txreconciliation']]\n+\n+    def run_test(self):\n+        t = int(time.time())\n+        self.nodes[0].setmocktime(t)\n+        self.generate(self.nodes[0], 200) # mature coinbase UTXO used later",
      "path": "test/functional/p2p_reqtxrcncl.py",
      "position": 36,
      "original_position": 36,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In 00df0aefff938e849bdab5278d6658d5c9d5d064, If the purpose is maturing them, I think we could do:\r\n```suggestion\r\n        self.generate(self.nodes[0], COINBASE_MATURITY) # mature coinbase UTXO used later\r\n```",
      "created_at": "2023-05-30T17:12:06Z",
      "updated_at": "2023-05-30T17:15:16Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1210580514",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1210580514"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 36,
      "original_line": 36,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1210698732",
      "pull_request_review_id": 1451623963,
      "id": 1210698732,
      "node_id": "PRRC_kwDOABII585IKcvs",
      "diff_hunk": "@@ -5787,6 +5795,21 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n         if (!vInv.empty())\n             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n+        //\n+        // Message: reconciliation request\n+        //\n+        {\n+            if (!m_chainman.ActiveChainstate().IsInitialBlockDownload()) {",
      "path": "src/net_processing.cpp",
      "position": 173,
      "original_position": 34,
      "commit_id": "00df0aefff938e849bdab5278d6658d5c9d5d064",
      "original_commit_id": "30c39c1316a7b5c1914654f2a1487309b6e550ac",
      "in_reply_to_id": null,
      "user": {
        "login": "brunoerg",
        "id": 19480819,
        "node_id": "MDQ6VXNlcjE5NDgwODE5",
        "avatar_url": "https://avatars.githubusercontent.com/u/19480819?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/brunoerg",
        "html_url": "https://github.com/brunoerg",
        "followers_url": "https://api.github.com/users/brunoerg/followers",
        "following_url": "https://api.github.com/users/brunoerg/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/brunoerg/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/brunoerg/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/brunoerg/subscriptions",
        "organizations_url": "https://api.github.com/users/brunoerg/orgs",
        "repos_url": "https://api.github.com/users/brunoerg/repos",
        "events_url": "https://api.github.com/users/brunoerg/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/brunoerg/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "In 30c39c1316a7b5c1914654f2a1487309b6e550ac: If we're in IBD, wouldn't we put that peer in the end of the queue with no need (I mean, without doing a rec request in fact)? ",
      "created_at": "2023-05-30T18:55:21Z",
      "updated_at": "2023-05-30T18:55:21Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1210698732",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1210698732"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 5802,
      "original_line": 5802,
      "side": "RIGHT"
    }
  ]
}