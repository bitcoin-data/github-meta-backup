{
  "type": "pull",
  "pull": {
    "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20864",
    "id": 550110185,
    "node_id": "MDExOlB1bGxSZXF1ZXN0NTUwMTEwMTg1",
    "html_url": "https://github.com/bitcoin/bitcoin/pull/20864",
    "diff_url": "https://github.com/bitcoin/bitcoin/pull/20864.diff",
    "patch_url": "https://github.com/bitcoin/bitcoin/pull/20864.patch",
    "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20864",
    "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20864/commits",
    "review_comments_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20864/comments",
    "review_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments%7B/number%7D",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20864/comments",
    "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/fa210689e27b0d78b2fe894e51e364179db7a3ce",
    "number": 20864,
    "state": "closed",
    "locked": true,
    "maintainer_can_modify": false,
    "title": "net: Move SocketSendData lock annotation to header",
    "user": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "body": "Lock annotations must be in the header, otherwise the will have limited or no effect",
    "labels": [
      {
        "id": 135961,
        "node_id": "MDU6TGFiZWwxMzU5NjE=",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/Refactoring",
        "name": "Refactoring",
        "color": "E6F6D6",
        "default": false
      },
      {
        "id": 98298007,
        "node_id": "MDU6TGFiZWw5ODI5ODAwNw==",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/labels/P2P",
        "name": "P2P",
        "color": "006b75",
        "default": false
      }
    ],
    "active_lock_reason": "resolved",
    "created_at": "2021-01-06T07:44:50Z",
    "updated_at": "2022-08-16T17:02:12Z",
    "closed_at": "2021-01-07T13:58:52Z",
    "mergeable_state": "unknown",
    "merged_at": "2021-01-07T13:58:52Z",
    "merge_commit_sha": "42675e783337bf56dfc51df6c14931df5e72f185",
    "assignees": [],
    "requested_reviewers": [],
    "requested_teams": [],
    "head": {
      "label": "MarcoFalke:2101-netLock",
      "ref": "2101-netLock",
      "sha": "fa210689e27b0d78b2fe894e51e364179db7a3ce",
      "user": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "repo": {
        "id": 40046254,
        "node_id": "MDEwOlJlcG9zaXRvcnk0MDA0NjI1NA==",
        "name": "b-c",
        "full_name": "MarcoFalke/b-c",
        "owner": {
          "login": "MarcoFalke",
          "id": 6399679,
          "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
          "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/MarcoFalke",
          "html_url": "https://github.com/MarcoFalke",
          "followers_url": "https://api.github.com/users/MarcoFalke/followers",
          "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
          "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
          "repos_url": "https://api.github.com/users/MarcoFalke/repos",
          "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
          "type": "User",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/MarcoFalke/b-c",
        "fork": true,
        "url": "https://api.github.com/repos/MarcoFalke/b-c",
        "archive_url": "https://api.github.com/repos/MarcoFalke/b-c/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/MarcoFalke/b-c/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/MarcoFalke/b-c/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/MarcoFalke/b-c/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/MarcoFalke/b-c/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/MarcoFalke/b-c/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/MarcoFalke/b-c/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/MarcoFalke/b-c/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/MarcoFalke/b-c/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/MarcoFalke/b-c/contributors",
        "deployments_url": "https://api.github.com/repos/MarcoFalke/b-c/deployments",
        "downloads_url": "https://api.github.com/repos/MarcoFalke/b-c/downloads",
        "events_url": "https://api.github.com/repos/MarcoFalke/b-c/events",
        "forks_url": "https://api.github.com/repos/MarcoFalke/b-c/forks",
        "git_commits_url": "https://api.github.com/repos/MarcoFalke/b-c/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/MarcoFalke/b-c/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/MarcoFalke/b-c/git/tags%7B/sha%7D",
        "git_url": "git://github.com/MarcoFalke/b-c.git",
        "issue_comment_url": "https://api.github.com/repos/MarcoFalke/b-c/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/MarcoFalke/b-c/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/MarcoFalke/b-c/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/MarcoFalke/b-c/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/MarcoFalke/b-c/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/MarcoFalke/b-c/languages",
        "merges_url": "https://api.github.com/repos/MarcoFalke/b-c/merges",
        "milestones_url": "https://api.github.com/repos/MarcoFalke/b-c/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/MarcoFalke/b-c/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/MarcoFalke/b-c/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/MarcoFalke/b-c/releases%7B/id%7D",
        "ssh_url": "git@github.com:MarcoFalke/b-c.git",
        "stargazers_url": "https://api.github.com/repos/MarcoFalke/b-c/stargazers",
        "statuses_url": "https://api.github.com/repos/MarcoFalke/b-c/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/MarcoFalke/b-c/subscribers",
        "subscription_url": "https://api.github.com/repos/MarcoFalke/b-c/subscription",
        "tags_url": "https://api.github.com/repos/MarcoFalke/b-c/tags",
        "teams_url": "https://api.github.com/repos/MarcoFalke/b-c/teams",
        "trees_url": "https://api.github.com/repos/MarcoFalke/b-c/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/MarcoFalke/b-c.git",
        "hooks_url": "https://api.github.com/repos/MarcoFalke/b-c/hooks",
        "svn_url": "https://github.com/MarcoFalke/b-c",
        "homepage": "",
        "language": "C++",
        "forks_count": 12,
        "stargazers_count": 25,
        "watchers_count": 25,
        "size": 205775,
        "default_branch": "master",
        "open_issues_count": 25,
        "is_template": false,
        "topics": [],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-06-06T19:05:17Z",
        "created_at": "2015-08-01T12:42:47Z",
        "updated_at": "2023-05-28T20:12:34Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "base": {
      "label": "bitcoin:master",
      "ref": "master",
      "sha": "8a720ced5ff2fdd23b6ec7688998ad29e54fac98",
      "user": {
        "login": "bitcoin",
        "id": 528860,
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bitcoin",
        "html_url": "https://github.com/bitcoin",
        "followers_url": "https://api.github.com/users/bitcoin/followers",
        "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
        "organizations_url": "https://api.github.com/users/bitcoin/orgs",
        "repos_url": "https://api.github.com/users/bitcoin/repos",
        "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/bitcoin/received_events",
        "type": "Organization",
        "site_admin": false
      },
      "repo": {
        "id": 1181927,
        "node_id": "MDEwOlJlcG9zaXRvcnkxMTgxOTI3",
        "name": "bitcoin",
        "full_name": "bitcoin/bitcoin",
        "owner": {
          "login": "bitcoin",
          "id": 528860,
          "node_id": "MDEyOk9yZ2FuaXphdGlvbjUyODg2MA==",
          "avatar_url": "https://avatars.githubusercontent.com/u/528860?v=4",
          "gravatar_id": "",
          "url": "https://api.github.com/users/bitcoin",
          "html_url": "https://github.com/bitcoin",
          "followers_url": "https://api.github.com/users/bitcoin/followers",
          "following_url": "https://api.github.com/users/bitcoin/following%7B/other_user%7D",
          "gists_url": "https://api.github.com/users/bitcoin/gists%7B/gist_id%7D",
          "starred_url": "https://api.github.com/users/bitcoin/starred%7B/owner%7D%7B/repo%7D",
          "subscriptions_url": "https://api.github.com/users/bitcoin/subscriptions",
          "organizations_url": "https://api.github.com/users/bitcoin/orgs",
          "repos_url": "https://api.github.com/users/bitcoin/repos",
          "events_url": "https://api.github.com/users/bitcoin/events%7B/privacy%7D",
          "received_events_url": "https://api.github.com/users/bitcoin/received_events",
          "type": "Organization",
          "site_admin": false
        },
        "private": false,
        "html_url": "https://github.com/bitcoin/bitcoin",
        "description": "Bitcoin Core integration/staging tree",
        "fork": false,
        "url": "https://api.github.com/repos/bitcoin/bitcoin",
        "archive_url": "https://api.github.com/repos/bitcoin/bitcoin/%7Barchive_format%7D%7B/ref%7D",
        "assignees_url": "https://api.github.com/repos/bitcoin/bitcoin/assignees%7B/user%7D",
        "blobs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/blobs%7B/sha%7D",
        "branches_url": "https://api.github.com/repos/bitcoin/bitcoin/branches%7B/branch%7D",
        "collaborators_url": "https://api.github.com/repos/bitcoin/bitcoin/collaborators%7B/collaborator%7D",
        "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/comments%7B/number%7D",
        "commits_url": "https://api.github.com/repos/bitcoin/bitcoin/commits%7B/sha%7D",
        "compare_url": "https://api.github.com/repos/bitcoin/bitcoin/compare/%7Bbase%7D...%7Bhead%7D",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/%7B+path%7D",
        "contributors_url": "https://api.github.com/repos/bitcoin/bitcoin/contributors",
        "deployments_url": "https://api.github.com/repos/bitcoin/bitcoin/deployments",
        "downloads_url": "https://api.github.com/repos/bitcoin/bitcoin/downloads",
        "events_url": "https://api.github.com/repos/bitcoin/bitcoin/events",
        "forks_url": "https://api.github.com/repos/bitcoin/bitcoin/forks",
        "git_commits_url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits%7B/sha%7D",
        "git_refs_url": "https://api.github.com/repos/bitcoin/bitcoin/git/refs%7B/sha%7D",
        "git_tags_url": "https://api.github.com/repos/bitcoin/bitcoin/git/tags%7B/sha%7D",
        "git_url": "git://github.com/bitcoin/bitcoin.git",
        "issue_comment_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments%7B/number%7D",
        "issue_events_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events%7B/number%7D",
        "issues_url": "https://api.github.com/repos/bitcoin/bitcoin/issues%7B/number%7D",
        "keys_url": "https://api.github.com/repos/bitcoin/bitcoin/keys%7B/key_id%7D",
        "labels_url": "https://api.github.com/repos/bitcoin/bitcoin/labels%7B/name%7D",
        "languages_url": "https://api.github.com/repos/bitcoin/bitcoin/languages",
        "merges_url": "https://api.github.com/repos/bitcoin/bitcoin/merges",
        "milestones_url": "https://api.github.com/repos/bitcoin/bitcoin/milestones%7B/number%7D",
        "notifications_url": "https://api.github.com/repos/bitcoin/bitcoin/notifications%7B?since,all,participating}",
        "pulls_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls%7B/number%7D",
        "releases_url": "https://api.github.com/repos/bitcoin/bitcoin/releases%7B/id%7D",
        "ssh_url": "git@github.com:bitcoin/bitcoin.git",
        "stargazers_url": "https://api.github.com/repos/bitcoin/bitcoin/stargazers",
        "statuses_url": "https://api.github.com/repos/bitcoin/bitcoin/statuses/%7Bsha%7D",
        "subscribers_url": "https://api.github.com/repos/bitcoin/bitcoin/subscribers",
        "subscription_url": "https://api.github.com/repos/bitcoin/bitcoin/subscription",
        "tags_url": "https://api.github.com/repos/bitcoin/bitcoin/tags",
        "teams_url": "https://api.github.com/repos/bitcoin/bitcoin/teams",
        "trees_url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees%7B/sha%7D",
        "clone_url": "https://github.com/bitcoin/bitcoin.git",
        "hooks_url": "https://api.github.com/repos/bitcoin/bitcoin/hooks",
        "svn_url": "https://github.com/bitcoin/bitcoin",
        "homepage": "https://bitcoincore.org/en/download",
        "language": "C++",
        "forks_count": 34324,
        "stargazers_count": 69819,
        "watchers_count": 69819,
        "size": 233879,
        "default_branch": "master",
        "open_issues_count": 627,
        "is_template": false,
        "topics": [
          "bitcoin",
          "c-plus-plus",
          "cryptocurrency",
          "cryptography",
          "p2p"
        ],
        "has_issues": true,
        "has_projects": true,
        "has_wiki": false,
        "has_pages": false,
        "has_downloads": false,
        "archived": false,
        "disabled": false,
        "visibility": "public",
        "pushed_at": "2023-06-06T22:42:00Z",
        "created_at": "2010-12-19T15:16:43Z",
        "updated_at": "2023-06-07T04:47:18Z",
        "license": {
          "key": "mit",
          "name": "MIT License",
          "node_id": "MDc6TGljZW5zZTEz",
          "spdx_id": "MIT",
          "url": "https://api.github.com/licenses/mit",
          "html_url": null,
          "description": null,
          "implementation": null,
          "permissions": null,
          "conditions": null,
          "limitations": null,
          "body": null,
          "featured": null
        }
      }
    },
    "_links": {
      "self": {
        "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20864"
      }
    },
    "author_association": "MEMBER",
    "draft": false,
    "additions": 892,
    "deletions": 893,
    "changed_files": 2,
    "commits": 2,
    "review_comments": 2,
    "comments": 6
  },
  "events": [
    {
      "event": "labeled",
      "id": 4173923956,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDQxNzM5MjM5NTY=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4173923956",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T07:44:56Z",
      "label": {
        "name": "Refactoring",
        "color": "E6F6D6"
      }
    },
    {
      "event": "labeled",
      "id": 4173924397,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDQxNzM5MjQzOTc=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4173924397",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T07:45:05Z",
      "label": {
        "name": "P2P",
        "color": "006b75"
      }
    },
    {
      "event": "commented",
      "id": 755162168,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1NTE2MjE2OA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/755162168",
      "actor": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T08:33:46Z",
      "updated_at": "2021-01-06T08:33:46Z",
      "author_association": "MEMBER",
      "body": "Concept ACK.\r\n\r\nIf you're moving things around in net.h to add lock annotations, might be worth moving `NetEventsInterface` to after the `CNode` definition, and making it `virtual bool SendMessages(CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(pnode->cs_sendProcessing) = 0;`.\r\n\r\nMoving `IsPeerAddrLocalGood` and `AdvertiseLocal` later as well would allow removing the `class CNode;` forward declaration entirely.\r\n\r\nIt would be nice if there were some easy way to review pointer-becomes-reference changes.",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/20864#issuecomment-755162168",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20864"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4174142110,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE3NDE0MjExMA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4174142110",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T08:44:28Z"
    },
    {
      "event": "commented",
      "id": 755167546,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1NTE2NzU0Ng==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/755167546",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T08:46:07Z",
      "updated_at": "2021-01-06T08:46:07Z",
      "author_association": "MEMBER",
      "body": "> It would be nice if there were some easy way to review pointer-becomes-reference changes.\r\n\r\nApart from `--word-diff-regex=.`?\r\n\r\n> SendMessages ...\r\n\r\nThanks, done",
      "user": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/20864#issuecomment-755167546",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20864"
    },
    {
      "event": "commented",
      "id": 755260797,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1NTI2MDc5Nw==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/755260797",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-06T12:03:19Z",
      "updated_at": "2021-01-07T08:57:43Z",
      "author_association": "MEMBER",
      "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #20811 (refactor: move net_processing implementation details out of header by ajtowns)\n* #20786 (net: [refactor] Prefer integral types in CNodeStats by MarcoFalke)\n* #20729 (p2p: standardize on outbound-{full, block}-relay connection type naming by jonatack)\n* #20724 (Cleanup of -debug=net log messages by ajtowns)\n* #20646 (doc: refer to BIPs 339/155 in feature negotiation by jonatack)\n* #20364 (Follow-ups to 19107 by troygiorshev)\n* #20234 (net: don't extra bind for Tor if binds are restricted by vasild)\n* #20228 (addrman: Make addrman a top-level component by jnewbery)\n* #20196 (net: fix GetListenPort() to derive the proper port by vasild)\n* #19843 (Refactoring and minor improvement for self-advertisements by naumenkogs)\n* #19460 (multiprocess: Add bitcoin-wallet -ipcconnect option by ryanofsky)\n* #19315 ([tests] Allow outbound & block-relay-only connections in functional tests. by amitiuttarwar)\n* #18819 (net: Replace cs_feeFilter with simple std::atomic by MarcoFalke)\n* #18077 (net: Add NAT-PMP port forwarding support by hebasto)\n* #10102 ([experimental] Multiprocess bitcoin by ryanofsky)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "user": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/20864#issuecomment-755260797",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20864"
    },
    {
      "event": "reviewed",
      "id": 562714005,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyNzE0MDA1",
      "url": null,
      "actor": null,
      "commit_id": "fad2e1f267d60afe9799e431233f54f02d14e8e0",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "ACK fad2e1f267d60afe9799e431233f54f02d14e8e0\r\n\r\nNice tidy-up.",
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/20864#pullrequestreview-562714005",
      "submitted_at": "2021-01-06T13:43:17Z",
      "state": "COMMENTED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20864"
    },
    {
      "event": "reviewed",
      "id": 562948649,
      "node_id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyOTQ4NjQ5",
      "url": null,
      "actor": null,
      "commit_id": "fad2e1f267d60afe9799e431233f54f02d14e8e0",
      "commit_url": null,
      "created_at": null,
      "author_association": "MEMBER",
      "body": "ACK fad2e1f267d60afe9799e431233f54f02d14e8e0\r\nWith the suggestions in the commit messages on how to best show the diffs, the review was quite straight-forward and painless. 👌 ",
      "user": {
        "login": "theStack",
        "id": 91535,
        "node_id": "MDQ6VXNlcjkxNTM1",
        "avatar_url": "https://avatars.githubusercontent.com/u/91535?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/theStack",
        "html_url": "https://github.com/theStack",
        "followers_url": "https://api.github.com/users/theStack/followers",
        "following_url": "https://api.github.com/users/theStack/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/theStack/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/theStack/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/theStack/subscriptions",
        "organizations_url": "https://api.github.com/users/theStack/orgs",
        "repos_url": "https://api.github.com/users/theStack/repos",
        "events_url": "https://api.github.com/users/theStack/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/theStack/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/20864#pullrequestreview-562948649",
      "submitted_at": "2021-01-06T18:34:56Z",
      "state": "APPROVED",
      "pull_request_url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20864"
    },
    {
      "event": "commented",
      "id": 755818506,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1NTgxODUwNg==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/755818506",
      "actor": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-07T01:07:15Z",
      "updated_at": "2021-01-07T01:07:15Z",
      "author_association": "MEMBER",
      "body": "ACK fad2e1f267d60afe9799e431233f54f02d14e8e0",
      "user": {
        "login": "ajtowns",
        "id": 127186,
        "node_id": "MDQ6VXNlcjEyNzE4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ajtowns",
        "html_url": "https://github.com/ajtowns",
        "followers_url": "https://api.github.com/users/ajtowns/followers",
        "following_url": "https://api.github.com/users/ajtowns/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/ajtowns/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/ajtowns/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
        "organizations_url": "https://api.github.com/users/ajtowns/orgs",
        "repos_url": "https://api.github.com/users/ajtowns/repos",
        "events_url": "https://api.github.com/users/ajtowns/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/ajtowns/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/20864#issuecomment-755818506",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20864"
    },
    {
      "event": "labeled",
      "id": 4178783002,
      "node_id": "MDEyOkxhYmVsZWRFdmVudDQxNzg3ODMwMDI=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4178783002",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-07T08:36:31Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4178789404,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE3ODc4OTQwNA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4178789404",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-07T08:38:20Z"
    },
    {
      "event": "commented",
      "id": 755971118,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1NTk3MTExOA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/755971118",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-07T08:39:31Z",
      "updated_at": "2021-01-07T08:39:31Z",
      "author_association": "MEMBER",
      "body": "Rebased, should be trivial to re-ACK with git range-diff or from scratch",
      "user": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/20864#issuecomment-755971118",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20864"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTBhNzE3ODFhOTY0ZDk0NGRiOWVjYzAwMjY3NWVmMzIyNDlmNjJl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa0a71781a964d944db9ecc002675ef32249f62e",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/fa0a71781a964d944db9ecc002675ef32249f62e",
      "tree": {
        "sha": "b001c0b58787d6ccbbd4673e2daf8a27733afa15",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b001c0b58787d6ccbbd4673e2daf8a27733afa15"
      },
      "verification": {
        "verified": false,
        "reason": "no_user",
        "payload": "tree b001c0b58787d6ccbbd4673e2daf8a27733afa15\nparent f13e03cda272fb7c9b667b4f7afb4b00fd44c461\nauthor MarcoFalke <falke.marco@gmail.com> 1609915144 +0100\ncommitter MarcoFalke <falke.marco@gmail.com> 1610008849 +0100\n\nnet: Move CConnman/NetEventsInterface after CNode in header file\n\nCan be reviewed with --color-moved=dimmed-zebra --patience\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUhemgv+KqcMdyBrexUwlO2EBQZuNFnMnbPVOb6f+9ZYjz070Ut/SlA6kF/0GRQs\n4wmxwz+ZWJ2uiOwuxfJ8aBHGKwSwxKXz7I3O6Woe8AEVmoZjBFu38JfqewWSvCy9\nWtbIEKnhp+q3mW+T0sa2dV0R/XunoCuPwi2lnTkLSRix/o/OccWRVWRk1iOKE8Ww\n/MsdCL3CpwOSgUJvWMnmo81N6yafMiDC3VTXqbHt33np5hSJx0nkOOee+FBUPHDn\nhntPt6zBKNbMWtkx4DDtHmYDRCECITs/NK3WL+8axcdHsY3ujs8Ljj/zShDqAuKD\nqppb7B01XbCHTmn17JcXGUDFNWlg1ZHBY97V6fCTtSSOYoyrKzzmIpdfrEmxzcsz\nU9BERWoD7jp4qZazQpZaKOoCWnQDQ+MMZeWfa0ob+geOiPf542G6l0VoOBFz3SP7\nP9hwlESrY5El12l9Hq5202YOdHBoJrc9PdFgbt4ofOon7W4/4zjYNDCLNSFWX1fi\nrprkKGLK\n=mqin\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f13e03cda272fb7c9b667b4f7afb4b00fd44c461",
          "sha": "f13e03cda272fb7c9b667b4f7afb4b00fd44c461",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/f13e03cda272fb7c9b667b4f7afb4b00fd44c461"
        }
      ],
      "message": "net: Move CConnman/NetEventsInterface after CNode in header file\n\nCan be reviewed with --color-moved=dimmed-zebra --patience",
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-01-07T08:40:49Z"
      },
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-01-06T06:39:04Z"
      },
      "sha": "fa0a71781a964d944db9ecc002675ef32249f62e"
    },
    {
      "event": "committed",
      "id": null,
      "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTIxMDY4OWUyN2IwZDc4YjJmZTg5NGU1MWUzNjQxNzlkYjdhM2Nl",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa210689e27b0d78b2fe894e51e364179db7a3ce",
      "actor": null,
      "commit_id": null,
      "commit_url": null,
      "created_at": null,
      "html_url": "https://github.com/bitcoin/bitcoin/commit/fa210689e27b0d78b2fe894e51e364179db7a3ce",
      "tree": {
        "sha": "e16fa7470067c2a56adcc5cd44f9f14dcc73f5a4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e16fa7470067c2a56adcc5cd44f9f14dcc73f5a4"
      },
      "verification": {
        "verified": false,
        "reason": "no_user",
        "payload": "tree e16fa7470067c2a56adcc5cd44f9f14dcc73f5a4\nparent fa0a71781a964d944db9ecc002675ef32249f62e\nauthor MarcoFalke <falke.marco@gmail.com> 1609917148 +0100\ncommitter MarcoFalke <falke.marco@gmail.com> 1610008894 +0100\n\nnet: Move SocketSendData lock annotation to header\n\nAlso, add lock annotation to SendMessages\n\nCan be reviewed with \"--word-diff-regex=.\"\n",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE+rVPoUahrI9sLGYTzit1aX5ppUgFAlwqrYAACgkQzit1aX5p\npUhFiQwAlXbGugaShIxf2+T3H81KqIiMNsvfe3laGd6dRSuzqbHWeEQPbyu6mRK8\nMnOkekWxCrkRd0oI7aSl8KrYLPfyogI9ywN90kuBChfi2kmh9d4AChwe6fReFsYU\nwxkJj21c2jrePiHc6whTctAxaXXxrU3r4zajPOh2ZgUqYgwpJVb4SWBYkODKWy16\nylOpry/XmDhgFKyf/gcFfpZ2K0WgN9d6k2Elqu1IB/BT68aLkWg65X+XvEGtAjhS\nrP307B7ataCnN5SJ8Nj2Yo9jE4LzBII/bcspKQZW/Tm7UZzI0xZhhBgDEZ1LfCNi\nVVp6JvtWoGxLz0X11GK79F4gxXN30U/+WC7D2pfbUYEQ34gLfAFKDZO8rSl1mOcl\nWgY0FY8rDmd8I4BMbtw2L2FU2ImgWAtx+csu8yhYrvrkPU/fBYNYb1M0GJd8FrW+\ncoDLdBHiiBnN44l/DEN5dZAdWCOiUqB+8TNm0Kdy1PQsu0UOiR7DVMNiZyr9bKRN\n+raDxF0g\n=dVch\n-----END PGP SIGNATURE-----"
      },
      "parents": [
        {
          "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa0a71781a964d944db9ecc002675ef32249f62e",
          "sha": "fa0a71781a964d944db9ecc002675ef32249f62e",
          "html_url": "https://github.com/bitcoin/bitcoin/commit/fa0a71781a964d944db9ecc002675ef32249f62e"
        }
      ],
      "message": "net: Move SocketSendData lock annotation to header\n\nAlso, add lock annotation to SendMessages\n\nCan be reviewed with \"--word-diff-regex=.\"",
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-01-07T08:41:34Z"
      },
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2021-01-06T07:12:28Z"
      },
      "sha": "fa210689e27b0d78b2fe894e51e364179db7a3ce"
    },
    {
      "event": "head_ref_force_pushed",
      "id": 4178803320,
      "node_id": "MDIzOkhlYWRSZWZGb3JjZVB1c2hlZEV2ZW50NDE3ODgwMzMyMA==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4178803320",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-07T08:42:02Z"
    },
    {
      "event": "unlabeled",
      "id": 4178826631,
      "node_id": "MDE0OlVubGFiZWxlZEV2ZW50NDE3ODgyNjYzMQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4178826631",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-07T08:48:41Z",
      "label": {
        "name": "Needs rebase",
        "color": "cccccc"
      }
    },
    {
      "event": "commented",
      "id": 755991945,
      "node_id": "MDEyOklzc3VlQ29tbWVudDc1NTk5MTk0NQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/755991945",
      "actor": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-07T09:20:16Z",
      "updated_at": "2021-01-07T09:20:16Z",
      "author_association": "MEMBER",
      "body": "utACK fa210689e2",
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "html_url": "https://github.com/bitcoin/bitcoin/pull/20864#issuecomment-755991945",
      "issue_url": "https://api.github.com/repos/bitcoin/bitcoin/issues/20864"
    },
    {
      "event": "merged",
      "id": 4179996355,
      "node_id": "MDExOk1lcmdlZEV2ZW50NDE3OTk5NjM1NQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4179996355",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "42675e783337bf56dfc51df6c14931df5e72f185",
      "commit_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/42675e783337bf56dfc51df6c14931df5e72f185",
      "created_at": "2021-01-07T13:58:52Z"
    },
    {
      "event": "closed",
      "id": 4179996375,
      "node_id": "MDExOkNsb3NlZEV2ZW50NDE3OTk5NjM3NQ==",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4179996375",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-07T13:58:52Z"
    },
    {
      "event": "head_ref_deleted",
      "id": 4180001973,
      "node_id": "MDE5OkhlYWRSZWZEZWxldGVkRXZlbnQ0MTgwMDAxOTcz",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4180001973",
      "actor": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2021-01-07T14:00:15Z"
    },
    {
      "event": "referenced",
      "id": 4180466481,
      "node_id": "MDE1OlJlZmVyZW5jZWRFdmVudDQxODA0NjY0ODE=",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/4180466481",
      "actor": {
        "login": "sidhujag",
        "id": 6238042,
        "node_id": "MDQ6VXNlcjYyMzgwNDI=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6238042?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/sidhujag",
        "html_url": "https://github.com/sidhujag",
        "followers_url": "https://api.github.com/users/sidhujag/followers",
        "following_url": "https://api.github.com/users/sidhujag/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/sidhujag/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/sidhujag/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/sidhujag/subscriptions",
        "organizations_url": "https://api.github.com/users/sidhujag/orgs",
        "repos_url": "https://api.github.com/users/sidhujag/repos",
        "events_url": "https://api.github.com/users/sidhujag/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/sidhujag/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "52a356407c6873989a36e2c808873a46a91916fc",
      "commit_url": "https://api.github.com/repos/syscoin/syscoin/commits/52a356407c6873989a36e2c808873a46a91916fc",
      "created_at": "2021-01-07T15:45:10Z"
    },
    {
      "event": "referenced",
      "id": 5949634877,
      "node_id": "REFE_lADOABII584ugOAdzwAAAAFioDk9",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5949634877",
      "actor": {
        "login": "Fabcien",
        "id": 44533924,
        "node_id": "MDQ6VXNlcjQ0NTMzOTI0",
        "avatar_url": "https://avatars.githubusercontent.com/u/44533924?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Fabcien",
        "html_url": "https://github.com/Fabcien",
        "followers_url": "https://api.github.com/users/Fabcien/followers",
        "following_url": "https://api.github.com/users/Fabcien/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Fabcien/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Fabcien/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Fabcien/subscriptions",
        "organizations_url": "https://api.github.com/users/Fabcien/orgs",
        "repos_url": "https://api.github.com/users/Fabcien/repos",
        "events_url": "https://api.github.com/users/Fabcien/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Fabcien/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "018d4cef0cd3b15dee5adb0fb9421e09eded6d8a",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/018d4cef0cd3b15dee5adb0fb9421e09eded6d8a",
      "created_at": "2022-01-25T12:53:50Z"
    },
    {
      "event": "referenced",
      "id": 5949634885,
      "node_id": "REFE_lADOABII584ugOAdzwAAAAFioDlF",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/5949634885",
      "actor": {
        "login": "Fabcien",
        "id": 44533924,
        "node_id": "MDQ6VXNlcjQ0NTMzOTI0",
        "avatar_url": "https://avatars.githubusercontent.com/u/44533924?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Fabcien",
        "html_url": "https://github.com/Fabcien",
        "followers_url": "https://api.github.com/users/Fabcien/followers",
        "following_url": "https://api.github.com/users/Fabcien/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Fabcien/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Fabcien/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Fabcien/subscriptions",
        "organizations_url": "https://api.github.com/users/Fabcien/orgs",
        "repos_url": "https://api.github.com/users/Fabcien/repos",
        "events_url": "https://api.github.com/users/Fabcien/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Fabcien/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": "13db67570818298731b738712fd2bbaa4fa57235",
      "commit_url": "https://api.github.com/repos/Bitcoin-ABC/bitcoin-abc/commits/13db67570818298731b738712fd2bbaa4fa57235",
      "created_at": "2022-01-25T12:53:50Z"
    },
    {
      "event": "locked",
      "id": 7199003442,
      "node_id": "LOE_lADOABII584ugOAdzwAAAAGtGBMy",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7199003442",
      "actor": {
        "login": "DrahtBot",
        "id": 39886733,
        "node_id": "MDQ6VXNlcjM5ODg2NzMz",
        "avatar_url": "https://avatars.githubusercontent.com/u/39886733?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/DrahtBot",
        "html_url": "https://github.com/DrahtBot",
        "followers_url": "https://api.github.com/users/DrahtBot/followers",
        "following_url": "https://api.github.com/users/DrahtBot/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/DrahtBot/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/DrahtBot/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/DrahtBot/subscriptions",
        "organizations_url": "https://api.github.com/users/DrahtBot/orgs",
        "repos_url": "https://api.github.com/users/DrahtBot/repos",
        "events_url": "https://api.github.com/users/DrahtBot/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/DrahtBot/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-08-16T17:02:12Z",
      "lock_reason": "resolved"
    },
    {
      "event": "subscribed",
      "id": 7547080021,
      "node_id": "SE_lADOABII584ugOAdzwAAAAHB101V",
      "url": "https://api.github.com/repos/bitcoin/bitcoin/issues/events/7547080021",
      "actor": {
        "login": "Leylimahmud",
        "id": 99537361,
        "node_id": "U_kgDOBe7R0Q",
        "avatar_url": "https://avatars.githubusercontent.com/u/99537361?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/Leylimahmud",
        "html_url": "https://github.com/Leylimahmud",
        "followers_url": "https://api.github.com/users/Leylimahmud/followers",
        "following_url": "https://api.github.com/users/Leylimahmud/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/Leylimahmud/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/Leylimahmud/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/Leylimahmud/subscriptions",
        "organizations_url": "https://api.github.com/users/Leylimahmud/orgs",
        "repos_url": "https://api.github.com/users/Leylimahmud/repos",
        "events_url": "https://api.github.com/users/Leylimahmud/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/Leylimahmud/received_events",
        "type": "User",
        "site_admin": false
      },
      "commit_id": null,
      "commit_url": null,
      "created_at": "2022-10-07T23:45:43Z"
    }
  ],
  "comments": [
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/552621025",
      "pull_request_review_id": 562714005,
      "id": 552621025,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjYyMTAyNQ==",
      "diff_hunk": "@@ -180,1041 +180,1040 @@ enum class ConnectionType {\n     ADDR_FETCH,\n };\n \n-class NetEventsInterface;\n-class CConnman\n-{\n-public:\n-\n-    enum NumConnections {\n-        CONNECTIONS_NONE = 0,\n-        CONNECTIONS_IN = (1U << 0),\n-        CONNECTIONS_OUT = (1U << 1),\n-        CONNECTIONS_ALL = (CONNECTIONS_IN | CONNECTIONS_OUT),\n-    };\n-\n-    struct Options\n-    {\n-        ServiceFlags nLocalServices = NODE_NONE;\n-        int nMaxConnections = 0;\n-        int m_max_outbound_full_relay = 0;\n-        int m_max_outbound_block_relay = 0;\n-        int nMaxAddnode = 0;\n-        int nMaxFeeler = 0;\n-        CClientUIInterface* uiInterface = nullptr;\n-        NetEventsInterface* m_msgproc = nullptr;\n-        BanMan* m_banman = nullptr;\n-        unsigned int nSendBufferMaxSize = 0;\n-        unsigned int nReceiveFloodSize = 0;\n-        uint64_t nMaxOutboundLimit = 0;\n-        int64_t m_peer_connect_timeout = DEFAULT_PEER_CONNECT_TIMEOUT;\n-        std::vector<std::string> vSeedNodes;\n-        std::vector<NetWhitelistPermissions> vWhitelistedRange;\n-        std::vector<NetWhitebindPermissions> vWhiteBinds;\n-        std::vector<CService> vBinds;\n-        std::vector<CService> onion_binds;\n-        bool m_use_addrman_outgoing = true;\n-        std::vector<std::string> m_specified_outgoing;\n-        std::vector<std::string> m_added_nodes;\n-        std::vector<bool> m_asmap;\n-    };\n-\n-    void Init(const Options& connOptions) {\n-        nLocalServices = connOptions.nLocalServices;\n-        nMaxConnections = connOptions.nMaxConnections;\n-        m_max_outbound_full_relay = std::min(connOptions.m_max_outbound_full_relay, connOptions.nMaxConnections);\n-        m_max_outbound_block_relay = connOptions.m_max_outbound_block_relay;\n-        m_use_addrman_outgoing = connOptions.m_use_addrman_outgoing;\n-        nMaxAddnode = connOptions.nMaxAddnode;\n-        nMaxFeeler = connOptions.nMaxFeeler;\n-        m_max_outbound = m_max_outbound_full_relay + m_max_outbound_block_relay + nMaxFeeler;\n-        clientInterface = connOptions.uiInterface;\n-        m_banman = connOptions.m_banman;\n-        m_msgproc = connOptions.m_msgproc;\n-        nSendBufferMaxSize = connOptions.nSendBufferMaxSize;\n-        nReceiveFloodSize = connOptions.nReceiveFloodSize;\n-        m_peer_connect_timeout = connOptions.m_peer_connect_timeout;\n-        {\n-            LOCK(cs_totalBytesSent);\n-            nMaxOutboundLimit = connOptions.nMaxOutboundLimit;\n-        }\n-        vWhitelistedRange = connOptions.vWhitelistedRange;\n-        {\n-            LOCK(cs_vAddedNodes);\n-            vAddedNodes = connOptions.m_added_nodes;\n-        }\n-        m_onion_binds = connOptions.onion_binds;\n-    }\n-\n-    CConnman(uint64_t seed0, uint64_t seed1, bool network_active = true);\n-    ~CConnman();\n-    bool Start(CScheduler& scheduler, const Options& options);\n-\n-    void StopThreads();\n-    void StopNodes();\n-    void Stop()\n-    {\n-        StopThreads();\n-        StopNodes();\n-    };\n-\n-    void Interrupt();\n-    bool GetNetworkActive() const { return fNetworkActive; };\n-    bool GetUseAddrmanOutgoing() const { return m_use_addrman_outgoing; };\n-    void SetNetworkActive(bool active);\n-    void OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant* grantOutbound, const char* strDest, ConnectionType conn_type);\n-    bool CheckIncomingNonce(uint64_t nonce);\n-\n-    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func);\n-\n-    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg);\n-\n-    using NodeFn = std::function<void(CNode*)>;\n-    void ForEachNode(const NodeFn& func)\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                func(node);\n-        }\n-    };\n-\n-    void ForEachNode(const NodeFn& func) const\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                func(node);\n-        }\n-    };\n-\n-    template<typename Callable, typename CallableAfter>\n-    void ForEachNodeThen(Callable&& pre, CallableAfter&& post)\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                pre(node);\n-        }\n-        post();\n-    };\n+void Discover();\n+void StartMapPort();\n+void InterruptMapPort();\n+void StopMapPort();\n+uint16_t GetListenPort();\n \n-    template<typename Callable, typename CallableAfter>\n-    void ForEachNodeThen(Callable&& pre, CallableAfter&& post) const\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                pre(node);\n-        }\n-        post();\n-    };\n+enum\n+{\n+    LOCAL_NONE,   // unknown\n+    LOCAL_IF,     // address a local interface listens on\n+    LOCAL_BIND,   // address explicit bound to\n+    LOCAL_UPNP,   // address reported by UPnP\n+    LOCAL_MANUAL, // address explicitly specified (-externalip=)\n \n-    // Addrman functions\n-    void SetServices(const CService &addr, ServiceFlags nServices);\n-    void MarkAddressGood(const CAddress& addr);\n-    bool AddNewAddresses(const std::vector<CAddress>& vAddr, const CAddress& addrFrom, int64_t nTimePenalty = 0);\n-    std::vector<CAddress> GetAddresses(size_t max_addresses, size_t max_pct);\n-    /**\n-     * Cache is used to minimize topology leaks, so it should\n-     * be used for all non-trusted calls, for example, p2p.\n-     * A non-malicious call (from RPC or a peer with addr permission) should\n-     * call the function without a parameter to avoid using the cache.\n-     */\n-    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct);\n+    LOCAL_MAX\n+};\n \n-    // This allows temporarily exceeding m_max_outbound_full_relay, with the goal of finding\n-    // a peer that is better than all our current peers.\n-    void SetTryNewOutboundPeer(bool flag);\n-    bool GetTryNewOutboundPeer();\n+bool IsPeerAddrLocalGood(CNode *pnode);\n+void AdvertiseLocal(CNode *pnode);\n \n-    void StartExtraBlockRelayPeers() {\n-        LogPrint(BCLog::NET, \"net: enabling extra block-relay-only peers\\n\");\n-        m_start_extra_block_relay_peers = true;\n-    }\n+/**\n+ * Mark a network as reachable or unreachable (no automatic connects to it)\n+ * @note Networks are reachable by default\n+ */\n+void SetReachable(enum Network net, bool reachable);\n+/** @returns true if the network is reachable, false otherwise */\n+bool IsReachable(enum Network net);\n+/** @returns true if the address is in a reachable network, false otherwise */\n+bool IsReachable(const CNetAddr& addr);\n \n-    // Return the number of outbound peers we have in excess of our target (eg,\n-    // if we previously called SetTryNewOutboundPeer(true), and have since set\n-    // to false, we may have extra peers that we wish to disconnect). This may\n-    // return a value less than (num_outbound_connections - num_outbound_slots)\n-    // in cases where some outbound connections are not yet fully connected, or\n-    // not yet fully disconnected.\n-    int GetExtraFullOutboundCount();\n-    // Count the number of block-relay-only peers we have over our limit.\n-    int GetExtraBlockRelayCount();\n+bool AddLocal(const CService& addr, int nScore = LOCAL_NONE);\n+bool AddLocal(const CNetAddr& addr, int nScore = LOCAL_NONE);\n+void RemoveLocal(const CService& addr);\n+bool SeenLocal(const CService& addr);\n+bool IsLocal(const CService& addr);\n+bool GetLocal(CService &addr, const CNetAddr *paddrPeer = nullptr);\n+CAddress GetLocalAddress(const CNetAddr *paddrPeer, ServiceFlags nLocalServices);\n \n-    bool AddNode(const std::string& node);\n-    bool RemoveAddedNode(const std::string& node);\n-    std::vector<AddedNodeInfo> GetAddedNodeInfo();\n \n-    size_t GetNodeCount(NumConnections num);\n-    void GetNodeStats(std::vector<CNodeStats>& vstats);\n-    bool DisconnectNode(const std::string& node);\n-    bool DisconnectNode(const CSubNet& subnet);\n-    bool DisconnectNode(const CNetAddr& addr);\n-    bool DisconnectNode(NodeId id);\n+extern bool fDiscover;\n+extern bool fListen;\n \n-    //! Used to convey which local services we are offering peers during node\n-    //! connection.\n-    //!\n-    //! The data returned by this is used in CNode construction,\n-    //! which is used to advertise which services we are offering\n-    //! that peer during `net_processing.cpp:PushNodeVersion()`.\n-    ServiceFlags GetLocalServices() const;\n+/** Subversion as sent to the P2P network in `version` messages */\n+extern std::string strSubVersion;\n \n-    uint64_t GetMaxOutboundTarget();\n-    std::chrono::seconds GetMaxOutboundTimeframe();\n+struct LocalServiceInfo {\n+    int nScore;\n+    int nPort;\n+};\n \n-    //! check if the outbound target is reached\n-    //! if param historicalBlockServingLimit is set true, the function will\n-    //! response true if the limit for serving historical blocks has been reached\n-    bool OutboundTargetReached(bool historicalBlockServingLimit);\n+extern RecursiveMutex cs_mapLocalHost;\n+extern std::map<CNetAddr, LocalServiceInfo> mapLocalHost GUARDED_BY(cs_mapLocalHost);\n \n-    //! response the bytes left in the current max outbound cycle\n-    //! in case of no limit, it will always response 0\n-    uint64_t GetOutboundTargetBytesLeft();\n+extern const std::string NET_MESSAGE_COMMAND_OTHER;\n+typedef std::map<std::string, uint64_t> mapMsgCmdSize; //command, total bytes\n \n-    //! returns the time left in the current max outbound cycle\n-    //! in case of no limit, it will always return 0\n-    std::chrono::seconds GetMaxOutboundTimeLeftInCycle();\n+class CNodeStats\n+{\n+public:\n+    NodeId nodeid;\n+    ServiceFlags nServices;\n+    bool fRelayTxes;\n+    int64_t nLastSend;\n+    int64_t nLastRecv;\n+    int64_t nLastTXTime;\n+    int64_t nLastBlockTime;\n+    int64_t nTimeConnected;\n+    int64_t nTimeOffset;\n+    std::string addrName;\n+    int nVersion;\n+    std::string cleanSubVer;\n+    bool fInbound;\n+    bool m_bip152_highbandwidth_to;\n+    bool m_bip152_highbandwidth_from;\n+    int m_starting_height;\n+    uint64_t nSendBytes;\n+    mapMsgCmdSize mapSendBytesPerMsgCmd;\n+    uint64_t nRecvBytes;\n+    mapMsgCmdSize mapRecvBytesPerMsgCmd;\n+    NetPermissionFlags m_permissionFlags;\n+    int64_t m_ping_usec;\n+    int64_t m_ping_wait_usec;\n+    int64_t m_min_ping_usec;\n+    CAmount minFeeFilter;\n+    // Our address, as reported by the peer\n+    std::string addrLocal;\n+    // Address of this peer\n+    CAddress addr;\n+    // Bind address of our side of the connection\n+    CAddress addrBind;\n+    // Network the peer connected through\n+    Network m_network;\n+    uint32_t m_mapped_as;\n+    std::string m_conn_type_string;\n+};\n \n-    uint64_t GetTotalBytesRecv();\n-    uint64_t GetTotalBytesSent();\n \n-    /** Get a unique deterministic randomizer. */\n-    CSipHasher GetDeterministicRandomizer(uint64_t id) const;\n \n-    unsigned int GetReceiveFloodSize() const;\n+/** Transport protocol agnostic message container.\n+ * Ideally it should only contain receive time, payload,\n+ * command and size.\n+ */\n+class CNetMessage {\n+public:\n+    CDataStream m_recv;                  //!< received message data\n+    std::chrono::microseconds m_time{0}; //!< time of message receipt\n+    uint32_t m_message_size{0};          //!< size of the payload\n+    uint32_t m_raw_message_size{0};      //!< used wire size of the message (including header/checksum)\n+    std::string m_command;\n \n-    void WakeMessageHandler();\n+    CNetMessage(CDataStream&& recv_in) : m_recv(std::move(recv_in)) {}\n \n-    /** Attempts to obfuscate tx time through exponentially distributed emitting.\n-        Works assuming that a single interval is used.\n-        Variable intervals will result in privacy decrease.\n-    */\n-    int64_t PoissonNextSendInbound(int64_t now, int average_interval_seconds);\n+    void SetVersion(int nVersionIn)\n+    {\n+        m_recv.SetVersion(nVersionIn);\n+    }\n+};\n \n-    void SetAsmap(std::vector<bool> asmap) { addrman.m_asmap = std::move(asmap); }\n+/** The TransportDeserializer takes care of holding and deserializing the\n+ * network receive buffer. It can deserialize the network buffer into a\n+ * transport protocol agnostic CNetMessage (command & payload)\n+ */\n+class TransportDeserializer {\n+public:\n+    // returns true if the current deserialization is complete\n+    virtual bool Complete() const = 0;\n+    // set the serialization context version\n+    virtual void SetVersion(int version) = 0;\n+    /** read and deserialize data, advances msg_bytes data pointer */\n+    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n+    // decomposes a message from the context\n+    virtual Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err) = 0;\n+    virtual ~TransportDeserializer() {}\n+};\n \n+class V1TransportDeserializer final : public TransportDeserializer\n+{\n private:\n-    struct ListenSocket {\n-    public:\n-        SOCKET socket;\n-        inline void AddSocketPermissionFlags(NetPermissionFlags& flags) const { NetPermissions::AddFlag(flags, m_permissions); }\n-        ListenSocket(SOCKET socket_, NetPermissionFlags permissions_) : socket(socket_), m_permissions(permissions_) {}\n-    private:\n-        NetPermissionFlags m_permissions;\n-    };\n-\n-    bool BindListenPort(const CService& bindAddr, bilingual_str& strError, NetPermissionFlags permissions);\n-    bool Bind(const CService& addr, unsigned int flags, NetPermissionFlags permissions);\n-    bool InitBinds(\n-        const std::vector<CService>& binds,\n-        const std::vector<NetWhitebindPermissions>& whiteBinds,\n-        const std::vector<CService>& onion_binds);\n-\n-    void ThreadOpenAddedConnections();\n-    void AddAddrFetch(const std::string& strDest);\n-    void ProcessAddrFetch();\n-    void ThreadOpenConnections(std::vector<std::string> connect);\n-    void ThreadMessageHandler();\n-    void AcceptConnection(const ListenSocket& hListenSocket);\n-    void DisconnectNodes();\n-    void NotifyNumConnectionsChanged();\n-    void InactivityCheck(CNode *pnode);\n-    bool GenerateSelectSet(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n-    void SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n-    void SocketHandler();\n-    void ThreadSocketHandler();\n-    void ThreadDNSAddressSeed();\n-\n-    uint64_t CalculateKeyedNetGroup(const CAddress& ad) const;\n-\n-    CNode* FindNode(const CNetAddr& ip);\n-    CNode* FindNode(const CSubNet& subNet);\n-    CNode* FindNode(const std::string& addrName);\n-    CNode* FindNode(const CService& addr);\n-\n-    /**\n-     * Determine whether we're already connected to a given address, in order to\n-     * avoid initiating duplicate connections.\n-     */\n-    bool AlreadyConnectedToAddress(const CAddress& addr);\n-\n-    bool AttemptToEvictConnection();\n-    CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, ConnectionType conn_type);\n-    void AddWhitelistPermissionFlags(NetPermissionFlags& flags, const CNetAddr &addr) const;\n-\n-    void DeleteNode(CNode* pnode);\n+    const CChainParams& m_chain_params;\n+    const NodeId m_node_id; // Only for logging\n+    mutable CHash256 hasher;\n+    mutable uint256 data_hash;\n+    bool in_data;                   // parsing header (false) or data (true)\n+    CDataStream hdrbuf;             // partially received header\n+    CMessageHeader hdr;             // complete header\n+    CDataStream vRecv;              // received message data\n+    unsigned int nHdrPos;\n+    unsigned int nDataPos;\n \n-    NodeId GetNewNodeId();\n+    const uint256& GetMessageHash() const;\n+    int readHeader(Span<const uint8_t> msg_bytes);\n+    int readData(Span<const uint8_t> msg_bytes);\n \n-    size_t SocketSendData(CNode *pnode) const;\n-    void DumpAddresses();\n+    void Reset() {\n+        vRecv.clear();\n+        hdrbuf.clear();\n+        hdrbuf.resize(24);\n+        in_data = false;\n+        nHdrPos = 0;\n+        nDataPos = 0;\n+        data_hash.SetNull();\n+        hasher.Reset();\n+    }\n \n-    // Network stats\n-    void RecordBytesRecv(uint64_t bytes);\n-    void RecordBytesSent(uint64_t bytes);\n+public:\n+    V1TransportDeserializer(const CChainParams& chain_params, const NodeId node_id, int nTypeIn, int nVersionIn)\n+        : m_chain_params(chain_params),\n+          m_node_id(node_id),\n+          hdrbuf(nTypeIn, nVersionIn),\n+          vRecv(nTypeIn, nVersionIn)\n+    {\n+        Reset();\n+    }\n \n-    /**\n-     * Return vector of current BLOCK_RELAY peers.\n-     */\n-    std::vector<CAddress> GetCurrentBlockRelayOnlyConns() const;\n+    bool Complete() const override\n+    {\n+        if (!in_data)\n+            return false;\n+        return (hdr.nMessageSize == nDataPos);\n+    }\n+    void SetVersion(int nVersionIn) override\n+    {\n+        hdrbuf.SetVersion(nVersionIn);\n+        vRecv.SetVersion(nVersionIn);\n+    }\n+    int Read(Span<const uint8_t>& msg_bytes) override\n+    {\n+        int ret = in_data ? readData(msg_bytes) : readHeader(msg_bytes);\n+        if (ret < 0) {\n+            Reset();\n+        } else {\n+            msg_bytes = msg_bytes.subspan(ret);\n+        }\n+        return ret;\n+    }\n+    Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err_raw_size) override;\n+};\n \n-    // Whether the node should be passed out in ForEach* callbacks\n-    static bool NodeFullyConnected(const CNode* pnode);\n+/** The TransportSerializer prepares messages for the network transport\n+ */\n+class TransportSerializer {\n+public:\n+    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n+    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) = 0;\n+    virtual ~TransportSerializer() {}\n+};\n \n-    // Network usage totals\n-    RecursiveMutex cs_totalBytesRecv;\n-    RecursiveMutex cs_totalBytesSent;\n-    uint64_t nTotalBytesRecv GUARDED_BY(cs_totalBytesRecv) {0};\n-    uint64_t nTotalBytesSent GUARDED_BY(cs_totalBytesSent) {0};\n+class V1TransportSerializer  : public TransportSerializer {\n+public:\n+    void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) override;\n+};\n \n-    // outbound limit & stats\n-    uint64_t nMaxOutboundTotalBytesSentInCycle GUARDED_BY(cs_totalBytesSent) {0};\n-    std::chrono::seconds nMaxOutboundCycleStartTime GUARDED_BY(cs_totalBytesSent) {0};\n-    uint64_t nMaxOutboundLimit GUARDED_BY(cs_totalBytesSent);\n+/** Information about a peer */\n+class CNode\n+{\n+    friend class CConnman;\n+    friend struct ConnmanTestMsg;\n \n-    // P2P timeout in seconds\n-    int64_t m_peer_connect_timeout;\n+public:\n+    std::unique_ptr<TransportDeserializer> m_deserializer;\n+    std::unique_ptr<TransportSerializer> m_serializer;\n \n-    // Whitelisted ranges. Any node connecting from these is automatically\n-    // whitelisted (as well as those connecting to whitelisted binds).\n-    std::vector<NetWhitelistPermissions> vWhitelistedRange;\n+    // socket\n+    std::atomic<ServiceFlags> nServices{NODE_NONE};\n+    SOCKET hSocket GUARDED_BY(cs_hSocket);\n+    /** Total size of all vSendMsg entries */\n+    size_t nSendSize GUARDED_BY(cs_vSend){0};\n+    /** Offset inside the first vSendMsg already sent */\n+    size_t nSendOffset GUARDED_BY(cs_vSend){0};\n+    uint64_t nSendBytes GUARDED_BY(cs_vSend){0};\n+    std::deque<std::vector<unsigned char>> vSendMsg GUARDED_BY(cs_vSend);\n+    Mutex cs_vSend;\n+    Mutex cs_hSocket;\n+    Mutex cs_vRecv;\n \n-    unsigned int nSendBufferMaxSize{0};\n-    unsigned int nReceiveFloodSize{0};\n+    RecursiveMutex cs_vProcessMsg;\n+    std::list<CNetMessage> vProcessMsg GUARDED_BY(cs_vProcessMsg);\n+    size_t nProcessQueueSize{0};\n \n-    std::vector<ListenSocket> vhListenSocket;\n-    std::atomic<bool> fNetworkActive{true};\n-    bool fAddressesInitialized{false};\n-    CAddrMan addrman;\n-    std::deque<std::string> m_addr_fetches GUARDED_BY(m_addr_fetches_mutex);\n-    RecursiveMutex m_addr_fetches_mutex;\n-    std::vector<std::string> vAddedNodes GUARDED_BY(cs_vAddedNodes);\n-    RecursiveMutex cs_vAddedNodes;\n-    std::vector<CNode*> vNodes GUARDED_BY(cs_vNodes);\n-    std::list<CNode*> vNodesDisconnected;\n-    mutable RecursiveMutex cs_vNodes;\n-    std::atomic<NodeId> nLastNodeId{0};\n-    unsigned int nPrevNodeCount{0};\n+    RecursiveMutex cs_sendProcessing;\n \n-    /**\n-     * Cache responses to addr requests to minimize privacy leak.\n-     * Attack example: scraping addrs in real-time may allow an attacker\n-     * to infer new connections of the victim by detecting new records\n-     * with fresh timestamps (per self-announcement).\n-     */\n-    struct CachedAddrResponse {\n-        std::vector<CAddress> m_addrs_response_cache;\n-        std::chrono::microseconds m_cache_entry_expiration{0};\n-    };\n+    uint64_t nRecvBytes GUARDED_BY(cs_vRecv){0};\n \n+    std::atomic<int64_t> nLastSend{0};\n+    std::atomic<int64_t> nLastRecv{0};\n+    const int64_t nTimeConnected;\n+    std::atomic<int64_t> nTimeOffset{0};\n+    // Address of this peer\n+    const CAddress addr;\n+    // Bind address of our side of the connection\n+    const CAddress addrBind;\n+    std::atomic<int> nVersion{0};\n+    RecursiveMutex cs_SubVer;\n     /**\n-     * Addr responses stored in different caches\n-     * per (network, local socket) prevent cross-network node identification.\n-     * If a node for example is multi-homed under Tor and IPv6,\n-     * a single cache (or no cache at all) would let an attacker\n-     * to easily detect that it is the same node by comparing responses.\n-     * Indexing by local socket prevents leakage when a node has multiple\n-     * listening addresses on the same network.\n-     *\n-     * The used memory equals to 1000 CAddress records (or around 40 bytes) per\n-     * distinct Network (up to 5) we have/had an inbound peer from,\n-     * resulting in at most ~196 KB. Every separate local socket may\n-     * add up to ~196 KB extra.\n+     * cleanSubVer is a sanitized string of the user agent byte array we read\n+     * from the wire. This cleaned string can safely be logged or displayed.\n      */\n-    std::map<uint64_t, CachedAddrResponse> m_addr_response_caches;\n-\n+    std::string cleanSubVer GUARDED_BY(cs_SubVer){};\n+    bool m_prefer_evict{false}; // This peer is preferred for eviction.\n+    bool HasPermission(NetPermissionFlags permission) const {\n+        return NetPermissions::HasFlag(m_permissionFlags, permission);\n+    }\n+    bool fClient{false}; // set by version message\n+    bool m_limited_node{false}; //after BIP159, set by version message\n     /**\n-     * Services this instance offers.\n-     *\n-     * This data is replicated in each CNode instance we create during peer\n-     * connection (in ConnectNode()) under a member also called\n-     * nLocalServices.\n-     *\n-     * This data is not marked const, but after being set it should not\n-     * change. See the note in CNode::nLocalServices documentation.\n-     *\n-     * \\sa CNode::nLocalServices\n+     * Whether the peer has signaled support for receiving ADDRv2 (BIP155)\n+     * messages, implying a preference to receive ADDRv2 instead of ADDR ones.\n      */\n-    ServiceFlags nLocalServices;\n-\n-    std::unique_ptr<CSemaphore> semOutbound;\n-    std::unique_ptr<CSemaphore> semAddnode;\n-    int nMaxConnections;\n+    std::atomic_bool m_wants_addrv2{false};\n+    std::atomic_bool fSuccessfullyConnected{false};\n+    // Setting fDisconnect to true will cause the node to be disconnected the\n+    // next time DisconnectNodes() runs\n+    std::atomic_bool fDisconnect{false};\n+    bool fSentAddr{false};\n+    CSemaphoreGrant grantOutbound;\n+    std::atomic<int> nRefCount{0};\n \n-    // How many full-relay (tx, block, addr) outbound peers we want\n-    int m_max_outbound_full_relay;\n+    const uint64_t nKeyedNetGroup;\n+    std::atomic_bool fPauseRecv{false};\n+    std::atomic_bool fPauseSend{false};\n \n-    // How many block-relay only outbound peers we want\n-    // We do not relay tx or addr messages with these peers\n-    int m_max_outbound_block_relay;\n+    bool IsOutboundOrBlockRelayConn() const {\n+        switch (m_conn_type) {\n+            case ConnectionType::OUTBOUND_FULL_RELAY:\n+            case ConnectionType::BLOCK_RELAY:\n+                return true;\n+            case ConnectionType::INBOUND:\n+            case ConnectionType::MANUAL:\n+            case ConnectionType::ADDR_FETCH:\n+            case ConnectionType::FEELER:\n+                return false;\n+        } // no default case, so the compiler can warn about missing cases\n \n-    int nMaxAddnode;\n-    int nMaxFeeler;\n-    int m_max_outbound;\n-    bool m_use_addrman_outgoing;\n-    CClientUIInterface* clientInterface;\n-    NetEventsInterface* m_msgproc;\n-    /** Pointer to this node's banman. May be nullptr - check existence before dereferencing. */\n-    BanMan* m_banman;\n+        assert(false);\n+    }\n \n-    /**\n-     * Addresses that were saved during the previous clean shutdown. We'll\n-     * attempt to make block-relay-only connections to them.\n-     */\n-    std::vector<CAddress> m_anchors;\n+    bool IsFullOutboundConn() const {\n+        return m_conn_type == ConnectionType::OUTBOUND_FULL_RELAY;\n+    }\n \n-    /** SipHasher seeds for deterministic randomness */\n-    const uint64_t nSeed0, nSeed1;\n+    bool IsManualConn() const {\n+        return m_conn_type == ConnectionType::MANUAL;\n+    }\n \n-    /** flag for waking the message processor. */\n-    bool fMsgProcWake GUARDED_BY(mutexMsgProc);\n+    bool IsBlockOnlyConn() const {\n+        return m_conn_type == ConnectionType::BLOCK_RELAY;\n+    }\n \n-    std::condition_variable condMsgProc;\n-    Mutex mutexMsgProc;\n-    std::atomic<bool> flagInterruptMsgProc{false};\n+    bool IsFeelerConn() const {\n+        return m_conn_type == ConnectionType::FEELER;\n+    }\n \n-    CThreadInterrupt interruptNet;\n+    bool IsAddrFetchConn() const {\n+        return m_conn_type == ConnectionType::ADDR_FETCH;\n+    }\n \n-    std::thread threadDNSAddressSeed;\n-    std::thread threadSocketHandler;\n-    std::thread threadOpenAddedConnections;\n-    std::thread threadOpenConnections;\n-    std::thread threadMessageHandler;\n+    bool IsInboundConn() const {\n+        return m_conn_type == ConnectionType::INBOUND;\n+    }\n \n-    /** flag for deciding to connect to an extra outbound peer,\n-     *  in excess of m_max_outbound_full_relay\n-     *  This takes the place of a feeler connection */\n-    std::atomic_bool m_try_another_outbound_peer;\n+    /* Whether we send addr messages over this connection */\n+    bool RelayAddrsWithConn() const\n+    {\n+        // Don't relay addr messages to peers that we connect to as block-relay-only\n+        // peers (to prevent adversaries from inferring these links from addr\n+        // traffic).\n+        return m_conn_type != ConnectionType::BLOCK_RELAY;\n+    }\n \n-    /** flag for initiating extra block-relay-only peer connections.\n-     *  this should only be enabled after initial chain sync has occurred,\n-     *  as these connections are intended to be short-lived and low-bandwidth.\n-     */\n-    std::atomic_bool m_start_extra_block_relay_peers{false};\n+    bool ExpectServicesFromConn() const {\n+        switch (m_conn_type) {\n+            case ConnectionType::INBOUND:\n+            case ConnectionType::MANUAL:\n+            case ConnectionType::FEELER:\n+                return false;\n+            case ConnectionType::OUTBOUND_FULL_RELAY:\n+            case ConnectionType::BLOCK_RELAY:\n+            case ConnectionType::ADDR_FETCH:\n+                return true;\n+        } // no default case, so the compiler can warn about missing cases\n \n-    std::atomic<int64_t> m_next_send_inv_to_incoming{0};\n+        assert(false);\n+    }\n \n     /**\n-     * A vector of -bind=<address>:<port>=onion arguments each of which is\n-     * an address and port that are designated for incoming Tor connections.\n+     * Get network the peer connected through.\n+     *\n+     * Returns Network::NET_ONION for *inbound* onion connections,\n+     * and CNetAddr::GetNetClass() otherwise. The latter cannot be used directly\n+     * because it doesn't detect the former, and it's not the responsibility of\n+     * the CNetAddr class to know the actual network a peer is connected through.\n+     *\n+     * @return network the peer connected through.\n      */\n-    std::vector<CService> m_onion_binds;\n+    Network ConnectedThroughNetwork() const;\n \n-    friend struct CConnmanTest;\n-    friend struct ConnmanTestMsg;\n-};\n-void Discover();\n-void StartMapPort();\n-void InterruptMapPort();\n-void StopMapPort();\n-uint16_t GetListenPort();\n+protected:\n+    mapMsgCmdSize mapSendBytesPerMsgCmd GUARDED_BY(cs_vSend);\n+    mapMsgCmdSize mapRecvBytesPerMsgCmd GUARDED_BY(cs_vRecv);\n \n-/**\n- * Interface for message handling\n- */\n-class NetEventsInterface\n-{\n public:\n-    virtual bool ProcessMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n-    virtual bool SendMessages(CNode* pnode) = 0;\n-    virtual void InitializeNode(CNode* pnode) = 0;\n-    virtual void FinalizeNode(const CNode& node, bool& update_connection_time) = 0;\n+    // We selected peer as (compact blocks) high-bandwidth peer (BIP152)\n+    std::atomic<bool> m_bip152_highbandwidth_to{false};\n+    // Peer selected us as (compact blocks) high-bandwidth peer (BIP152)\n+    std::atomic<bool> m_bip152_highbandwidth_from{false};\n+\n+    // flood relay\n+    std::vector<CAddress> vAddrToSend;\n+    std::unique_ptr<CRollingBloomFilter> m_addr_known{nullptr};\n+    bool fGetAddr{false};\n+    std::chrono::microseconds m_next_addr_send GUARDED_BY(cs_sendProcessing){0};\n+    std::chrono::microseconds m_next_local_addr_send GUARDED_BY(cs_sendProcessing){0};\n+\n+    struct TxRelay {\n+        mutable RecursiveMutex cs_filter;\n+        // We use fRelayTxes for two purposes -\n+        // a) it allows us to not relay tx invs before receiving the peer's version message\n+        // b) the peer may tell us in its version message that we should not relay tx invs\n+        //    unless it loads a bloom filter.\n+        bool fRelayTxes GUARDED_BY(cs_filter){false};\n+        std::unique_ptr<CBloomFilter> pfilter PT_GUARDED_BY(cs_filter) GUARDED_BY(cs_filter){nullptr};\n+\n+        mutable RecursiveMutex cs_tx_inventory;\n+        CRollingBloomFilter filterInventoryKnown GUARDED_BY(cs_tx_inventory){50000, 0.000001};\n+        // Set of transaction ids we still have to announce.\n+        // They are sorted by the mempool before relay, so the order is not important.\n+        std::set<uint256> setInventoryTxToSend;\n+        // Used for BIP35 mempool sending\n+        bool fSendMempool GUARDED_BY(cs_tx_inventory){false};\n+        // Last time a \"MEMPOOL\" request was serviced.\n+        std::atomic<std::chrono::seconds> m_last_mempool_req{0s};\n+        std::chrono::microseconds nNextInvSend{0};\n \n-protected:\n-    /**\n-     * Protected destructor so that instances can only be deleted by derived classes.\n-     * If that restriction is no longer desired, this should be made public and virtual.\n-     */\n-    ~NetEventsInterface() = default;\n-};\n+        RecursiveMutex cs_feeFilter;\n+        // Minimum fee rate with which to filter inv's to this node\n+        CAmount minFeeFilter GUARDED_BY(cs_feeFilter){0};\n+        CAmount lastSentFeeFilter{0};\n+        int64_t nextSendTimeFeeFilter{0};\n+    };\n \n-enum\n-{\n-    LOCAL_NONE,   // unknown\n-    LOCAL_IF,     // address a local interface listens on\n-    LOCAL_BIND,   // address explicit bound to\n-    LOCAL_UPNP,   // address reported by UPnP\n-    LOCAL_MANUAL, // address explicitly specified (-externalip=)\n+    // m_tx_relay == nullptr if we're not relaying transactions with this peer\n+    std::unique_ptr<TxRelay> m_tx_relay;\n \n-    LOCAL_MAX\n-};\n+    /** UNIX epoch time of the last block received from this peer that we had\n+     * not yet seen (e.g. not already received from another peer), that passed\n+     * preliminary validity checks and was saved to disk, even if we don't\n+     * connect the block or it eventually fails connection. Used as an inbound\n+     * peer eviction criterium in CConnman::AttemptToEvictConnection. */\n+    std::atomic<int64_t> nLastBlockTime{0};\n \n-bool IsPeerAddrLocalGood(CNode *pnode);\n-void AdvertiseLocal(CNode *pnode);\n+    /** UNIX epoch time of the last transaction received from this peer that we\n+     * had not yet seen (e.g. not already received from another peer) and that\n+     * was accepted into our mempool. Used as an inbound peer eviction criterium\n+     * in CConnman::AttemptToEvictConnection. */\n+    std::atomic<int64_t> nLastTXTime{0};\n \n-/**\n- * Mark a network as reachable or unreachable (no automatic connects to it)\n- * @note Networks are reachable by default\n- */\n-void SetReachable(enum Network net, bool reachable);\n-/** @returns true if the network is reachable, false otherwise */\n-bool IsReachable(enum Network net);\n-/** @returns true if the address is in a reachable network, false otherwise */\n-bool IsReachable(const CNetAddr& addr);\n+    // Ping time measurement:\n+    // The pong reply we're expecting, or 0 if no pong expected.\n+    std::atomic<uint64_t> nPingNonceSent{0};\n+    /** When the last ping was sent, or 0 if no ping was ever sent */\n+    std::atomic<std::chrono::microseconds> m_ping_start{0us};\n+    // Last measured round-trip time.\n+    std::atomic<int64_t> nPingUsecTime{0};\n+    // Best measured round-trip time.\n+    std::atomic<int64_t> nMinPingUsecTime{std::numeric_limits<int64_t>::max()};\n+    // Whether a ping is requested.\n+    std::atomic<bool> fPingQueued{false};\n \n-bool AddLocal(const CService& addr, int nScore = LOCAL_NONE);\n-bool AddLocal(const CNetAddr& addr, int nScore = LOCAL_NONE);\n-void RemoveLocal(const CService& addr);\n-bool SeenLocal(const CService& addr);\n-bool IsLocal(const CService& addr);\n-bool GetLocal(CService &addr, const CNetAddr *paddrPeer = nullptr);\n-CAddress GetLocalAddress(const CNetAddr *paddrPeer, ServiceFlags nLocalServices);\n+    CNode(NodeId id, ServiceFlags nLocalServicesIn, SOCKET hSocketIn, const CAddress& addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress& addrBindIn, const std::string& addrNameIn, ConnectionType conn_type_in, bool inbound_onion = false);\n+    ~CNode();\n+    CNode(const CNode&) = delete;\n+    CNode& operator=(const CNode&) = delete;\n \n+private:\n+    const NodeId id;\n+    const uint64_t nLocalHostNonce;\n+    const ConnectionType m_conn_type;\n+    std::atomic<int> m_greatest_common_version{INIT_PROTO_VERSION};\n \n-extern bool fDiscover;\n-extern bool fListen;\n+    //! Services offered to this peer.\n+    //!\n+    //! This is supplied by the parent CConnman during peer connection\n+    //! (CConnman::ConnectNode()) from its attribute of the same name.\n+    //!\n+    //! This is const because there is no protocol defined for renegotiating\n+    //! services initially offered to a peer. The set of local services we\n+    //! offer should not change after initialization.\n+    //!\n+    //! An interesting example of this is NODE_NETWORK and initial block\n+    //! download: a node which starts up from scratch doesn't have any blocks\n+    //! to serve, but still advertises NODE_NETWORK because it will eventually\n+    //! fulfill this role after IBD completes. P2P code is written in such a\n+    //! way that it can gracefully handle peers who don't make good on their\n+    //! service advertisements.\n+    const ServiceFlags nLocalServices;\n \n-/** Subversion as sent to the P2P network in `version` messages */\n-extern std::string strSubVersion;\n+    NetPermissionFlags m_permissionFlags{ PF_NONE };\n+    std::list<CNetMessage> vRecvMsg;  // Used only by SocketHandler thread\n \n-struct LocalServiceInfo {\n-    int nScore;\n-    int nPort;\n-};\n+    mutable RecursiveMutex cs_addrName;\n+    std::string addrName GUARDED_BY(cs_addrName);\n \n-extern RecursiveMutex cs_mapLocalHost;\n-extern std::map<CNetAddr, LocalServiceInfo> mapLocalHost GUARDED_BY(cs_mapLocalHost);\n+    // Our address, as reported by the peer\n+    CService addrLocal GUARDED_BY(cs_addrLocal);\n+    mutable RecursiveMutex cs_addrLocal;\n \n-extern const std::string NET_MESSAGE_COMMAND_OTHER;\n-typedef std::map<std::string, uint64_t> mapMsgCmdSize; //command, total bytes\n+    //! Whether this peer is an inbound onion, e.g. connected via our Tor onion service.\n+    const bool m_inbound_onion{false};\n \n-class CNodeStats\n-{\n public:\n-    NodeId nodeid;\n-    ServiceFlags nServices;\n-    bool fRelayTxes;\n-    int64_t nLastSend;\n-    int64_t nLastRecv;\n-    int64_t nLastTXTime;\n-    int64_t nLastBlockTime;\n-    int64_t nTimeConnected;\n-    int64_t nTimeOffset;\n-    std::string addrName;\n-    int nVersion;\n-    std::string cleanSubVer;\n-    bool fInbound;\n-    bool m_bip152_highbandwidth_to;\n-    bool m_bip152_highbandwidth_from;\n-    int m_starting_height;\n-    uint64_t nSendBytes;\n-    mapMsgCmdSize mapSendBytesPerMsgCmd;\n-    uint64_t nRecvBytes;\n-    mapMsgCmdSize mapRecvBytesPerMsgCmd;\n-    NetPermissionFlags m_permissionFlags;\n-    int64_t m_ping_usec;\n-    int64_t m_ping_wait_usec;\n-    int64_t m_min_ping_usec;\n-    CAmount minFeeFilter;\n-    // Our address, as reported by the peer\n-    std::string addrLocal;\n-    // Address of this peer\n-    CAddress addr;\n-    // Bind address of our side of the connection\n-    CAddress addrBind;\n-    // Network the peer connected through\n-    Network m_network;\n-    uint32_t m_mapped_as;\n-    std::string m_conn_type_string;\n-};\n \n+    NodeId GetId() const {\n+        return id;\n+    }\n \n+    uint64_t GetLocalNonce() const {\n+        return nLocalHostNonce;\n+    }\n \n-/** Transport protocol agnostic message container.\n- * Ideally it should only contain receive time, payload,\n- * command and size.\n- */\n-class CNetMessage {\n-public:\n-    CDataStream m_recv;                  //!< received message data\n-    std::chrono::microseconds m_time{0}; //!< time of message receipt\n-    uint32_t m_message_size{0};          //!< size of the payload\n-    uint32_t m_raw_message_size{0};      //!< used wire size of the message (including header/checksum)\n-    std::string m_command;\n+    int GetRefCount() const\n+    {\n+        assert(nRefCount >= 0);\n+        return nRefCount;\n+    }\n \n-    CNetMessage(CDataStream&& recv_in) : m_recv(std::move(recv_in)) {}\n+    /**\n+     * Receive bytes from the buffer and deserialize them into messages.\n+     *\n+     * @param[in]   msg_bytes   The raw data\n+     * @param[out]  complete    Set True if at least one message has been\n+     *                          deserialized and is ready to be processed\n+     * @return  True if the peer should stay connected,\n+     *          False if the peer should be disconnected from.\n+     */\n+    bool ReceiveMsgBytes(Span<const uint8_t> msg_bytes, bool& complete);\n \n-    void SetVersion(int nVersionIn)\n+    void SetCommonVersion(int greatest_common_version)\n     {\n-        m_recv.SetVersion(nVersionIn);\n+        Assume(m_greatest_common_version == INIT_PROTO_VERSION);\n+        m_greatest_common_version = greatest_common_version;\n+    }\n+    int GetCommonVersion() const\n+    {\n+        return m_greatest_common_version;\n     }\n-};\n \n-/** The TransportDeserializer takes care of holding and deserializing the\n- * network receive buffer. It can deserialize the network buffer into a\n- * transport protocol agnostic CNetMessage (command & payload)\n- */\n-class TransportDeserializer {\n-public:\n-    // returns true if the current deserialization is complete\n-    virtual bool Complete() const = 0;\n-    // set the serialization context version\n-    virtual void SetVersion(int version) = 0;\n-    /** read and deserialize data, advances msg_bytes data pointer */\n-    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n-    // decomposes a message from the context\n-    virtual Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err) = 0;\n-    virtual ~TransportDeserializer() {}\n-};\n+    CService GetAddrLocal() const;\n+    //! May not be called more than once\n+    void SetAddrLocal(const CService& addrLocalIn);\n \n-class V1TransportDeserializer final : public TransportDeserializer\n-{\n-private:\n-    const CChainParams& m_chain_params;\n-    const NodeId m_node_id; // Only for logging\n-    mutable CHash256 hasher;\n-    mutable uint256 data_hash;\n-    bool in_data;                   // parsing header (false) or data (true)\n-    CDataStream hdrbuf;             // partially received header\n-    CMessageHeader hdr;             // complete header\n-    CDataStream vRecv;              // received message data\n-    unsigned int nHdrPos;\n-    unsigned int nDataPos;\n+    CNode* AddRef()\n+    {\n+        nRefCount++;\n+        return this;\n+    }\n \n-    const uint256& GetMessageHash() const;\n-    int readHeader(Span<const uint8_t> msg_bytes);\n-    int readData(Span<const uint8_t> msg_bytes);\n+    void Release()\n+    {\n+        nRefCount--;\n+    }\n \n-    void Reset() {\n-        vRecv.clear();\n-        hdrbuf.clear();\n-        hdrbuf.resize(24);\n-        in_data = false;\n-        nHdrPos = 0;\n-        nDataPos = 0;\n-        data_hash.SetNull();\n-        hasher.Reset();\n+\n+\n+    void AddAddressKnown(const CAddress& _addr)\n+    {\n+        assert(m_addr_known);\n+        m_addr_known->insert(_addr.GetKey());\n     }\n \n-public:\n-    V1TransportDeserializer(const CChainParams& chain_params, const NodeId node_id, int nTypeIn, int nVersionIn)\n-        : m_chain_params(chain_params),\n-          m_node_id(node_id),\n-          hdrbuf(nTypeIn, nVersionIn),\n-          vRecv(nTypeIn, nVersionIn)\n+    /**\n+     * Whether the peer supports the address. For example, a peer that does not\n+     * implement BIP155 cannot receive Tor v3 addresses because it requires\n+     * ADDRv2 (BIP155) encoding.\n+     */\n+    bool IsAddrCompatible(const CAddress& addr) const\n     {\n-        Reset();\n+        return m_wants_addrv2 || addr.IsAddrV1Compatible();\n     }\n \n-    bool Complete() const override\n+    void PushAddress(const CAddress& _addr, FastRandomContext &insecure_rand)\n     {\n-        if (!in_data)\n-            return false;\n-        return (hdr.nMessageSize == nDataPos);\n+        // Known checking here is only to save space from duplicates.\n+        // SendMessages will filter it again for knowns that were added\n+        // after addresses were pushed.\n+        assert(m_addr_known);\n+        if (_addr.IsValid() && !m_addr_known->contains(_addr.GetKey()) && IsAddrCompatible(_addr)) {\n+            if (vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\n+                vAddrToSend[insecure_rand.randrange(vAddrToSend.size())] = _addr;\n+            } else {\n+                vAddrToSend.push_back(_addr);\n+            }\n+        }\n     }\n-    void SetVersion(int nVersionIn) override\n+\n+\n+    void AddKnownTx(const uint256& hash)\n     {\n-        hdrbuf.SetVersion(nVersionIn);\n-        vRecv.SetVersion(nVersionIn);\n+        if (m_tx_relay != nullptr) {\n+            LOCK(m_tx_relay->cs_tx_inventory);\n+            m_tx_relay->filterInventoryKnown.insert(hash);\n+        }\n     }\n-    int Read(Span<const uint8_t>& msg_bytes) override\n+\n+    void PushTxInventory(const uint256& hash)\n     {\n-        int ret = in_data ? readData(msg_bytes) : readHeader(msg_bytes);\n-        if (ret < 0) {\n-            Reset();\n-        } else {\n-            msg_bytes = msg_bytes.subspan(ret);\n+        if (m_tx_relay == nullptr) return;\n+        LOCK(m_tx_relay->cs_tx_inventory);\n+        if (!m_tx_relay->filterInventoryKnown.contains(hash)) {\n+            m_tx_relay->setInventoryTxToSend.insert(hash);\n         }\n-        return ret;\n     }\n-    Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err_raw_size) override;\n+\n+    void CloseSocketDisconnect();\n+\n+    void copyStats(CNodeStats &stats, const std::vector<bool> &m_asmap);\n+\n+    ServiceFlags GetLocalServices() const\n+    {\n+        return nLocalServices;\n+    }\n+\n+    std::string GetAddrName() const;\n+    //! Sets the addrName only if it was not previously set\n+    void MaybeSetAddrName(const std::string& addrNameIn);\n+\n+    std::string ConnectionTypeAsString() const;\n+\n+    /** Whether this peer is an inbound onion, e.g. connected via our Tor onion service. */\n+    bool IsInboundOnion() const { return m_inbound_onion; }\n };\n \n-/** The TransportSerializer prepares messages for the network transport\n+/**\n+ * Interface for message handling\n  */\n-class TransportSerializer {\n+class NetEventsInterface\n+{\n public:\n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) = 0;\n-    virtual ~TransportSerializer() {}\n-};\n+    virtual bool ProcessMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n+    virtual bool SendMessages(CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(pnode->cs_sendProcessing) = 0;\n+    virtual void InitializeNode(CNode* pnode) = 0;\n+    virtual void FinalizeNode(const CNode& node, bool& update_connection_time) = 0;\n \n-class V1TransportSerializer  : public TransportSerializer {\n-public:\n-    void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) override;\n+protected:\n+    /**\n+     * Protected destructor so that instances can only be deleted by derived classes.\n+     * If that restriction is no longer desired, this should be made public and virtual.\n+     */\n+    ~NetEventsInterface() = default;\n };\n \n-/** Information about a peer */\n-class CNode\n+class CConnman\n {\n-    friend class CConnman;\n-    friend struct ConnmanTestMsg;\n-\n public:\n-    std::unique_ptr<TransportDeserializer> m_deserializer;\n-    std::unique_ptr<TransportSerializer> m_serializer;\n \n-    // socket\n-    std::atomic<ServiceFlags> nServices{NODE_NONE};\n-    SOCKET hSocket GUARDED_BY(cs_hSocket);\n-    /** Total size of all vSendMsg entries */\n-    size_t nSendSize GUARDED_BY(cs_vSend){0};\n-    /** Offset inside the first vSendMsg already sent */\n-    size_t nSendOffset GUARDED_BY(cs_vSend){0};\n-    uint64_t nSendBytes GUARDED_BY(cs_vSend){0};\n-    std::deque<std::vector<unsigned char>> vSendMsg GUARDED_BY(cs_vSend);\n-    Mutex cs_vSend;\n-    Mutex cs_hSocket;\n-    Mutex cs_vRecv;\n+    enum NumConnections {\n+        CONNECTIONS_NONE = 0,\n+        CONNECTIONS_IN = (1U << 0),\n+        CONNECTIONS_OUT = (1U << 1),\n+        CONNECTIONS_ALL = (CONNECTIONS_IN | CONNECTIONS_OUT),\n+    };\n \n-    RecursiveMutex cs_vProcessMsg;\n-    std::list<CNetMessage> vProcessMsg GUARDED_BY(cs_vProcessMsg);\n-    size_t nProcessQueueSize{0};\n+    struct Options\n+    {\n+        ServiceFlags nLocalServices = NODE_NONE;\n+        int nMaxConnections = 0;\n+        int m_max_outbound_full_relay = 0;\n+        int m_max_outbound_block_relay = 0;\n+        int nMaxAddnode = 0;\n+        int nMaxFeeler = 0;\n+        CClientUIInterface* uiInterface = nullptr;\n+        NetEventsInterface* m_msgproc = nullptr;\n+        BanMan* m_banman = nullptr;\n+        unsigned int nSendBufferMaxSize = 0;\n+        unsigned int nReceiveFloodSize = 0;\n+        uint64_t nMaxOutboundLimit = 0;\n+        int64_t m_peer_connect_timeout = DEFAULT_PEER_CONNECT_TIMEOUT;\n+        std::vector<std::string> vSeedNodes;\n+        std::vector<NetWhitelistPermissions> vWhitelistedRange;\n+        std::vector<NetWhitebindPermissions> vWhiteBinds;\n+        std::vector<CService> vBinds;\n+        std::vector<CService> onion_binds;\n+        bool m_use_addrman_outgoing = true;\n+        std::vector<std::string> m_specified_outgoing;\n+        std::vector<std::string> m_added_nodes;\n+        std::vector<bool> m_asmap;\n+    };\n \n-    RecursiveMutex cs_sendProcessing;\n+    void Init(const Options& connOptions) {\n+        nLocalServices = connOptions.nLocalServices;\n+        nMaxConnections = connOptions.nMaxConnections;\n+        m_max_outbound_full_relay = std::min(connOptions.m_max_outbound_full_relay, connOptions.nMaxConnections);\n+        m_max_outbound_block_relay = connOptions.m_max_outbound_block_relay;\n+        m_use_addrman_outgoing = connOptions.m_use_addrman_outgoing;\n+        nMaxAddnode = connOptions.nMaxAddnode;\n+        nMaxFeeler = connOptions.nMaxFeeler;\n+        m_max_outbound = m_max_outbound_full_relay + m_max_outbound_block_relay + nMaxFeeler;\n+        clientInterface = connOptions.uiInterface;\n+        m_banman = connOptions.m_banman;\n+        m_msgproc = connOptions.m_msgproc;\n+        nSendBufferMaxSize = connOptions.nSendBufferMaxSize;\n+        nReceiveFloodSize = connOptions.nReceiveFloodSize;\n+        m_peer_connect_timeout = connOptions.m_peer_connect_timeout;\n+        {\n+            LOCK(cs_totalBytesSent);\n+            nMaxOutboundLimit = connOptions.nMaxOutboundLimit;\n+        }\n+        vWhitelistedRange = connOptions.vWhitelistedRange;\n+        {\n+            LOCK(cs_vAddedNodes);\n+            vAddedNodes = connOptions.m_added_nodes;\n+        }\n+        m_onion_binds = connOptions.onion_binds;\n+    }\n \n-    uint64_t nRecvBytes GUARDED_BY(cs_vRecv){0};\n+    CConnman(uint64_t seed0, uint64_t seed1, bool network_active = true);\n+    ~CConnman();\n+    bool Start(CScheduler& scheduler, const Options& options);\n \n-    std::atomic<int64_t> nLastSend{0};\n-    std::atomic<int64_t> nLastRecv{0};\n-    const int64_t nTimeConnected;\n-    std::atomic<int64_t> nTimeOffset{0};\n-    // Address of this peer\n-    const CAddress addr;\n-    // Bind address of our side of the connection\n-    const CAddress addrBind;\n-    std::atomic<int> nVersion{0};\n-    RecursiveMutex cs_SubVer;\n-    /**\n-     * cleanSubVer is a sanitized string of the user agent byte array we read\n-     * from the wire. This cleaned string can safely be logged or displayed.\n-     */\n-    std::string cleanSubVer GUARDED_BY(cs_SubVer){};\n-    bool m_prefer_evict{false}; // This peer is preferred for eviction.\n-    bool HasPermission(NetPermissionFlags permission) const {\n-        return NetPermissions::HasFlag(m_permissionFlags, permission);\n-    }\n-    bool fClient{false}; // set by version message\n-    bool m_limited_node{false}; //after BIP159, set by version message\n-    /**\n-     * Whether the peer has signaled support for receiving ADDRv2 (BIP155)\n-     * messages, implying a preference to receive ADDRv2 instead of ADDR ones.\n-     */\n-    std::atomic_bool m_wants_addrv2{false};\n-    std::atomic_bool fSuccessfullyConnected{false};\n-    // Setting fDisconnect to true will cause the node to be disconnected the\n-    // next time DisconnectNodes() runs\n-    std::atomic_bool fDisconnect{false};\n-    bool fSentAddr{false};\n-    CSemaphoreGrant grantOutbound;\n-    std::atomic<int> nRefCount{0};\n+    void StopThreads();\n+    void StopNodes();\n+    void Stop()\n+    {\n+        StopThreads();\n+        StopNodes();\n+    };\n+\n+    void Interrupt();\n+    bool GetNetworkActive() const { return fNetworkActive; };\n+    bool GetUseAddrmanOutgoing() const { return m_use_addrman_outgoing; };\n+    void SetNetworkActive(bool active);\n+    void OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant* grantOutbound, const char* strDest, ConnectionType conn_type);\n+    bool CheckIncomingNonce(uint64_t nonce);\n+\n+    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func);\n+\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg);\n+\n+    using NodeFn = std::function<void(CNode*)>;\n+    void ForEachNode(const NodeFn& func)\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                func(node);\n+        }\n+    };\n+\n+    void ForEachNode(const NodeFn& func) const\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                func(node);\n+        }\n+    };\n+\n+    template<typename Callable, typename CallableAfter>\n+    void ForEachNodeThen(Callable&& pre, CallableAfter&& post)\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                pre(node);\n+        }\n+        post();\n+    };\n \n-    const uint64_t nKeyedNetGroup;\n-    std::atomic_bool fPauseRecv{false};\n-    std::atomic_bool fPauseSend{false};\n+    template<typename Callable, typename CallableAfter>\n+    void ForEachNodeThen(Callable&& pre, CallableAfter&& post) const\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                pre(node);\n+        }\n+        post();\n+    };\n \n-    bool IsOutboundOrBlockRelayConn() const {\n-        switch (m_conn_type) {\n-            case ConnectionType::OUTBOUND_FULL_RELAY:\n-            case ConnectionType::BLOCK_RELAY:\n-                return true;\n-            case ConnectionType::INBOUND:\n-            case ConnectionType::MANUAL:\n-            case ConnectionType::ADDR_FETCH:\n-            case ConnectionType::FEELER:\n-                return false;\n-        } // no default case, so the compiler can warn about missing cases\n+    // Addrman functions\n+    void SetServices(const CService &addr, ServiceFlags nServices);\n+    void MarkAddressGood(const CAddress& addr);\n+    bool AddNewAddresses(const std::vector<CAddress>& vAddr, const CAddress& addrFrom, int64_t nTimePenalty = 0);\n+    std::vector<CAddress> GetAddresses(size_t max_addresses, size_t max_pct);\n+    /**\n+     * Cache is used to minimize topology leaks, so it should\n+     * be used for all non-trusted calls, for example, p2p.\n+     * A non-malicious call (from RPC or a peer with addr permission) should\n+     * call the function without a parameter to avoid using the cache.\n+     */\n+    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct);\n \n-        assert(false);\n-    }\n+    // This allows temporarily exceeding m_max_outbound_full_relay, with the goal of finding\n+    // a peer that is better than all our current peers.\n+    void SetTryNewOutboundPeer(bool flag);\n+    bool GetTryNewOutboundPeer();\n \n-    bool IsFullOutboundConn() const {\n-        return m_conn_type == ConnectionType::OUTBOUND_FULL_RELAY;\n+    void StartExtraBlockRelayPeers() {\n+        LogPrint(BCLog::NET, \"net: enabling extra block-relay-only peers\\n\");\n+        m_start_extra_block_relay_peers = true;\n     }\n \n-    bool IsManualConn() const {\n-        return m_conn_type == ConnectionType::MANUAL;\n-    }\n+    // Return the number of outbound peers we have in excess of our target (eg,\n+    // if we previously called SetTryNewOutboundPeer(true), and have since set\n+    // to false, we may have extra peers that we wish to disconnect). This may\n+    // return a value less than (num_outbound_connections - num_outbound_slots)\n+    // in cases where some outbound connections are not yet fully connected, or\n+    // not yet fully disconnected.\n+    int GetExtraFullOutboundCount();\n+    // Count the number of block-relay-only peers we have over our limit.\n+    int GetExtraBlockRelayCount();\n \n-    bool IsBlockOnlyConn() const {\n-        return m_conn_type == ConnectionType::BLOCK_RELAY;\n-    }\n+    bool AddNode(const std::string& node);\n+    bool RemoveAddedNode(const std::string& node);\n+    std::vector<AddedNodeInfo> GetAddedNodeInfo();\n \n-    bool IsFeelerConn() const {\n-        return m_conn_type == ConnectionType::FEELER;\n-    }\n+    size_t GetNodeCount(NumConnections num);\n+    void GetNodeStats(std::vector<CNodeStats>& vstats);\n+    bool DisconnectNode(const std::string& node);\n+    bool DisconnectNode(const CSubNet& subnet);\n+    bool DisconnectNode(const CNetAddr& addr);\n+    bool DisconnectNode(NodeId id);\n \n-    bool IsAddrFetchConn() const {\n-        return m_conn_type == ConnectionType::ADDR_FETCH;\n-    }\n+    //! Used to convey which local services we are offering peers during node\n+    //! connection.\n+    //!\n+    //! The data returned by this is used in CNode construction,\n+    //! which is used to advertise which services we are offering\n+    //! that peer during `net_processing.cpp:PushNodeVersion()`.\n+    ServiceFlags GetLocalServices() const;\n \n-    bool IsInboundConn() const {\n-        return m_conn_type == ConnectionType::INBOUND;\n-    }\n+    uint64_t GetMaxOutboundTarget();\n+    std::chrono::seconds GetMaxOutboundTimeframe();\n \n-    /* Whether we send addr messages over this connection */\n-    bool RelayAddrsWithConn() const\n-    {\n-        // Don't relay addr messages to peers that we connect to as block-relay-only\n-        // peers (to prevent adversaries from inferring these links from addr\n-        // traffic).\n-        return m_conn_type != ConnectionType::BLOCK_RELAY;\n-    }\n+    //! check if the outbound target is reached\n+    //! if param historicalBlockServingLimit is set true, the function will\n+    //! response true if the limit for serving historical blocks has been reached\n+    bool OutboundTargetReached(bool historicalBlockServingLimit);\n \n-    bool ExpectServicesFromConn() const {\n-        switch (m_conn_type) {\n-            case ConnectionType::INBOUND:\n-            case ConnectionType::MANUAL:\n-            case ConnectionType::FEELER:\n-                return false;\n-            case ConnectionType::OUTBOUND_FULL_RELAY:\n-            case ConnectionType::BLOCK_RELAY:\n-            case ConnectionType::ADDR_FETCH:\n-                return true;\n-        } // no default case, so the compiler can warn about missing cases\n+    //! response the bytes left in the current max outbound cycle\n+    //! in case of no limit, it will always response 0\n+    uint64_t GetOutboundTargetBytesLeft();\n \n-        assert(false);\n-    }\n+    //! returns the time left in the current max outbound cycle\n+    //! in case of no limit, it will always return 0\n+    std::chrono::seconds GetMaxOutboundTimeLeftInCycle();\n \n-    /**\n-     * Get network the peer connected through.\n-     *\n-     * Returns Network::NET_ONION for *inbound* onion connections,\n-     * and CNetAddr::GetNetClass() otherwise. The latter cannot be used directly\n-     * because it doesn't detect the former, and it's not the responsibility of\n-     * the CNetAddr class to know the actual network a peer is connected through.\n-     *\n-     * @return network the peer connected through.\n-     */\n-    Network ConnectedThroughNetwork() const;\n+    uint64_t GetTotalBytesRecv();\n+    uint64_t GetTotalBytesSent();\n \n-protected:\n-    mapMsgCmdSize mapSendBytesPerMsgCmd GUARDED_BY(cs_vSend);\n-    mapMsgCmdSize mapRecvBytesPerMsgCmd GUARDED_BY(cs_vRecv);\n+    /** Get a unique deterministic randomizer. */\n+    CSipHasher GetDeterministicRandomizer(uint64_t id) const;\n \n-public:\n-    // We selected peer as (compact blocks) high-bandwidth peer (BIP152)\n-    std::atomic<bool> m_bip152_highbandwidth_to{false};\n-    // Peer selected us as (compact blocks) high-bandwidth peer (BIP152)\n-    std::atomic<bool> m_bip152_highbandwidth_from{false};\n+    unsigned int GetReceiveFloodSize() const;\n \n-    // flood relay\n-    std::vector<CAddress> vAddrToSend;\n-    std::unique_ptr<CRollingBloomFilter> m_addr_known{nullptr};\n-    bool fGetAddr{false};\n-    std::chrono::microseconds m_next_addr_send GUARDED_BY(cs_sendProcessing){0};\n-    std::chrono::microseconds m_next_local_addr_send GUARDED_BY(cs_sendProcessing){0};\n+    void WakeMessageHandler();\n \n-    struct TxRelay {\n-        mutable RecursiveMutex cs_filter;\n-        // We use fRelayTxes for two purposes -\n-        // a) it allows us to not relay tx invs before receiving the peer's version message\n-        // b) the peer may tell us in its version message that we should not relay tx invs\n-        //    unless it loads a bloom filter.\n-        bool fRelayTxes GUARDED_BY(cs_filter){false};\n-        std::unique_ptr<CBloomFilter> pfilter PT_GUARDED_BY(cs_filter) GUARDED_BY(cs_filter){nullptr};\n+    /** Attempts to obfuscate tx time through exponentially distributed emitting.\n+        Works assuming that a single interval is used.\n+        Variable intervals will result in privacy decrease.\n+    */\n+    int64_t PoissonNextSendInbound(int64_t now, int average_interval_seconds);\n \n-        mutable RecursiveMutex cs_tx_inventory;\n-        CRollingBloomFilter filterInventoryKnown GUARDED_BY(cs_tx_inventory){50000, 0.000001};\n-        // Set of transaction ids we still have to announce.\n-        // They are sorted by the mempool before relay, so the order is not important.\n-        std::set<uint256> setInventoryTxToSend;\n-        // Used for BIP35 mempool sending\n-        bool fSendMempool GUARDED_BY(cs_tx_inventory){false};\n-        // Last time a \"MEMPOOL\" request was serviced.\n-        std::atomic<std::chrono::seconds> m_last_mempool_req{0s};\n-        std::chrono::microseconds nNextInvSend{0};\n+    void SetAsmap(std::vector<bool> asmap) { addrman.m_asmap = std::move(asmap); }\n \n-        RecursiveMutex cs_feeFilter;\n-        // Minimum fee rate with which to filter inv's to this node\n-        CAmount minFeeFilter GUARDED_BY(cs_feeFilter){0};\n-        CAmount lastSentFeeFilter{0};\n-        int64_t nextSendTimeFeeFilter{0};\n+private:\n+    struct ListenSocket {\n+    public:\n+        SOCKET socket;\n+        inline void AddSocketPermissionFlags(NetPermissionFlags& flags) const { NetPermissions::AddFlag(flags, m_permissions); }\n+        ListenSocket(SOCKET socket_, NetPermissionFlags permissions_) : socket(socket_), m_permissions(permissions_) {}\n+    private:\n+        NetPermissionFlags m_permissions;\n     };\n \n-    // m_tx_relay == nullptr if we're not relaying transactions with this peer\n-    std::unique_ptr<TxRelay> m_tx_relay;\n+    bool BindListenPort(const CService& bindAddr, bilingual_str& strError, NetPermissionFlags permissions);\n+    bool Bind(const CService& addr, unsigned int flags, NetPermissionFlags permissions);\n+    bool InitBinds(\n+        const std::vector<CService>& binds,\n+        const std::vector<NetWhitebindPermissions>& whiteBinds,\n+        const std::vector<CService>& onion_binds);\n \n-    /** UNIX epoch time of the last block received from this peer that we had\n-     * not yet seen (e.g. not already received from another peer), that passed\n-     * preliminary validity checks and was saved to disk, even if we don't\n-     * connect the block or it eventually fails connection. Used as an inbound\n-     * peer eviction criterium in CConnman::AttemptToEvictConnection. */\n-    std::atomic<int64_t> nLastBlockTime{0};\n+    void ThreadOpenAddedConnections();\n+    void AddAddrFetch(const std::string& strDest);\n+    void ProcessAddrFetch();\n+    void ThreadOpenConnections(std::vector<std::string> connect);\n+    void ThreadMessageHandler();\n+    void AcceptConnection(const ListenSocket& hListenSocket);\n+    void DisconnectNodes();\n+    void NotifyNumConnectionsChanged();\n+    void InactivityCheck(CNode *pnode);\n+    bool GenerateSelectSet(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n+    void SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n+    void SocketHandler();\n+    void ThreadSocketHandler();\n+    void ThreadDNSAddressSeed();\n \n-    /** UNIX epoch time of the last transaction received from this peer that we\n-     * had not yet seen (e.g. not already received from another peer) and that\n-     * was accepted into our mempool. Used as an inbound peer eviction criterium\n-     * in CConnman::AttemptToEvictConnection. */\n-    std::atomic<int64_t> nLastTXTime{0};\n+    uint64_t CalculateKeyedNetGroup(const CAddress& ad) const;\n \n-    // Ping time measurement:\n-    // The pong reply we're expecting, or 0 if no pong expected.\n-    std::atomic<uint64_t> nPingNonceSent{0};\n-    /** When the last ping was sent, or 0 if no ping was ever sent */\n-    std::atomic<std::chrono::microseconds> m_ping_start{0us};\n-    // Last measured round-trip time.\n-    std::atomic<int64_t> nPingUsecTime{0};\n-    // Best measured round-trip time.\n-    std::atomic<int64_t> nMinPingUsecTime{std::numeric_limits<int64_t>::max()};\n-    // Whether a ping is requested.\n-    std::atomic<bool> fPingQueued{false};\n+    CNode* FindNode(const CNetAddr& ip);\n+    CNode* FindNode(const CSubNet& subNet);\n+    CNode* FindNode(const std::string& addrName);\n+    CNode* FindNode(const CService& addr);\n+\n+    /**\n+     * Determine whether we're already connected to a given address, in order to\n+     * avoid initiating duplicate connections.\n+     */\n+    bool AlreadyConnectedToAddress(const CAddress& addr);\n+\n+    bool AttemptToEvictConnection();\n+    CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, ConnectionType conn_type);\n+    void AddWhitelistPermissionFlags(NetPermissionFlags& flags, const CNetAddr &addr) const;\n+\n+    void DeleteNode(CNode* pnode);\n \n-    CNode(NodeId id, ServiceFlags nLocalServicesIn, SOCKET hSocketIn, const CAddress& addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress& addrBindIn, const std::string& addrNameIn, ConnectionType conn_type_in, bool inbound_onion = false);\n-    ~CNode();\n-    CNode(const CNode&) = delete;\n-    CNode& operator=(const CNode&) = delete;\n+    NodeId GetNewNodeId();\n \n-private:\n-    const NodeId id;\n-    const uint64_t nLocalHostNonce;\n-    const ConnectionType m_conn_type;\n-    std::atomic<int> m_greatest_common_version{INIT_PROTO_VERSION};\n+    size_t SocketSendData(CNode& node) const EXCLUSIVE_LOCKS_REQUIRED(node.cs_vSend);\n+    void DumpAddresses();\n \n-    //! Services offered to this peer.\n-    //!\n-    //! This is supplied by the parent CConnman during peer connection\n-    //! (CConnman::ConnectNode()) from its attribute of the same name.\n-    //!\n-    //! This is const because there is no protocol defined for renegotiating\n-    //! services initially offered to a peer. The set of local services we\n-    //! offer should not change after initialization.\n-    //!\n-    //! An interesting example of this is NODE_NETWORK and initial block\n-    //! download: a node which starts up from scratch doesn't have any blocks\n-    //! to serve, but still advertises NODE_NETWORK because it will eventually\n-    //! fulfill this role after IBD completes. P2P code is written in such a\n-    //! way that it can gracefully handle peers who don't make good on their\n-    //! service advertisements.\n-    const ServiceFlags nLocalServices;\n+    // Network stats\n+    void RecordBytesRecv(uint64_t bytes);\n+    void RecordBytesSent(uint64_t bytes);\n \n-    NetPermissionFlags m_permissionFlags{ PF_NONE };\n-    std::list<CNetMessage> vRecvMsg;  // Used only by SocketHandler thread\n+    /**\n+     * Return vector of current BLOCK_RELAY peers.\n+     */\n+    std::vector<CAddress> GetCurrentBlockRelayOnlyConns() const;\n \n-    mutable RecursiveMutex cs_addrName;\n-    std::string addrName GUARDED_BY(cs_addrName);\n+    // Whether the node should be passed out in ForEach* callbacks\n+    static bool NodeFullyConnected(const CNode* pnode);\n \n-    // Our address, as reported by the peer\n-    CService addrLocal GUARDED_BY(cs_addrLocal);\n-    mutable RecursiveMutex cs_addrLocal;\n+    // Network usage totals\n+    RecursiveMutex cs_totalBytesRecv;\n+    RecursiveMutex cs_totalBytesSent;\n+    uint64_t nTotalBytesRecv GUARDED_BY(cs_totalBytesRecv) {0};\n+    uint64_t nTotalBytesSent GUARDED_BY(cs_totalBytesSent) {0};\n \n-    //! Whether this peer is an inbound onion, e.g. connected via our Tor onion service.\n-    const bool m_inbound_onion{false};\n+    // outbound limit & stats\n+    uint64_t nMaxOutboundTotalBytesSentInCycle GUARDED_BY(cs_totalBytesSent) {0};\n+    std::chrono::seconds nMaxOutboundCycleStartTime GUARDED_BY(cs_totalBytesSent) {0};\n+    uint64_t nMaxOutboundLimit GUARDED_BY(cs_totalBytesSent);\n \n-public:\n+    // P2P timeout in seconds\n+    int64_t m_peer_connect_timeout;\n \n-    NodeId GetId() const {\n-        return id;\n-    }\n+    // Whitelisted ranges. Any node connecting from these is automatically\n+    // whitelisted (as well as those connecting to whitelisted binds).\n+    std::vector<NetWhitelistPermissions> vWhitelistedRange;\n \n-    uint64_t GetLocalNonce() const {\n-        return nLocalHostNonce;\n-    }\n+    unsigned int nSendBufferMaxSize{0};\n+    unsigned int nReceiveFloodSize{0};\n \n-    int GetRefCount() const\n-    {\n-        assert(nRefCount >= 0);\n-        return nRefCount;\n-    }\n+    std::vector<ListenSocket> vhListenSocket;\n+    std::atomic<bool> fNetworkActive{true};\n+    bool fAddressesInitialized{false};\n+    CAddrMan addrman;\n+    std::deque<std::string> m_addr_fetches GUARDED_BY(m_addr_fetches_mutex);\n+    RecursiveMutex m_addr_fetches_mutex;\n+    std::vector<std::string> vAddedNodes GUARDED_BY(cs_vAddedNodes);\n+    RecursiveMutex cs_vAddedNodes;\n+    std::vector<CNode*> vNodes GUARDED_BY(cs_vNodes);\n+    std::list<CNode*> vNodesDisconnected;\n+    mutable RecursiveMutex cs_vNodes;\n+    std::atomic<NodeId> nLastNodeId{0};\n+    unsigned int nPrevNodeCount{0};\n \n     /**\n-     * Receive bytes from the buffer and deserialize them into messages.\n-     *\n-     * @param[in]   msg_bytes   The raw data\n-     * @param[out]  complete    Set True if at least one message has been\n-     *                          deserialized and is ready to be processed\n-     * @return  True if the peer should stay connected,\n-     *          False if the peer should be disconnected from.\n+     * Cache responses to addr requests to minimize privacy leak.\n+     * Attack example: scraping addrs in real-time may allow an attacker\n+     * to infer new connections of the victim by detecting new records\n+     * with fresh timestamps (per self-announcement).\n      */\n-    bool ReceiveMsgBytes(Span<const uint8_t> msg_bytes, bool& complete);\n-\n-    void SetCommonVersion(int greatest_common_version)\n-    {\n-        Assume(m_greatest_common_version == INIT_PROTO_VERSION);\n-        m_greatest_common_version = greatest_common_version;\n-    }\n-    int GetCommonVersion() const\n-    {\n-        return m_greatest_common_version;\n-    }\n+    struct CachedAddrResponse {\n+        std::vector<CAddress> m_addrs_response_cache;\n+        std::chrono::microseconds m_cache_entry_expiration{0};\n+    };\n \n-    CService GetAddrLocal() const;\n-    //! May not be called more than once\n-    void SetAddrLocal(const CService& addrLocalIn);\n+    /**\n+     * Addr responses stored in different caches\n+     * per (network, local socket) prevent cross-network node identification.\n+     * If a node for example is multi-homed under Tor and IPv6,\n+     * a single cache (or no cache at all) would let an attacker\n+     * to easily detect that it is the same node by comparing responses.\n+     * Indexing by local socket prevents leakage when a node has multiple\n+     * listening addresses on the same network.\n+     *\n+     * The used memory equals to 1000 CAddress records (or around 40 bytes) per\n+     * distinct Network (up to 5) we have/had an inbound peer from,\n+     * resulting in at most ~196 KB. Every separate local socket may\n+     * add up to ~196 KB extra.\n+     */\n+    std::map<uint64_t, CachedAddrResponse> m_addr_response_caches;\n \n-    CNode* AddRef()\n-    {\n-        nRefCount++;\n-        return this;\n-    }\n+    /**\n+     * Services this instance offers.\n+     *\n+     * This data is replicated in each CNode instance we create during peer\n+     * connection (in ConnectNode()) under a member also called\n+     * nLocalServices.\n+     *\n+     * This data is not marked const, but after being set it should not\n+     * change. See the note in CNode::nLocalServices documentation.\n+     *\n+     * \\sa CNode::nLocalServices\n+     */\n+    ServiceFlags nLocalServices;\n \n-    void Release()\n-    {\n-        nRefCount--;\n-    }\n+    std::unique_ptr<CSemaphore> semOutbound;\n+    std::unique_ptr<CSemaphore> semAddnode;\n+    int nMaxConnections;\n \n+    // How many full-relay (tx, block, addr) outbound peers we want\n+    int m_max_outbound_full_relay;\n \n+    // How many block-relay only outbound peers we want\n+    // We do not relay tx or addr messages with these peers\n+    int m_max_outbound_block_relay;\n \n-    void AddAddressKnown(const CAddress& _addr)\n-    {\n-        assert(m_addr_known);\n-        m_addr_known->insert(_addr.GetKey());\n-    }\n+    int nMaxAddnode;\n+    int nMaxFeeler;\n+    int m_max_outbound;\n+    bool m_use_addrman_outgoing;\n+    CClientUIInterface* clientInterface;\n+    NetEventsInterface* m_msgproc;\n+    /** Pointer to this node's banman. May be nullptr - check existence before dereferencing. */\n+    BanMan* m_banman;\n \n     /**\n-     * Whether the peer supports the address. For example, a peer that does not\n-     * implement BIP155 cannot receive Tor v3 addresses because it requires\n-     * ADDRv2 (BIP155) encoding.\n+     * Addresses that were saved during the previous clean shutdown. We'll\n+     * attempt to make block-relay-only connections to them.\n      */\n-    bool IsAddrCompatible(const CAddress& addr) const\n-    {\n-        return m_wants_addrv2 || addr.IsAddrV1Compatible();\n-    }\n+    std::vector<CAddress> m_anchors;\n \n-    void PushAddress(const CAddress& _addr, FastRandomContext &insecure_rand)\n-    {\n-        // Known checking here is only to save space from duplicates.\n-        // SendMessages will filter it again for knowns that were added\n-        // after addresses were pushed.\n-        assert(m_addr_known);\n-        if (_addr.IsValid() && !m_addr_known->contains(_addr.GetKey()) && IsAddrCompatible(_addr)) {\n-            if (vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\n-                vAddrToSend[insecure_rand.randrange(vAddrToSend.size())] = _addr;\n-            } else {\n-                vAddrToSend.push_back(_addr);\n-            }\n-        }\n-    }\n+    /** SipHasher seeds for deterministic randomness */\n+    const uint64_t nSeed0, nSeed1;\n \n+    /** flag for waking the message processor. */\n+    bool fMsgProcWake GUARDED_BY(mutexMsgProc);\n \n-    void AddKnownTx(const uint256& hash)\n-    {\n-        if (m_tx_relay != nullptr) {\n-            LOCK(m_tx_relay->cs_tx_inventory);\n-            m_tx_relay->filterInventoryKnown.insert(hash);\n-        }\n-    }\n+    std::condition_variable condMsgProc;\n+    Mutex mutexMsgProc;\n+    std::atomic<bool> flagInterruptMsgProc{false};\n \n-    void PushTxInventory(const uint256& hash)\n-    {\n-        if (m_tx_relay == nullptr) return;\n-        LOCK(m_tx_relay->cs_tx_inventory);\n-        if (!m_tx_relay->filterInventoryKnown.contains(hash)) {\n-            m_tx_relay->setInventoryTxToSend.insert(hash);\n-        }\n-    }\n+    CThreadInterrupt interruptNet;\n \n-    void CloseSocketDisconnect();\n+    std::thread threadDNSAddressSeed;\n+    std::thread threadSocketHandler;\n+    std::thread threadOpenAddedConnections;\n+    std::thread threadOpenConnections;\n+    std::thread threadMessageHandler;\n \n-    void copyStats(CNodeStats &stats, const std::vector<bool> &m_asmap);\n+    /** flag for deciding to connect to an extra outbound peer,\n+     *  in excess of m_max_outbound_full_relay\n+     *  This takes the place of a feeler connection */\n+    std::atomic_bool m_try_another_outbound_peer;\n \n-    ServiceFlags GetLocalServices() const\n-    {\n-        return nLocalServices;\n-    }\n+    /** flag for initiating extra block-relay-only peer connections.\n+     *  this should only be enabled after initial chain sync has occurred,\n+     *  as these connections are intended to be short-lived and low-bandwidth.\n+     */\n+    std::atomic_bool m_start_extra_block_relay_peers{false};\n \n-    std::string GetAddrName() const;\n-    //! Sets the addrName only if it was not previously set\n-    void MaybeSetAddrName(const std::string& addrNameIn);\n+    std::atomic<int64_t> m_next_send_inv_to_incoming{0};\n \n-    std::string ConnectionTypeAsString() const;\n+    /**\n+     * A vector of -bind=<address>:<port>=onion arguments each of which is\n+     * an address and port that are designated for incoming Tor connections.\n+     */\n+    std::vector<CService> m_onion_binds;\n \n-    /** Whether this peer is an inbound onion, e.g. connected via our Tor onion service. */\n-    bool IsInboundOnion() const { return m_inbound_onion; }\n+    friend struct CConnmanTest;\n+    friend struct ConnmanTestMsg;\n };",
      "path": "src/net.h",
      "position": 1906,
      "original_position": 1906,
      "commit_id": "fa210689e27b0d78b2fe894e51e364179db7a3ce",
      "original_commit_id": "fad2e1f267d60afe9799e431233f54f02d14e8e0",
      "in_reply_to_id": null,
      "user": {
        "login": "jnewbery",
        "id": 1063656,
        "node_id": "MDQ6VXNlcjEwNjM2NTY=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1063656?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/jnewbery",
        "html_url": "https://github.com/jnewbery",
        "followers_url": "https://api.github.com/users/jnewbery/followers",
        "following_url": "https://api.github.com/users/jnewbery/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/jnewbery/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/jnewbery/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/jnewbery/subscriptions",
        "organizations_url": "https://api.github.com/users/jnewbery/orgs",
        "repos_url": "https://api.github.com/users/jnewbery/repos",
        "events_url": "https://api.github.com/users/jnewbery/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/jnewbery/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "If you touch this again, add a blank line after the class declaration.",
      "created_at": "2021-01-06T13:40:13Z",
      "updated_at": "2021-01-07T08:42:02Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/20864#discussion_r552621025",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/552621025"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20864"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1216,
      "original_line": 1216,
      "side": "RIGHT"
    },
    {
      "url": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/553182212",
      "pull_request_review_id": 563299405,
      "id": 553182212,
      "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE4MjIxMg==",
      "diff_hunk": "@@ -180,1041 +180,1040 @@ enum class ConnectionType {\n     ADDR_FETCH,\n };\n \n-class NetEventsInterface;\n-class CConnman\n-{\n-public:\n-\n-    enum NumConnections {\n-        CONNECTIONS_NONE = 0,\n-        CONNECTIONS_IN = (1U << 0),\n-        CONNECTIONS_OUT = (1U << 1),\n-        CONNECTIONS_ALL = (CONNECTIONS_IN | CONNECTIONS_OUT),\n-    };\n-\n-    struct Options\n-    {\n-        ServiceFlags nLocalServices = NODE_NONE;\n-        int nMaxConnections = 0;\n-        int m_max_outbound_full_relay = 0;\n-        int m_max_outbound_block_relay = 0;\n-        int nMaxAddnode = 0;\n-        int nMaxFeeler = 0;\n-        CClientUIInterface* uiInterface = nullptr;\n-        NetEventsInterface* m_msgproc = nullptr;\n-        BanMan* m_banman = nullptr;\n-        unsigned int nSendBufferMaxSize = 0;\n-        unsigned int nReceiveFloodSize = 0;\n-        uint64_t nMaxOutboundLimit = 0;\n-        int64_t m_peer_connect_timeout = DEFAULT_PEER_CONNECT_TIMEOUT;\n-        std::vector<std::string> vSeedNodes;\n-        std::vector<NetWhitelistPermissions> vWhitelistedRange;\n-        std::vector<NetWhitebindPermissions> vWhiteBinds;\n-        std::vector<CService> vBinds;\n-        std::vector<CService> onion_binds;\n-        bool m_use_addrman_outgoing = true;\n-        std::vector<std::string> m_specified_outgoing;\n-        std::vector<std::string> m_added_nodes;\n-        std::vector<bool> m_asmap;\n-    };\n-\n-    void Init(const Options& connOptions) {\n-        nLocalServices = connOptions.nLocalServices;\n-        nMaxConnections = connOptions.nMaxConnections;\n-        m_max_outbound_full_relay = std::min(connOptions.m_max_outbound_full_relay, connOptions.nMaxConnections);\n-        m_max_outbound_block_relay = connOptions.m_max_outbound_block_relay;\n-        m_use_addrman_outgoing = connOptions.m_use_addrman_outgoing;\n-        nMaxAddnode = connOptions.nMaxAddnode;\n-        nMaxFeeler = connOptions.nMaxFeeler;\n-        m_max_outbound = m_max_outbound_full_relay + m_max_outbound_block_relay + nMaxFeeler;\n-        clientInterface = connOptions.uiInterface;\n-        m_banman = connOptions.m_banman;\n-        m_msgproc = connOptions.m_msgproc;\n-        nSendBufferMaxSize = connOptions.nSendBufferMaxSize;\n-        nReceiveFloodSize = connOptions.nReceiveFloodSize;\n-        m_peer_connect_timeout = connOptions.m_peer_connect_timeout;\n-        {\n-            LOCK(cs_totalBytesSent);\n-            nMaxOutboundLimit = connOptions.nMaxOutboundLimit;\n-        }\n-        vWhitelistedRange = connOptions.vWhitelistedRange;\n-        {\n-            LOCK(cs_vAddedNodes);\n-            vAddedNodes = connOptions.m_added_nodes;\n-        }\n-        m_onion_binds = connOptions.onion_binds;\n-    }\n-\n-    CConnman(uint64_t seed0, uint64_t seed1, bool network_active = true);\n-    ~CConnman();\n-    bool Start(CScheduler& scheduler, const Options& options);\n-\n-    void StopThreads();\n-    void StopNodes();\n-    void Stop()\n-    {\n-        StopThreads();\n-        StopNodes();\n-    };\n-\n-    void Interrupt();\n-    bool GetNetworkActive() const { return fNetworkActive; };\n-    bool GetUseAddrmanOutgoing() const { return m_use_addrman_outgoing; };\n-    void SetNetworkActive(bool active);\n-    void OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant* grantOutbound, const char* strDest, ConnectionType conn_type);\n-    bool CheckIncomingNonce(uint64_t nonce);\n-\n-    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func);\n-\n-    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg);\n-\n-    using NodeFn = std::function<void(CNode*)>;\n-    void ForEachNode(const NodeFn& func)\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                func(node);\n-        }\n-    };\n-\n-    void ForEachNode(const NodeFn& func) const\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                func(node);\n-        }\n-    };\n-\n-    template<typename Callable, typename CallableAfter>\n-    void ForEachNodeThen(Callable&& pre, CallableAfter&& post)\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                pre(node);\n-        }\n-        post();\n-    };\n+void Discover();\n+void StartMapPort();\n+void InterruptMapPort();\n+void StopMapPort();\n+uint16_t GetListenPort();\n \n-    template<typename Callable, typename CallableAfter>\n-    void ForEachNodeThen(Callable&& pre, CallableAfter&& post) const\n-    {\n-        LOCK(cs_vNodes);\n-        for (auto&& node : vNodes) {\n-            if (NodeFullyConnected(node))\n-                pre(node);\n-        }\n-        post();\n-    };\n+enum\n+{\n+    LOCAL_NONE,   // unknown\n+    LOCAL_IF,     // address a local interface listens on\n+    LOCAL_BIND,   // address explicit bound to\n+    LOCAL_UPNP,   // address reported by UPnP\n+    LOCAL_MANUAL, // address explicitly specified (-externalip=)\n \n-    // Addrman functions\n-    void SetServices(const CService &addr, ServiceFlags nServices);\n-    void MarkAddressGood(const CAddress& addr);\n-    bool AddNewAddresses(const std::vector<CAddress>& vAddr, const CAddress& addrFrom, int64_t nTimePenalty = 0);\n-    std::vector<CAddress> GetAddresses(size_t max_addresses, size_t max_pct);\n-    /**\n-     * Cache is used to minimize topology leaks, so it should\n-     * be used for all non-trusted calls, for example, p2p.\n-     * A non-malicious call (from RPC or a peer with addr permission) should\n-     * call the function without a parameter to avoid using the cache.\n-     */\n-    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct);\n+    LOCAL_MAX\n+};\n \n-    // This allows temporarily exceeding m_max_outbound_full_relay, with the goal of finding\n-    // a peer that is better than all our current peers.\n-    void SetTryNewOutboundPeer(bool flag);\n-    bool GetTryNewOutboundPeer();\n+bool IsPeerAddrLocalGood(CNode *pnode);\n+void AdvertiseLocal(CNode *pnode);\n \n-    void StartExtraBlockRelayPeers() {\n-        LogPrint(BCLog::NET, \"net: enabling extra block-relay-only peers\\n\");\n-        m_start_extra_block_relay_peers = true;\n-    }\n+/**\n+ * Mark a network as reachable or unreachable (no automatic connects to it)\n+ * @note Networks are reachable by default\n+ */\n+void SetReachable(enum Network net, bool reachable);\n+/** @returns true if the network is reachable, false otherwise */\n+bool IsReachable(enum Network net);\n+/** @returns true if the address is in a reachable network, false otherwise */\n+bool IsReachable(const CNetAddr& addr);\n \n-    // Return the number of outbound peers we have in excess of our target (eg,\n-    // if we previously called SetTryNewOutboundPeer(true), and have since set\n-    // to false, we may have extra peers that we wish to disconnect). This may\n-    // return a value less than (num_outbound_connections - num_outbound_slots)\n-    // in cases where some outbound connections are not yet fully connected, or\n-    // not yet fully disconnected.\n-    int GetExtraFullOutboundCount();\n-    // Count the number of block-relay-only peers we have over our limit.\n-    int GetExtraBlockRelayCount();\n+bool AddLocal(const CService& addr, int nScore = LOCAL_NONE);\n+bool AddLocal(const CNetAddr& addr, int nScore = LOCAL_NONE);\n+void RemoveLocal(const CService& addr);\n+bool SeenLocal(const CService& addr);\n+bool IsLocal(const CService& addr);\n+bool GetLocal(CService &addr, const CNetAddr *paddrPeer = nullptr);\n+CAddress GetLocalAddress(const CNetAddr *paddrPeer, ServiceFlags nLocalServices);\n \n-    bool AddNode(const std::string& node);\n-    bool RemoveAddedNode(const std::string& node);\n-    std::vector<AddedNodeInfo> GetAddedNodeInfo();\n \n-    size_t GetNodeCount(NumConnections num);\n-    void GetNodeStats(std::vector<CNodeStats>& vstats);\n-    bool DisconnectNode(const std::string& node);\n-    bool DisconnectNode(const CSubNet& subnet);\n-    bool DisconnectNode(const CNetAddr& addr);\n-    bool DisconnectNode(NodeId id);\n+extern bool fDiscover;\n+extern bool fListen;\n \n-    //! Used to convey which local services we are offering peers during node\n-    //! connection.\n-    //!\n-    //! The data returned by this is used in CNode construction,\n-    //! which is used to advertise which services we are offering\n-    //! that peer during `net_processing.cpp:PushNodeVersion()`.\n-    ServiceFlags GetLocalServices() const;\n+/** Subversion as sent to the P2P network in `version` messages */\n+extern std::string strSubVersion;\n \n-    uint64_t GetMaxOutboundTarget();\n-    std::chrono::seconds GetMaxOutboundTimeframe();\n+struct LocalServiceInfo {\n+    int nScore;\n+    int nPort;\n+};\n \n-    //! check if the outbound target is reached\n-    //! if param historicalBlockServingLimit is set true, the function will\n-    //! response true if the limit for serving historical blocks has been reached\n-    bool OutboundTargetReached(bool historicalBlockServingLimit);\n+extern RecursiveMutex cs_mapLocalHost;\n+extern std::map<CNetAddr, LocalServiceInfo> mapLocalHost GUARDED_BY(cs_mapLocalHost);\n \n-    //! response the bytes left in the current max outbound cycle\n-    //! in case of no limit, it will always response 0\n-    uint64_t GetOutboundTargetBytesLeft();\n+extern const std::string NET_MESSAGE_COMMAND_OTHER;\n+typedef std::map<std::string, uint64_t> mapMsgCmdSize; //command, total bytes\n \n-    //! returns the time left in the current max outbound cycle\n-    //! in case of no limit, it will always return 0\n-    std::chrono::seconds GetMaxOutboundTimeLeftInCycle();\n+class CNodeStats\n+{\n+public:\n+    NodeId nodeid;\n+    ServiceFlags nServices;\n+    bool fRelayTxes;\n+    int64_t nLastSend;\n+    int64_t nLastRecv;\n+    int64_t nLastTXTime;\n+    int64_t nLastBlockTime;\n+    int64_t nTimeConnected;\n+    int64_t nTimeOffset;\n+    std::string addrName;\n+    int nVersion;\n+    std::string cleanSubVer;\n+    bool fInbound;\n+    bool m_bip152_highbandwidth_to;\n+    bool m_bip152_highbandwidth_from;\n+    int m_starting_height;\n+    uint64_t nSendBytes;\n+    mapMsgCmdSize mapSendBytesPerMsgCmd;\n+    uint64_t nRecvBytes;\n+    mapMsgCmdSize mapRecvBytesPerMsgCmd;\n+    NetPermissionFlags m_permissionFlags;\n+    int64_t m_ping_usec;\n+    int64_t m_ping_wait_usec;\n+    int64_t m_min_ping_usec;\n+    CAmount minFeeFilter;\n+    // Our address, as reported by the peer\n+    std::string addrLocal;\n+    // Address of this peer\n+    CAddress addr;\n+    // Bind address of our side of the connection\n+    CAddress addrBind;\n+    // Network the peer connected through\n+    Network m_network;\n+    uint32_t m_mapped_as;\n+    std::string m_conn_type_string;\n+};\n \n-    uint64_t GetTotalBytesRecv();\n-    uint64_t GetTotalBytesSent();\n \n-    /** Get a unique deterministic randomizer. */\n-    CSipHasher GetDeterministicRandomizer(uint64_t id) const;\n \n-    unsigned int GetReceiveFloodSize() const;\n+/** Transport protocol agnostic message container.\n+ * Ideally it should only contain receive time, payload,\n+ * command and size.\n+ */\n+class CNetMessage {\n+public:\n+    CDataStream m_recv;                  //!< received message data\n+    std::chrono::microseconds m_time{0}; //!< time of message receipt\n+    uint32_t m_message_size{0};          //!< size of the payload\n+    uint32_t m_raw_message_size{0};      //!< used wire size of the message (including header/checksum)\n+    std::string m_command;\n \n-    void WakeMessageHandler();\n+    CNetMessage(CDataStream&& recv_in) : m_recv(std::move(recv_in)) {}\n \n-    /** Attempts to obfuscate tx time through exponentially distributed emitting.\n-        Works assuming that a single interval is used.\n-        Variable intervals will result in privacy decrease.\n-    */\n-    int64_t PoissonNextSendInbound(int64_t now, int average_interval_seconds);\n+    void SetVersion(int nVersionIn)\n+    {\n+        m_recv.SetVersion(nVersionIn);\n+    }\n+};\n \n-    void SetAsmap(std::vector<bool> asmap) { addrman.m_asmap = std::move(asmap); }\n+/** The TransportDeserializer takes care of holding and deserializing the\n+ * network receive buffer. It can deserialize the network buffer into a\n+ * transport protocol agnostic CNetMessage (command & payload)\n+ */\n+class TransportDeserializer {\n+public:\n+    // returns true if the current deserialization is complete\n+    virtual bool Complete() const = 0;\n+    // set the serialization context version\n+    virtual void SetVersion(int version) = 0;\n+    /** read and deserialize data, advances msg_bytes data pointer */\n+    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n+    // decomposes a message from the context\n+    virtual Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err) = 0;\n+    virtual ~TransportDeserializer() {}\n+};\n \n+class V1TransportDeserializer final : public TransportDeserializer\n+{\n private:\n-    struct ListenSocket {\n-    public:\n-        SOCKET socket;\n-        inline void AddSocketPermissionFlags(NetPermissionFlags& flags) const { NetPermissions::AddFlag(flags, m_permissions); }\n-        ListenSocket(SOCKET socket_, NetPermissionFlags permissions_) : socket(socket_), m_permissions(permissions_) {}\n-    private:\n-        NetPermissionFlags m_permissions;\n-    };\n-\n-    bool BindListenPort(const CService& bindAddr, bilingual_str& strError, NetPermissionFlags permissions);\n-    bool Bind(const CService& addr, unsigned int flags, NetPermissionFlags permissions);\n-    bool InitBinds(\n-        const std::vector<CService>& binds,\n-        const std::vector<NetWhitebindPermissions>& whiteBinds,\n-        const std::vector<CService>& onion_binds);\n-\n-    void ThreadOpenAddedConnections();\n-    void AddAddrFetch(const std::string& strDest);\n-    void ProcessAddrFetch();\n-    void ThreadOpenConnections(std::vector<std::string> connect);\n-    void ThreadMessageHandler();\n-    void AcceptConnection(const ListenSocket& hListenSocket);\n-    void DisconnectNodes();\n-    void NotifyNumConnectionsChanged();\n-    void InactivityCheck(CNode *pnode);\n-    bool GenerateSelectSet(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n-    void SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n-    void SocketHandler();\n-    void ThreadSocketHandler();\n-    void ThreadDNSAddressSeed();\n-\n-    uint64_t CalculateKeyedNetGroup(const CAddress& ad) const;\n-\n-    CNode* FindNode(const CNetAddr& ip);\n-    CNode* FindNode(const CSubNet& subNet);\n-    CNode* FindNode(const std::string& addrName);\n-    CNode* FindNode(const CService& addr);\n-\n-    /**\n-     * Determine whether we're already connected to a given address, in order to\n-     * avoid initiating duplicate connections.\n-     */\n-    bool AlreadyConnectedToAddress(const CAddress& addr);\n-\n-    bool AttemptToEvictConnection();\n-    CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, ConnectionType conn_type);\n-    void AddWhitelistPermissionFlags(NetPermissionFlags& flags, const CNetAddr &addr) const;\n-\n-    void DeleteNode(CNode* pnode);\n+    const CChainParams& m_chain_params;\n+    const NodeId m_node_id; // Only for logging\n+    mutable CHash256 hasher;\n+    mutable uint256 data_hash;\n+    bool in_data;                   // parsing header (false) or data (true)\n+    CDataStream hdrbuf;             // partially received header\n+    CMessageHeader hdr;             // complete header\n+    CDataStream vRecv;              // received message data\n+    unsigned int nHdrPos;\n+    unsigned int nDataPos;\n \n-    NodeId GetNewNodeId();\n+    const uint256& GetMessageHash() const;\n+    int readHeader(Span<const uint8_t> msg_bytes);\n+    int readData(Span<const uint8_t> msg_bytes);\n \n-    size_t SocketSendData(CNode *pnode) const;\n-    void DumpAddresses();\n+    void Reset() {\n+        vRecv.clear();\n+        hdrbuf.clear();\n+        hdrbuf.resize(24);\n+        in_data = false;\n+        nHdrPos = 0;\n+        nDataPos = 0;\n+        data_hash.SetNull();\n+        hasher.Reset();\n+    }\n \n-    // Network stats\n-    void RecordBytesRecv(uint64_t bytes);\n-    void RecordBytesSent(uint64_t bytes);\n+public:\n+    V1TransportDeserializer(const CChainParams& chain_params, const NodeId node_id, int nTypeIn, int nVersionIn)\n+        : m_chain_params(chain_params),\n+          m_node_id(node_id),\n+          hdrbuf(nTypeIn, nVersionIn),\n+          vRecv(nTypeIn, nVersionIn)\n+    {\n+        Reset();\n+    }\n \n-    /**\n-     * Return vector of current BLOCK_RELAY peers.\n-     */\n-    std::vector<CAddress> GetCurrentBlockRelayOnlyConns() const;\n+    bool Complete() const override\n+    {\n+        if (!in_data)\n+            return false;\n+        return (hdr.nMessageSize == nDataPos);\n+    }\n+    void SetVersion(int nVersionIn) override\n+    {\n+        hdrbuf.SetVersion(nVersionIn);\n+        vRecv.SetVersion(nVersionIn);\n+    }\n+    int Read(Span<const uint8_t>& msg_bytes) override\n+    {\n+        int ret = in_data ? readData(msg_bytes) : readHeader(msg_bytes);\n+        if (ret < 0) {\n+            Reset();\n+        } else {\n+            msg_bytes = msg_bytes.subspan(ret);\n+        }\n+        return ret;\n+    }\n+    Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err_raw_size) override;\n+};\n \n-    // Whether the node should be passed out in ForEach* callbacks\n-    static bool NodeFullyConnected(const CNode* pnode);\n+/** The TransportSerializer prepares messages for the network transport\n+ */\n+class TransportSerializer {\n+public:\n+    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n+    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) = 0;\n+    virtual ~TransportSerializer() {}\n+};\n \n-    // Network usage totals\n-    RecursiveMutex cs_totalBytesRecv;\n-    RecursiveMutex cs_totalBytesSent;\n-    uint64_t nTotalBytesRecv GUARDED_BY(cs_totalBytesRecv) {0};\n-    uint64_t nTotalBytesSent GUARDED_BY(cs_totalBytesSent) {0};\n+class V1TransportSerializer  : public TransportSerializer {\n+public:\n+    void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) override;\n+};\n \n-    // outbound limit & stats\n-    uint64_t nMaxOutboundTotalBytesSentInCycle GUARDED_BY(cs_totalBytesSent) {0};\n-    std::chrono::seconds nMaxOutboundCycleStartTime GUARDED_BY(cs_totalBytesSent) {0};\n-    uint64_t nMaxOutboundLimit GUARDED_BY(cs_totalBytesSent);\n+/** Information about a peer */\n+class CNode\n+{\n+    friend class CConnman;\n+    friend struct ConnmanTestMsg;\n \n-    // P2P timeout in seconds\n-    int64_t m_peer_connect_timeout;\n+public:\n+    std::unique_ptr<TransportDeserializer> m_deserializer;\n+    std::unique_ptr<TransportSerializer> m_serializer;\n \n-    // Whitelisted ranges. Any node connecting from these is automatically\n-    // whitelisted (as well as those connecting to whitelisted binds).\n-    std::vector<NetWhitelistPermissions> vWhitelistedRange;\n+    // socket\n+    std::atomic<ServiceFlags> nServices{NODE_NONE};\n+    SOCKET hSocket GUARDED_BY(cs_hSocket);\n+    /** Total size of all vSendMsg entries */\n+    size_t nSendSize GUARDED_BY(cs_vSend){0};\n+    /** Offset inside the first vSendMsg already sent */\n+    size_t nSendOffset GUARDED_BY(cs_vSend){0};\n+    uint64_t nSendBytes GUARDED_BY(cs_vSend){0};\n+    std::deque<std::vector<unsigned char>> vSendMsg GUARDED_BY(cs_vSend);\n+    Mutex cs_vSend;\n+    Mutex cs_hSocket;\n+    Mutex cs_vRecv;\n \n-    unsigned int nSendBufferMaxSize{0};\n-    unsigned int nReceiveFloodSize{0};\n+    RecursiveMutex cs_vProcessMsg;\n+    std::list<CNetMessage> vProcessMsg GUARDED_BY(cs_vProcessMsg);\n+    size_t nProcessQueueSize{0};\n \n-    std::vector<ListenSocket> vhListenSocket;\n-    std::atomic<bool> fNetworkActive{true};\n-    bool fAddressesInitialized{false};\n-    CAddrMan addrman;\n-    std::deque<std::string> m_addr_fetches GUARDED_BY(m_addr_fetches_mutex);\n-    RecursiveMutex m_addr_fetches_mutex;\n-    std::vector<std::string> vAddedNodes GUARDED_BY(cs_vAddedNodes);\n-    RecursiveMutex cs_vAddedNodes;\n-    std::vector<CNode*> vNodes GUARDED_BY(cs_vNodes);\n-    std::list<CNode*> vNodesDisconnected;\n-    mutable RecursiveMutex cs_vNodes;\n-    std::atomic<NodeId> nLastNodeId{0};\n-    unsigned int nPrevNodeCount{0};\n+    RecursiveMutex cs_sendProcessing;\n \n-    /**\n-     * Cache responses to addr requests to minimize privacy leak.\n-     * Attack example: scraping addrs in real-time may allow an attacker\n-     * to infer new connections of the victim by detecting new records\n-     * with fresh timestamps (per self-announcement).\n-     */\n-    struct CachedAddrResponse {\n-        std::vector<CAddress> m_addrs_response_cache;\n-        std::chrono::microseconds m_cache_entry_expiration{0};\n-    };\n+    uint64_t nRecvBytes GUARDED_BY(cs_vRecv){0};\n \n+    std::atomic<int64_t> nLastSend{0};\n+    std::atomic<int64_t> nLastRecv{0};\n+    const int64_t nTimeConnected;\n+    std::atomic<int64_t> nTimeOffset{0};\n+    // Address of this peer\n+    const CAddress addr;\n+    // Bind address of our side of the connection\n+    const CAddress addrBind;\n+    std::atomic<int> nVersion{0};\n+    RecursiveMutex cs_SubVer;\n     /**\n-     * Addr responses stored in different caches\n-     * per (network, local socket) prevent cross-network node identification.\n-     * If a node for example is multi-homed under Tor and IPv6,\n-     * a single cache (or no cache at all) would let an attacker\n-     * to easily detect that it is the same node by comparing responses.\n-     * Indexing by local socket prevents leakage when a node has multiple\n-     * listening addresses on the same network.\n-     *\n-     * The used memory equals to 1000 CAddress records (or around 40 bytes) per\n-     * distinct Network (up to 5) we have/had an inbound peer from,\n-     * resulting in at most ~196 KB. Every separate local socket may\n-     * add up to ~196 KB extra.\n+     * cleanSubVer is a sanitized string of the user agent byte array we read\n+     * from the wire. This cleaned string can safely be logged or displayed.\n      */\n-    std::map<uint64_t, CachedAddrResponse> m_addr_response_caches;\n-\n+    std::string cleanSubVer GUARDED_BY(cs_SubVer){};\n+    bool m_prefer_evict{false}; // This peer is preferred for eviction.\n+    bool HasPermission(NetPermissionFlags permission) const {\n+        return NetPermissions::HasFlag(m_permissionFlags, permission);\n+    }\n+    bool fClient{false}; // set by version message\n+    bool m_limited_node{false}; //after BIP159, set by version message\n     /**\n-     * Services this instance offers.\n-     *\n-     * This data is replicated in each CNode instance we create during peer\n-     * connection (in ConnectNode()) under a member also called\n-     * nLocalServices.\n-     *\n-     * This data is not marked const, but after being set it should not\n-     * change. See the note in CNode::nLocalServices documentation.\n-     *\n-     * \\sa CNode::nLocalServices\n+     * Whether the peer has signaled support for receiving ADDRv2 (BIP155)\n+     * messages, implying a preference to receive ADDRv2 instead of ADDR ones.\n      */\n-    ServiceFlags nLocalServices;\n-\n-    std::unique_ptr<CSemaphore> semOutbound;\n-    std::unique_ptr<CSemaphore> semAddnode;\n-    int nMaxConnections;\n+    std::atomic_bool m_wants_addrv2{false};\n+    std::atomic_bool fSuccessfullyConnected{false};\n+    // Setting fDisconnect to true will cause the node to be disconnected the\n+    // next time DisconnectNodes() runs\n+    std::atomic_bool fDisconnect{false};\n+    bool fSentAddr{false};\n+    CSemaphoreGrant grantOutbound;\n+    std::atomic<int> nRefCount{0};\n \n-    // How many full-relay (tx, block, addr) outbound peers we want\n-    int m_max_outbound_full_relay;\n+    const uint64_t nKeyedNetGroup;\n+    std::atomic_bool fPauseRecv{false};\n+    std::atomic_bool fPauseSend{false};\n \n-    // How many block-relay only outbound peers we want\n-    // We do not relay tx or addr messages with these peers\n-    int m_max_outbound_block_relay;\n+    bool IsOutboundOrBlockRelayConn() const {\n+        switch (m_conn_type) {\n+            case ConnectionType::OUTBOUND_FULL_RELAY:\n+            case ConnectionType::BLOCK_RELAY:\n+                return true;\n+            case ConnectionType::INBOUND:\n+            case ConnectionType::MANUAL:\n+            case ConnectionType::ADDR_FETCH:\n+            case ConnectionType::FEELER:\n+                return false;\n+        } // no default case, so the compiler can warn about missing cases\n \n-    int nMaxAddnode;\n-    int nMaxFeeler;\n-    int m_max_outbound;\n-    bool m_use_addrman_outgoing;\n-    CClientUIInterface* clientInterface;\n-    NetEventsInterface* m_msgproc;\n-    /** Pointer to this node's banman. May be nullptr - check existence before dereferencing. */\n-    BanMan* m_banman;\n+        assert(false);\n+    }\n \n-    /**\n-     * Addresses that were saved during the previous clean shutdown. We'll\n-     * attempt to make block-relay-only connections to them.\n-     */\n-    std::vector<CAddress> m_anchors;\n+    bool IsFullOutboundConn() const {\n+        return m_conn_type == ConnectionType::OUTBOUND_FULL_RELAY;\n+    }\n \n-    /** SipHasher seeds for deterministic randomness */\n-    const uint64_t nSeed0, nSeed1;\n+    bool IsManualConn() const {\n+        return m_conn_type == ConnectionType::MANUAL;\n+    }\n \n-    /** flag for waking the message processor. */\n-    bool fMsgProcWake GUARDED_BY(mutexMsgProc);\n+    bool IsBlockOnlyConn() const {\n+        return m_conn_type == ConnectionType::BLOCK_RELAY;\n+    }\n \n-    std::condition_variable condMsgProc;\n-    Mutex mutexMsgProc;\n-    std::atomic<bool> flagInterruptMsgProc{false};\n+    bool IsFeelerConn() const {\n+        return m_conn_type == ConnectionType::FEELER;\n+    }\n \n-    CThreadInterrupt interruptNet;\n+    bool IsAddrFetchConn() const {\n+        return m_conn_type == ConnectionType::ADDR_FETCH;\n+    }\n \n-    std::thread threadDNSAddressSeed;\n-    std::thread threadSocketHandler;\n-    std::thread threadOpenAddedConnections;\n-    std::thread threadOpenConnections;\n-    std::thread threadMessageHandler;\n+    bool IsInboundConn() const {\n+        return m_conn_type == ConnectionType::INBOUND;\n+    }\n \n-    /** flag for deciding to connect to an extra outbound peer,\n-     *  in excess of m_max_outbound_full_relay\n-     *  This takes the place of a feeler connection */\n-    std::atomic_bool m_try_another_outbound_peer;\n+    /* Whether we send addr messages over this connection */\n+    bool RelayAddrsWithConn() const\n+    {\n+        // Don't relay addr messages to peers that we connect to as block-relay-only\n+        // peers (to prevent adversaries from inferring these links from addr\n+        // traffic).\n+        return m_conn_type != ConnectionType::BLOCK_RELAY;\n+    }\n \n-    /** flag for initiating extra block-relay-only peer connections.\n-     *  this should only be enabled after initial chain sync has occurred,\n-     *  as these connections are intended to be short-lived and low-bandwidth.\n-     */\n-    std::atomic_bool m_start_extra_block_relay_peers{false};\n+    bool ExpectServicesFromConn() const {\n+        switch (m_conn_type) {\n+            case ConnectionType::INBOUND:\n+            case ConnectionType::MANUAL:\n+            case ConnectionType::FEELER:\n+                return false;\n+            case ConnectionType::OUTBOUND_FULL_RELAY:\n+            case ConnectionType::BLOCK_RELAY:\n+            case ConnectionType::ADDR_FETCH:\n+                return true;\n+        } // no default case, so the compiler can warn about missing cases\n \n-    std::atomic<int64_t> m_next_send_inv_to_incoming{0};\n+        assert(false);\n+    }\n \n     /**\n-     * A vector of -bind=<address>:<port>=onion arguments each of which is\n-     * an address and port that are designated for incoming Tor connections.\n+     * Get network the peer connected through.\n+     *\n+     * Returns Network::NET_ONION for *inbound* onion connections,\n+     * and CNetAddr::GetNetClass() otherwise. The latter cannot be used directly\n+     * because it doesn't detect the former, and it's not the responsibility of\n+     * the CNetAddr class to know the actual network a peer is connected through.\n+     *\n+     * @return network the peer connected through.\n      */\n-    std::vector<CService> m_onion_binds;\n+    Network ConnectedThroughNetwork() const;\n \n-    friend struct CConnmanTest;\n-    friend struct ConnmanTestMsg;\n-};\n-void Discover();\n-void StartMapPort();\n-void InterruptMapPort();\n-void StopMapPort();\n-uint16_t GetListenPort();\n+protected:\n+    mapMsgCmdSize mapSendBytesPerMsgCmd GUARDED_BY(cs_vSend);\n+    mapMsgCmdSize mapRecvBytesPerMsgCmd GUARDED_BY(cs_vRecv);\n \n-/**\n- * Interface for message handling\n- */\n-class NetEventsInterface\n-{\n public:\n-    virtual bool ProcessMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n-    virtual bool SendMessages(CNode* pnode) = 0;\n-    virtual void InitializeNode(CNode* pnode) = 0;\n-    virtual void FinalizeNode(const CNode& node, bool& update_connection_time) = 0;\n+    // We selected peer as (compact blocks) high-bandwidth peer (BIP152)\n+    std::atomic<bool> m_bip152_highbandwidth_to{false};\n+    // Peer selected us as (compact blocks) high-bandwidth peer (BIP152)\n+    std::atomic<bool> m_bip152_highbandwidth_from{false};\n+\n+    // flood relay\n+    std::vector<CAddress> vAddrToSend;\n+    std::unique_ptr<CRollingBloomFilter> m_addr_known{nullptr};\n+    bool fGetAddr{false};\n+    std::chrono::microseconds m_next_addr_send GUARDED_BY(cs_sendProcessing){0};\n+    std::chrono::microseconds m_next_local_addr_send GUARDED_BY(cs_sendProcessing){0};\n+\n+    struct TxRelay {\n+        mutable RecursiveMutex cs_filter;\n+        // We use fRelayTxes for two purposes -\n+        // a) it allows us to not relay tx invs before receiving the peer's version message\n+        // b) the peer may tell us in its version message that we should not relay tx invs\n+        //    unless it loads a bloom filter.\n+        bool fRelayTxes GUARDED_BY(cs_filter){false};\n+        std::unique_ptr<CBloomFilter> pfilter PT_GUARDED_BY(cs_filter) GUARDED_BY(cs_filter){nullptr};\n+\n+        mutable RecursiveMutex cs_tx_inventory;\n+        CRollingBloomFilter filterInventoryKnown GUARDED_BY(cs_tx_inventory){50000, 0.000001};\n+        // Set of transaction ids we still have to announce.\n+        // They are sorted by the mempool before relay, so the order is not important.\n+        std::set<uint256> setInventoryTxToSend;\n+        // Used for BIP35 mempool sending\n+        bool fSendMempool GUARDED_BY(cs_tx_inventory){false};\n+        // Last time a \"MEMPOOL\" request was serviced.\n+        std::atomic<std::chrono::seconds> m_last_mempool_req{0s};\n+        std::chrono::microseconds nNextInvSend{0};\n \n-protected:\n-    /**\n-     * Protected destructor so that instances can only be deleted by derived classes.\n-     * If that restriction is no longer desired, this should be made public and virtual.\n-     */\n-    ~NetEventsInterface() = default;\n-};\n+        RecursiveMutex cs_feeFilter;\n+        // Minimum fee rate with which to filter inv's to this node\n+        CAmount minFeeFilter GUARDED_BY(cs_feeFilter){0};\n+        CAmount lastSentFeeFilter{0};\n+        int64_t nextSendTimeFeeFilter{0};\n+    };\n \n-enum\n-{\n-    LOCAL_NONE,   // unknown\n-    LOCAL_IF,     // address a local interface listens on\n-    LOCAL_BIND,   // address explicit bound to\n-    LOCAL_UPNP,   // address reported by UPnP\n-    LOCAL_MANUAL, // address explicitly specified (-externalip=)\n+    // m_tx_relay == nullptr if we're not relaying transactions with this peer\n+    std::unique_ptr<TxRelay> m_tx_relay;\n \n-    LOCAL_MAX\n-};\n+    /** UNIX epoch time of the last block received from this peer that we had\n+     * not yet seen (e.g. not already received from another peer), that passed\n+     * preliminary validity checks and was saved to disk, even if we don't\n+     * connect the block or it eventually fails connection. Used as an inbound\n+     * peer eviction criterium in CConnman::AttemptToEvictConnection. */\n+    std::atomic<int64_t> nLastBlockTime{0};\n \n-bool IsPeerAddrLocalGood(CNode *pnode);\n-void AdvertiseLocal(CNode *pnode);\n+    /** UNIX epoch time of the last transaction received from this peer that we\n+     * had not yet seen (e.g. not already received from another peer) and that\n+     * was accepted into our mempool. Used as an inbound peer eviction criterium\n+     * in CConnman::AttemptToEvictConnection. */\n+    std::atomic<int64_t> nLastTXTime{0};\n \n-/**\n- * Mark a network as reachable or unreachable (no automatic connects to it)\n- * @note Networks are reachable by default\n- */\n-void SetReachable(enum Network net, bool reachable);\n-/** @returns true if the network is reachable, false otherwise */\n-bool IsReachable(enum Network net);\n-/** @returns true if the address is in a reachable network, false otherwise */\n-bool IsReachable(const CNetAddr& addr);\n+    // Ping time measurement:\n+    // The pong reply we're expecting, or 0 if no pong expected.\n+    std::atomic<uint64_t> nPingNonceSent{0};\n+    /** When the last ping was sent, or 0 if no ping was ever sent */\n+    std::atomic<std::chrono::microseconds> m_ping_start{0us};\n+    // Last measured round-trip time.\n+    std::atomic<int64_t> nPingUsecTime{0};\n+    // Best measured round-trip time.\n+    std::atomic<int64_t> nMinPingUsecTime{std::numeric_limits<int64_t>::max()};\n+    // Whether a ping is requested.\n+    std::atomic<bool> fPingQueued{false};\n \n-bool AddLocal(const CService& addr, int nScore = LOCAL_NONE);\n-bool AddLocal(const CNetAddr& addr, int nScore = LOCAL_NONE);\n-void RemoveLocal(const CService& addr);\n-bool SeenLocal(const CService& addr);\n-bool IsLocal(const CService& addr);\n-bool GetLocal(CService &addr, const CNetAddr *paddrPeer = nullptr);\n-CAddress GetLocalAddress(const CNetAddr *paddrPeer, ServiceFlags nLocalServices);\n+    CNode(NodeId id, ServiceFlags nLocalServicesIn, SOCKET hSocketIn, const CAddress& addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress& addrBindIn, const std::string& addrNameIn, ConnectionType conn_type_in, bool inbound_onion = false);\n+    ~CNode();\n+    CNode(const CNode&) = delete;\n+    CNode& operator=(const CNode&) = delete;\n \n+private:\n+    const NodeId id;\n+    const uint64_t nLocalHostNonce;\n+    const ConnectionType m_conn_type;\n+    std::atomic<int> m_greatest_common_version{INIT_PROTO_VERSION};\n \n-extern bool fDiscover;\n-extern bool fListen;\n+    //! Services offered to this peer.\n+    //!\n+    //! This is supplied by the parent CConnman during peer connection\n+    //! (CConnman::ConnectNode()) from its attribute of the same name.\n+    //!\n+    //! This is const because there is no protocol defined for renegotiating\n+    //! services initially offered to a peer. The set of local services we\n+    //! offer should not change after initialization.\n+    //!\n+    //! An interesting example of this is NODE_NETWORK and initial block\n+    //! download: a node which starts up from scratch doesn't have any blocks\n+    //! to serve, but still advertises NODE_NETWORK because it will eventually\n+    //! fulfill this role after IBD completes. P2P code is written in such a\n+    //! way that it can gracefully handle peers who don't make good on their\n+    //! service advertisements.\n+    const ServiceFlags nLocalServices;\n \n-/** Subversion as sent to the P2P network in `version` messages */\n-extern std::string strSubVersion;\n+    NetPermissionFlags m_permissionFlags{ PF_NONE };\n+    std::list<CNetMessage> vRecvMsg;  // Used only by SocketHandler thread\n \n-struct LocalServiceInfo {\n-    int nScore;\n-    int nPort;\n-};\n+    mutable RecursiveMutex cs_addrName;\n+    std::string addrName GUARDED_BY(cs_addrName);\n \n-extern RecursiveMutex cs_mapLocalHost;\n-extern std::map<CNetAddr, LocalServiceInfo> mapLocalHost GUARDED_BY(cs_mapLocalHost);\n+    // Our address, as reported by the peer\n+    CService addrLocal GUARDED_BY(cs_addrLocal);\n+    mutable RecursiveMutex cs_addrLocal;\n \n-extern const std::string NET_MESSAGE_COMMAND_OTHER;\n-typedef std::map<std::string, uint64_t> mapMsgCmdSize; //command, total bytes\n+    //! Whether this peer is an inbound onion, e.g. connected via our Tor onion service.\n+    const bool m_inbound_onion{false};\n \n-class CNodeStats\n-{\n public:\n-    NodeId nodeid;\n-    ServiceFlags nServices;\n-    bool fRelayTxes;\n-    int64_t nLastSend;\n-    int64_t nLastRecv;\n-    int64_t nLastTXTime;\n-    int64_t nLastBlockTime;\n-    int64_t nTimeConnected;\n-    int64_t nTimeOffset;\n-    std::string addrName;\n-    int nVersion;\n-    std::string cleanSubVer;\n-    bool fInbound;\n-    bool m_bip152_highbandwidth_to;\n-    bool m_bip152_highbandwidth_from;\n-    int m_starting_height;\n-    uint64_t nSendBytes;\n-    mapMsgCmdSize mapSendBytesPerMsgCmd;\n-    uint64_t nRecvBytes;\n-    mapMsgCmdSize mapRecvBytesPerMsgCmd;\n-    NetPermissionFlags m_permissionFlags;\n-    int64_t m_ping_usec;\n-    int64_t m_ping_wait_usec;\n-    int64_t m_min_ping_usec;\n-    CAmount minFeeFilter;\n-    // Our address, as reported by the peer\n-    std::string addrLocal;\n-    // Address of this peer\n-    CAddress addr;\n-    // Bind address of our side of the connection\n-    CAddress addrBind;\n-    // Network the peer connected through\n-    Network m_network;\n-    uint32_t m_mapped_as;\n-    std::string m_conn_type_string;\n-};\n \n+    NodeId GetId() const {\n+        return id;\n+    }\n \n+    uint64_t GetLocalNonce() const {\n+        return nLocalHostNonce;\n+    }\n \n-/** Transport protocol agnostic message container.\n- * Ideally it should only contain receive time, payload,\n- * command and size.\n- */\n-class CNetMessage {\n-public:\n-    CDataStream m_recv;                  //!< received message data\n-    std::chrono::microseconds m_time{0}; //!< time of message receipt\n-    uint32_t m_message_size{0};          //!< size of the payload\n-    uint32_t m_raw_message_size{0};      //!< used wire size of the message (including header/checksum)\n-    std::string m_command;\n+    int GetRefCount() const\n+    {\n+        assert(nRefCount >= 0);\n+        return nRefCount;\n+    }\n \n-    CNetMessage(CDataStream&& recv_in) : m_recv(std::move(recv_in)) {}\n+    /**\n+     * Receive bytes from the buffer and deserialize them into messages.\n+     *\n+     * @param[in]   msg_bytes   The raw data\n+     * @param[out]  complete    Set True if at least one message has been\n+     *                          deserialized and is ready to be processed\n+     * @return  True if the peer should stay connected,\n+     *          False if the peer should be disconnected from.\n+     */\n+    bool ReceiveMsgBytes(Span<const uint8_t> msg_bytes, bool& complete);\n \n-    void SetVersion(int nVersionIn)\n+    void SetCommonVersion(int greatest_common_version)\n     {\n-        m_recv.SetVersion(nVersionIn);\n+        Assume(m_greatest_common_version == INIT_PROTO_VERSION);\n+        m_greatest_common_version = greatest_common_version;\n+    }\n+    int GetCommonVersion() const\n+    {\n+        return m_greatest_common_version;\n     }\n-};\n \n-/** The TransportDeserializer takes care of holding and deserializing the\n- * network receive buffer. It can deserialize the network buffer into a\n- * transport protocol agnostic CNetMessage (command & payload)\n- */\n-class TransportDeserializer {\n-public:\n-    // returns true if the current deserialization is complete\n-    virtual bool Complete() const = 0;\n-    // set the serialization context version\n-    virtual void SetVersion(int version) = 0;\n-    /** read and deserialize data, advances msg_bytes data pointer */\n-    virtual int Read(Span<const uint8_t>& msg_bytes) = 0;\n-    // decomposes a message from the context\n-    virtual Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err) = 0;\n-    virtual ~TransportDeserializer() {}\n-};\n+    CService GetAddrLocal() const;\n+    //! May not be called more than once\n+    void SetAddrLocal(const CService& addrLocalIn);\n \n-class V1TransportDeserializer final : public TransportDeserializer\n-{\n-private:\n-    const CChainParams& m_chain_params;\n-    const NodeId m_node_id; // Only for logging\n-    mutable CHash256 hasher;\n-    mutable uint256 data_hash;\n-    bool in_data;                   // parsing header (false) or data (true)\n-    CDataStream hdrbuf;             // partially received header\n-    CMessageHeader hdr;             // complete header\n-    CDataStream vRecv;              // received message data\n-    unsigned int nHdrPos;\n-    unsigned int nDataPos;\n+    CNode* AddRef()\n+    {\n+        nRefCount++;\n+        return this;\n+    }\n \n-    const uint256& GetMessageHash() const;\n-    int readHeader(Span<const uint8_t> msg_bytes);\n-    int readData(Span<const uint8_t> msg_bytes);\n+    void Release()\n+    {\n+        nRefCount--;\n+    }\n \n-    void Reset() {\n-        vRecv.clear();\n-        hdrbuf.clear();\n-        hdrbuf.resize(24);\n-        in_data = false;\n-        nHdrPos = 0;\n-        nDataPos = 0;\n-        data_hash.SetNull();\n-        hasher.Reset();\n+\n+\n+    void AddAddressKnown(const CAddress& _addr)\n+    {\n+        assert(m_addr_known);\n+        m_addr_known->insert(_addr.GetKey());\n     }\n \n-public:\n-    V1TransportDeserializer(const CChainParams& chain_params, const NodeId node_id, int nTypeIn, int nVersionIn)\n-        : m_chain_params(chain_params),\n-          m_node_id(node_id),\n-          hdrbuf(nTypeIn, nVersionIn),\n-          vRecv(nTypeIn, nVersionIn)\n+    /**\n+     * Whether the peer supports the address. For example, a peer that does not\n+     * implement BIP155 cannot receive Tor v3 addresses because it requires\n+     * ADDRv2 (BIP155) encoding.\n+     */\n+    bool IsAddrCompatible(const CAddress& addr) const\n     {\n-        Reset();\n+        return m_wants_addrv2 || addr.IsAddrV1Compatible();\n     }\n \n-    bool Complete() const override\n+    void PushAddress(const CAddress& _addr, FastRandomContext &insecure_rand)\n     {\n-        if (!in_data)\n-            return false;\n-        return (hdr.nMessageSize == nDataPos);\n+        // Known checking here is only to save space from duplicates.\n+        // SendMessages will filter it again for knowns that were added\n+        // after addresses were pushed.\n+        assert(m_addr_known);\n+        if (_addr.IsValid() && !m_addr_known->contains(_addr.GetKey()) && IsAddrCompatible(_addr)) {\n+            if (vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\n+                vAddrToSend[insecure_rand.randrange(vAddrToSend.size())] = _addr;\n+            } else {\n+                vAddrToSend.push_back(_addr);\n+            }\n+        }\n     }\n-    void SetVersion(int nVersionIn) override\n+\n+\n+    void AddKnownTx(const uint256& hash)\n     {\n-        hdrbuf.SetVersion(nVersionIn);\n-        vRecv.SetVersion(nVersionIn);\n+        if (m_tx_relay != nullptr) {\n+            LOCK(m_tx_relay->cs_tx_inventory);\n+            m_tx_relay->filterInventoryKnown.insert(hash);\n+        }\n     }\n-    int Read(Span<const uint8_t>& msg_bytes) override\n+\n+    void PushTxInventory(const uint256& hash)\n     {\n-        int ret = in_data ? readData(msg_bytes) : readHeader(msg_bytes);\n-        if (ret < 0) {\n-            Reset();\n-        } else {\n-            msg_bytes = msg_bytes.subspan(ret);\n+        if (m_tx_relay == nullptr) return;\n+        LOCK(m_tx_relay->cs_tx_inventory);\n+        if (!m_tx_relay->filterInventoryKnown.contains(hash)) {\n+            m_tx_relay->setInventoryTxToSend.insert(hash);\n         }\n-        return ret;\n     }\n-    Optional<CNetMessage> GetMessage(std::chrono::microseconds time, uint32_t& out_err_raw_size) override;\n+\n+    void CloseSocketDisconnect();\n+\n+    void copyStats(CNodeStats &stats, const std::vector<bool> &m_asmap);\n+\n+    ServiceFlags GetLocalServices() const\n+    {\n+        return nLocalServices;\n+    }\n+\n+    std::string GetAddrName() const;\n+    //! Sets the addrName only if it was not previously set\n+    void MaybeSetAddrName(const std::string& addrNameIn);\n+\n+    std::string ConnectionTypeAsString() const;\n+\n+    /** Whether this peer is an inbound onion, e.g. connected via our Tor onion service. */\n+    bool IsInboundOnion() const { return m_inbound_onion; }\n };\n \n-/** The TransportSerializer prepares messages for the network transport\n+/**\n+ * Interface for message handling\n  */\n-class TransportSerializer {\n+class NetEventsInterface\n+{\n public:\n-    // prepare message for transport (header construction, error-correction computation, payload encryption, etc.)\n-    virtual void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) = 0;\n-    virtual ~TransportSerializer() {}\n-};\n+    virtual bool ProcessMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n+    virtual bool SendMessages(CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(pnode->cs_sendProcessing) = 0;\n+    virtual void InitializeNode(CNode* pnode) = 0;\n+    virtual void FinalizeNode(const CNode& node, bool& update_connection_time) = 0;\n \n-class V1TransportSerializer  : public TransportSerializer {\n-public:\n-    void prepareForTransport(CSerializedNetMsg& msg, std::vector<unsigned char>& header) override;\n+protected:\n+    /**\n+     * Protected destructor so that instances can only be deleted by derived classes.\n+     * If that restriction is no longer desired, this should be made public and virtual.\n+     */\n+    ~NetEventsInterface() = default;\n };\n \n-/** Information about a peer */\n-class CNode\n+class CConnman\n {\n-    friend class CConnman;\n-    friend struct ConnmanTestMsg;\n-\n public:\n-    std::unique_ptr<TransportDeserializer> m_deserializer;\n-    std::unique_ptr<TransportSerializer> m_serializer;\n \n-    // socket\n-    std::atomic<ServiceFlags> nServices{NODE_NONE};\n-    SOCKET hSocket GUARDED_BY(cs_hSocket);\n-    /** Total size of all vSendMsg entries */\n-    size_t nSendSize GUARDED_BY(cs_vSend){0};\n-    /** Offset inside the first vSendMsg already sent */\n-    size_t nSendOffset GUARDED_BY(cs_vSend){0};\n-    uint64_t nSendBytes GUARDED_BY(cs_vSend){0};\n-    std::deque<std::vector<unsigned char>> vSendMsg GUARDED_BY(cs_vSend);\n-    Mutex cs_vSend;\n-    Mutex cs_hSocket;\n-    Mutex cs_vRecv;\n+    enum NumConnections {\n+        CONNECTIONS_NONE = 0,\n+        CONNECTIONS_IN = (1U << 0),\n+        CONNECTIONS_OUT = (1U << 1),\n+        CONNECTIONS_ALL = (CONNECTIONS_IN | CONNECTIONS_OUT),\n+    };\n \n-    RecursiveMutex cs_vProcessMsg;\n-    std::list<CNetMessage> vProcessMsg GUARDED_BY(cs_vProcessMsg);\n-    size_t nProcessQueueSize{0};\n+    struct Options\n+    {\n+        ServiceFlags nLocalServices = NODE_NONE;\n+        int nMaxConnections = 0;\n+        int m_max_outbound_full_relay = 0;\n+        int m_max_outbound_block_relay = 0;\n+        int nMaxAddnode = 0;\n+        int nMaxFeeler = 0;\n+        CClientUIInterface* uiInterface = nullptr;\n+        NetEventsInterface* m_msgproc = nullptr;\n+        BanMan* m_banman = nullptr;\n+        unsigned int nSendBufferMaxSize = 0;\n+        unsigned int nReceiveFloodSize = 0;\n+        uint64_t nMaxOutboundLimit = 0;\n+        int64_t m_peer_connect_timeout = DEFAULT_PEER_CONNECT_TIMEOUT;\n+        std::vector<std::string> vSeedNodes;\n+        std::vector<NetWhitelistPermissions> vWhitelistedRange;\n+        std::vector<NetWhitebindPermissions> vWhiteBinds;\n+        std::vector<CService> vBinds;\n+        std::vector<CService> onion_binds;\n+        bool m_use_addrman_outgoing = true;\n+        std::vector<std::string> m_specified_outgoing;\n+        std::vector<std::string> m_added_nodes;\n+        std::vector<bool> m_asmap;\n+    };\n \n-    RecursiveMutex cs_sendProcessing;\n+    void Init(const Options& connOptions) {\n+        nLocalServices = connOptions.nLocalServices;\n+        nMaxConnections = connOptions.nMaxConnections;\n+        m_max_outbound_full_relay = std::min(connOptions.m_max_outbound_full_relay, connOptions.nMaxConnections);\n+        m_max_outbound_block_relay = connOptions.m_max_outbound_block_relay;\n+        m_use_addrman_outgoing = connOptions.m_use_addrman_outgoing;\n+        nMaxAddnode = connOptions.nMaxAddnode;\n+        nMaxFeeler = connOptions.nMaxFeeler;\n+        m_max_outbound = m_max_outbound_full_relay + m_max_outbound_block_relay + nMaxFeeler;\n+        clientInterface = connOptions.uiInterface;\n+        m_banman = connOptions.m_banman;\n+        m_msgproc = connOptions.m_msgproc;\n+        nSendBufferMaxSize = connOptions.nSendBufferMaxSize;\n+        nReceiveFloodSize = connOptions.nReceiveFloodSize;\n+        m_peer_connect_timeout = connOptions.m_peer_connect_timeout;\n+        {\n+            LOCK(cs_totalBytesSent);\n+            nMaxOutboundLimit = connOptions.nMaxOutboundLimit;\n+        }\n+        vWhitelistedRange = connOptions.vWhitelistedRange;\n+        {\n+            LOCK(cs_vAddedNodes);\n+            vAddedNodes = connOptions.m_added_nodes;\n+        }\n+        m_onion_binds = connOptions.onion_binds;\n+    }\n \n-    uint64_t nRecvBytes GUARDED_BY(cs_vRecv){0};\n+    CConnman(uint64_t seed0, uint64_t seed1, bool network_active = true);\n+    ~CConnman();\n+    bool Start(CScheduler& scheduler, const Options& options);\n \n-    std::atomic<int64_t> nLastSend{0};\n-    std::atomic<int64_t> nLastRecv{0};\n-    const int64_t nTimeConnected;\n-    std::atomic<int64_t> nTimeOffset{0};\n-    // Address of this peer\n-    const CAddress addr;\n-    // Bind address of our side of the connection\n-    const CAddress addrBind;\n-    std::atomic<int> nVersion{0};\n-    RecursiveMutex cs_SubVer;\n-    /**\n-     * cleanSubVer is a sanitized string of the user agent byte array we read\n-     * from the wire. This cleaned string can safely be logged or displayed.\n-     */\n-    std::string cleanSubVer GUARDED_BY(cs_SubVer){};\n-    bool m_prefer_evict{false}; // This peer is preferred for eviction.\n-    bool HasPermission(NetPermissionFlags permission) const {\n-        return NetPermissions::HasFlag(m_permissionFlags, permission);\n-    }\n-    bool fClient{false}; // set by version message\n-    bool m_limited_node{false}; //after BIP159, set by version message\n-    /**\n-     * Whether the peer has signaled support for receiving ADDRv2 (BIP155)\n-     * messages, implying a preference to receive ADDRv2 instead of ADDR ones.\n-     */\n-    std::atomic_bool m_wants_addrv2{false};\n-    std::atomic_bool fSuccessfullyConnected{false};\n-    // Setting fDisconnect to true will cause the node to be disconnected the\n-    // next time DisconnectNodes() runs\n-    std::atomic_bool fDisconnect{false};\n-    bool fSentAddr{false};\n-    CSemaphoreGrant grantOutbound;\n-    std::atomic<int> nRefCount{0};\n+    void StopThreads();\n+    void StopNodes();\n+    void Stop()\n+    {\n+        StopThreads();\n+        StopNodes();\n+    };\n+\n+    void Interrupt();\n+    bool GetNetworkActive() const { return fNetworkActive; };\n+    bool GetUseAddrmanOutgoing() const { return m_use_addrman_outgoing; };\n+    void SetNetworkActive(bool active);\n+    void OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant* grantOutbound, const char* strDest, ConnectionType conn_type);\n+    bool CheckIncomingNonce(uint64_t nonce);\n+\n+    bool ForNode(NodeId id, std::function<bool(CNode* pnode)> func);\n+\n+    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg);\n+\n+    using NodeFn = std::function<void(CNode*)>;\n+    void ForEachNode(const NodeFn& func)\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                func(node);\n+        }\n+    };\n+\n+    void ForEachNode(const NodeFn& func) const\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                func(node);\n+        }\n+    };\n+\n+    template<typename Callable, typename CallableAfter>\n+    void ForEachNodeThen(Callable&& pre, CallableAfter&& post)\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                pre(node);\n+        }\n+        post();\n+    };\n \n-    const uint64_t nKeyedNetGroup;\n-    std::atomic_bool fPauseRecv{false};\n-    std::atomic_bool fPauseSend{false};\n+    template<typename Callable, typename CallableAfter>\n+    void ForEachNodeThen(Callable&& pre, CallableAfter&& post) const\n+    {\n+        LOCK(cs_vNodes);\n+        for (auto&& node : vNodes) {\n+            if (NodeFullyConnected(node))\n+                pre(node);\n+        }\n+        post();\n+    };\n \n-    bool IsOutboundOrBlockRelayConn() const {\n-        switch (m_conn_type) {\n-            case ConnectionType::OUTBOUND_FULL_RELAY:\n-            case ConnectionType::BLOCK_RELAY:\n-                return true;\n-            case ConnectionType::INBOUND:\n-            case ConnectionType::MANUAL:\n-            case ConnectionType::ADDR_FETCH:\n-            case ConnectionType::FEELER:\n-                return false;\n-        } // no default case, so the compiler can warn about missing cases\n+    // Addrman functions\n+    void SetServices(const CService &addr, ServiceFlags nServices);\n+    void MarkAddressGood(const CAddress& addr);\n+    bool AddNewAddresses(const std::vector<CAddress>& vAddr, const CAddress& addrFrom, int64_t nTimePenalty = 0);\n+    std::vector<CAddress> GetAddresses(size_t max_addresses, size_t max_pct);\n+    /**\n+     * Cache is used to minimize topology leaks, so it should\n+     * be used for all non-trusted calls, for example, p2p.\n+     * A non-malicious call (from RPC or a peer with addr permission) should\n+     * call the function without a parameter to avoid using the cache.\n+     */\n+    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct);\n \n-        assert(false);\n-    }\n+    // This allows temporarily exceeding m_max_outbound_full_relay, with the goal of finding\n+    // a peer that is better than all our current peers.\n+    void SetTryNewOutboundPeer(bool flag);\n+    bool GetTryNewOutboundPeer();\n \n-    bool IsFullOutboundConn() const {\n-        return m_conn_type == ConnectionType::OUTBOUND_FULL_RELAY;\n+    void StartExtraBlockRelayPeers() {\n+        LogPrint(BCLog::NET, \"net: enabling extra block-relay-only peers\\n\");\n+        m_start_extra_block_relay_peers = true;\n     }\n \n-    bool IsManualConn() const {\n-        return m_conn_type == ConnectionType::MANUAL;\n-    }\n+    // Return the number of outbound peers we have in excess of our target (eg,\n+    // if we previously called SetTryNewOutboundPeer(true), and have since set\n+    // to false, we may have extra peers that we wish to disconnect). This may\n+    // return a value less than (num_outbound_connections - num_outbound_slots)\n+    // in cases where some outbound connections are not yet fully connected, or\n+    // not yet fully disconnected.\n+    int GetExtraFullOutboundCount();\n+    // Count the number of block-relay-only peers we have over our limit.\n+    int GetExtraBlockRelayCount();\n \n-    bool IsBlockOnlyConn() const {\n-        return m_conn_type == ConnectionType::BLOCK_RELAY;\n-    }\n+    bool AddNode(const std::string& node);\n+    bool RemoveAddedNode(const std::string& node);\n+    std::vector<AddedNodeInfo> GetAddedNodeInfo();\n \n-    bool IsFeelerConn() const {\n-        return m_conn_type == ConnectionType::FEELER;\n-    }\n+    size_t GetNodeCount(NumConnections num);\n+    void GetNodeStats(std::vector<CNodeStats>& vstats);\n+    bool DisconnectNode(const std::string& node);\n+    bool DisconnectNode(const CSubNet& subnet);\n+    bool DisconnectNode(const CNetAddr& addr);\n+    bool DisconnectNode(NodeId id);\n \n-    bool IsAddrFetchConn() const {\n-        return m_conn_type == ConnectionType::ADDR_FETCH;\n-    }\n+    //! Used to convey which local services we are offering peers during node\n+    //! connection.\n+    //!\n+    //! The data returned by this is used in CNode construction,\n+    //! which is used to advertise which services we are offering\n+    //! that peer during `net_processing.cpp:PushNodeVersion()`.\n+    ServiceFlags GetLocalServices() const;\n \n-    bool IsInboundConn() const {\n-        return m_conn_type == ConnectionType::INBOUND;\n-    }\n+    uint64_t GetMaxOutboundTarget();\n+    std::chrono::seconds GetMaxOutboundTimeframe();\n \n-    /* Whether we send addr messages over this connection */\n-    bool RelayAddrsWithConn() const\n-    {\n-        // Don't relay addr messages to peers that we connect to as block-relay-only\n-        // peers (to prevent adversaries from inferring these links from addr\n-        // traffic).\n-        return m_conn_type != ConnectionType::BLOCK_RELAY;\n-    }\n+    //! check if the outbound target is reached\n+    //! if param historicalBlockServingLimit is set true, the function will\n+    //! response true if the limit for serving historical blocks has been reached\n+    bool OutboundTargetReached(bool historicalBlockServingLimit);\n \n-    bool ExpectServicesFromConn() const {\n-        switch (m_conn_type) {\n-            case ConnectionType::INBOUND:\n-            case ConnectionType::MANUAL:\n-            case ConnectionType::FEELER:\n-                return false;\n-            case ConnectionType::OUTBOUND_FULL_RELAY:\n-            case ConnectionType::BLOCK_RELAY:\n-            case ConnectionType::ADDR_FETCH:\n-                return true;\n-        } // no default case, so the compiler can warn about missing cases\n+    //! response the bytes left in the current max outbound cycle\n+    //! in case of no limit, it will always response 0\n+    uint64_t GetOutboundTargetBytesLeft();\n \n-        assert(false);\n-    }\n+    //! returns the time left in the current max outbound cycle\n+    //! in case of no limit, it will always return 0\n+    std::chrono::seconds GetMaxOutboundTimeLeftInCycle();\n \n-    /**\n-     * Get network the peer connected through.\n-     *\n-     * Returns Network::NET_ONION for *inbound* onion connections,\n-     * and CNetAddr::GetNetClass() otherwise. The latter cannot be used directly\n-     * because it doesn't detect the former, and it's not the responsibility of\n-     * the CNetAddr class to know the actual network a peer is connected through.\n-     *\n-     * @return network the peer connected through.\n-     */\n-    Network ConnectedThroughNetwork() const;\n+    uint64_t GetTotalBytesRecv();\n+    uint64_t GetTotalBytesSent();\n \n-protected:\n-    mapMsgCmdSize mapSendBytesPerMsgCmd GUARDED_BY(cs_vSend);\n-    mapMsgCmdSize mapRecvBytesPerMsgCmd GUARDED_BY(cs_vRecv);\n+    /** Get a unique deterministic randomizer. */\n+    CSipHasher GetDeterministicRandomizer(uint64_t id) const;\n \n-public:\n-    // We selected peer as (compact blocks) high-bandwidth peer (BIP152)\n-    std::atomic<bool> m_bip152_highbandwidth_to{false};\n-    // Peer selected us as (compact blocks) high-bandwidth peer (BIP152)\n-    std::atomic<bool> m_bip152_highbandwidth_from{false};\n+    unsigned int GetReceiveFloodSize() const;\n \n-    // flood relay\n-    std::vector<CAddress> vAddrToSend;\n-    std::unique_ptr<CRollingBloomFilter> m_addr_known{nullptr};\n-    bool fGetAddr{false};\n-    std::chrono::microseconds m_next_addr_send GUARDED_BY(cs_sendProcessing){0};\n-    std::chrono::microseconds m_next_local_addr_send GUARDED_BY(cs_sendProcessing){0};\n+    void WakeMessageHandler();\n \n-    struct TxRelay {\n-        mutable RecursiveMutex cs_filter;\n-        // We use fRelayTxes for two purposes -\n-        // a) it allows us to not relay tx invs before receiving the peer's version message\n-        // b) the peer may tell us in its version message that we should not relay tx invs\n-        //    unless it loads a bloom filter.\n-        bool fRelayTxes GUARDED_BY(cs_filter){false};\n-        std::unique_ptr<CBloomFilter> pfilter PT_GUARDED_BY(cs_filter) GUARDED_BY(cs_filter){nullptr};\n+    /** Attempts to obfuscate tx time through exponentially distributed emitting.\n+        Works assuming that a single interval is used.\n+        Variable intervals will result in privacy decrease.\n+    */\n+    int64_t PoissonNextSendInbound(int64_t now, int average_interval_seconds);\n \n-        mutable RecursiveMutex cs_tx_inventory;\n-        CRollingBloomFilter filterInventoryKnown GUARDED_BY(cs_tx_inventory){50000, 0.000001};\n-        // Set of transaction ids we still have to announce.\n-        // They are sorted by the mempool before relay, so the order is not important.\n-        std::set<uint256> setInventoryTxToSend;\n-        // Used for BIP35 mempool sending\n-        bool fSendMempool GUARDED_BY(cs_tx_inventory){false};\n-        // Last time a \"MEMPOOL\" request was serviced.\n-        std::atomic<std::chrono::seconds> m_last_mempool_req{0s};\n-        std::chrono::microseconds nNextInvSend{0};\n+    void SetAsmap(std::vector<bool> asmap) { addrman.m_asmap = std::move(asmap); }\n \n-        RecursiveMutex cs_feeFilter;\n-        // Minimum fee rate with which to filter inv's to this node\n-        CAmount minFeeFilter GUARDED_BY(cs_feeFilter){0};\n-        CAmount lastSentFeeFilter{0};\n-        int64_t nextSendTimeFeeFilter{0};\n+private:\n+    struct ListenSocket {\n+    public:\n+        SOCKET socket;\n+        inline void AddSocketPermissionFlags(NetPermissionFlags& flags) const { NetPermissions::AddFlag(flags, m_permissions); }\n+        ListenSocket(SOCKET socket_, NetPermissionFlags permissions_) : socket(socket_), m_permissions(permissions_) {}\n+    private:\n+        NetPermissionFlags m_permissions;\n     };\n \n-    // m_tx_relay == nullptr if we're not relaying transactions with this peer\n-    std::unique_ptr<TxRelay> m_tx_relay;\n+    bool BindListenPort(const CService& bindAddr, bilingual_str& strError, NetPermissionFlags permissions);\n+    bool Bind(const CService& addr, unsigned int flags, NetPermissionFlags permissions);\n+    bool InitBinds(\n+        const std::vector<CService>& binds,\n+        const std::vector<NetWhitebindPermissions>& whiteBinds,\n+        const std::vector<CService>& onion_binds);\n \n-    /** UNIX epoch time of the last block received from this peer that we had\n-     * not yet seen (e.g. not already received from another peer), that passed\n-     * preliminary validity checks and was saved to disk, even if we don't\n-     * connect the block or it eventually fails connection. Used as an inbound\n-     * peer eviction criterium in CConnman::AttemptToEvictConnection. */\n-    std::atomic<int64_t> nLastBlockTime{0};\n+    void ThreadOpenAddedConnections();\n+    void AddAddrFetch(const std::string& strDest);\n+    void ProcessAddrFetch();\n+    void ThreadOpenConnections(std::vector<std::string> connect);\n+    void ThreadMessageHandler();\n+    void AcceptConnection(const ListenSocket& hListenSocket);\n+    void DisconnectNodes();\n+    void NotifyNumConnectionsChanged();\n+    void InactivityCheck(CNode *pnode);\n+    bool GenerateSelectSet(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n+    void SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set);\n+    void SocketHandler();\n+    void ThreadSocketHandler();\n+    void ThreadDNSAddressSeed();\n \n-    /** UNIX epoch time of the last transaction received from this peer that we\n-     * had not yet seen (e.g. not already received from another peer) and that\n-     * was accepted into our mempool. Used as an inbound peer eviction criterium\n-     * in CConnman::AttemptToEvictConnection. */\n-    std::atomic<int64_t> nLastTXTime{0};\n+    uint64_t CalculateKeyedNetGroup(const CAddress& ad) const;\n \n-    // Ping time measurement:\n-    // The pong reply we're expecting, or 0 if no pong expected.\n-    std::atomic<uint64_t> nPingNonceSent{0};\n-    /** When the last ping was sent, or 0 if no ping was ever sent */\n-    std::atomic<std::chrono::microseconds> m_ping_start{0us};\n-    // Last measured round-trip time.\n-    std::atomic<int64_t> nPingUsecTime{0};\n-    // Best measured round-trip time.\n-    std::atomic<int64_t> nMinPingUsecTime{std::numeric_limits<int64_t>::max()};\n-    // Whether a ping is requested.\n-    std::atomic<bool> fPingQueued{false};\n+    CNode* FindNode(const CNetAddr& ip);\n+    CNode* FindNode(const CSubNet& subNet);\n+    CNode* FindNode(const std::string& addrName);\n+    CNode* FindNode(const CService& addr);\n+\n+    /**\n+     * Determine whether we're already connected to a given address, in order to\n+     * avoid initiating duplicate connections.\n+     */\n+    bool AlreadyConnectedToAddress(const CAddress& addr);\n+\n+    bool AttemptToEvictConnection();\n+    CNode* ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, ConnectionType conn_type);\n+    void AddWhitelistPermissionFlags(NetPermissionFlags& flags, const CNetAddr &addr) const;\n+\n+    void DeleteNode(CNode* pnode);\n \n-    CNode(NodeId id, ServiceFlags nLocalServicesIn, SOCKET hSocketIn, const CAddress& addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress& addrBindIn, const std::string& addrNameIn, ConnectionType conn_type_in, bool inbound_onion = false);\n-    ~CNode();\n-    CNode(const CNode&) = delete;\n-    CNode& operator=(const CNode&) = delete;\n+    NodeId GetNewNodeId();\n \n-private:\n-    const NodeId id;\n-    const uint64_t nLocalHostNonce;\n-    const ConnectionType m_conn_type;\n-    std::atomic<int> m_greatest_common_version{INIT_PROTO_VERSION};\n+    size_t SocketSendData(CNode& node) const EXCLUSIVE_LOCKS_REQUIRED(node.cs_vSend);\n+    void DumpAddresses();\n \n-    //! Services offered to this peer.\n-    //!\n-    //! This is supplied by the parent CConnman during peer connection\n-    //! (CConnman::ConnectNode()) from its attribute of the same name.\n-    //!\n-    //! This is const because there is no protocol defined for renegotiating\n-    //! services initially offered to a peer. The set of local services we\n-    //! offer should not change after initialization.\n-    //!\n-    //! An interesting example of this is NODE_NETWORK and initial block\n-    //! download: a node which starts up from scratch doesn't have any blocks\n-    //! to serve, but still advertises NODE_NETWORK because it will eventually\n-    //! fulfill this role after IBD completes. P2P code is written in such a\n-    //! way that it can gracefully handle peers who don't make good on their\n-    //! service advertisements.\n-    const ServiceFlags nLocalServices;\n+    // Network stats\n+    void RecordBytesRecv(uint64_t bytes);\n+    void RecordBytesSent(uint64_t bytes);\n \n-    NetPermissionFlags m_permissionFlags{ PF_NONE };\n-    std::list<CNetMessage> vRecvMsg;  // Used only by SocketHandler thread\n+    /**\n+     * Return vector of current BLOCK_RELAY peers.\n+     */\n+    std::vector<CAddress> GetCurrentBlockRelayOnlyConns() const;\n \n-    mutable RecursiveMutex cs_addrName;\n-    std::string addrName GUARDED_BY(cs_addrName);\n+    // Whether the node should be passed out in ForEach* callbacks\n+    static bool NodeFullyConnected(const CNode* pnode);\n \n-    // Our address, as reported by the peer\n-    CService addrLocal GUARDED_BY(cs_addrLocal);\n-    mutable RecursiveMutex cs_addrLocal;\n+    // Network usage totals\n+    RecursiveMutex cs_totalBytesRecv;\n+    RecursiveMutex cs_totalBytesSent;\n+    uint64_t nTotalBytesRecv GUARDED_BY(cs_totalBytesRecv) {0};\n+    uint64_t nTotalBytesSent GUARDED_BY(cs_totalBytesSent) {0};\n \n-    //! Whether this peer is an inbound onion, e.g. connected via our Tor onion service.\n-    const bool m_inbound_onion{false};\n+    // outbound limit & stats\n+    uint64_t nMaxOutboundTotalBytesSentInCycle GUARDED_BY(cs_totalBytesSent) {0};\n+    std::chrono::seconds nMaxOutboundCycleStartTime GUARDED_BY(cs_totalBytesSent) {0};\n+    uint64_t nMaxOutboundLimit GUARDED_BY(cs_totalBytesSent);\n \n-public:\n+    // P2P timeout in seconds\n+    int64_t m_peer_connect_timeout;\n \n-    NodeId GetId() const {\n-        return id;\n-    }\n+    // Whitelisted ranges. Any node connecting from these is automatically\n+    // whitelisted (as well as those connecting to whitelisted binds).\n+    std::vector<NetWhitelistPermissions> vWhitelistedRange;\n \n-    uint64_t GetLocalNonce() const {\n-        return nLocalHostNonce;\n-    }\n+    unsigned int nSendBufferMaxSize{0};\n+    unsigned int nReceiveFloodSize{0};\n \n-    int GetRefCount() const\n-    {\n-        assert(nRefCount >= 0);\n-        return nRefCount;\n-    }\n+    std::vector<ListenSocket> vhListenSocket;\n+    std::atomic<bool> fNetworkActive{true};\n+    bool fAddressesInitialized{false};\n+    CAddrMan addrman;\n+    std::deque<std::string> m_addr_fetches GUARDED_BY(m_addr_fetches_mutex);\n+    RecursiveMutex m_addr_fetches_mutex;\n+    std::vector<std::string> vAddedNodes GUARDED_BY(cs_vAddedNodes);\n+    RecursiveMutex cs_vAddedNodes;\n+    std::vector<CNode*> vNodes GUARDED_BY(cs_vNodes);\n+    std::list<CNode*> vNodesDisconnected;\n+    mutable RecursiveMutex cs_vNodes;\n+    std::atomic<NodeId> nLastNodeId{0};\n+    unsigned int nPrevNodeCount{0};\n \n     /**\n-     * Receive bytes from the buffer and deserialize them into messages.\n-     *\n-     * @param[in]   msg_bytes   The raw data\n-     * @param[out]  complete    Set True if at least one message has been\n-     *                          deserialized and is ready to be processed\n-     * @return  True if the peer should stay connected,\n-     *          False if the peer should be disconnected from.\n+     * Cache responses to addr requests to minimize privacy leak.\n+     * Attack example: scraping addrs in real-time may allow an attacker\n+     * to infer new connections of the victim by detecting new records\n+     * with fresh timestamps (per self-announcement).\n      */\n-    bool ReceiveMsgBytes(Span<const uint8_t> msg_bytes, bool& complete);\n-\n-    void SetCommonVersion(int greatest_common_version)\n-    {\n-        Assume(m_greatest_common_version == INIT_PROTO_VERSION);\n-        m_greatest_common_version = greatest_common_version;\n-    }\n-    int GetCommonVersion() const\n-    {\n-        return m_greatest_common_version;\n-    }\n+    struct CachedAddrResponse {\n+        std::vector<CAddress> m_addrs_response_cache;\n+        std::chrono::microseconds m_cache_entry_expiration{0};\n+    };\n \n-    CService GetAddrLocal() const;\n-    //! May not be called more than once\n-    void SetAddrLocal(const CService& addrLocalIn);\n+    /**\n+     * Addr responses stored in different caches\n+     * per (network, local socket) prevent cross-network node identification.\n+     * If a node for example is multi-homed under Tor and IPv6,\n+     * a single cache (or no cache at all) would let an attacker\n+     * to easily detect that it is the same node by comparing responses.\n+     * Indexing by local socket prevents leakage when a node has multiple\n+     * listening addresses on the same network.\n+     *\n+     * The used memory equals to 1000 CAddress records (or around 40 bytes) per\n+     * distinct Network (up to 5) we have/had an inbound peer from,\n+     * resulting in at most ~196 KB. Every separate local socket may\n+     * add up to ~196 KB extra.\n+     */\n+    std::map<uint64_t, CachedAddrResponse> m_addr_response_caches;\n \n-    CNode* AddRef()\n-    {\n-        nRefCount++;\n-        return this;\n-    }\n+    /**\n+     * Services this instance offers.\n+     *\n+     * This data is replicated in each CNode instance we create during peer\n+     * connection (in ConnectNode()) under a member also called\n+     * nLocalServices.\n+     *\n+     * This data is not marked const, but after being set it should not\n+     * change. See the note in CNode::nLocalServices documentation.\n+     *\n+     * \\sa CNode::nLocalServices\n+     */\n+    ServiceFlags nLocalServices;\n \n-    void Release()\n-    {\n-        nRefCount--;\n-    }\n+    std::unique_ptr<CSemaphore> semOutbound;\n+    std::unique_ptr<CSemaphore> semAddnode;\n+    int nMaxConnections;\n \n+    // How many full-relay (tx, block, addr) outbound peers we want\n+    int m_max_outbound_full_relay;\n \n+    // How many block-relay only outbound peers we want\n+    // We do not relay tx or addr messages with these peers\n+    int m_max_outbound_block_relay;\n \n-    void AddAddressKnown(const CAddress& _addr)\n-    {\n-        assert(m_addr_known);\n-        m_addr_known->insert(_addr.GetKey());\n-    }\n+    int nMaxAddnode;\n+    int nMaxFeeler;\n+    int m_max_outbound;\n+    bool m_use_addrman_outgoing;\n+    CClientUIInterface* clientInterface;\n+    NetEventsInterface* m_msgproc;\n+    /** Pointer to this node's banman. May be nullptr - check existence before dereferencing. */\n+    BanMan* m_banman;\n \n     /**\n-     * Whether the peer supports the address. For example, a peer that does not\n-     * implement BIP155 cannot receive Tor v3 addresses because it requires\n-     * ADDRv2 (BIP155) encoding.\n+     * Addresses that were saved during the previous clean shutdown. We'll\n+     * attempt to make block-relay-only connections to them.\n      */\n-    bool IsAddrCompatible(const CAddress& addr) const\n-    {\n-        return m_wants_addrv2 || addr.IsAddrV1Compatible();\n-    }\n+    std::vector<CAddress> m_anchors;\n \n-    void PushAddress(const CAddress& _addr, FastRandomContext &insecure_rand)\n-    {\n-        // Known checking here is only to save space from duplicates.\n-        // SendMessages will filter it again for knowns that were added\n-        // after addresses were pushed.\n-        assert(m_addr_known);\n-        if (_addr.IsValid() && !m_addr_known->contains(_addr.GetKey()) && IsAddrCompatible(_addr)) {\n-            if (vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\n-                vAddrToSend[insecure_rand.randrange(vAddrToSend.size())] = _addr;\n-            } else {\n-                vAddrToSend.push_back(_addr);\n-            }\n-        }\n-    }\n+    /** SipHasher seeds for deterministic randomness */\n+    const uint64_t nSeed0, nSeed1;\n \n+    /** flag for waking the message processor. */\n+    bool fMsgProcWake GUARDED_BY(mutexMsgProc);\n \n-    void AddKnownTx(const uint256& hash)\n-    {\n-        if (m_tx_relay != nullptr) {\n-            LOCK(m_tx_relay->cs_tx_inventory);\n-            m_tx_relay->filterInventoryKnown.insert(hash);\n-        }\n-    }\n+    std::condition_variable condMsgProc;\n+    Mutex mutexMsgProc;\n+    std::atomic<bool> flagInterruptMsgProc{false};\n \n-    void PushTxInventory(const uint256& hash)\n-    {\n-        if (m_tx_relay == nullptr) return;\n-        LOCK(m_tx_relay->cs_tx_inventory);\n-        if (!m_tx_relay->filterInventoryKnown.contains(hash)) {\n-            m_tx_relay->setInventoryTxToSend.insert(hash);\n-        }\n-    }\n+    CThreadInterrupt interruptNet;\n \n-    void CloseSocketDisconnect();\n+    std::thread threadDNSAddressSeed;\n+    std::thread threadSocketHandler;\n+    std::thread threadOpenAddedConnections;\n+    std::thread threadOpenConnections;\n+    std::thread threadMessageHandler;\n \n-    void copyStats(CNodeStats &stats, const std::vector<bool> &m_asmap);\n+    /** flag for deciding to connect to an extra outbound peer,\n+     *  in excess of m_max_outbound_full_relay\n+     *  This takes the place of a feeler connection */\n+    std::atomic_bool m_try_another_outbound_peer;\n \n-    ServiceFlags GetLocalServices() const\n-    {\n-        return nLocalServices;\n-    }\n+    /** flag for initiating extra block-relay-only peer connections.\n+     *  this should only be enabled after initial chain sync has occurred,\n+     *  as these connections are intended to be short-lived and low-bandwidth.\n+     */\n+    std::atomic_bool m_start_extra_block_relay_peers{false};\n \n-    std::string GetAddrName() const;\n-    //! Sets the addrName only if it was not previously set\n-    void MaybeSetAddrName(const std::string& addrNameIn);\n+    std::atomic<int64_t> m_next_send_inv_to_incoming{0};\n \n-    std::string ConnectionTypeAsString() const;\n+    /**\n+     * A vector of -bind=<address>:<port>=onion arguments each of which is\n+     * an address and port that are designated for incoming Tor connections.\n+     */\n+    std::vector<CService> m_onion_binds;\n \n-    /** Whether this peer is an inbound onion, e.g. connected via our Tor onion service. */\n-    bool IsInboundOnion() const { return m_inbound_onion; }\n+    friend struct CConnmanTest;\n+    friend struct ConnmanTestMsg;\n };",
      "path": "src/net.h",
      "position": 1906,
      "original_position": 1906,
      "commit_id": "fa210689e27b0d78b2fe894e51e364179db7a3ce",
      "original_commit_id": "fad2e1f267d60afe9799e431233f54f02d14e8e0",
      "in_reply_to_id": 552621025,
      "user": {
        "login": "MarcoFalke",
        "id": 6399679,
        "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/MarcoFalke",
        "html_url": "https://github.com/MarcoFalke",
        "followers_url": "https://api.github.com/users/MarcoFalke/followers",
        "following_url": "https://api.github.com/users/MarcoFalke/following%7B/other_user%7D",
        "gists_url": "https://api.github.com/users/MarcoFalke/gists%7B/gist_id%7D",
        "starred_url": "https://api.github.com/users/MarcoFalke/starred%7B/owner%7D%7B/repo%7D",
        "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
        "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
        "repos_url": "https://api.github.com/users/MarcoFalke/repos",
        "events_url": "https://api.github.com/users/MarcoFalke/events%7B/privacy%7D",
        "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
        "type": "User",
        "site_admin": false
      },
      "body": "thanks, done",
      "created_at": "2021-01-07T08:42:52Z",
      "updated_at": "2021-01-07T08:42:52Z",
      "html_url": "https://github.com/bitcoin/bitcoin/pull/20864#discussion_r553182212",
      "author_association": "MEMBER",
      "_links": {
        "self": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/553182212"
        },
        "pull_request": {
          "href": "https://api.github.com/repos/bitcoin/bitcoin/pulls/20864"
        }
      },
      "start_line": null,
      "original_start_line": null,
      "start_side": null,
      "line": 1216,
      "original_line": 1216,
      "side": "RIGHT"
    }
  ]
}